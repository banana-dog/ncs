[CLS] / * $ open ##bs ##d $ * / / * * copyright ( c ) 2008 nicholas marriott < nicholas . marriott @ gma ##il . com > * * permission to use , copy , modify , and distribute this software for any * purpose with or without fee is here ##by granted , provided that the above * copyright notice and this permission notice appear in all copies . * * the software is provided " as is " and the author disc ##lai ##ms all warrant ##ies * with regard to this software including all implied warrant ##ies of * merchant ##ability and fitness . in no event shall the author be liable for * any special , direct , indirect , or con ##se ##quent ##ial damages or any damages * whatsoever resulting from loss of mind , use , data or profits , whether * in an action of contract , negligence or other tor ##tious action , arising * out of or in connection with the use or performance of this software . * / # include < sy ##s / types . h > # include < ct ##ype . h > # include < er ##rno . h > # include < st ##dl ##ib . h > # include < string . h > # include < wc ##har . h > # include " t ##mu ##x . h " static con ##st wc ##har _ t ut ##f ##8 _ force _ wide [ ] = { 0 ##x ##0 ##26 ##1 ##d , 0 ##x ##0 ##26 ##f ##9 , 0 ##x ##0 ##27 ##0 ##a , 0 ##x ##0 ##27 ##0 ##b , 0 ##x ##0 ##27 ##0 ##c , 0 ##x ##0 ##27 ##0 ##d , 0 ##x ##1 ##f ##1 ##e ##6 , 0 ##x ##1 ##f ##1 ##e ##7 , 0 ##x ##1 ##f ##1 ##e ##8 , 0 ##x ##1 ##f ##1 ##e ##9 , 0 ##x ##1 ##f ##1 ##ea , 0 ##x ##1 ##f ##1 ##eb , 0 ##x ##1 ##f ##1 ##ec , 0 ##x ##1 ##f ##1 ##ed , 0 ##x ##1 ##f ##1 ##ee , 0 ##x ##1 ##f ##1 ##ef , 0 ##x ##1 ##f ##1 ##f ##0 , 0 ##x ##1 ##f ##1 ##f ##1 , 0 ##x ##1 ##f ##1 ##f ##2 , 0 ##x ##1 ##f ##1 ##f ##3 , 0 ##x ##1 ##f ##1 ##f ##4 , 0 ##x ##1 ##f ##1 ##f ##5 , 0 ##x ##1 ##f ##1 ##f ##6 , 0 ##x ##1 ##f ##1 ##f ##7 , 0 ##x ##1 ##f ##1 ##f ##8 , 0 ##x ##1 ##f ##1 ##f ##9 , 0 ##x ##1 ##f ##1 ##fa , 0 ##x ##1 ##f ##1 ##fb , 0 ##x ##1 ##f ##1 ##fc , 0 ##x ##1 ##f ##1 ##f ##d , 0 ##x ##1 ##f ##1 ##fe , 0 ##x ##1 ##f ##1 ##ff , 0 ##x ##1 ##f ##38 ##5 , 0 ##x ##1 ##f ##3 ##c ##2 , 0 ##x ##1 ##f ##3 ##c ##3 , 0 ##x ##1 ##f ##3 ##c ##4 , 0 ##x ##1 ##f ##3 ##c ##7 , 0 ##x ##1 ##f ##3 ##ca , 0 ##x ##1 ##f ##3 ##cb , 0 ##x ##1 ##f ##3 ##cc , 0 ##x ##1 ##f ##3 ##fb , 0 ##x ##1 ##f ##3 ##fc , 0 ##x ##1 ##f ##3 ##f ##d , 0 ##x ##1 ##f ##3 ##fe , 0 ##x ##1 ##f ##3 ##ff , 0 ##x ##1 ##f ##44 ##2 , 0 ##x ##1 ##f ##44 ##3 , 0 ##x ##1 ##f ##44 ##6 , 0 ##x ##1 ##f ##44 ##7 , 0 ##x ##1 ##f ##44 ##8 , 0 ##x ##1 ##f ##44 ##9 , 0 ##x ##1 ##f ##44 ##a , 0 ##x ##1 ##f ##44 ##b , 0 ##x ##1 ##f ##44 ##c , 0 ##x ##1 ##f ##44 ##d , 0 ##x ##1 ##f ##44 ##e , 0 ##x ##1 ##f ##44 ##f , 0 ##x ##1 ##f ##45 ##0 , 0 ##x ##1 ##f ##46 ##6 , 0 ##x ##1 ##f ##46 ##7 , 0 ##x ##1 ##f ##46 ##8 , 0 ##x ##1 ##f ##46 ##9 , 0 ##x ##1 ##f ##46 ##b , 0 ##x ##1 ##f ##46 ##c , 0 ##x ##1 ##f ##46 ##d , 0 ##x ##1 ##f ##46 ##e , 0 ##x ##1 ##f ##47 ##0 , 0 ##x ##1 ##f ##47 ##1 , 0 ##x ##1 ##f ##47 ##2 , 0 ##x ##1 ##f ##47 ##3 , 0 ##x ##1 ##f ##47 ##4 , 0 ##x ##1 ##f ##47 ##5 , 0 ##x ##1 ##f ##47 ##6 , 0 ##x ##1 ##f ##47 ##7 , 0 ##x ##1 ##f ##47 ##8 , 0 ##x ##1 ##f ##47 ##c , 0 ##x ##1 ##f ##48 ##1 , 0 ##x ##1 ##f ##48 ##2 , 0 ##x ##1 ##f ##48 ##3 , 0 ##x ##1 ##f ##48 ##5 , 0 ##x ##1 ##f ##48 ##6 , 0 ##x ##1 ##f ##48 ##7 , 0 ##x ##1 ##f ##48 ##f , 0 ##x ##1 ##f ##49 ##1 , 0 ##x ##1 ##f ##4 ##aa , 0 ##x ##1 ##f ##57 ##4 , 0 ##x ##1 ##f ##57 ##5 , 0 ##x ##1 ##f ##57 ##a , 0 ##x ##1 ##f ##59 ##0 , 0 ##x ##1 ##f ##59 ##5 , 0 ##x ##1 ##f ##59 ##6 , 0 ##x ##1 ##f ##64 ##5 , 0 ##x ##1 ##f ##64 ##6 , 0 ##x ##1 ##f ##64 ##7 , 0 ##x ##1 ##f ##64 ##b , 0 ##x ##1 ##f ##64 ##c , 0 ##x ##1 ##f ##64 ##d , 0 ##x ##1 ##f ##64 ##e , 0 ##x ##1 ##f ##64 ##f , 0 ##x ##1 ##f ##6 ##a ##3 , 0 ##x ##1 ##f ##6 ##b ##4 , 0 ##x ##1 ##f ##6 ##b ##5 , 0 ##x ##1 ##f ##6 ##b ##6 , 0 ##x ##1 ##f ##6 ##c ##0 , 0 ##x ##1 ##f ##6 ##cc , 0 ##x ##1 ##f ##90 ##c , 0 ##x ##1 ##f ##90 ##f , 0 ##x ##1 ##f ##9 ##18 , 0 ##x ##1 ##f ##9 ##19 , 0 ##x ##1 ##f ##9 ##1 ##a , 0 ##x ##1 ##f ##9 ##1 ##b , 0 ##x ##1 ##f ##9 ##1 ##c , 0 ##x ##1 ##f ##9 ##1 ##d , 0 ##x ##1 ##f ##9 ##1 ##e , 0 ##x ##1 ##f ##9 ##1 ##f , 0 ##x ##1 ##f ##9 ##26 , 0 ##x ##1 ##f ##9 ##30 , 0 ##x ##1 ##f ##9 ##31 , 0 ##x ##1 ##f ##9 ##32 , 0 ##x ##1 ##f ##9 ##33 , 0 ##x ##1 ##f ##9 ##34 , 0 ##x ##1 ##f ##9 ##35 , 0 ##x ##1 ##f ##9 ##36 , 0 ##x ##1 ##f ##9 ##37 , 0 ##x ##1 ##f ##9 ##38 , 0 ##x ##1 ##f ##9 ##39 , 0 ##x ##1 ##f ##9 ##3d , 0 ##x ##1 ##f ##9 ##3 ##e , 0 ##x ##1 ##f ##9 ##7 ##7 , 0 ##x ##1 ##f ##9 ##b ##5 , 0 ##x ##1 ##f ##9 ##b ##6 , 0 ##x ##1 ##f ##9 ##b ##8 , 0 ##x ##1 ##f ##9 ##b ##9 , 0 ##x ##1 ##f ##9 ##bb , 0 ##x ##1 ##f ##9 ##cd , 0 ##x ##1 ##f ##9 ##ce , 0 ##x ##1 ##f ##9 ##c ##f , 0 ##x ##1 ##f ##9 ##d ##1 , 0 ##x ##1 ##f ##9 ##d ##2 , 0 ##x ##1 ##f ##9 ##d ##3 , 0 ##x ##1 ##f ##9 ##d ##4 , 0 ##x ##1 ##f ##9 ##d ##5 , 0 ##x ##1 ##f ##9 ##d ##6 , 0 ##x ##1 ##f ##9 ##d ##7 , 0 ##x ##1 ##f ##9 ##d ##8 , 0 ##x ##1 ##f ##9 ##d ##9 , 0 ##x ##1 ##f ##9 ##da , 0 ##x ##1 ##f ##9 ##db , 0 ##x ##1 ##f ##9 ##dc , 0 ##x ##1 ##f ##9 ##dd , 0 ##x ##1 ##fa ##c ##3 , 0 ##x ##1 ##fa ##c ##4 , 0 ##x ##1 ##fa ##c ##5 , 0 ##x ##1 ##fa ##f ##0 , 0 ##x ##1 ##fa ##f ##1 , 0 ##x ##1 ##fa ##f ##2 , 0 ##x ##1 ##fa ##f ##3 , 0 ##x ##1 ##fa ##f ##4 , 0 ##x ##1 ##fa ##f ##5 , 0 ##x ##1 ##fa ##f ##6 , 0 ##x ##1 ##fa ##f ##7 , 0 ##x ##1 ##fa ##f ##8 } ; st ##ru ##ct ut ##f ##8 _ item { rb _ entry ( ut ##f ##8 _ item ) index _ entry ; u _ int index ; rb _ entry ( ut ##f ##8 _ item ) data _ entry ; char data [ ut ##f ##8 _ size ] ; u _ char size ; } ; static int ut ##f ##8 _ data _ cm ##p ( st ##ru ##ct ut ##f ##8 _ item * ui ##1 , st ##ru ##ct ut ##f ##8 _ item * ui ##2 ) { if ( ui ##1 - > size < ui ##2 - > size ) return ( - 1 ) ; if ( ui ##1 - > size > ui ##2 - > size ) return ( 1 ) ; return ( me ##mc ##mp ( ui ##1 - > data , ui ##2 - > data , ui ##1 - > size ) ) ; } rb _ head ( ut ##f ##8 _ data _ tree , ut ##f ##8 _ item ) ; rb _ generate _ static ( ut ##f ##8 _ data _ tree , ut ##f ##8 _ item , data _ entry , ut ##f ##8 _ data _ cm ##p ) ; static st ##ru ##ct ut ##f ##8 _ data _ tree ut ##f ##8 _ data _ tree = rb _ initial ##izer ( ut ##f ##8 _ data _ tree ) ; static int ut ##f ##8 _ index _ cm ##p ( st ##ru ##ct ut ##f ##8 _ item * ui ##1 , st ##ru ##ct ut ##f ##8 _ item * ui ##2 ) { if ( ui ##1 - > index < ui ##2 - > index ) return ( - 1 ) ; if ( ui ##1 - > index > ui ##2 - > index ) return ( 1 ) ; return ( 0 ) ; } rb _ head ( ut ##f ##8 _ index _ tree , ut ##f ##8 _ item ) ; rb _ generate _ static ( ut ##f ##8 _ index _ tree , ut ##f ##8 _ item , index _ entry , ut ##f ##8 _ index _ cm ##p ) ; static st ##ru ##ct ut ##f ##8 _ index _ tree ut ##f ##8 _ index _ tree = rb _ initial ##izer ( ut ##f ##8 _ index _ tree ) ; static u _ int ut ##f ##8 _ next _ index ; # define ut ##f ##8 _ get _ size ( uc ) ( ( ( uc ) > > 24 ) & 0 ##x ##1 ##f ) # define ut ##f ##8 _ get _ width ( uc ) ( ( ( uc ) > > 29 ) - 1 ) # define ut ##f ##8 _ set _ size ( size ) ( ( ( ut ##f ##8 _ char ) ( size ) ) < < 24 ) # define ut ##f ##8 _ set _ width ( width ) ( ( ( ( ut ##f ##8 _ char ) ( width ) ) + 1 ) < < 29 ) / * get a ut ##f - 8 item from data . * / static st ##ru ##ct ut ##f ##8 _ item * ut ##f ##8 _ item _ by _ data ( con ##st u _ char * data , size _ t size ) { st ##ru ##ct ut ##f ##8 _ item ui ; me ##mc ##py ( ui . data , data , size ) ; ui . size = size ; return ( rb _ find ( ut ##f ##8 _ data _ tree , & ut ##f ##8 _ data _ tree , & ui ) ) ; } / * get a ut ##f - 8 item from data . * / static st ##ru ##ct ut ##f ##8 _ item * ut ##f ##8 _ item _ by _ index ( u _ int index ) { st ##ru ##ct ut ##f ##8 _ item ui ; ui . index = index ; return ( rb _ find ( ut ##f ##8 _ index _ tree , & ut ##f ##8 _ index _ tree , & ui ) ) ; } / * add a ut ##f - 8 item . * / static int ut ##f ##8 _ put _ item ( con ##st u _ char * data , size _ t size , u _ int * index ) { st ##ru ##ct ut ##f ##8 _ item * ui ; ui = ut ##f ##8 _ item _ by _ data ( data , size ) ; if ( ui ! = null ) { * index = ui - > index ; log _ de ##bu ##g ( " % s : found % . * s = % u " , _ _ fun ##c _ _ , ( int ) size , data , * index ) ; return ( 0 ) ; } if ( ut ##f ##8 _ next _ index = = 0 ##x ##ff ##ff ##ff + 1 ) return ( - 1 ) ; ui = x ##cal ##lo ##c ( 1 , size ##of * ui ) ; ui - > index = ut ##f ##8 _ next _ index + + ; rb _ insert ( ut ##f ##8 _ index _ tree , & ut ##f ##8 _ index _ tree , ui ) ; me ##mc ##py ( ui - > data , data , size ) ; ui - > size = size ; rb _ insert ( ut ##f ##8 _ data _ tree , & ut ##f ##8 _ data _ tree , ui ) ; * index = ui - > index ; log _ de ##bu ##g ( " % s : added % . * s = % u " , _ _ fun ##c _ _ , ( int ) size , data , * index ) ; return ( 0 ) ; } static int ut ##f ##8 _ table _ cm ##p ( con ##st void * vp ##1 , con ##st void * vp ##2 ) { con ##st wc ##har _ t * wc ##1 = vp ##1 , * wc ##2 = vp ##2 ; if ( * wc ##1 < * wc ##2 ) return ( - 1 ) ; if ( * wc ##1 > * wc ##2 ) return ( 1 ) ; return ( 0 ) ; } / * check if character in table . * / int ut ##f ##8 _ in _ table ( wc ##har _ t find , con ##st wc ##har _ t * table , u _ int count ) { wc ##har _ t * found ; found = bs ##ear ##ch ( & find , table , count , size ##of * table , ut ##f ##8 _ table _ cm ##p ) ; return ( found ! = null ) ; } / * get ut ##f - 8 character from data . * / en ##um ut ##f ##8 _ state ut ##f ##8 _ from _ data ( con ##st st ##ru ##ct ut ##f ##8 _ data * ud , ut ##f ##8 _ char * uc ) { u _ int index ; if ( ud - > width > 2 ) fatal ##x ( " invalid ut ##f - 8 width : % u " , ud - > width ) ; if ( ud - > size > ut ##f ##8 _ size ) got ##o fail ; if ( ud - > size < = 3 ) { index = ( ( ( ut ##f ##8 _ char ) ud - > data [ 2 ] < < 16 ) | ( ( ut ##f ##8 _ char ) ud - > data [ 1 ] < < 8 ) | ( ( ut ##f ##8 _ char ) ud - > data [ 0 ] ) ) ; } else if ( ut ##f ##8 _ put _ item ( ud - > data , ud - > size , & index ) ! = 0 ) got ##o fail ; * uc = ut ##f ##8 _ set _ size ( ud - > size ) | ut ##f ##8 _ set _ width ( ud - > width ) | index ; log _ de ##bu ##g ( " % s : ( % d % d % . * s ) - > % 08 ##x " , _ _ fun ##c _ _ , ud - > width , ud - > size , ( int ) ud - > size , ud - > data , * uc ) ; return ( ut ##f ##8 _ done ) ; fail : if ( ud - > width = = 0 ) * uc = ut ##f ##8 _ set _ size ( 0 ) | ut ##f ##8 _ set _ width ( 0 ) ; else if ( ud - > width = = 1 ) * uc = ut ##f ##8 _ set _ size ( 1 ) | ut ##f ##8 _ set _ width ( 1 ) | 0 ##x ##20 ; else * uc = ut ##f ##8 _ set _ size ( 1 ) | ut ##f ##8 _ set _ width ( 1 ) | 0 ##x ##20 ##20 ; return ( ut ##f ##8 _ error ) ; } / * get ut ##f - 8 data from character . * / void ut ##f ##8 _ to _ data ( ut ##f ##8 _ char uc , st ##ru ##ct ut ##f ##8 _ data * ud ) { st ##ru ##ct ut ##f ##8 _ item * ui ; u _ int index ; me ##ms ##et ( ud , 0 , size ##of * ud ) ; ud - > size = ud - > have = ut ##f ##8 _ get _ size ( uc ) ; ud - > width = ut ##f ##8 _ get _ width ( uc ) ; if ( ud - > size < = 3 ) { ud - > data [ 2 ] = ( uc > > 16 ) ; ud - > data [ 1 ] = ( ( uc > > 8 ) & 0 ##x ##ff ) ; ud - > data [ 0 ] = ( uc & 0 ##x ##ff ) ; } else { index = ( uc & 0 ##x ##ff ##ff ##ff ) ; if ( ( ui = ut ##f ##8 _ item _ by _ index ( index ) ) = = null ) me ##ms ##et ( ud - > data , ' ' , ud - > size ) ; else me ##mc ##py ( ud - > data , ui - > data , ud - > size ) ; } log _ de ##bu ##g ( " % s : % 08 ##x - > ( % d % d % . * s ) " , _ _ fun ##c _ _ , uc , ud - > width , ud - > size , ( int ) ud - > size , ud - > data ) ; } / * get ut ##f - 8 character from a single as ##ci ##i character . * / u _ int ut ##f ##8 _ build _ one ( u _ char ch ) { return ( ut ##f ##8 _ set _ size ( 1 ) | ut ##f ##8 _ set _ width ( 1 ) | ch ) ; } / * set a single character . * / void ut ##f ##8 _ set ( st ##ru ##ct ut ##f ##8 _ data * ud , u _ char ch ) { static con ##st st ##ru ##ct ut ##f ##8 _ data empty = { { 0 } , 1 , 1 , 1 } ; me ##mc ##py ( ud , & empty , size ##of * ud ) ; * ud - > data = ch ; } / * copy ut ##f - 8 character . * / void ut ##f ##8 _ copy ( st ##ru ##ct ut ##f ##8 _ data * to , con ##st st ##ru ##ct ut ##f ##8 _ data * from ) { u _ int i ; me ##mc ##py ( to , from , size ##of * to ) ; for ( i = to - > size ; i < size ##of to - > data ; i + + ) to - > data [ i ] = ' \ 0 ' ; } / * get width of unicode character . * / static en ##um ut ##f ##8 _ state ut ##f ##8 _ width ( st ##ru ##ct ut ##f ##8 _ data * ud , int * width ) { wc ##har _ t wc ; if ( ut ##f ##8 _ tow ##c ( ud , & wc ) ! = ut ##f ##8 _ done ) return ( ut ##f ##8 _ error ) ; if ( ut ##f ##8 _ in _ table ( wc , ut ##f ##8 _ force _ wide , ni ##tem ##s ( ut ##f ##8 _ force _ wide ) ) ) { * width = 2 ; return ( ut ##f ##8 _ done ) ; } # if ##de ##f have _ ut ##f ##8 ##pro ##c * width = ut ##f ##8 ##pro ##c _ wcw ##id ##th ( wc ) ; log _ de ##bu ##g ( " ut ##f ##8 ##pro ##c _ wcw ##id ##th ( % 05 ##x ) returned % d " , ( u _ int ) wc , * width ) ; # else * width = wcw ##id ##th ( wc ) ; log _ de ##bu ##g ( " wcw ##id ##th ( % 05 ##x ) returned % d " , ( u _ int ) wc , * width ) ; if ( * width < 0 ) { / * * c1 control characters are non ##print ##able , so they are always * zero width . * / * width = ( wc > = 0 ##x ##80 & & wc < = 0 ##x ##9 ##f ) ? 0 : 1 ; } # end ##if if ( * width > = 0 & & * width < = 0 ##x ##ff ) return ( ut ##f ##8 _ done ) ; return ( ut ##f ##8 _ error ) ; } / * convert ut ##f - 8 character to wide character . * / en ##um ut ##f ##8 _ state ut ##f ##8 _ tow ##c ( con ##st st ##ru ##ct ut ##f ##8 _ data * ud , wc ##har _ t * wc ) { # if ##de ##f have _ ut ##f ##8 ##pro ##c switch ( ut ##f ##8 ##pro ##c _ mb ##tow ##c ( wc , ud - > data , ud - > size ) ) { # else switch ( mb ##tow ##c ( wc , ud - > data , ud - > size ) ) { # end ##if case - 1 : log _ de ##bu ##g ( " ut ##f - 8 % . * s , mb ##tow ##c ( ) % d " , ( int ) ud - > size , ud - > data , er ##rno ) ; mb ##tow ##c ( null , null , mb _ cu ##r _ max ) ; return ( ut ##f ##8 _ error ) ; case 0 : return ( ut ##f ##8 _ error ) ; } log _ de ##bu ##g ( " ut ##f - 8 % . * s is % 05 ##x " , ( int ) ud - > size , ud - > data , ( u _ int ) * wc ) ; return ( ut ##f ##8 _ done ) ; } / * * open ut ##f - 8 sequence . * * 1100 ##00 ##10 - 110 ##11 ##11 ##1 c2 - d ##f start of 2 - byte sequence * 111 ##00 ##00 ##0 - 111 ##01 ##11 ##1 e ##0 - e ##f start of 3 - byte sequence * 111 ##100 ##00 - 111 ##10 ##100 f ##0 - f ##4 start of 4 - byte sequence * / en ##um ut ##f ##8 _ state ut ##f ##8 _ open ( st ##ru ##ct ut ##f ##8 _ data * ud , u _ char ch ) { me ##ms ##et ( ud , 0 , size ##of * ud ) ; if ( ch > = 0 ##x ##c ##2 & & ch < = 0 ##x ##df ) ud - > size = 2 ; else if ( ch > = 0 ##x ##e ##0 & & ch < = 0 ##x ##ef ) ud - > size = 3 ; else if ( ch > = 0 ##x ##f ##0 & & ch < = 0 ##x ##f ##4 ) ud - > size = 4 ; else return ( ut ##f ##8 _ error ) ; ut ##f ##8 _ app ##end ( ud , ch ) ; return ( ut ##f ##8 _ more ) ; } / * app ##end character to ut ##f - 8 , closing if finished . * / en ##um ut ##f ##8 _ state ut ##f ##8 _ app ##end ( st ##ru ##ct ut ##f ##8 _ data * ud , u _ char ch ) { int width ; if ( ud - > have > = ud - > size ) fatal ##x ( " ut ##f - 8 character over ##flow " ) ; if ( ud - > size > size ##of ud - > data ) fatal ##x ( " ut ##f - 8 character size too large " ) ; if ( ud - > have ! = 0 & & ( ch & 0 ##x ##c ##0 ) ! = 0 ##x ##80 ) ud - > width = 0 ##x ##ff ; ud - > data [ ud - > have + + ] = ch ; if ( ud - > have ! = ud - > size ) return ( ut ##f ##8 _ more ) ; if ( ud - > width = = 0 ##x ##ff ) return ( ut ##f ##8 _ error ) ; if ( ut ##f ##8 _ width ( ud , & width ) ! = ut ##f ##8 _ done ) return ( ut ##f ##8 _ error ) ; ud - > width = width ; return ( ut ##f ##8 _ done ) ; } / * * en ##code len characters from sr ##c into ds ##t , which is guaranteed to have four * bytes available for each character from sr ##c ( for \ abc or ut ##f - 8 ) plus space * for \ 0 . * / int ut ##f ##8 _ st ##rvis ( char * ds ##t , con ##st char * sr ##c , size _ t len , int flag ) { st ##ru ##ct ut ##f ##8 _ data ud ; con ##st char * start = ds ##t , * end = sr ##c + len ; en ##um ut ##f ##8 _ state more ; size _ t i ; while ( sr ##c < end ) { if ( ( more = ut ##f ##8 _ open ( & ud , * sr ##c ) ) = = ut ##f ##8 _ more ) { while ( + + sr ##c < end & & more = = ut ##f ##8 _ more ) more = ut ##f ##8 _ app ##end ( & ud , * sr ##c ) ; if ( more = = ut ##f ##8 _ done ) { / * ut ##f - 8 character finished . * / for ( i = 0 ; i < ud . size ; i + + ) * ds ##t + + = ud . data [ i ] ; continue ; } / * not a complete , valid ut ##f - 8 character . * / sr ##c - = ud . have ; } if ( sr ##c [ 0 ] = = ' $ ' & & sr ##c < end - 1 ) { if ( isa ##lp ##ha ( ( u _ char ) sr ##c [ 1 ] ) | | sr ##c [ 1 ] = = ' _ ' | | sr ##c [ 1 ] = = ' { ' ) * ds ##t + + = ' \ \ ' ; * ds ##t + + = ' $ ' ; } else if ( sr ##c < end - 1 ) ds ##t = vis ( ds ##t , sr ##c [ 0 ] , flag , sr ##c [ 1 ] ) ; else if ( sr ##c < end ) ds ##t = vis ( ds ##t , sr ##c [ 0 ] , flag , ' \ 0 ' ) ; sr ##c + + ; } * ds ##t = ' \ 0 ' ; return ( ds ##t - start ) ; } / * same as ut ##f ##8 _ st ##rvis but all ##oca ##te the buffer . * / int ut ##f ##8 _ st ##ra ##vis ( char * * ds ##t , con ##st char * sr ##c , int flag ) { char * bu ##f ; int len ; bu ##f = x ##real ##lo ##car ##ray ( null , 4 , st ##rle ##n ( sr ##c ) + 1 ) ; len = ut ##f ##8 _ st ##rvis ( bu ##f , sr ##c , st ##rle ##n ( sr ##c ) , flag ) ; * ds ##t = x ##real ##lo ##c ( bu ##f , len + 1 ) ; return ( len ) ; } / * same as ut ##f ##8 _ st ##rvis but all ##oca ##te the buffer . * / int ut ##f ##8 _ st ##ra ##vis ##x ( char * * ds ##t , con ##st char * sr ##c , size _ t sr ##cle ##n , int flag ) { char * bu ##f ; int len ; bu ##f = x ##real ##lo ##car ##ray ( null , 4 , sr ##cle ##n + 1 ) ; len = ut ##f ##8 _ st ##rvis ( bu ##f , sr ##c , sr ##cle ##n , flag ) ; * ds ##t = x ##real ##lo ##c ( bu ##f , len + 1 ) ; return ( len ) ; } / * does this string contain anything that isn ' t valid ut ##f - 8 ? * / int ut ##f ##8 _ is ##val ##id ( con ##st char * s ) { st ##ru ##ct ut ##f ##8 _ data ud ; con ##st char * end ; en ##um ut ##f ##8 _ state more ; end = s + st ##rle ##n ( s ) ; while ( s < end ) { if ( ( more = ut ##f ##8 _ open ( & ud , * s ) ) = = ut ##f ##8 _ more ) { while ( + + s < end & & more = = ut ##f ##8 _ more ) more = ut ##f ##8 _ app ##end ( & ud , * s ) ; if ( more = = ut ##f ##8 _ done ) continue ; return ( 0 ) ; } if ( * s < 0 ##x ##20 | | * s > 0 ##x ##7 ##e ) return ( 0 ) ; s + + ; } return ( 1 ) ; } / * * san ##iti ##ze a string , changing any ut ##f - 8 characters to ' _ ' . caller should free * the returned string . anything not valid print ##able as ##ci ##i or ut ##f - 8 is * stripped . * / char * ut ##f ##8 _ san ##iti ##ze ( con ##st char * sr ##c ) { char * ds ##t = null ; size _ t n = 0 ; en ##um ut ##f ##8 _ state more ; st ##ru ##ct ut ##f ##8 _ data ud ; u _ int i ; while ( * sr ##c ! = ' \ 0 ' ) { ds ##t = x ##real ##lo ##car ##ray ( ds ##t , n + 1 , size ##of * ds ##t ) ; if ( ( more = ut ##f ##8 _ open ( & ud , * sr ##c ) ) = = ut ##f ##8 _ more ) { while ( * + + sr ##c ! = ' \ 0 ' & & more = = ut ##f ##8 _ more ) more = ut ##f ##8 _ app ##end ( & ud , * sr ##c ) ; if ( more = = ut ##f ##8 _ done ) { ds ##t = x ##real ##lo ##car ##ray ( ds ##t , n + ud . width , size ##of * ds ##t ) ; for ( i = 0 ; i < ud . width ; i + + ) ds ##t [ n + + ] = ' _ ' ; continue ; } sr ##c - = ud . have ; } if ( * sr ##c > 0 ##x ##1 ##f & & * sr ##c < 0 ##x ##7 ##f ) ds ##t [ n + + ] = * sr ##c ; else ds ##t [ n + + ] = ' _ ' ; sr ##c + + ; } ds ##t = x ##real ##lo ##car ##ray ( ds ##t , n + 1 , size ##of * ds ##t ) ; ds ##t [ n ] = ' \ 0 ' ; return ( ds ##t ) ; } / * get ut ##f - 8 buffer length . * / size _ t ut ##f ##8 _ st ##rle ##n ( con ##st st ##ru ##ct ut ##f ##8 _ data * s ) { size _ t i ; for ( i = 0 ; s [ i ] . size ! = 0 ; i + + ) / * nothing * / ; return ( i ) ; } / * get ut ##f - 8 string width . * / u _ int ut ##f ##8 _ st ##r ##wi ##dt ##h ( con ##st st ##ru ##ct ut ##f ##8 _ data * s , ss ##ize _ t n ) { ss ##ize _ t i ; u _ int width = 0 ; for ( i = 0 ; s [ i ] . size ! = 0 ; i + + ) { if ( n ! = - 1 & & n = = i ) break ; width + = s [ i ] . width ; } return ( width ) ; } / * * convert a string into a buffer of ut ##f - 8 characters . terminated by size = = 0 . * caller free ##s . * / st ##ru ##ct ut ##f ##8 _ data * ut ##f ##8 _ from ##cs ##tr ( con ##st char * sr ##c ) { st ##ru ##ct ut ##f ##8 _ data * ds ##t = null ; size _ t n = 0 ; en ##um ut ##f ##8 _ state more ; while ( * sr ##c ! = ' \ 0 ' ) { ds ##t = x ##real ##lo ##car ##ray ( ds ##t , n + 1 , size ##of * ds ##t ) ; if ( ( more = ut ##f ##8 _ open ( & ds ##t [ n ] , * sr ##c ) ) = = ut ##f ##8 _ more ) { while ( * + + sr ##c ! = ' \ 0 ' & & more = = ut ##f ##8 _ more ) more = ut ##f ##8 _ app ##end ( & ds ##t [ n ] , * sr ##c ) ; if ( more = = ut ##f ##8 _ done ) { n + + ; continue ; } sr ##c - = ds ##t [ n ] . have ; } ut ##f ##8 _ set ( & ds ##t [ n ] , * sr ##c ) ; n + + ; sr ##c + + ; } ds ##t = x ##real ##lo ##car ##ray ( ds ##t , n + 1 , size ##of * ds ##t ) ; ds ##t [ n ] . size = 0 ; return ( ds ##t ) ; } / * convert from a buffer of ut ##f - 8 characters into a string . caller free ##s . * / char * ut ##f ##8 _ to ##cs ##tr ( st ##ru ##ct ut ##f ##8 _ data * sr ##c ) { char * ds ##t = null ; size _ t n = 0 ; for ( ; sr ##c - > size ! = 0 ; sr ##c + + ) { ds ##t = x ##real ##lo ##car ##ray ( ds ##t , n + sr ##c - > size , 1 ) ; me ##mc ##py ( ds ##t + n , sr ##c - > data , sr ##c - > size ) ; n + = sr ##c - > size ; } ds ##t = x ##real ##lo ##car ##ray ( ds ##t , n + 1 , 1 ) ; ds ##t [ n ] = ' \ 0 ' ; return ( ds ##t ) ; } / * get width of ut ##f - 8 string . * / u _ int ut ##f ##8 _ cs ##tr ##wi ##dt ##h ( con ##st char * s ) { st ##ru ##ct ut ##f ##8 _ data t ##mp ; u _ int width ; en ##um ut ##f ##8 _ state more ; width = 0 ; while ( * s ! = ' \ 0 ' ) { if ( ( more = ut ##f ##8 _ open ( & t ##mp , * s ) ) = = ut ##f ##8 _ more ) { while ( * + + s ! = ' \ 0 ' & & more = = ut ##f ##8 _ more ) more = ut ##f ##8 _ app ##end ( & t ##mp , * s ) ; if ( more = = ut ##f ##8 _ done ) { width + = t ##mp . width ; continue ; } s - = t ##mp . have ; } if ( * s > 0 ##x ##1 ##f & & * s ! = 0 ##x ##7 ##f ) width + + ; s + + ; } return ( width ) ; } / * pad ut ##f - 8 string to width on the left . caller free ##s . * / char * ut ##f ##8 _ pad ##cs ##tr ( con ##st char * s , u _ int width ) { size _ t sl ##en ; char * out ; u _ int n , i ; n = ut ##f ##8 _ cs ##tr ##wi ##dt ##h ( s ) ; if ( n > = width ) return ( x ##st ##rd ##up ( s ) ) ; sl ##en = st ##rle ##n ( s ) ; out = x ##mal ##lo ##c ( sl ##en + 1 + ( width - n ) ) ; me ##mc ##py ( out , s , sl ##en ) ; for ( i = n ; i < width ; i + + ) out [ sl ##en + + ] = ' ' ; out [ sl ##en ] = ' \ 0 ' ; return ( out ) ; } / * pad ut ##f - 8 string to width on the right . caller free ##s . * / char * ut ##f ##8 _ r ##pad ##cs ##tr ( con ##st char * s , u _ int width ) { size _ t sl ##en ; char * out ; u _ int n , i ; n = ut ##f ##8 _ cs ##tr ##wi ##dt ##h ( s ) ; if ( n > = width ) return ( x ##st ##rd ##up ( s ) ) ; sl ##en = st ##rle ##n ( s ) ; out = x ##mal ##lo ##c ( sl ##en + 1 + ( width - n ) ) ; for ( i = 0 ; i < width - n ; i + + ) out [ i ] = ' ' ; me ##mc ##py ( out + i , s , sl ##en ) ; out [ i + sl ##en ] = ' \ 0 ' ; return ( out ) ; } int ut ##f ##8 _ cs ##tr ##has ( con ##st char * s , con ##st st ##ru ##ct ut ##f ##8 _ data * ud ) { st ##ru ##ct ut ##f ##8 _ data * copy , * loop ; int found = 0 ; copy = ut ##f ##8 _ from ##cs ##tr ( s ) ; for ( loop = copy ; loop - > size ! = 0 ; loop + + ) { if ( loop - > size ! = ud - > size ) continue ; if ( me ##mc ##mp ( loop - > data , ud - > data , loop - > size ) = = 0 ) { found = 1 ; break ; } } free ( copy ) ; return ( found ) ; } [SEP] 