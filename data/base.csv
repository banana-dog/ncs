./repos/cosmopolitan/tool/lambda/lam2bin.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/calls/calls.h""
#include ""libc/intrin/kprintf.h""
#include ""libc/mem/mem.h""
#include ""libc/runtime/runtime.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/locale.h""
#include ""libc/str/str.h""
#include ""third_party/getopt/getopt.internal.h""

#define USAGE \
  "" [-?h] <lambda.txt >binary.txt\n\
Converts lambda notation to ASCII binary, e.g.\n\
\n\
    $ printf 'λf.(λx.f(xx))(λx.f(xx))' | lam2bin\n\
    000100011100110100001110011010\n\
\n\
FLAGS\n\
\n\
  -h      Help\n\
  -?      Help\n""

struct Node {
  int t, x;
  struct Node *l, *r;
};

int sp;
int end;
int unget;
int args[1024];
const char *str;

static void LoadFlags(int argc, char *argv[]) {
  int i;
  const char *prog;
  prog = argc ? argv[0] : ""lam2bin"";
  while ((i = getopt(argc, argv, ""?h"")) != -1) {
    switch (i) {
      case '?':
      case 'h':
        fputs(""Usage: "", stdout);
        fputs(prog, stdout);
        fputs(USAGE, stdout);
        exit(0);
      default:
        fputs(""Usage: "", stderr);
        fputs(prog, stderr);
        fputs(USAGE, stderr);
        exit(1);
    }
  }
}

wontreturn static void Error(int rc, const char *s, ...) {
  va_list va;
  fflush(stdout);
  fputs(""\33[1;31merror\33[37m: "", stderr);
  fflush(stderr);
  va_start(va, s);
  kvprintf(s, va);
  va_end(va);
  fputc('\n', stderr);
  exit(rc);
}

static struct Node *NewNode(int t, int x, struct Node *l, struct Node *r) {
  struct Node *n;
  n = malloc(sizeof(struct Node));
  n->t = t;
  n->x = x;
  n->l = l;
  n->r = r;
  return n;
}

static int Greed(void) {
  int c, t;
  for (t = 0;;) {
    if (unget) {
      c = unget;
      unget = 0;
    } else if (str) {
      if (*str) {
        c = *str++;
      } else {
        str = 0;
        c = fgetwc(stdin);
      }
    } else {
      c = fgetwc(stdin);
    }
    if (c == EOF) return c;
    if (!t) {
      if (c == '#' || c == ';') {
        t = 1;
        continue;
      }
    } else {
      if (c == '\n') {
        t = 0;
      }
      continue;
    }
    if (iswspace(c)) continue;
    if (!str) {
      switch (c) {
        case L'⊥':
          str = ""(\\ab.b)"";
          continue;
        case L'⊤':
          str = ""(\\ab.a)"";
          continue;
#if 0
        case L'0':
          str = ""(\\ab.b)"";
          continue;
        case L'1':
          str = ""(\\ab.ab)"";
          continue;
        case L'2':
          str = ""(\\ab.a(ab))"";
          continue;
        case L'3':
          str = ""(\\ab.a(a(ab)))"";
          continue;
        case L'4':
          str = ""(\\ab.a(a(a(ab))))"";
          continue;
        case L'5':
          str = ""(\\ab.a(a(a(a(ab)))))"";
          continue;
        case L'6':
          str = ""(\\ab.a(a(a(a(a(ab))))))"";
          continue;
        case L'7':
          str = ""(\\ab.a(a(a(a(a(a(ab)))))))"";
          continue;
        case L'8':
          str = ""(\\ab.a(a(a(a(a(a(a(ab))))))))"";
          continue;
        case L'9':
          str = ""(\\ab.a(a(a(a(a(a(a(a(ab)))))))))"";
          continue;
#endif
        case L'ω':
          str = ""(\\x.xx)"";
          continue;
        case L'Ω':
          str = ""((\\x.xx)(\\x.xx))"";
          continue;
        case L'Y':
          str = ""(\\f.(\\x.f(xx))(\\x.f(xx)))"";
          continue;
        case L'∧':
          str = ""(\\ab.aba)"";
          continue;
        case L'∨':
          str = ""(\\ab.aab)"";
          continue;
        case L'⊻':
          str = ""(\\ab.a((\\c.c(\\de.e)(\\de.d))b)b)"";
          continue;
        case L'¬':
          str = ""(\\a.a(\\bc.c)(\\bc.b))"";
          continue;
        case L'+':
          str = ""(\\abcd.ac(bcd))"";
          continue;
        case L'*':
          str = ""(\\abc.a(bc))"";
          continue;
        case L'^':
          str = ""(\\ab.ba)"";
          continue;
        case L'-':
          str = ""(\\ab.b(\\cde.c(\\fg.g(fd))(\\f.e)(\\f.f))a)"";
          continue;
        case L'/':
          str = ""(\\a.(\\b.(\\c.cc)(\\c.b(cc)))(\\bcdef.(\\g.(\\h.h(\\ijk.k)(""
                ""\\ij.i))g((\\hi.i)ef)(e(bgdef)))((\\gh.h(\\ijk.i(\\lm.m(lj))(""
                ""\\l.k)(\\l.l))g)cd))((\\bcd.c(bcd))a))"";
          continue;
        case L'Я':
          str = ""(\\a.a((\\b.bb)(\\bcde.d(bb)(\\f.fce)))(\\bc.c))"";
          continue;
        default:
          break;
      }
    }
    return c;
  }
}

static int Need(void) {
  int c;
  if ((c = Greed()) != EOF) return c;
  Error(1, ""unfinished expression"");
}

static struct Node *Parse1(void) {
  wint_t c;
  int i, oldsp;
  struct Node *r, *p, *q;
  if ((c = Greed()) == EOF) return 0;
  if (c == L'λ' || c == '\\') {
    oldsp = sp;
    c = Need();
    if (!(isalnum(c) || c == '_')) Error(2, ""lambda needs argument"");
    p = r = NewNode(0, 0, 0, 0);
    args[sp++] = c;
    while ((c = Need()) != '.') {
      if (!(isalnum(c) || c == '_')) Error(3, ""lambda needs argument"");
      p = p->l = NewNode(0, 0, 0, 0);
      args[sp++] = c;
    }
    q = Parse1();
    if (!q) Error(4, ""lambda needs body"");
    p->l = q;
    while ((q = Parse1())) {
      p->l = NewNode(2, 0, p->l, q);
    }
    sp = oldsp;
    return r;
  } else if (c == L'!') {
    // intentionally trigger undefined variable
    return NewNode(1, sp, 0, 0);
  } else if (isalnum(c) || c == '_') {
    for (i = sp; i--;) {
      if (args[i] == c) {
        i = sp - 1 - i;
        break;
      }
    }
    if (i < 0) Error(5, ""undefined variable: %d %lc"", c, c);
    return NewNode(1, i, 0, 0);
  } else if (c == '(') {
    p = r = Parse1();
    if (!p) Error(6, ""empty parenthesis"");
    while ((q = Parse1())) {
      r = NewNode(2, 0, r, q);
    }
    c = Need();
    if (c != ')') Error(7, ""expected closing parenthesis"");
    return r;
  } else if (c == ')') {
    unget = c;
    return 0;
  } else {
    Error(8, ""unexpected character: 0x%04x %lc"", c, c);
  }
}

static struct Node *Parse(void) {
  struct Node *r, *p, *q;
  p = r = Parse1();
  if (!p) Error(6, ""empty expression"");
  while ((q = Parse1())) {
    r = NewNode(2, 0, r, q);
  }
  return r;
}

static void Print(struct Node *p) {
  int i;
  if (p->t == 0) {
    fputc('0', stdout);
    fputc('0', stdout);
    Print(p->l);
  } else if (p->t == 1) {
    for (i = -1; i < p->x; ++i) {
      fputc('1', stdout);
    }
    fputc('0', stdout);
  } else if (p->t == 2) {
    fputc('0', stdout);
    fputc('1', stdout);
    Print(p->l);
    Print(p->r);
  } else {
    abort();
  }
}

int main(int argc, char *argv[]) {
  setlocale(LC_ALL, """");
  LoadFlags(argc, argv);
  Print(Parse());
}
"
./repos/cosmopolitan/tool/lambda/lambda.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/assert.h""
#include ""libc/calls/calls.h""
#include ""libc/calls/struct/rlimit.h""
#include ""libc/calls/struct/sigaction.h""
#include ""libc/log/log.h""
#include ""libc/runtime/runtime.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/locale.h""
#include ""libc/sysv/consts/map.h""
#include ""libc/sysv/consts/prot.h""
#include ""libc/sysv/consts/rlimit.h""
#include ""libc/sysv/consts/sig.h""
#include ""third_party/getopt/getopt.internal.h""
#include ""tool/lambda/lib/blc.h""

#define USAGE \
  "" [-?hubBdsarvnNlS] <stdin >expr.txt\n\
Binary Lambda Calculus Virtual Machine\n\
\n\
FLAGS\n\
\n\
  -h      help\n\
  -r      rex log\n\
  -b      binary 8-bit i/o\n\
  -B      debug print binary\n\
  -l      print lambda notation\n\
  -a      action log [implies -r]\n\
  -v      variable log [implies -r]\n\
  -s      full machine state logging\n\
  -n      disables name rewriting rules\n\
  -N      disables most unicode symbolism\n\
  -d      dump terms on successful exit\n""

#define NIL   23
#define TRUE  27
#define FALSE 23

#define REF(c) (++(c)->refs, c)

static const char kRom[] = {
    APP, 0,  //  0 (λ 0 λ 0 (λ 0 wr0 wr1) put) (main gro)
    ABS,     //  2 λ 0 λ 0 (λ 0 wr0 wr1) put
    APP, 0,  //  3
    VAR, 0,  //  5
    ABS,     //  7
    APP,     //  8
    ABS,     //  9 λ 0 λ 0 wr0 wr1
    APP, 2,  // 10
    VAR,     // 12
    IOP,     // 13
    ABS,     // 14 λ 0 wr0 wr1
    APP, 4,  // 15
    APP, 1,  // 17
    VAR,     // 19
    IOP,     // 20 wr0
    IOP, 0,  // 21 wr1
    ABS,     // 23 (λλ 0) a.k.a. nil
    ABS,     // 24 exit
    VAR,     // 25
    0,       // 26 exit[0]
    ABS,     // 27 (λλ 1) a.k.a. true
    ABS,     // 28
    VAR, 1,  // 29
};

static int postdump;
static int kLazy[256];

void Quit(int sig) {
  Dump(0, end, stderr);
  exit(128 + sig);
}

void PrintUsage(const char *prog, int rc, FILE *f) {
  fputs(""Usage: "", f);
  fputs(prog, f);
  fputs(USAGE, f);
  exit(rc);
}

int Backref(int x) {
  return x - (end + 1);
}

static inline void Expand(int c) {
  if (end >= TERMS) Error(5, ""OUT OF TERMS"");
  mem[end++] = c;
}

void Gc(struct Closure *p) {
  struct Closure *t;
  while (p && p != &root) {
    if (--p->refs) break;
    Gc(p->next);
    t = p->envp;
    p->envp = 0;
    p->next = frep;
    frep = p;
    p = t;
  }
}

void Var(void) {
  int i, x;
  struct Closure *t, *e;
  e = t = envp;
  x = mem[ip + 1];
  for (i = 0; i < x && e != &root; ++i) e = e->next;
  if (e == &root) Error(10 + x, ""UNDEFINED VARIABLE %d"", x);
  ip = e->term;
  envp = REF(e->envp);
  Gc(t);
}

void Gro(void) {
  int c = fgetc(stdin);
  if (c != -1) {
    Expand(ABS);
    Expand(APP);
    Expand(4);
    Expand(APP);
    Expand(Backref(binary ? kLazy[c] : c & 1 ? FALSE : TRUE));
    Expand(VAR);
    Expand(0);
  } else {
    Expand(ABS);
    Expand(ABS);
    Expand(VAR);
    Expand(0);
  }
}

void Put(void) {
  int bit;
  long newip;
  if (!binary) {
    co = '0' + (ip & 1);
    fputc(co, stdout);
    newip = 2;
  } else if (mem[ip + 1] & 1) {  // ip ∈ {6,13}
    fputc(co, stdout);
    newip = 2;
  } else {      // ip ∈ {20,21}
    newip = 9;  // (λ 0 (λ 0 wr1 wr0))
    bit = ip & 1;
    co = (co * 2) | bit;
  }
  if (ferror(stdout)) {
    exit(55);
  }
  ip = newip;
}

void Bye(void) {
  int rc = mem[ip + 2];  // (λ 0) [exitcode]
  if (rc) Error(rc, ""CONTINUATIONS EXHAUSTED"");
  if (postdump && !rc) Dump(0, end, stderr);
  exit(0);
}

// pops continuation and pushes it to environment
void Abs(void) {
  if (!contp) Bye();
  struct Closure *t = contp;
  contp = t->next;
  t->next = envp;
  envp = t;
  ++ip;
}

struct Closure *Alloc(void) {
  struct Closure *t;
  if (!(t = frep)) {
    if (!(t = Calloc(1, sizeof(struct Closure)))) {
      Error(6, ""OUT OF HEAP"");
    }
  }
  frep = t->next;
  t->refs = 1;
  ++heap;
  return t;
}

// pushes continuation for argument
void App(void) {
  int x = mem[ip + 1];
  struct Closure *t = Alloc();
  t->term = ip + 2 + x;
  t->envp = t->term > 21 && t->term != end ? REF(envp) : &root;
  t->next = contp;
  contp = t;
  ip += 2;
}

int LoadByte(int c) {
  int i, r = end;
  for (i = 7; i >= 0; --i) {
    Expand(ABS);
    Expand(APP);
    Expand(i ? +4 : Backref(NIL));
    Expand(APP);
    Expand(Backref(c & (1 << i) ? FALSE : TRUE));
    Expand(VAR);
    Expand(0);
  }
  return r;
}

void LoadRom(void) {
  long i;
  for (; end < sizeof(kRom) / sizeof(*kRom); ++end) {
    mem[end] = kRom[end];
  }
  mem[4] = binary ? 2 : 9;
  if (binary) {
    for (i = 0; i < 256; ++i) {
      kLazy[i] = LoadByte(i);
    }
  }
  mem[1] = end - 2;
}

void Iop(void) {
  if (ip == end) {
    Gro();
  } else {
    Put();  // ip ∈ {6,13,20,21}
  }
  Gc(envp);
  envp = &root;
}

static void Rex(void) {
  if (slog) PrintMachineState(stderr);
  if (rlog && (alog || mem[ip] != APP)) {
    PrintExpressions(stderr, alog, vlog);
  }
  switch (mem[ip]) {
    case VAR:
      Var();
      break;
    case APP:
      App();
      break;
    case ABS:
      Abs();
      break;
    case IOP:
      Iop();
      break;
    default:
      Error(7, ""CORRUPT TERM"");
  }
}

void Krivine(void) {
  int main;
  long gotoget;
  LoadRom();
  mem[end++] = APP;
  gotoget = end++;
  main = end;
  mem[gotoget] = Parse(1, stdin).n;
  if (rlog) {
    Print(main, 1, 0, stderr);
    fputs(""\n"", stderr);
    if (alog) {
      fputs(""⟿ wrap["", stderr);
      Print(0, 1, 0, stderr);
      fputs(""]\n"", stderr);
    }
  }
  for (;;) Rex();
}

void LoadFlags(int argc, char *argv[]) {
  int i;
  const char *prog;
  prog = argc ? argv[0] : ""cblc"";
  while ((i = getopt(argc, argv, ""?hubBdsarvnNlS"")) != -1) {
    switch (i) {
      case 'b':
        binary = 1;
        break;
      case 'S':
        safer = 1;
        break;
      case 'n':
        noname = 1;
        break;
      case 'N':
        asciiname = 1;
        break;
      case 'B':
        style = 2;
        break;
      case 'l':
        style = 1;
        break;
      case 's':
        slog = 1;
        break;
      case 'r':
        rlog = 1;
        break;
      case 'a':
        rlog = 1;
        alog = 1;
        break;
      case 'v':
        rlog = 1;
        vlog = 1;
        break;
      case 'd':
        postdump = 1;
        break;
      case '?':
      case 'h':
        PrintUsage(prog, 0, stdout);
      default:
        PrintUsage(prog, 1, stderr);
    }
  }
}

int main(int argc, char *argv[]) {
  struct rlimit rlim = {512 * 1024 * 1024, 512 * 1024 * 1024};
  setrlimit(RLIMIT_AS, &rlim);
  signal(SIGQUIT, Quit);
  signal(SIGPIPE, Quit);
  LoadFlags(argc, argv);
  setlocale(LC_ALL, """");
  setvbuf(stdout, 0, _IOLBF, 0);
  setvbuf(stderr, 0, _IOLBF, 0);
  Krivine();
}
"
./repos/cosmopolitan/tool/lambda/blcdump.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/calls/calls.h""
#include ""libc/calls/struct/rlimit.h""
#include ""libc/runtime/runtime.h""
#include ""libc/str/locale.h""
#include ""libc/sysv/consts/rlimit.h""
#include ""third_party/getopt/getopt.internal.h""
#include ""tool/lambda/lib/blc.h""

/**
 * @fileoverview Binary Lambda Calculus Dump Utility, e.g.
 *
 *     $ echo 0000001110 | o//blcdump -b 2>/dev/null
 *     (λ (λ (λ 2)))
 *
 * The term rom is printed to stderr along with all skewed overlapping
 * perspectives on the in-memory representation.
 *
 *     $ echo 0000001110 | o//blcdump -b >/dev/null
 *         .long  ABS     # 0=3: (λ (λ (λ 2)))
 *         .long  ABS     # 1=3: (λ (λ 2))
 *         .long  ABS     # 2=3: (λ 2)
 *         .long  VAR     # 3=1: 2
 *         .long  2       # 4=2: (⋯ ⋯)
 */

#define USAGE \
  "" [-?hbBnNlS] [FILE...] <stdin >expr.txt 2>memory.txt\n\
Binary Lambda Calculus Dump Tool\n\
\n\
FLAGS\n\
\n\
  -h      Help\n\
  -b      8-bit binary mode\n\
  -B      debug print binary\n\
  -l      print lambda notation\n\
  -n      disables name rewriting rules\n\
  -N      disables most unicode symbolism\n""

void PrintUsage(const char *prog, int rc, FILE *f) {
  fputs(""Usage: "", f);
  fputs(prog, f);
  fputs(USAGE, f);
  exit(rc);
}

void LoadFlags(int argc, char *argv[]) {
  int i;
  const char *prog;
  prog = argc ? argv[0] : ""blcdump"";
  while ((i = getopt(argc, argv, ""?hubBnNlS"")) != -1) {
    switch (i) {
      case 'b':
        binary = 1;
        break;
      case 'n':
        noname = 1;
        break;
      case 'N':
        asciiname = 1;
        break;
      case 'l':
        style = 1;
        break;
      case 'B':
        style = 2;
        break;
      case 'S':
        safer = 1;
        break;
      case '?':
      case 'h':
        PrintUsage(prog, 0, stdout);
      default:
        PrintUsage(prog, 1, stderr);
    }
  }
}

void Expand(int c) {
  if (end >= TERMS) Error(5, ""OUT OF TERMS"");
  mem[end++] = c;
}

void ExpandBit(int b) {
  Expand(ABS);
  Expand(ABS);
  Expand(VAR);
  Expand(b);
}

void ExpandList(int next) {
  Expand(ABS);
  Expand(APP);
  Expand(next);
  Expand(APP);
  Expand(2);
  Expand(VAR);
  Expand(0);
}

void ExpandItem(int b) {
  ExpandList(8);
  ExpandBit(b);
}

void ExpandByte(int b) {
  ExpandList(4 + 8 * (7 + 4));
  ExpandItem((b >> 0) & 1);
  ExpandItem((b >> 1) & 1);
  ExpandItem((b >> 2) & 1);
  ExpandItem((b >> 3) & 1);
  ExpandItem((b >> 4) & 1);
  ExpandItem((b >> 5) & 1);
  ExpandItem((b >> 6) & 1);
  ExpandItem((b >> 7) & 1);
  ExpandBit(0);
}

int main(int argc, char *argv[]) {
  struct Parse p;
  struct rlimit rlim = {512 * 1024 * 1024, 512 * 1024 * 1024};
  setrlimit(RLIMIT_AS, &rlim);
  setlocale(LC_ALL, """");
  setvbuf(stdout, 0, _IOFBF, 0);
  setvbuf(stderr, 0, _IOLBF, 0);
  LoadFlags(argc, argv);
#if DEBUG
  logh = fopen(""o//log"", ""w"");
  fprintf(logh, ""      IP      END     HEAP %-*s NOM MESSAGE\n"", LOC, ""LOC"");
  setvbuf(logh, 0, _IOLBF, 0);
#endif
  end = 32;
  for (; !feof(stdin); ip = end) {
    p = Parse(1, stdin);
    if (p.n) {
      Print(p.i, 1, 0, stdout);
      fputc('\n', stdout);
      Dump(p.i, p.i + p.n, stderr);
    }
  }
}
"
./repos/cosmopolitan/tool/lambda/bru2bin.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/calls/calls.h""
#include ""libc/intrin/kprintf.h""
#include ""libc/mem/mem.h""
#include ""libc/runtime/runtime.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/locale.h""
#include ""libc/str/str.h""
#include ""third_party/getopt/getopt.internal.h""

#define USAGE \
  "" [-?h01] <lambda.txt >binary.txt\n\
Converts de Bruijn notation to ASCII binary, e.g.\n\
\n\
    $ printf 'λ (λ 1 (0 0)) (λ 1 (0 0)))' | lam2bin\n\
    000100011100110100001110011010\n\
\n\
FLAGS\n\
\n\
  -h      Help\n\
  -?      Help\n\
  -0      0-based indexing\n\
  -1      1-based indexing\n""

struct Node {
  int t, x;
  struct Node *l, *r;
};

int sp;
int end;
int unget;
int indexing;
const char *str;

static void LoadFlags(int argc, char *argv[]) {
  int i;
  const char *prog;
  prog = argc ? argv[0] : ""lam2bin"";
  while ((i = getopt(argc, argv, ""?h01"")) != -1) {
    switch (i) {
      case '0':
        indexing = 0;
        break;
      case '1':
        indexing = 1;
        break;
      case '?':
      case 'h':
        fputs(""Usage: "", stdout);
        fputs(prog, stdout);
        fputs(USAGE, stdout);
        exit(0);
      default:
        fputs(""Usage: "", stderr);
        fputs(prog, stderr);
        fputs(USAGE, stderr);
        exit(1);
    }
  }
}

wontreturn static void Error(int rc, const char *s, ...) {
  va_list va;
  fflush(stdout);
  fputs(""\33[1;31merror\33[37m: "", stderr);
  fflush(stderr);
  va_start(va, s);
  kvprintf(s, va);
  va_end(va);
  fputc('\n', stderr);
  exit(rc);
}

static struct Node *NewNode(int t, int x, struct Node *l, struct Node *r) {
  struct Node *n;
  n = malloc(sizeof(struct Node));
  n->t = t;
  n->x = x;
  n->l = l;
  n->r = r;
  return n;
}

static int Greed(void) {
  int c, t;
  for (t = 0;;) {
    if (unget) {
      c = unget;
      unget = 0;
    } else if (str) {
      if (*str) {
        c = *str++;
      } else {
        str = 0;
        c = fgetwc(stdin);
      }
    } else {
      c = fgetwc(stdin);
    }
    if (c == EOF) return c;
    if (!t) {
      if (c == '#' || c == ';') {
        t = 1;
        continue;
      }
    } else {
      if (c == '\n') {
        t = 0;
      }
      continue;
    }
    if (!str) {
      switch (c) {
        case L'⊥':
          str = ""(\\ab.b)"";
          continue;
        case L'⊤':
          str = ""(\\ab.a)"";
          continue;
#if 0
        case L'0':
          str = ""(\\ab.b)"";
          continue;
        case L'1':
          str = ""(\\ab.ab)"";
          continue;
        case L'2':
          str = ""(\\ab.a(ab))"";
          continue;
        case L'3':
          str = ""(\\ab.a(a(ab)))"";
          continue;
        case L'4':
          str = ""(\\ab.a(a(a(ab))))"";
          continue;
        case L'5':
          str = ""(\\ab.a(a(a(a(ab)))))"";
          continue;
        case L'6':
          str = ""(\\ab.a(a(a(a(a(ab))))))"";
          continue;
        case L'7':
          str = ""(\\ab.a(a(a(a(a(a(ab)))))))"";
          continue;
        case L'8':
          str = ""(\\ab.a(a(a(a(a(a(a(ab))))))))"";
          continue;
        case L'9':
          str = ""(\\ab.a(a(a(a(a(a(a(a(ab)))))))))"";
          continue;
#endif
        case L'ω':
          str = ""(\\x.xx)"";
          continue;
        case L'Ω':
          str = ""((\\x.xx)(\\x.xx))"";
          continue;
        case L'Y':
          str = ""(\\f.(\\x.f(xx))(\\x.f(xx)))"";
          continue;
        case L'∧':
          str = ""(\\ab.aba)"";
          continue;
        case L'∨':
          str = ""(\\ab.aab)"";
          continue;
        case L'⊻':
          str = ""(\\ab.a((\\c.c(\\de.e)(\\de.d))b)b)"";
          continue;
        case L'¬':
          str = ""(\\a.a(\\bc.c)(\\bc.b))"";
          continue;
        case L'+':
          str = ""(\\abcd.ac(bcd))"";
          continue;
        case L'*':
          str = ""(\\abc.a(bc))"";
          continue;
        case L'^':
          str = ""(\\ab.ba)"";
          continue;
        case L'-':
          str = ""(\\ab.b(\\cde.c(\\fg.g(fd))(\\f.e)(\\f.f))a)"";
          continue;
        case L'/':
          str = ""(\\a.(\\b.(\\c.cc)(\\c.b(cc)))(\\bcdef.(\\g.(\\h.h(\\ijk.k)(""
                ""\\ij.i))g((\\hi.i)ef)(e(bgdef)))((\\gh.h(\\ijk.i(\\lm.m(lj))(""
                ""\\l.k)(\\l.l))g)cd))((\\bcd.c(bcd))a))"";
          continue;
        case L'Я':
          str = ""(\\a.a((\\b.bb)(\\bcde.d(bb)(\\f.fce)))(\\bc.c))"";
          continue;
        default:
          break;
      }
    }
    return c;
  }
}

static int Need(void) {
  int c;
  if ((c = Greed()) != EOF) return c;
  Error(1, ""unfinished expression"");
}

static struct Node *Parse1(void) {
  wint_t c;
  int i, oldsp;
  struct Node *r, *p, *q;
  do {
    if ((c = Greed()) == EOF) return 0;
  } while (iswspace(c));
  if (c == L'λ' || c == '\\') {
    oldsp = sp;
    p = r = NewNode(0, 0, 0, 0);
    ++sp;
    for (;;) {
      c = Need();
      if (c == L'λ' || c == '\\') {
        p = p->l = NewNode(0, 0, 0, 0);
        ++sp;
        continue;
      } else {
        unget = c;
        break;
      }
    }
    q = Parse1();
    if (!q) Error(4, ""lambda needs body"");
    p->l = q;
    while ((q = Parse1())) {
      p->l = NewNode(2, 0, p->l, q);
    }
    sp = oldsp;
    return r;
  } else if (c == L'!') {
    // intentionally trigger undefined variable
    return NewNode(1, sp, 0, 0);
  } else if (iswdigit(c)) {
    i = 0;
    for (;;) {
      i *= 10;
      i += c - '0';
      c = Greed();
      if (c == EOF) break;
      if (!iswdigit(c)) {
        unget = c;
        break;
      }
    }
    i -= indexing;
    if (i < 0) Error(5, ""undefined variable: %lc"", c);
    return NewNode(1, i, 0, 0);
  } else if (c == '(') {
    p = r = Parse1();
    if (!p) Error(6, ""empty parenthesis"");
    while ((q = Parse1())) {
      r = NewNode(2, 0, r, q);
    }
    c = Need();
    if (c != ')') Error(7, ""expected closing parenthesis"");
    return r;
  } else if (c == ')') {
    unget = c;
    return 0;
  } else {
    Error(8, ""unexpected character: 0x%04x %lc"", c, c);
  }
}

static struct Node *Parse(void) {
  struct Node *r, *p, *q;
  p = r = Parse1();
  if (!p) Error(6, ""empty expression"");
  while ((q = Parse1())) {
    r = NewNode(2, 0, r, q);
  }
  return r;
}

static void Print(struct Node *p) {
  int i;
  if (p->t == 0) {
    fputc('0', stdout);
    fputc('0', stdout);
    Print(p->l);
  } else if (p->t == 1) {
    for (i = -1; i < p->x; ++i) {
      fputc('1', stdout);
    }
    fputc('0', stdout);
  } else if (p->t == 2) {
    fputc('0', stdout);
    fputc('1', stdout);
    Print(p->l);
    Print(p->r);
  } else {
    abort();
  }
}

int main(int argc, char *argv[]) {
  setlocale(LC_ALL, """");
  LoadFlags(argc, argv);
  Print(Parse());
}
"
./repos/cosmopolitan/tool/lambda/asc2bin.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/runtime/runtime.h""
#include ""third_party/getopt/getopt.internal.h""
#include ""tool/lambda/lib/blc.h""

#define USAGE \
  "" [-?h] [FILE...] <binary.txt >binary.bin\n\
Converts ASCII binary to ACTUAL binary, e.g.\n\
\n\
    $ { printf 'λx.x' | o/lam2bin | o/asc2bin; printf abc; } | o/Blc\n\
    abc\n\
\n\
    $ printf '\n\
    (00 (01 (01 10 ((01 (00 (01 10 10))\n\
                        (00000000 (01 (01 110 ((01 11110 11110)))\n\
                                      (00 (01 (01 10 11110) 110)))))))\n\
            (0000 10)))\n\
    ' | asc2bin | xxd -b\n\
    00000000: 00010110 01000110 10000000 00010111 00111110 11110000  .F..>.\n\
    00000006: 10110111 10110000 01000000                             ..@\n\
\n\
FLAGS\n\
\n\
  -h      Help\n\
  -?      Help\n""

void LoadFlags(int argc, char *argv[]) {
  int i;
  const char *prog;
  prog = argc ? argv[0] : ""asc2bin"";
  while ((i = getopt(argc, argv, ""?h"")) != -1) {
    switch (i) {
      case '?':
      case 'h':
        fputs(""Usage: "", stdout);
        fputs(prog, stdout);
        fputs(USAGE, stdout);
        exit(0);
      default:
        fputs(""Usage: "", stderr);
        fputs(prog, stderr);
        fputs(USAGE, stderr);
        exit(1);
    }
  }
}

int main(int argc, char *argv[]) {
  int i, b, c, n;
  LoadFlags(argc, argv);
  n = c = i = 0;
  while ((b = GetBit(stdin)) != -1) {
    c |= b << (7 - n);
    if (++n == 8) {
      fputc(c, stdout);
      c = 0;
      n = 0;
    }
  }
  if (n) {
    fputc(c, stdout);
  }
}
"
./repos/cosmopolitan/tool/lambda/lib/print.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/fmt/itoa.h""
#include ""tool/lambda/lib/blc.h""

#define FREEBIES u""ɐqɔpǝɟƃɥıɾʞןɯuodbɹsʇnʌʍxʎz""

/* clang-format off */
#define ALPHABET                \
  u""abcdefghijklmnopqrsuvwxyz""  \
  u""αβγδεζηθιμξπρςστυφχψϑϕ""     \
  u""ℵℶℷℸ""                       \
  u""идџжлђ""                     \
  u""⅄ℏ℘þæß§£¥₿""                 \
  u""𝘢𝘣𝘤𝘥𝘦𝘧𝘨𝘩𝘪𝘫𝘬𝘭𝘮𝘯𝘰𝘱𝘲𝘳𝘴𝘵𝘶𝘷𝘸𝘹𝘺𝘻"" \
  u""𝕒𝕓𝕔𝕕𝕖𝕗𝕘𝕙𝕚𝕛𝕜𝕝𝕞𝕟𝕠𝕡𝕢𝕣𝕤𝕥𝕦𝕧𝕨𝕩𝕪𝕫"" \
  u""𝗮𝗯𝗰𝗱𝗲𝗳𝗴𝗵𝗶𝗷𝗸𝗹𝗺𝗻𝗼𝗽𝗾𝗿𝘀𝘁𝘂𝘃𝘄𝘅𝘆𝘇""
/* clang-format on */

static char kFalse[] = {
    ABS,     //  0: false
    ABS,     //  1: (λ 0)
    VAR, 0,  //  2: 0
};

static char kTrue[] = {
    ABS,     //  0: true
    ABS,     //  1: (λ 1)
    VAR, 1,  //  2: 1
};

static char kOne[] = {
    ABS,     //  4: (λab.ab)
    ABS,     //  5: (λa.ɐa)
    APP, 2,  //  6: qɐ
    VAR, 1,  //  8: q
    VAR, 0,  // 10: ɐ
};

static char kTwo[] = {
    ABS,     // 12: (λab.a(ab))
    ABS,     // 13: (λa.ɐ(ɐa))
    APP, 2,  // 14: q(qɐ)
    VAR, 1,  // 16: q
    APP, 2,  // 18: qɐ
    VAR, 1,  // 20: q
    VAR, 0,  // 22: ɐ
};

static char kThree[] = {
    ABS,     // 24: (λab.a(a(ab)))
    ABS,     // 25: (λa.ɐ(ɐ(ɐa)))
    APP, 2,  // 26: q(q(qɐ))
    VAR, 1,  // 28: q
    APP, 2,  // 30: q(qɐ)
    VAR, 1,  // 32: q
    APP, 2,  // 34: qɐ
    VAR, 1,  // 36: q
    VAR, 0,  // 38: ɐ
};

static char kFour[] = {
    ABS,     // 40: (λab.a(a(a(ab))))
    ABS,     // 41: (λa.ɐ(ɐ(ɐ(ɐa))))
    APP, 2,  // 42: q(q(q(qɐ)))
    VAR, 1,  // 44: q
    APP, 2,  // 46: q(q(qɐ))
    VAR, 1,  // 48: q
    APP, 2,  // 50: q(qɐ)
    VAR, 1,  // 52: q
    APP, 2,  // 54: qɐ
    VAR, 1,  // 56: q
    VAR, 0,  // 58: ɐ
};

static char kFive[] = {
    ABS,     // 60: (λab.a(a(a(a(ab)))))
    ABS,     // 61: (λa.ɐ(ɐ(ɐ(ɐ(ɐa)))))
    APP, 2,  // 62: q(q(q(q(qɐ))))
    VAR, 1,  // 64: q
    APP, 2,  // 66: q(q(q(qɐ)))
    VAR, 1,  // 68: q
    APP, 2,  // 70: q(q(qɐ))
    VAR, 1,  // 72: q
    APP, 2,  // 74: q(qɐ)
    VAR, 1,  // 76: q
    APP, 2,  // 78: qɐ
    VAR, 1,  // 80: q
    VAR, 0,  // 82: ɐ
};

static char kSix[] = {
    ABS,     // 84: (λab.a(a(a(a(a(ab))))))
    ABS,     // 85: (λa.ɐ(ɐ(ɐ(ɐ(ɐ(ɐa))))))
    APP, 2,  // 86: q(q(q(q(q(qɐ)))))
    VAR, 1,  // 88: q
    APP, 2,  // 90: q(q(q(q(qɐ))))
    VAR, 1,  // 92: q
    APP, 2,  // 94: q(q(q(qɐ)))
    VAR, 1,  // 96: q
    APP, 2,  // 98: q(q(qɐ))
    VAR, 1,  // 100: q
    APP, 2,  // 102: q(qɐ)
    VAR, 1,  // 104: q
    APP, 2,  // 106: qɐ
    VAR, 1,  // 108: q
    VAR, 0,  // 110: ɐ
};

static char kSeven[] = {
    ABS,     // 112: (λab.a(a(a(a(a(a(ab)))))))
    ABS,     // 113: (λa.ɐ(ɐ(ɐ(ɐ(ɐ(ɐ(ɐa)))))))
    APP, 2,  // 114: q(q(q(q(q(q(qɐ))))))
    VAR, 1,  // 116: q
    APP, 2,  // 118: q(q(q(q(q(qɐ)))))
    VAR, 1,  // 120: q
    APP, 2,  // 122: q(q(q(q(qɐ))))
    VAR, 1,  // 124: q
    APP, 2,  // 126: q(q(q(qɐ)))
    VAR, 1,  // 128: q
    APP, 2,  // 130: q(q(qɐ))
    VAR, 1,  // 132: q
    APP, 2,  // 134: q(qɐ)
    VAR, 1,  // 136: q
    APP, 2,  // 138: qɐ
    VAR, 1,  // 140: q
    VAR, 0,  // 142: ɐ
};

static char kEight[] = {
    ABS,     // 144: (λab.a(a(a(a(a(a(a(ab))))))))
    ABS,     // 145: (λa.ɐ(ɐ(ɐ(ɐ(ɐ(ɐ(ɐ(ɐa))))))))
    APP, 2,  // 146: q(q(q(q(q(q(q(qɐ)))))))
    VAR, 1,  // 148: q
    APP, 2,  // 150: q(q(q(q(q(q(qɐ))))))
    VAR, 1,  // 152: q
    APP, 2,  // 154: q(q(q(q(q(qɐ)))))
    VAR, 1,  // 156: q
    APP, 2,  // 158: q(q(q(q(qɐ))))
    VAR, 1,  // 160: q
    APP, 2,  // 162: q(q(q(qɐ)))
    VAR, 1,  // 164: q
    APP, 2,  // 166: q(q(qɐ))
    VAR, 1,  // 168: q
    APP, 2,  // 170: q(qɐ)
    VAR, 1,  // 172: q
    APP, 2,  // 174: qɐ
    VAR, 1,  // 176: q
    VAR, 0,  // 178: ɐ
};

static char kNine[] = {
    ABS,     // 180: (λab.a(a(a(a(a(a(a(a(ab)))))))))
    ABS,     // 181: (λa.ɐ(ɐ(ɐ(ɐ(ɐ(ɐ(ɐ(ɐ(ɐa)))))))))
    APP, 2,  // 182: q(q(q(q(q(q(q(q(qɐ))))))))
    VAR, 1,  // 184: q
    APP, 2,  // 186: q(q(q(q(q(q(q(qɐ)))))))
    VAR, 1,  // 188: q
    APP, 2,  // 190: q(q(q(q(q(q(qɐ))))))
    VAR, 1,  // 192: q
    APP, 2,  // 194: q(q(q(q(q(qɐ)))))
    VAR, 1,  // 196: q
    APP, 2,  // 198: q(q(q(q(qɐ))))
    VAR, 1,  // 200: q
    APP, 2,  // 202: q(q(q(qɐ)))
    VAR, 1,  // 204: q
    APP, 2,  // 206: q(q(qɐ))
    VAR, 1,  // 208: q
    APP, 2,  // 210: q(qɐ)
    VAR, 1,  // 212: q
    APP, 2,  // 214: qɐ
    VAR, 1,  // 216: q
    VAR, 0,  // 218: ɐ
};

static char kSelf[] = {
    ABS,     //  0: λa.aa
    APP, 2,  //  1: ɐɐ
    VAR, 0,  //  3: ɐ
    VAR, 0,  //  5: ɐ
};

static char kOmega[] = {
    APP, 7,  //  0: ω ω
    ABS,     //  2: ω
    APP, 2,  //  3: ɐ ɐ
    VAR, 0,  //  5: ɐ
    VAR, 0,  //  7: ɐ
    ABS,     //  9: ω
    APP, 2,  // 10: ɐ ɐ
    VAR, 0,  // 12: ɐ
    VAR, 0,  // 14: ɐ
};

static char kIf[] = {
    ABS,     //  0: if
    ABS,     //  1: (λλ 2 1 0)
    ABS,     //  2: (λ 2 1 0)
    APP, 6,  //  3: 2 1 0
    APP, 2,  //  5: 2 1
    VAR, 2,  //  7: 2
    VAR, 1,  //  9: 1
    VAR, 0,  // 11: 0
};

static char kOr[] = {
    ABS,     // 32: λab.bba
    ABS,     // 33: λa.aaɐ
    APP, 6,  // 34: ɐɐq
    APP, 2,  // 36: ɐɐ
    VAR, 0,  // 38: ɐ
    VAR, 0,  // 40: ɐ
    VAR, 1,  // 42: q
};

static char kAnd[] = {
    ABS,     // 32: λab.bab
    ABS,     // 33: λa.aɐa
    APP, 6,  // 34: ɐqɐ
    APP, 2,  // 36: ɐq
    VAR, 0,  // 38: ɐ
    VAR, 1,  // 40: q
    VAR, 0,  // 42: ɐ
};

static char kNot[] = {
    ABS,     // 32: λabc.acb
    ABS,     // 33: λab.ɐba
    ABS,     // 34: λa.qaɐ
    APP, 6,  // 35: ɔɐq
    APP, 2,  // 37: ɔɐ
    VAR, 2,  // 39: ɔ
    VAR, 0,  // 41: ɐ
    VAR, 1,  // 43: q
};

static char kPair[] = {
    ABS,     //  0: (λλλ 0 2 1)
    ABS,     //  1: (λλ 0 2 1)
    ABS,     //  2: (λ 0 2 1)
    APP, 6,  //  3: 0 2 1
    APP, 2,  //  5: 0 2
    VAR, 0,  //  7: 0
    VAR, 2,  //  9: 2
    VAR, 1,  // 11: 1
};

static char kFirst[] = {
    ABS,     //  0: (λ 0 false)
    APP, 2,  //  1: 0 false
    VAR, 0,  //  3: 0
    ABS,     //  5: false
    ABS,     //  6: (λ 0)
    VAR, 0,  //  7: 0
};

static char kSecond[] = {
    ABS,     //  0: (λ 0 true)
    APP, 2,  //  1: 0 true
    VAR, 0,  //  3: 0
    ABS,     //  5: true
    ABS,     //  6: (λ 1)
    VAR, 1,  //  7: 1
};

static char kSucc[] = {
    ABS,     //  0: (λλλ 1 (2 1 0))
    ABS,     //  1: (λλ 1 (2 1 0))
    ABS,     //  2: (λ 1 (2 1 0))
    APP, 2,  //  3: 1 (2 1 0)
    VAR, 1,  //  5: 1
    APP, 6,  //  7: 2 1 0
    APP, 2,  //  9: 2 1
    VAR, 2,  // 11: 2
    VAR, 1,  // 13: 1
    VAR, 0,  // 15: 0
};

static char kCompose[] = {
    ABS,     //  0: (λλλ 2 (1 0))
    ABS,     //  1: (λλ 2 (1 0))
    ABS,     //  2: (λ 2 (1 0))
    APP, 2,  //  3: 2 (1 0)
    VAR, 2,  //  5: 2
    APP, 2,  //  7: 1 0
    VAR, 1,  //  9: 1
    VAR, 0,  // 11: 0
};

static char kMap[] = {
    ABS,      //  0: (λλλλ 2 (compose 1 3) 0)
    ABS,      //  1: (λλλ 2 (compose 1 3) 0)
    ABS,      //  2: (λλ 2 (compose 1 3) 0)
    ABS,      //  3: (λ 2 (compose 1 3) 0)
    APP, 25,  //  4: 2 (compose 1 3) 0
    APP, 2,   //  6: 2 (compose 1 3)
    VAR, 2,   //  8: 2
    APP, 17,  // 10: compose 1 3
    APP, 13,  // 12: compose 1
    ABS,      // 14: compose
    ABS,      // 15: (λλ 2 (1 0))
    ABS,      // 16: (λ 2 (1 0))
    APP, 2,   // 17: 2 (1 0)
    VAR, 2,   // 19: 2
    APP, 2,   // 21: 1 0
    VAR, 1,   // 23: 1
    VAR, 0,   // 25: 0
    VAR, 1,   // 27: 1
    VAR, 3,   // 29: 3
    VAR, 0,   // 31: 0
};

static char kCons[] = {
    ABS,     //  0: (λλλλ 1 3 (2 1 0))
    ABS,     //  1: (λλλ 1 3 (2 1 0))
    ABS,     //  2: (λλ 1 3 (2 1 0))
    ABS,     //  3: (λ 1 3 (2 1 0))
    APP, 6,  //  4: 1 3 (2 1 0)
    APP, 2,  //  6: 1 3
    VAR, 1,  //  8: 1
    VAR, 3,  // 10: 3
    APP, 6,  // 12: 2 1 0
    APP, 2,  // 14: 2 1
    VAR, 2,  // 16: 2
    VAR, 1,  // 18: 1
    VAR, 0,  // 20: 0
};

static char kY[] = {
    ABS,     // 32: λa.(λb.bb)(λb.a(bb))
    APP, 7,  // 33: (λa.aa)(λa.ɐ(aa))
    ABS,     // 35: λa.aa
    APP, 2,  // 36: ɐɐ
    VAR, 0,  // 38: ɐ
    VAR, 0,  // 40: ɐ
    ABS,     // 42: λa.ɐ(aa)
    APP, 2,  // 43: q(ɐɐ)
    VAR, 1,  // 45: q
    APP, 2,  // 47: ɐɐ
    VAR, 0,  // 49: ɐ
    VAR, 0,  // 51: ɐ
};

static char kYCurry[] = {
    ABS,      //  0: (λ (λ 1 (0 0)) (λ 1 (0 0)))
    APP, 11,  //  1: (λ 1 (0 0)) (λ 1 (0 0))
    ABS,      //  3: (λ 1 (0 0))
    APP, 2,   //  4: 1 (0 0)
    VAR, 1,   //  6: 1
    APP, 2,   //  8: 0 0
    VAR, 0,   // 10: 0
    VAR, 0,   // 12: 0
    ABS,      // 14: (λ 1 (0 0))
    APP, 2,   // 15: 1 (0 0)
    VAR, 1,   // 17: 1
    APP, 2,   // 19: 0 0
    VAR, 0,   // 21: 0
    VAR, 0,   // 23: 0
};

static char kIszero[] = {
    ABS,     // 32: λabc.a(λd.c)b
    ABS,     // 33: λab.ɐ(λc.b)a
    ABS,     // 34: λa.q(λb.a)ɐ
    APP, 7,  // 35: ɔ(λa.ɐ)q
    APP, 2,  // 37: ɔ(λa.ɐ)
    VAR, 2,  // 39: ɔ
    ABS,     // 41: λa.ɐ
    VAR, 1,  // 42: q
    VAR, 1,  // 44: q
};

static char kPred[] = {
    ABS,      //  0: λabc.a(λde.e(db))(λd.c)(λd.d)
    ABS,      //  1: λab.ɐ(λcd.d(ca))(λc.b)(λc.c)
    ABS,      //  2: λa.q(λbc.c(bɐ))(λb.a)(λb.b)
    APP, 21,  //  3: ɔ(λab.b(aq))(λa.ɐ)(λa.a)
    APP, 16,  //  5: ɔ(λab.b(aq))(λa.ɐ)
    APP, 2,   //  7: ɔ(λab.b(aq))
    VAR, 2,   //  9: ɔ
    ABS,      // 11: λab.b(aq)
    ABS,      // 12: λa.a(ɐɔ)
    APP, 2,   // 13: ɐ(qp)
    VAR, 0,   // 15: ɐ
    APP, 2,   // 17: qp
    VAR, 1,   // 19: q
    VAR, 3,   // 21: p
    ABS,      // 23: λa.ɐ
    VAR, 1,   // 24: q
    ABS,      // 26: λa.a
    VAR, 0,   // 27: ɐ
};

static char kXor[] = {
    ABS,      // 32: λab.a(λcd.bdc)b
    ABS,      // 33: λa.ɐ(λbc.acb)a
    APP, 16,  // 34: q(λab.ɐba)ɐ
    APP, 2,   // 36: q(λab.ɐba)
    VAR, 1,   // 38: q
    ABS,      // 40: λab.ɐba
    ABS,      // 41: λa.qaɐ
    APP, 6,   // 42: ɔɐq
    APP, 2,   // 44: ɔɐ
    VAR, 2,   // 46: ɔ
    VAR, 0,   // 48: ɐ
    VAR, 1,   // 50: q
    VAR, 0,   // 52: ɐ
};

static char kAdd[] = {
    ABS,     // 29: λabcd.ac(bcd)
    ABS,     // 30: λabc.ɐb(abc)
    ABS,     // 31: λab.qa(ɐab)
    ABS,     // 32: λa.ɔɐ(qɐa)
    APP, 6,  // 33: pq(ɔqɐ)
    APP, 2,  // 35: pq
    VAR, 3,  // 37: p
    VAR, 1,  // 39: q
    APP, 6,  // 41: ɔqɐ
    APP, 2,  // 43: ɔq
    VAR, 2,  // 45: ɔ
    VAR, 1,  // 47: q
    VAR, 0,  // 49: ɐ
};

static char kSub[] = {
    ABS,      // 51: λab.b(λcde.c(λfg.g(fd))(λf.e)(λf.f))a
    ABS,      // 52: λa.a(λbcd.b(λef.f(ec))(λe.d)(λe.e))ɐ
    APP, 33,  // 53: ɐ(λabc.a(λde.e(db))(λd.c)(λd.d))q
    APP, 2,   // 55: ɐ(λabc.a(λde.e(db))(λd.c)(λd.d))
    VAR, 0,   // 57: ɐ
    ABS,      // 59: λabc.a(λde.e(db))(λd.c)(λd.d)
    ABS,      // 60: λab.ɐ(λcd.d(ca))(λc.b)(λc.c)
    ABS,      // 61: λa.q(λbc.c(bɐ))(λb.a)(λb.b)
    APP, 21,  // 62: ɔ(λab.b(aq))(λa.ɐ)(λa.a)
    APP, 16,  // 64: ɔ(λab.b(aq))(λa.ɐ)
    APP, 2,   // 66: ɔ(λab.b(aq))
    VAR, 2,   // 68: ɔ
    ABS,      // 70: λab.b(aq)
    ABS,      // 71: λa.a(ɐɔ)
    APP, 2,   // 72: ɐ(qp)
    VAR, 0,   // 74: ɐ
    APP, 2,   // 76: qp
    VAR, 1,   // 78: q
    VAR, 3,   // 80: p
    ABS,      // 82: λa.ɐ
    VAR, 1,   // 83: q
    ABS,      // 85: λa.a
    VAR, 0,   // 86: ɐ
    VAR, 1,   // 88: q
};

static char kLe[] = {
    ABS,      //  0: λab.iszero(- a b)
    ABS,      //  1: λa.iszero(- ɐ a)
    APP, 16,  //  2: iszero(- q ɐ)
    ABS,      //  4: iszero
    APP, 9,   //  5: ɐ (λabc.c) ⊤
    APP, 2,   //  7: ɐ (λabc.c)
    VAR, 0,   //  9: ɐ
    ABS,      // 11: λabc.c
    ABS,      // 12: ⊥
    ABS,      // 13: λa.a
    VAR, 0,   // 14: ɐ
    ABS,      // 16: ⊤
    ABS,      // 17: λa.ɐ
    VAR, 1,   // 18: q
    APP, 43,  // 20: - q ɐ
    APP, 39,  // 22: - q
    ABS,      // 24: -
    ABS,      // 25: λa.a dec ɐ
    APP, 33,  // 26: ɐ dec q
    APP, 2,   // 28: ɐ dec
    VAR, 0,   // 30: ɐ
    ABS,      // 32: dec
    ABS,      // 33: λab.ɐ (λcd.d(c a)) (λc.b) (λc.c)
    ABS,      // 34: λa.q (λbc.c(b ɐ)) (λb.a) (λb.b)
    APP, 21,  // 35: ɔ (λab.b(a q)) (λa.ɐ) (λa.a)
    APP, 16,  // 37: ɔ (λab.b(a q)) (λa.ɐ)
    APP, 2,   // 39: ɔ (λab.b(a q))
    VAR, 2,   // 41: ɔ
    ABS,      // 43: λab.b(a q)
    ABS,      // 44: λa.a(ɐ ɔ)
    APP, 2,   // 45: ɐ(q p)
    VAR, 0,   // 47: ɐ
    APP, 2,   // 49: q p
    VAR, 1,   // 51: q
    VAR, 3,   // 53: p
    ABS,      // 55: λa.ɐ
    VAR, 1,   // 56: q
    ABS,      // 58: λa.a
    VAR, 0,   // 59: ɐ
    VAR, 1,   // 61: q
    VAR, 1,   // 63: q
    VAR, 0,   // 65: ɐ
};

static char kEq[] = {
    ABS,      //  0: λab.∧(≤ a b)(≤ b a)
    ABS,      //  1: λa.∧(≤ ɐ a)(≤ a ɐ)
    APP, 89,  //  2: ∧(≤ q ɐ)(≤ ɐ q)
    APP, 12,  //  4: ∧(≤ q ɐ)
    ABS,      //  6: ∧
    ABS,      //  7: λa.ɐ a ɐ
    APP, 6,   //  8: q ɐ q
    APP, 2,   // 10: q ɐ
    VAR, 1,   // 12: q
    VAR, 0,   // 14: ɐ
    VAR, 1,   // 16: q
    APP, 71,  // 18: ≤ q ɐ
    APP, 67,  // 20: ≤ q
    ABS,      // 22: ≤
    ABS,      // 23: λa.iszero(- ɐ a)
    APP, 16,  // 24: iszero(- q ɐ)
    ABS,      // 26: iszero
    APP, 9,   // 27: ɐ (λabc.c) ⊤
    APP, 2,   // 29: ɐ (λabc.c)
    VAR, 0,   // 31: ɐ
    ABS,      // 33: λabc.c
    ABS,      // 34: ⊥
    ABS,      // 35: λa.a
    VAR, 0,   // 36: ɐ
    ABS,      // 38: ⊤
    ABS,      // 39: λa.ɐ
    VAR, 1,   // 40: q
    APP, 43,  // 42: - q ɐ
    APP, 39,  // 44: - q
    ABS,      // 46: -
    ABS,      // 47: λa.a dec ɐ
    APP, 33,  // 48: ɐ dec q
    APP, 2,   // 50: ɐ dec
    VAR, 0,   // 52: ɐ
    ABS,      // 54: dec
    ABS,      // 55: λab.ɐ (λcd.d(c a)) (λc.b) (λc.c)
    ABS,      // 56: λa.q (λbc.c(b ɐ)) (λb.a) (λb.b)
    APP, 21,  // 57: ɔ (λab.b(a q)) (λa.ɐ) (λa.a)
    APP, 16,  // 59: ɔ (λab.b(a q)) (λa.ɐ)
    APP, 2,   // 61: ɔ (λab.b(a q))
    VAR, 2,   // 63: ɔ
    ABS,      // 65: λab.b(a q)
    ABS,      // 66: λa.a(ɐ ɔ)
    APP, 2,   // 67: ɐ(q p)
    VAR, 0,   // 69: ɐ
    APP, 2,   // 71: q p
    VAR, 1,   // 73: q
    VAR, 3,   // 75: p
    ABS,      // 77: λa.ɐ
    VAR, 1,   // 78: q
    ABS,      // 80: λa.a
    VAR, 0,   // 81: ɐ
    VAR, 1,   // 83: q
    VAR, 1,   // 85: q
    VAR, 0,   // 87: ɐ
    VAR, 1,   // 89: q
    VAR, 0,   // 91: ɐ
    APP, 71,  // 93: ≤ ɐ q
    APP, 67,  // 95: ≤ ɐ
    ABS,      // 97: ≤
    ABS,      // 98: λa.iszero(- ɐ a)
    APP, 16,  // 99: iszero(- q ɐ)
    ABS,      // 101: iszero
    APP, 9,   // 102: ɐ (λabc.c) ⊤
    APP, 2,   // 104: ɐ (λabc.c)
    VAR, 0,   // 106: ɐ
    ABS,      // 108: λabc.c
    ABS,      // 109: ⊥
    ABS,      // 110: λa.a
    VAR, 0,   // 111: ɐ
    ABS,      // 113: ⊤
    ABS,      // 114: λa.ɐ
    VAR, 1,   // 115: q
    APP, 43,  // 117: - q ɐ
    APP, 39,  // 119: - q
    ABS,      // 121: -
    ABS,      // 122: λa.a dec ɐ
    APP, 33,  // 123: ɐ dec q
    APP, 2,   // 125: ɐ dec
    VAR, 0,   // 127: ɐ
    ABS,      // 129: dec
    ABS,      // 130: λab.ɐ (λcd.d(c a)) (λc.b) (λc.c)
    ABS,      // 131: λa.q (λbc.c(b ɐ)) (λb.a) (λb.b)
    APP, 21,  // 132: ɔ (λab.b(a q)) (λa.ɐ) (λa.a)
    APP, 16,  // 134: ɔ (λab.b(a q)) (λa.ɐ)
    APP, 2,   // 136: ɔ (λab.b(a q))
    VAR, 2,   // 138: ɔ
    ABS,      // 140: λab.b(a q)
    ABS,      // 141: λa.a(ɐ ɔ)
    APP, 2,   // 142: ɐ(q p)
    VAR, 0,   // 144: ɐ
    APP, 2,   // 146: q p
    VAR, 1,   // 148: q
    VAR, 3,   // 150: p
    ABS,      // 152: λa.ɐ
    VAR, 1,   // 153: q
    ABS,      // 155: λa.a
    VAR, 0,   // 156: ɐ
    VAR, 1,   // 158: q
    VAR, 1,   // 160: q
    VAR, 0,   // 162: ɐ
    VAR, 0,   // 164: ɐ
    VAR, 1,   // 166: q
};

static int termcmp(const int* p, const char* q, size_t n) {
  int c;
  size_t i;
  for (i = 0; i < n; ++i) {
    if ((c = p[i] - q[i])) {
      return c;
    }
  }
  return 0;
}

void PrintVar(int i, FILE* f) {
  char ibuf[22];
  switch (style) {
    case 0:
      FormatInt64(ibuf, i);
      fputs(ibuf, f);
      break;
    case 1:
      if (0 <= i && i < sizeof(ALPHABET) / sizeof(*ALPHABET) - 1) {
        fputwc(ALPHABET[i], f);
      } else if (i < 0 && ~i < sizeof(FREEBIES) / sizeof(*FREEBIES) - 1) {
        fputwc(FREEBIES[~i], f);
      } else {
        ibuf[0] = '?';
        FormatInt64(ibuf + 1, i);
        fputs(ibuf, f);
      }
      break;
    default:
      do {
        fputc('1', f);
      } while (i-- > 0);
      fputc('0', f);
      break;
  }
}

void PrintDebruijn(int x, int head, int depth, FILE* f) {
  char ibuf[22];
  if (0 <= x && x < TERMS) {
    if (mem[x] == ABS) {
      if (!noname) {
        if (x == 14) {
          fputs(""put"", f);
          return;
        }
        if (x + sizeof(kTrue) / sizeof(*kTrue) <= end &&
            !termcmp(mem + x, kTrue, sizeof(kTrue))) {
          if (asciiname) {
            fputs(""true"", f);
          } else {
            fputs(""⊤"", f);
          }
          return;
        }
        if (x + sizeof(kFalse) / sizeof(*kFalse) <= end &&
            !termcmp(mem + x, kFalse, sizeof(kFalse))) {
          if (asciiname) {
            fputs(""false"", f);
          } else {
            fputs(""⊥"", f);
          }
          return;
        }
        if (x + sizeof(kOmega) / sizeof(*kOmega) <= end &&
            !termcmp(mem + x, kOmega, sizeof(kOmega))) {
          if (asciiname) {
            fputs(""omega"", f);
          } else {
            fputs(""Ω"", f);
          }
          return;
        }
        if (x + sizeof(kSelf) / sizeof(*kSelf) <= end &&
            !termcmp(mem + x, kSelf, sizeof(kSelf))) {
          if (asciiname) {
            fputs(""omega"", f);
          } else {
            fputs(""ω"", f);
          }
          return;
        }
        if (x + sizeof(kY) / sizeof(*kY) <= end &&
            !termcmp(mem + x, kY, sizeof(kY))) {
          fputs(""Y"", f);
          return;
        }
        if (x + sizeof(kYCurry) / sizeof(*kYCurry) <= end &&
            !termcmp(mem + x, kYCurry, sizeof(kYCurry))) {
          fputs(""Y"", f);
          return;
        }
        if (x + sizeof(kIf) / sizeof(*kIf) <= end &&
            !termcmp(mem + x, kIf, sizeof(kIf))) {
          fputs(""if"", f);
          return;
        }
        if (x + sizeof(kPair) / sizeof(*kPair) <= end &&
            !termcmp(mem + x, kPair, sizeof(kPair))) {
          fputs(""pair"", f);
          return;
        }
        if (x + sizeof(kNot) / sizeof(*kNot) <= end &&
            !termcmp(mem + x, kNot, sizeof(kNot))) {
          if (asciiname) {
            fputs(""not"", f);
          } else {
            fputwc(L'¬', f);
          }
          return;
        }
        if (x + sizeof(kOr) / sizeof(*kOr) <= end &&
            !termcmp(mem + x, kOr, sizeof(kOr))) {
          if (asciiname) {
            fputs(""or"", f);
          } else {
            fputwc(L'∨', f);
          }
          return;
        }
        if (x + sizeof(kAnd) / sizeof(*kAnd) <= end &&
            !termcmp(mem + x, kAnd, sizeof(kAnd))) {
          if (asciiname) {
            fputs(""and"", f);
          } else {
            fputwc(L'∧', f);
          }
          return;
        }
        if (x + sizeof(kXor) / sizeof(*kXor) <= end &&
            !termcmp(mem + x, kXor, sizeof(kXor))) {
          if (asciiname) {
            fputs(""xor"", f);
          } else {
            fputwc(L'⊻', f);
          }
          return;
        }
        if (x + sizeof(kLe) / sizeof(*kLe) <= end &&
            !termcmp(mem + x, kLe, sizeof(kLe))) {
          if (asciiname) {
            fputs(""le"", f);
          } else {
            fputwc(L'≤', f);
          }
          return;
        }
        if (x + sizeof(kEq) / sizeof(*kEq) <= end &&
            !termcmp(mem + x, kEq, sizeof(kEq))) {
          fputwc(L'=', f);
          return;
        }
        if (x + sizeof(kAdd) / sizeof(*kAdd) <= end &&
            !termcmp(mem + x, kAdd, sizeof(kAdd))) {
          fputs(""+"", f);
          return;
        }
        if (x + sizeof(kSub) / sizeof(*kSub) <= end &&
            !termcmp(mem + x, kSub, sizeof(kSub))) {
          fputs(""-"", f);
          return;
        }
        if (x + sizeof(kCompose) / sizeof(*kCompose) <= end &&
            !termcmp(mem + x, kCompose, sizeof(kCompose))) {
          fputs(""∘"", f);
          return;
        }
        if (x + sizeof(kSucc) / sizeof(*kSucc) <= end &&
            !termcmp(mem + x, kSucc, sizeof(kSucc))) {
          fputs(""inc"", f);
          return;
        }
        if (x + sizeof(kPred) / sizeof(*kPred) <= end &&
            !termcmp(mem + x, kPred, sizeof(kPred))) {
          fputs(""dec"", f);
          return;
        }
        if (x + sizeof(kSecond) / sizeof(*kSecond) <= end &&
            !termcmp(mem + x, kSecond, sizeof(kSecond))) {
          fputs(""second"", f);
          return;
        }
        if (x + sizeof(kFirst) / sizeof(*kFirst) <= end &&
            !termcmp(mem + x, kFirst, sizeof(kFirst))) {
          fputs(""first"", f);
          return;
        }
        if (x + sizeof(kMap) / sizeof(*kMap) <= end &&
            !termcmp(mem + x, kMap, sizeof(kMap))) {
          fputs(""map"", f);
          return;
        }
        if (x + sizeof(kIszero) / sizeof(*kIszero) <= end &&
            !termcmp(mem + x, kIszero, sizeof(kIszero))) {
          fputs(""iszero"", f);
          return;
        }
        if (x + sizeof(kCons) / sizeof(*kCons) <= end &&
            !termcmp(mem + x, kCons, sizeof(kCons))) {
          fputs(""cons"", f);
          return;
        }
        if (x + sizeof(kOne) / sizeof(*kOne) <= end &&
            !termcmp(mem + x, kOne, sizeof(kOne))) {
          fputs(""one"", f);
          return;
        }
        if (x + sizeof(kTwo) / sizeof(*kTwo) <= end &&
            !termcmp(mem + x, kTwo, sizeof(kTwo))) {
          fputs(""two"", f);
          return;
        }
        if (x + sizeof(kThree) / sizeof(*kThree) <= end &&
            !termcmp(mem + x, kThree, sizeof(kThree))) {
          fputs(""three"", f);
          return;
        }
        if (x + sizeof(kFour) / sizeof(*kFour) <= end &&
            !termcmp(mem + x, kFour, sizeof(kFour))) {
          fputs(""four"", f);
          return;
        }
        if (x + sizeof(kFive) / sizeof(*kFive) <= end &&
            !termcmp(mem + x, kFive, sizeof(kFive))) {
          fputs(""five"", f);
          return;
        }
        if (x + sizeof(kSix) / sizeof(*kSix) <= end &&
            !termcmp(mem + x, kSix, sizeof(kSix))) {
          fputs(""six"", f);
          return;
        }
        if (x + sizeof(kSeven) / sizeof(*kSeven) <= end &&
            !termcmp(mem + x, kSeven, sizeof(kSeven))) {
          fputs(""seven"", f);
          return;
        }
        if (x + sizeof(kEight) / sizeof(*kEight) <= end &&
            !termcmp(mem + x, kEight, sizeof(kEight))) {
          fputs(""eight"", f);
          return;
        }
        if (x + sizeof(kNine) / sizeof(*kNine) <= end &&
            !termcmp(mem + x, kNine, sizeof(kNine))) {
          fputs(""nine"", f);
          return;
        }
      }
      do {
        ++x;
        if (asciiname) {
          fputc('\\', f);
        } else {
          fputwc(L'λ', f);
        }
        if (!(0 <= x && x < TERMS)) goto Overflow;
      } while (mem[x] == ABS);
      fputc(' ', f);
    }
    if (!(0 <= (x + 1) && (x + 1) < TERMS)) goto Overflow;
    if (mem[x] == APP) {
      fputc('[', f);
      PrintDebruijn(x + 2, 1, depth, f);
      fputc(' ', f);
      PrintDebruijn(x + 2 + mem[x + 1], 0, depth, f);
      fputc(']', f);
    } else if (mem[x] == VAR) {
      if (0 <= x + 1 && x + 1 < TERMS) {
        PrintVar(mem[x + 1], f);
      } else {
        fputc(L'‼', f);
        FormatInt64(ibuf, x);
        fputs(ibuf, f);
      }
    } else if (mem[x] == IOP) {
      if (x < 22) {
        if (mem[x + 1] & 1) {
          fputs(""put"", f);
        } else if (x & 1) {
          fputs(""wr1"", f);
        } else {
          fputs(""wr0"", f);
        }
      } else if (x == end) {
        fputs(asciiname ? ""gro"" : ""⋯"", f);
      } else {
        fputc(L'!', f);
        FormatInt64(ibuf, x);
        fputs(ibuf, f);
      }
    } else {
      fputc(L'!', f);
      FormatInt64(ibuf, x);
      fputs(ibuf, f);
    }
    return;
  }
Overflow:
  fputc(L'‼', f);
  FormatInt64(ibuf, x);
  fputs(ibuf, f);
}

void PrintLambda(int x, int head, int depth, int apps, FILE* f) {
  int close = 0;
  char ibuf[22];
  if (0 <= x && x < TERMS) {
    if (mem[x] == ABS) {
      if (!noname) {
        if (x == 14) {
          if (asciiname) {
            fputs(""put"", f);
          } else {
            fputs(""⍆"", f);
          }
          return;
        }
        if (x + sizeof(kTrue) / sizeof(*kTrue) <= end &&
            !termcmp(mem + x, kTrue, sizeof(kTrue))) {
          if (asciiname) {
            fputs(""true"", f);
          } else {
            fputs(""⊤"", f);
          }
          return;
        }
        if (x + sizeof(kFalse) / sizeof(*kFalse) <= end &&
            !termcmp(mem + x, kFalse, sizeof(kFalse))) {
          if (asciiname) {
            fputs(""false"", f);
          } else {
            fputs(""⊥"", f);
          }
          return;
        }
        if (x + sizeof(kY) / sizeof(*kY) <= end &&
            !termcmp(mem + x, kY, sizeof(kY))) {
          fputs(""Y"", f);
          return;
        }
        if (x + sizeof(kYCurry) / sizeof(*kYCurry) <= end &&
            !termcmp(mem + x, kYCurry, sizeof(kYCurry))) {
          fputs(""Y"", f);
          return;
        }
        if (x + sizeof(kOmega) / sizeof(*kOmega) <= end &&
            !termcmp(mem + x, kOmega, sizeof(kOmega))) {
          if (asciiname) {
            fputs(""OMEGA"", f);
          } else {
            fputs(""Ω"", f);
          }
          return;
        }
        if (x + sizeof(kSelf) / sizeof(*kSelf) <= end &&
            !termcmp(mem + x, kSelf, sizeof(kSelf))) {
          if (asciiname) {
            fputs(""omega"", f);
          } else {
            fputs(""ω"", f);
          }
          return;
        }
        if (x + sizeof(kNot) / sizeof(*kNot) <= end &&
            !termcmp(mem + x, kNot, sizeof(kNot))) {
          if (asciiname) {
            fputs(""not"", f);
          } else {
            fputwc(L'¬', f);
          }
          return;
        }
        if (x + sizeof(kOr) / sizeof(*kOr) <= end &&
            !termcmp(mem + x, kOr, sizeof(kOr))) {
          if (asciiname) {
            fputs(""or"", f);
          } else {
            fputwc(L'∨', f);
          }
          return;
        }
        if (x + sizeof(kXor) / sizeof(*kXor) <= end &&
            !termcmp(mem + x, kXor, sizeof(kXor))) {
          if (asciiname) {
            fputs(""xor"", f);
          } else {
            fputwc(L'⊻', f);
          }
          return;
        }
        if (x + sizeof(kLe) / sizeof(*kLe) <= end &&
            !termcmp(mem + x, kLe, sizeof(kLe))) {
          if (asciiname) {
            fputs(""le"", f);
          } else {
            fputwc(L'≤', f);
          }
          return;
        }
        if (x + sizeof(kEq) / sizeof(*kEq) <= end &&
            !termcmp(mem + x, kEq, sizeof(kEq))) {
          fputwc(L'=', f);
          return;
        }
        if (x + sizeof(kAnd) / sizeof(*kAnd) <= end &&
            !termcmp(mem + x, kAnd, sizeof(kAnd))) {
          if (asciiname) {
            fputs(""and"", f);
          } else {
            fputwc(L'∧', f);
          }
          return;
        }
        if (x + sizeof(kAdd) / sizeof(*kAdd) <= end &&
            !termcmp(mem + x, kAdd, sizeof(kAdd))) {
          fputs(""+"", f);
          return;
        }
        if (x + sizeof(kSub) / sizeof(*kSub) <= end &&
            !termcmp(mem + x, kSub, sizeof(kSub))) {
          fputs(""-"", f);
          return;
        }
        if (x + sizeof(kCompose) / sizeof(*kCompose) <= end &&
            !termcmp(mem + x, kCompose, sizeof(kCompose))) {
          if (asciiname) {
            fputs(""compose"", f);
          } else {
            fputs(""∘"", f);
          }
          return;
        }
        if (x + sizeof(kOne) / sizeof(*kOne) <= end &&
            !termcmp(mem + x, kOne, sizeof(kOne))) {
          fputc('1', f);
          return;
        }
        if (x + sizeof(kTwo) / sizeof(*kTwo) <= end &&
            !termcmp(mem + x, kTwo, sizeof(kTwo))) {
          fputc('2', f);
          return;
        }
        if (x + sizeof(kThree) / sizeof(*kThree) <= end &&
            !termcmp(mem + x, kThree, sizeof(kThree))) {
          fputc('3', f);
          return;
        }
        if (x + sizeof(kFour) / sizeof(*kFour) <= end &&
            !termcmp(mem + x, kFour, sizeof(kFour))) {
          fputc('4', f);
          return;
        }
        if (x + sizeof(kFive) / sizeof(*kFive) <= end &&
            !termcmp(mem + x, kFive, sizeof(kFive))) {
          fputc('5', f);
          return;
        }
        if (x + sizeof(kSix) / sizeof(*kSix) <= end &&
            !termcmp(mem + x, kSix, sizeof(kSix))) {
          fputc('6', f);
          return;
        }
        if (x + sizeof(kSeven) / sizeof(*kSeven) <= end &&
            !termcmp(mem + x, kSeven, sizeof(kSeven))) {
          fputc('7', f);
          return;
        }
        if (x + sizeof(kEight) / sizeof(*kEight) <= end &&
            !termcmp(mem + x, kEight, sizeof(kEight))) {
          fputc('8', f);
          return;
        }
        if (x + sizeof(kNine) / sizeof(*kNine) <= end &&
            !termcmp(mem + x, kNine, sizeof(kNine))) {
          fputc('9', f);
          return;
        }
        if (x + sizeof(kIf) / sizeof(*kIf) <= end &&
            !termcmp(mem + x, kIf, sizeof(kIf))) {
          fputs(""if"", f);
          return;
        }
        if (x + sizeof(kPair) / sizeof(*kPair) <= end &&
            !termcmp(mem + x, kPair, sizeof(kPair))) {
          fputs(""pair"", f);
          return;
        }
        if (x + sizeof(kSucc) / sizeof(*kSucc) <= end &&
            !termcmp(mem + x, kSucc, sizeof(kSucc))) {
          fputs(""inc"", f);
          return;
        }
        if (x + sizeof(kPred) / sizeof(*kPred) <= end &&
            !termcmp(mem + x, kPred, sizeof(kPred))) {
          fputs(""dec"", f);
          return;
        }
        if (x + sizeof(kSecond) / sizeof(*kSecond) <= end &&
            !termcmp(mem + x, kSecond, sizeof(kSecond))) {
          fputs(""second"", f);
          return;
        }
        if (x + sizeof(kFirst) / sizeof(*kFirst) <= end &&
            !termcmp(mem + x, kFirst, sizeof(kFirst))) {
          fputs(""first"", f);
          return;
        }
        if (x + sizeof(kMap) / sizeof(*kMap) <= end &&
            !termcmp(mem + x, kMap, sizeof(kMap))) {
          fputs(""map"", f);
          return;
        }
        if (x + sizeof(kIszero) / sizeof(*kIszero) <= end &&
            !termcmp(mem + x, kIszero, sizeof(kIszero))) {
          fputs(""iszero"", f);
          return;
        }
        if (x + sizeof(kCons) / sizeof(*kCons) <= end &&
            !termcmp(mem + x, kCons, sizeof(kCons))) {
          fputs(""cons"", f);
          return;
        }
      }
      if (apps) {
        fputc('(', f);
        close = 1;
      }
      if (asciiname) {
        fputc('\\', f);
      } else {
        fputwc(L'λ', f);
      }
      if (safer) {
        fputwc(ALPHABET[depth++], f);
        fputc('.', f);
        PrintLambda(x + 1, head, depth, apps + 1, f);
        if (close) {
          fputc(')', f);
        }
        return;
      }
      do {
        ++x;
        fputwc(ALPHABET[depth++], f);
        if (!(0 <= x && x < TERMS)) goto Overflow;
      } while (mem[x] == ABS);
      fputc('.', f);
    }
    if (!(0 <= (x + 1) && (x + 1) < TERMS)) goto Overflow;
    if (mem[x] == VAR) {
      if (0 <= x + 1 && x + 1 < TERMS) {
        PrintVar(depth - 1 - mem[x + 1], f);
      } else {
        fputc(L'‼', f);
        FormatInt64(ibuf, x);
        fputs(ibuf, f);
      }
    } else if (mem[x] == APP) {
      if (!close && !head) {
        fputc('(', f);
        close = 1;
      }
      PrintLambda(x + 2, 1, depth, apps + 1, f);
      if (!(x + 2 + mem[x + 1] < TERMS && mem[x + 2 + mem[x + 1]] == APP)) {
        if (safer || !noname) fputc(' ', f);
      }
      PrintLambda(x + 2 + mem[x + 1], 0, depth, apps + 1, f);
    } else if (mem[x] == IOP) {
      if (x < 22) {
        if (mem[x + 1] & 1) {
          fputs(asciiname ? ""put"" : ""⍆"", f);
        } else if (x & 1) {
          fputs(asciiname ? ""wr1"" : ""⍆₁"", f);
        } else {
          fputs(asciiname ? ""wr0"" : ""⍆₀"", f);
        }
      } else if (x == end) {
        fputs(asciiname ? ""gro"" : ""⋯"", f);
      } else {
        fputc(L'!', f);
        FormatInt64(ibuf, x);
        fputs(ibuf, f);
      }
    } else {
      fputc(L'!', f);
      FormatInt64(ibuf, x);
      fputs(ibuf, f);
    }
    if (close) {
      fputc(')', f);
    }
    return;
  }
Overflow:
  fputc(L'‼', f);
  FormatInt64(ibuf, x);
  fputs(ibuf, f);
}

void PrintBinary(int x, int head, int depth, FILE* f) {
  char ibuf[22];
  if (0 <= x && x < TERMS) {
    if (mem[x] == ABS) {
      if (x == 14) {
        fputs(""⍆"", f);
        return;
      }
      do {
        ++x;
        ++depth;
        fputc('0', f);
        fputc('0', f);
        if (!(0 <= x && x < TERMS)) goto Overflow;
      } while (mem[x] == ABS);
    }
    if (!(0 <= (x + 1) && (x + 1) < TERMS)) goto Overflow;
    if (mem[x] == VAR) {
      if (0 <= x + 1 && x + 1 < TERMS) {
        PrintVar(mem[x + 1], f);
      } else {
        fputc(L'‼', f);
        FormatInt64(ibuf, x);
        fputs(ibuf, f);
      }
    } else if (mem[x] == APP) {
      fputc('0', f);
      fputc('1', f);
      PrintBinary(x + 2, 0, 0, f);
      PrintBinary(x + 2 + mem[x + 1], 0, 0, f);
    } else if (mem[x] == IOP) {
      if (x < 22) {
        if (mem[x + 1] & 1) {
          fputs(""⍆"", f);
        } else if (x & 1) {
          fputs(""⍆₁"", f);
        } else {
          fputs(""⍆₀"", f);
        }
      } else {
        fputwc(L'⋯', f);
      }
    } else if (mem[x] == -1) {
      fputwc(L'⋯', f);
    } else {
      fputc(L'!', f);
      FormatInt64(ibuf, x);
      fputs(ibuf, f);
    }
    return;
  }
Overflow:
  fputc(L'‼', f);
  FormatInt64(ibuf, x);
  fputs(ibuf, f);
}

void Print(int x, int head, int depth, FILE* f) {
  switch (style) {
    case 0:
      PrintDebruijn(x, head, depth, f);
      break;
    case 1:
      PrintLambda(x, head, depth, 0, f);
      break;
    default:
      PrintBinary(x, head, depth, f);
      break;
  }
}
"
./repos/cosmopolitan/tool/lambda/lib/parserom.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/str/str.h""
#include ""tool/lambda/lib/blc.h""

static struct Parse ParseImpl(int tail, int need, FILE *f) {
  struct Parse p, q;
  int b, i, j, t, start;
  for (start = end;;) {
    if (end + 2 > TERMS) Error(5, ""OUT OF TERMS"");
    if ((b = GetBit(f)) == -1) {
      if (need) Error(9, ""UNFINISHED EXPRESSION"");
      break;
    } else if (b) {
      for (t = 0; NeedBit(f);) ++t;
      mem[end++] = VAR;
      mem[end++] = t;
      break;
    } else if (NeedBit(f)) {
      t = end;
      end += 2;
      p = ParseImpl(0, 1, f);
      q = ParseImpl(t + 2, 1, f);
      mem[t + 0] = APP;
      mem[t + 1] = q.i - (t + 2);
      break;
    } else {
      mem[end++] = ABS;
    }
  }
  p.i = start;
  p.n = end - start;
  if (p.n && tail) {
    /* find backwards overlaps within 8-bit displacement */
    i = tail - 32768;
    j = start - p.n;
    for (i = i < 0 ? 0 : i; i <= j; ++i) {
      if (!memcmp(mem + i, mem + p.i, p.n * sizeof(*mem))) {
        memset(mem + start, -1, p.n * sizeof(*mem));
        end = start;
        p.i = i;
        break;
      }
    }
  }
  return p;
}

/**
 * Parses binary lambda calculus closed expression from stream.
 *
 * If `tail` is non-zero then this subroutine will perform expensive
 * deduplication so that optimal ROMs may be computed ahead of time.
 */
struct Parse Parse(int tail, FILE *f) {
  return ParseImpl(tail, 0, f);
}
"
./repos/cosmopolitan/tool/lambda/lib/vars.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/lambda/lib/blc.h""

char binary;            // 8-bit
char safer;             // safer
char style;             // notation
char asciiname;         // <3 ascii
char noname;            // rewriting
char rlog;              // redex log
char slog;              // state log
char alog;              // action log
char vlog;              // variable log
int co;                 // output character
int heap;               // heap usage counter
long ip;                // instruction pointer
long end;               // end of code pointer
FILE *logh;             // log file stdio stream
struct Closure *frep;   // freed closures list
struct Closure *contp;  // continuations stack
int mem[TERMS];         // bss memory for terms

struct Closure root = {.refs = 100000, .term = -1, .next = 0};
struct Closure *envp = &root;
"
./repos/cosmopolitan/tool/lambda/lib/needbit.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/lambda/lib/blc.h""

char NeedBit(FILE* f) {
  char b = GetBit(f);
  if (b == -1) Error(9, ""UNEXPECTED EOF"");
  return b;
}
"
./repos/cosmopolitan/tool/lambda/lib/dump.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/intrin/kprintf.h""
#include ""tool/lambda/lib/blc.h""

void Dumper(int i, int j, FILE *f) {
  char buf[64];
  if (i) fputc('\n', f);
  for (; i < j; ++i) {
    switch (mem[i]) {
      case VAR:
        ksnprintf(buf, sizeof(buf), ""    %s,%d,\t// %2d: "", ""VAR"", mem[i + 1],
                  i);
        fputs(buf, f);
        Print(i, 1, 0, f);
        fputc('\n', f);
        ++i;
        break;
      case APP:
        ksnprintf(buf, sizeof(buf), ""    %s,%d,\t// %2d: "", ""APP"", mem[i + 1],
                  i);
        fputs(buf, f);
        Print(i, 1, 0, f);
        fputc('\n', f);
        ++i;
        break;
      case ABS:
        ksnprintf(buf, sizeof(buf), ""    %s,\t// %2d: "", ""ABS"", i);
        fputs(buf, f);
        Print(i, 1, 0, f);
        fputc('\n', f);
        break;
      default:
        ksnprintf(buf, sizeof(buf), ""    %d,\t// %2d: "", mem[i], i);
        fputs(buf, f);
        Print(i, 1, 0, f);
        fputc('\n', f);
        break;
    }
  }
}

void Dump(int i, int j, FILE *f) {
  fputs(""\nstatic int kTerm[] = {\n"", f);
  Dumper(i, j, f);
  fputs(""};\n"", f);
}
"
./repos/cosmopolitan/tool/lambda/lib/calloc.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/runtime/runtime.h""
#include ""libc/sysv/consts/map.h""
#include ""libc/sysv/consts/prot.h""

void *Calloc(size_t a, size_t b) {
  char *r;
  size_t z;
  static char *p;
  static size_t i;
  static size_t n;
  z = a * b;
  if (!p) {
    n = FRAMESIZE;
    p = mmap((void *)0x300000000000, FRAMESIZE, PROT_READ | PROT_WRITE,
             MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED, -1, 0);
  }
  if (i + z > n) {
    mmap(p + i, FRAMESIZE, PROT_READ | PROT_WRITE,
         MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED, -1, 0);
    n += FRAMESIZE;
  }
  r = p + i;
  i += z;
  return r;
}
"
./repos/cosmopolitan/tool/lambda/lib/error.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/intrin/kprintf.h""
#include ""libc/runtime/runtime.h""
#include ""tool/lambda/lib/blc.h""

void Error(int rc, const char* s, ...) {
  va_list va;
  fflush(stdout);
  fputs(""\n\33[1;31mERROR\33[37m:\t"", stderr);
  fflush(stderr);
  va_start(va, s);
  kvprintf(s, va);
  va_end(va);
  fputs(""\33[0m\n"", stderr);
  kprintf(""   ip:\t%ld\n"", ip);
  kprintf(""  end:\t%ld\n"", end);
  kprintf("" term:\t"");
  PrintExpressions(stderr, 0, 1);
  /* Dump(0, end, stderr); */
  exit(rc);
}
"
./repos/cosmopolitan/tool/lambda/lib/getbit.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/str/str.h""
#include ""tool/lambda/lib/blc.h""

char GetBit(FILE* f) {
  wint_t c;
  char comment;
  static wint_t buf, mask;
  if (!binary) {
    for (comment = 0;;) {
      c = fgetwc(f);
      if (c == -1) break;
      if (!comment) {
        fflush(stdout);
        if (c == ';') {
          comment = 1;
        } else if (!iswspace(c) && c != '(' && c != ')' && c != '[' &&
                   c != ']') {
          if (c != -1) c &= 1;
          break;
        }
      } else if (c == '\n') {
        comment = 0;
      }
    }
  } else if (mask) {
    c = !!(buf & mask);
    mask >>= 1;
  } else {
    c = fgetc(f);
    if (c != -1) {
      buf = c;
      c = (c >> 7) & 1;
      mask = 64;
    }
  }
  return c;
}
"
./repos/cosmopolitan/tool/lambda/lib/debug.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/fmt/itoa.h""
#include ""libc/intrin/kprintf.h""
#include ""libc/str/str.h""
#include ""tool/lambda/lib/blc.h""

const char *GetOpName(int x) {
  switch (x) {
    case VAR:
      return ""var"";
    case APP:
      return ""app"";
    case ABS:
      return ""abs"";
    case IOP:
      return ""iop"";
    default:
      return ""wut"";
  }
}

int GetDepth(struct Closure *env) {
  int i;
  for (i = 0; env && env != &root; ++i) {
    env = env->next;
  }
  return i;
}

void PrintClosure(struct Closure *c, const char *name, int indent, FILE *f) {
  int j;
  char ibuf[21];
  while (c && c != &root) {
    for (j = 0; j < indent; ++j) {
      if (j) {
        fputs(""│ "", f);
      } else {
        fputs(""  "", f);
      }
    }
    fputs(name, f);
    fputs("": "", f);
    Print(c->term, 0, GetDepth(c->envp), f);
    fputs("" +"", f);
    FormatInt64(ibuf, c->refs);
    fputs(ibuf, f);
    fputc('\n', f);
    PrintClosure(c->envp, ""envp"", indent + 1, f);
    c = c->next;
  }
}

void PrintMachineState(FILE *f) {
  int i;
  char buf[256];
  static int op;
  fputc('\n', f);
  for (i = 0; i < 80; ++i) fputwc(L'─', f);
  ksnprintf(buf, sizeof(buf),
            ""%d\n   ip      %ld | op %d %s | arg %d | end %ld\n"", op++, ip,
            mem[ip], GetOpName(mem[ip]), mem[ip + 1], end);
  fputs(buf, f);
  fputs("" term      "", f);
  Print(ip, 0, GetDepth(envp), f);
  fputc('\n', f);
  fputc('\n', f);
  PrintClosure(contp, ""contp"", 1, f);
  fputc('\n', f);
  PrintClosure(envp, ""envp"", 1, f);
  fputc('\n', f);
  PrintClosure(frep, ""frep"", 1, f);
}

void PrintExpressions(FILE *f, char alog, char vlog) {
  int i, d;
  char buf[48];
  struct Closure *p, ps;
  ps.term = ip;
  ps.next = contp;
  ps.envp = envp;
  for (p = &ps; p; p = p->next) {
    Print(p->term, 1, GetDepth(p->envp), f);
    if (p->next) fputc(' ', f);
  }
  if (alog) {
    fputs("" ⟹ "", f);
    switch (mem[ip]) {
      case VAR:
        ksnprintf(buf, sizeof(buf), ""var[%d]"", mem[ip + 1]);
        fputs(buf, f);
        break;
      case APP:
        fputs(""app["", f);
        Print(ip + 2 + mem[ip + 1], 1, GetDepth(envp), f);
        fputc(']', f);
        break;
      case ABS:
        if (contp) {
          fputs(""abs["", f);
          Print(ip + 1, 1, GetDepth(envp), f);
          fputc(']', f);
        } else {
          ksnprintf(buf, sizeof(buf), ""bye[%d]"", mem[ip + 2]);
          fputs(buf, f);
        }
        break;
      case IOP:
        if (ip < 22) {
          if (!binary) {
            ksnprintf(buf, sizeof(buf), ""put[%c]"", '0' + (int)(ip & 1));
          } else if (mem[ip + 1] & 1) {
            ksnprintf(buf, sizeof(buf), ""put[0%hho '%c']"", co,
                      isprint(co) ? co : '.');
          } else {
            ksnprintf(buf, sizeof(buf), ""wr%d[0%hho]"", (int)(ip & 1), co);
          }
          fputs(buf, f);
        } else {
          fputs(""gro"", f);
        }
        break;
      default:
        break;
    }
  }
  if (vlog) {
    d = GetDepth(envp);
    for (i = 0, p = envp; p->term != -1; ++i, p = p->next) {
      fputc('\n', f);
      fputc('\t', f);
      PrintVar(style != 1 ? i : d - 1 - i, f);
      fputc('=', f);
      Print(p->term, 0, GetDepth(p), f);
    }
  }
  fputc('\n', f);
}
"
./repos/cosmopolitan/tool/lambda/lib/parse.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/lambda/lib/blc.h""

/**
 * Parses binary lambda calculus closed expression from stream.
 */
struct Parse Parse(int ignored, FILE* f) {
  int t, start;
  char bit, need;
  struct Parse p;
  for (need = 0, start = end;;) {
    if (end + 2 > TERMS) Error(5, ""OUT OF TERMS"");
    if ((bit = GetBit(f)) == -1) {
      if (!need) break;
      fflush(stdout);
      fputs(""---\n"", stderr);
      Print(start, 0, 0, stderr);
      Error(9, ""UNFINISHED EXPRESSION"");
    } else if (bit) {
      for (t = 0; NeedBit(f);) ++t;
      mem[end++] = VAR;
      mem[end++] = t;
      break;
    } else if (NeedBit(f)) {
      t = end;
      end += 2;
      mem[t] = APP;
      p = Parse(0, f);
      mem[t + 1] = p.n;
      need = 1;
    } else {
      mem[end++] = ABS;
    }
  }
  p.i = start;
  p.n = end - start;
  return p;
}
"
./repos/cosmopolitan/tool/net/lre.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/macros.internal.h""
#include ""libc/str/str.h""
#include ""third_party/lua/lauxlib.h""
#include ""third_party/regex/regex.h""

struct ReErrno {
  int err;
  char doc[64];
};

static void LuaSetIntField(lua_State *L, const char *k, lua_Integer v) {
  lua_pushinteger(L, v);
  lua_setfield(L, -2, k);
}

static int LuaReReturnError(lua_State *L, regex_t *r, int rc) {
  struct ReErrno *e;
  lua_pushnil(L);
  e = lua_newuserdatauv(L, sizeof(struct ReErrno), 0);
  luaL_setmetatable(L, ""re.Errno"");
  e->err = rc;
  regerror(rc, r, e->doc, sizeof(e->doc));
  return 2;
}

static regex_t *LuaReCompileImpl(lua_State *L, const char *p, int f) {
  int rc;
  regex_t *r;
  r = lua_newuserdatauv(L, sizeof(regex_t), 0);
  luaL_setmetatable(L, ""re.Regex"");
  f &= REG_EXTENDED | REG_ICASE | REG_NEWLINE | REG_NOSUB;
  f ^= REG_EXTENDED;
  if ((rc = regcomp(r, p, f)) == REG_OK) {
    return r;
  } else {
    LuaReReturnError(L, r, rc);
    return NULL;
  }
}

static int LuaReSearchImpl(lua_State *L, regex_t *r, const char *s, int f) {
  int rc, i, n;
  regmatch_t *m;
  luaL_Buffer tmp;
  n = 1 + r->re_nsub;
  m = (regmatch_t *)luaL_buffinitsize(L, &tmp, n * sizeof(regmatch_t));
  m->rm_so = 0;
  m->rm_eo = 0;
  if ((rc = regexec(r, s, n, m, f >> 8)) == REG_OK) {
    for (i = 0; i < n; ++i) {
      lua_pushlstring(L, s + m[i].rm_so, m[i].rm_eo - m[i].rm_so);
    }
    return n;
  } else {
    return LuaReReturnError(L, r, rc);
  }
}

////////////////////////////////////////////////////////////////////////////////
// re

static int LuaReSearch(lua_State *L) {
  int f;
  regex_t *r;
  const char *p, *s;
  p = luaL_checkstring(L, 1);
  s = luaL_checkstring(L, 2);
  f = luaL_optinteger(L, 3, 0);
  if (f & ~(REG_EXTENDED | REG_ICASE | REG_NEWLINE | REG_NOSUB |
            REG_NOTBOL << 8 | REG_NOTEOL << 8)) {
    luaL_argerror(L, 3, ""invalid flags"");
    __builtin_unreachable();
  }
  if ((r = LuaReCompileImpl(L, p, f))) {
    return LuaReSearchImpl(L, r, s, f);
  } else {
    return 2;
  }
}

static int LuaReCompile(lua_State *L) {
  int f;
  regex_t *r;
  const char *p;
  p = luaL_checkstring(L, 1);
  f = luaL_optinteger(L, 2, 0);
  if (f & ~(REG_EXTENDED | REG_ICASE | REG_NEWLINE | REG_NOSUB)) {
    luaL_argerror(L, 2, ""invalid flags"");
    __builtin_unreachable();
  }
  if ((r = LuaReCompileImpl(L, p, f))) {
    return 1;
  } else {
    return 2;
  }
}

////////////////////////////////////////////////////////////////////////////////
// re.Regex

static int LuaReRegexSearch(lua_State *L) {
  int f;
  regex_t *r;
  const char *s;
  r = luaL_checkudata(L, 1, ""re.Regex"");
  s = luaL_checkstring(L, 2);
  f = luaL_optinteger(L, 3, 0);
  if (f & ~(REG_NOTBOL << 8 | REG_NOTEOL << 8)) {
    luaL_argerror(L, 3, ""invalid flags"");
    __builtin_unreachable();
  }
  return LuaReSearchImpl(L, r, s, f);
}

static int LuaReRegexGc(lua_State *L) {
  regex_t *r;
  r = luaL_checkudata(L, 1, ""re.Regex"");
  regfree(r);
  return 0;
}

static const luaL_Reg kLuaRe[] = {
    {""compile"", LuaReCompile},  //
    {""search"", LuaReSearch},    //
    {NULL, NULL},               //
};

static const luaL_Reg kLuaReRegexMeth[] = {
    {""search"", LuaReRegexSearch},  //
    {NULL, NULL},                  //
};

static const luaL_Reg kLuaReRegexMeta[] = {
    {""__gc"", LuaReRegexGc},  //
    {NULL, NULL},            //
};

static void LuaReRegexObj(lua_State *L) {
  luaL_newmetatable(L, ""re.Regex"");
  luaL_setfuncs(L, kLuaReRegexMeta, 0);
  luaL_newlibtable(L, kLuaReRegexMeth);
  luaL_setfuncs(L, kLuaReRegexMeth, 0);
  lua_setfield(L, -2, ""__index"");
  lua_pop(L, 1);
}

////////////////////////////////////////////////////////////////////////////////
// re.Errno

static struct ReErrno *GetReErrno(lua_State *L) {
  return luaL_checkudata(L, 1, ""re.Errno"");
}

// re.Errno:errno()
//     └─→ errno:int
static int LuaReErrnoErrno(lua_State *L) {
  lua_pushinteger(L, GetReErrno(L)->err);
  return 1;
}

// re.Errno:doc()
//     └─→ description:str
static int LuaReErrnoDoc(lua_State *L) {
  lua_pushstring(L, GetReErrno(L)->doc);
  return 1;
}

static const luaL_Reg kLuaReErrnoMeth[] = {
    {""errno"", LuaReErrnoErrno},  //
    {""doc"", LuaReErrnoDoc},      //
    {0},                         //
};

static const luaL_Reg kLuaReErrnoMeta[] = {
    {""__tostring"", LuaReErrnoDoc},  //
    {0},                            //
};

static void LuaReErrnoObj(lua_State *L) {
  luaL_newmetatable(L, ""re.Errno"");
  luaL_setfuncs(L, kLuaReErrnoMeta, 0);
  luaL_newlibtable(L, kLuaReErrnoMeth);
  luaL_setfuncs(L, kLuaReErrnoMeth, 0);
  lua_setfield(L, -2, ""__index"");
  lua_pop(L, 1);
}

////////////////////////////////////////////////////////////////////////////////

_Alignas(1) static const struct thatispacked {
  const char s[8];
  char x;
} kReMagnums[] = {
    {""BASIC"", REG_EXTENDED},     // compile flag
    {""ICASE"", REG_ICASE},        // compile flag
    {""NEWLINE"", REG_NEWLINE},    // compile flag
    {""NOSUB"", REG_NOSUB},        // compile flag
    {""NOMATCH"", REG_NOMATCH},    // error
    {""BADPAT"", REG_BADPAT},      // error
    {""ECOLLATE"", REG_ECOLLATE},  // error
    {""ECTYPE"", REG_ECTYPE},      // error
    {""EESCAPE"", REG_EESCAPE},    // error
    {""ESUBREG"", REG_ESUBREG},    // error
    {""EBRACK"", REG_EBRACK},      // error
    {""EPAREN"", REG_EPAREN},      // error
    {""EBRACE"", REG_EBRACE},      // error
    {""BADBR"", REG_BADBR},        // error
    {""ERANGE"", REG_ERANGE},      // error
    {""ESPACE"", REG_ESPACE},      // error
    {""BADRPT"", REG_BADRPT},      // error
};

int LuaRe(lua_State *L) {
  int i;
  char buf[9];
  luaL_newlib(L, kLuaRe);
  LuaSetIntField(L, ""NOTBOL"", REG_NOTBOL << 8);  // search flag
  LuaSetIntField(L, ""NOTEOL"", REG_NOTEOL << 8);  // search flag
  for (i = 0; i < ARRAYLEN(kReMagnums); ++i) {
    memcpy(buf, kReMagnums[i].s, 8);
    buf[8] = 0;
    LuaSetIntField(L, buf, kReMagnums[i].x);
  }
  LuaReRegexObj(L);
  LuaReErrnoObj(L);
  return 1;
}
"
./repos/cosmopolitan/tool/net/winbench.c,https://github.com/jart/cosmopolitan.git,"#if 0
/*─────────────────────────────────────────────────────────────────╗
│ To the extent possible under law, Justine Tunney has waived      │
│ all copyright and related or neighboring rights to this file,    │
│ as it is written in the following disclaimers:                   │
│   • http://unlicense.org/                                        │
│   • http://creativecommons.org/publicdomain/zero/1.0/            │
╚─────────────────────────────────────────────────────────────────*/
#endif
#include ""libc/assert.h""
#include ""libc/atomic.h""
#include ""libc/calls/calls.h""
#include ""libc/calls/struct/sigaction.h""
#include ""libc/calls/struct/timespec.h""
#include ""libc/dce.h""
#include ""libc/errno.h""
#include ""libc/fmt/conv.h""
#include ""libc/intrin/kprintf.h""
#include ""libc/macros.internal.h""
#include ""libc/mem/mem.h""
#include ""libc/nt/accounting.h""
#include ""libc/nt/enum/wsaid.h""
#include ""libc/nt/errors.h""
#include ""libc/nt/iocp.h""
#include ""libc/nt/runtime.h""
#include ""libc/nt/struct/overlapped.h""
#include ""libc/nt/thunk/msabi.h""
#include ""libc/nt/winsock.h""
#include ""libc/runtime/runtime.h""
#include ""libc/sock/sock.h""
#include ""libc/sock/struct/sockaddr.h""
#include ""libc/sock/wsaid.internal.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#include ""libc/sysv/consts/af.h""
#include ""libc/sysv/consts/auxv.h""
#include ""libc/sysv/consts/ipproto.h""
#include ""libc/sysv/consts/sig.h""
#include ""libc/sysv/consts/sock.h""
#include ""libc/thread/thread.h""
#include ""libc/thread/thread2.h""
#include ""third_party/getopt/getopt.internal.h""

__msabi extern typeof(__sys_bind_nt) *const __imp_bind;
__msabi extern typeof(__sys_closesocket_nt) *const __imp_closesocket;

enum State { SENDING, RECEIVING };

struct Client {
  struct NtOverlapped overlap;
  int64_t handle;
  enum State state;
  char buf[1500];
  struct NtIovec iov;
};

static int64_t iocp;
static char msg[128];
static uint32_t msglen;
static const char *prog;
static atomic_int a_termsig;
static atomic_long a_requests;
static atomic_bool a_finished;

static wontreturn void PrintUsage(int fd, int rc) {
  tinyprint(fd, ""Usage: "", prog, "" -H HOST -P PORT\n"", NULL);
  exit(rc);
}

static bool32 (*__msabi ConnectEx)(int64_t hSocket, const void *name,
                                   int namelen, const void *opt_lpSendBuffer,
                                   uint32_t dwSendDataLength,
                                   uint32_t *opt_out_lpdwBytesSent,
                                   struct NtOverlapped *lpOverlapped);

static int64_t CreateNewCompletionPort(uint32_t dwNumberOfConcurrentThreads) {
  return CreateIoCompletionPort(-1, 0, 0, dwNumberOfConcurrentThreads);
}

static bool AssociateDeviceWithCompletionPort(int64_t hCompletionPort,
                                              int64_t hDevice,
                                              uint64_t dwCompletionKey) {
  int64_t h =
      CreateIoCompletionPort(hDevice, hCompletionPort, dwCompletionKey, 0);
  return h == hCompletionPort;
}

static void NewClient(struct Client *client, const struct sockaddr_in *addr) {

  client->handle = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0,
                             kNtWsaFlagOverlapped);
  if (client->handle == -1) {
    fprintf(stderr, ""WSASocket() failed w/ %d\n"", WSAGetLastError());
    exit(1);
  }
  struct sockaddr_in bindaddr = {AF_INET};
  if (__imp_bind(client->handle, &bindaddr, sizeof(bindaddr))) {
    fprintf(stderr, ""bind() failed w/ %d\n"", WSAGetLastError());
    exit(1);
  }

  if (!AssociateDeviceWithCompletionPort(iocp, client->handle,
                                         (intptr_t)client)) {
    fprintf(stderr, ""AssociateDeviceWithCompletionPort() failed w/ %d\n"",
            GetLastError());
    exit(1);
  }
  if (!SetFileCompletionNotificationModes(client->handle,
                                          kNtFileSkipSetEventOnHandle)) {
    fprintf(stderr, ""SetFileCompletionNotificationModes() failed w/ %d\n"",
            GetLastError());
    exit(1);
  }

  struct NtOverlapped overlap = {0};
  if (!ConnectEx(client->handle, addr, sizeof(*addr), msg, msglen, 0,
                 &overlap) &&
      WSAGetLastError() != kNtErrorIoPending) {
    fprintf(stderr, ""ConnectEx() failed w/ %d\n"", WSAGetLastError());
    exit(1);
  }
}

static void *Worker(void *arg) {
  while (!a_finished) {
    uint32_t i;
    uint32_t dwFlags;
    uint32_t dwRecordCount;
    struct NtOverlappedEntry records[8];
    if (!GetQueuedCompletionStatusEx(iocp, records, ARRAYLEN(records),
                                     &dwRecordCount, -1u, false)) {
      fprintf(stderr, ""GetQueuedCompletionStatus() failed w/ %d\n"",
              GetLastError());
      exit(1);
    }
    for (i = 0; i < dwRecordCount; ++i) {
      uint32_t dwBytes = records[i].dwNumberOfBytesTransferred;
      struct Client *client = (struct Client *)records[i].lpCompletionKey;
      switch (client->state) {
        case SENDING:
          dwFlags = 0;
          client->state = RECEIVING;
          client->iov.buf = client->buf;
          client->iov.len = sizeof(client->buf) - 1;
          bzero(&client->overlap, sizeof(client->overlap));
          if (WSARecv(client->handle, &client->iov, 1, 0, &dwFlags,
                      &client->overlap, 0) &&
              WSAGetLastError() != kNtErrorIoPending) {
            fprintf(stderr, ""WSARecv() failed w/ %d\n"", WSAGetLastError());
            exit(1);
          }
          break;
        case RECEIVING:
          if (!dwBytes) {
            fprintf(stderr, ""got disconnect\n"");
            break;
          }
          client->buf[dwBytes] = 0;
          if (!startswith(client->buf, ""HTTP/1.1 200"")) {
            fprintf(stderr, ""request failed: %d bytes %`'s\n"", dwBytes,
                    client->buf);
            exit(1);
          }
          ++a_requests;
          client->state = SENDING;
          client->iov.buf = msg;
          client->iov.len = msglen;
          bzero(&client->overlap, sizeof(client->overlap));
          if (WSASend(client->handle, &client->iov, 1, 0, 0, &client->overlap,
                      0) &&
              WSAGetLastError() != kNtErrorIoPending) {
            fprintf(stderr, ""WSASend() failed w/ %d\n"", WSAGetLastError());
            exit(1);
          }
          break;
        default:
          __builtin_unreachable();
      }
    }
  }
  return 0;
}

static void OnTerm(int sig) {
  a_termsig = sig;
}

int main(int argc, char *argv[]) {

  if (!IsWindows()) {
    tinyprint(2, ""error: this program is intended for windows\n"", NULL);
    return 1;
  }

  prog = argv[0];
  if (!prog) {
    prog = ""winbench"";
  }

  int opt;
  int nclients = 1000;
  int nthreads = GetMaximumProcessorCount(0xffff);
  struct sockaddr_in destaddr = {AF_INET, htons(8080), {htonl(0x7f000001)}};
  while ((opt = getopt(argc, argv, ""hH:P:"")) != -1) {
    switch (opt) {
      case 'H':
        destaddr.sin_addr.s_addr = inet_addr(optarg);
        break;
      case 'P':
        destaddr.sin_port = htons(atoi(optarg));
        break;
      case 'h':
        PrintUsage(1, 0);
      default:
        PrintUsage(2, 1);
    }
  }

  uint32_t ip = ntohl(destaddr.sin_addr.s_addr);
  uint16_t port = ntohs(destaddr.sin_port);
  msglen = snprintf(msg, sizeof(msg),
                    ""GET / HTTP/1.1\r\n""
                    ""Host: %hhu.%hhu.%hhu.%hhu:%hu\r\n""
                    ""\r\n"",
                    ip >> 24, ip >> 16, ip >> 8, ip, port);

  struct NtWsaData kNtWsaData = {0};
  WSAStartup(0x0202, &kNtWsaData);

  static struct NtGuid ConnectExGuid = WSAID_CONNECTEX;
  ConnectEx = __get_wsaid(&ConnectExGuid);

  iocp = CreateNewCompletionPort(0);
  if (!iocp) {
    fprintf(stderr, ""CreateNewCompletionPort() failed w/ %d\n"", GetLastError());
    exit(1);
  }

  struct sigaction sa = {.sa_handler = OnTerm};
  unassert(!sigaction(SIGINT, &sa, 0));
  unassert(!sigaction(SIGHUP, &sa, 0));
  unassert(!sigaction(SIGTERM, &sa, 0));

  sigset_t block;
  sigfillset(&block);
  pthread_attr_t attr;
  int pagesz = getauxval(AT_PAGESZ);
  pthread_t *threads = calloc(nthreads, sizeof(pthread_t));
  unassert(!pthread_attr_init(&attr));
  unassert(!pthread_attr_setstacksize(&attr, 65536));
  unassert(!pthread_attr_setguardsize(&attr, pagesz));
  unassert(!pthread_attr_setsigmask_np(&attr, &block));
  for (int i = 0; i < nthreads; ++i) {
    if ((errno = pthread_create(threads + i, &attr, Worker, 0))) {
      perror(""pthread_create"");
      exit(1);
    }
  }
  unassert(!pthread_attr_destroy(&attr));

  struct timespec start_time = timespec_real();

  struct Client *clients = calloc(nclients, sizeof(struct Client));
  for (int i = 0; i < nclients; ++i) {
    NewClient(clients + i, &destaddr);
  }

  sleep(10);

  a_finished = true;
  long request_count = a_requests;
  struct timespec end_time = timespec_real();

  for (int i = 0; i < nthreads; ++i) {
    if ((errno = pthread_join(threads[i], 0))) {
      perror(""pthread_join"");
      exit(1);
    }
  }

  double elapsed_seconds =
      timespec_tonanos(timespec_sub(end_time, start_time)) * 1e-9;
  double requests_per_second = request_count / elapsed_seconds;
  fprintf(stderr, ""qps = %g\n"", requests_per_second);
}
"
./repos/cosmopolitan/tool/net/redbean-static.c,https://github.com/jart/cosmopolitan.git,"#define STATIC
#define REDBEAN ""redbean-static""
#include ""tool/net/redbean.c""
"
./repos/cosmopolitan/tool/net/redbean.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""ape/sections.internal.h""
#include ""libc/assert.h""
#include ""libc/atomic.h""
#include ""libc/calls/calls.h""
#include ""libc/calls/pledge.h""
#include ""libc/calls/struct/dirent.h""
#include ""libc/calls/struct/flock.h""
#include ""libc/calls/struct/iovec.h""
#include ""libc/calls/struct/rusage.h""
#include ""libc/calls/struct/sigaction.h""
#include ""libc/calls/struct/sigset.h""
#include ""libc/calls/struct/stat.h""
#include ""libc/calls/struct/termios.h""
#include ""libc/calls/struct/timespec.h""
#include ""libc/calls/termios.h""
#include ""libc/dce.h""
#include ""libc/dos.internal.h""
#include ""libc/errno.h""
#include ""libc/fmt/conv.h""
#include ""libc/fmt/itoa.h""
#include ""libc/fmt/wintime.internal.h""
#include ""libc/intrin/atomic.h""
#include ""libc/intrin/bsr.h""
#include ""libc/intrin/likely.h""
#include ""libc/intrin/nomultics.internal.h""
#include ""libc/intrin/safemacros.internal.h""
#include ""libc/log/appendresourcereport.internal.h""
#include ""libc/log/check.h""
#include ""libc/log/log.h""
#include ""libc/macros.internal.h""
#include ""libc/math.h""
#include ""libc/mem/alloca.h""
#include ""libc/mem/gc.h""
#include ""libc/mem/mem.h""
#include ""libc/nexgen32e/crc32.h""
#include ""libc/nexgen32e/rdtsc.h""
#include ""libc/nexgen32e/vendor.internal.h""
#include ""libc/nexgen32e/x86feature.h""
#include ""libc/nt/enum/fileflagandattributes.h""
#include ""libc/runtime/clktck.h""
#include ""libc/runtime/internal.h""
#include ""libc/runtime/memtrack.internal.h""
#include ""libc/runtime/runtime.h""
#include ""libc/runtime/stack.h""
#include ""libc/serialize.h""
#include ""libc/sock/goodsocket.internal.h""
#include ""libc/sock/sock.h""
#include ""libc/sock/struct/pollfd.h""
#include ""libc/sock/struct/sockaddr.h""
#include ""libc/stdio/append.h""
#include ""libc/stdio/hex.internal.h""
#include ""libc/stdio/rand.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/slice.h""
#include ""libc/str/str.h""
#include ""libc/str/strwidth.h""
#include ""libc/sysv/consts/af.h""
#include ""libc/sysv/consts/auxv.h""
#include ""libc/sysv/consts/clock.h""
#include ""libc/sysv/consts/clone.h""
#include ""libc/sysv/consts/dt.h""
#include ""libc/sysv/consts/ex.h""
#include ""libc/sysv/consts/exit.h""
#include ""libc/sysv/consts/f.h""
#include ""libc/sysv/consts/hwcap.h""
#include ""libc/sysv/consts/inaddr.h""
#include ""libc/sysv/consts/ipproto.h""
#include ""libc/sysv/consts/madv.h""
#include ""libc/sysv/consts/map.h""
#include ""libc/sysv/consts/o.h""
#include ""libc/sysv/consts/poll.h""
#include ""libc/sysv/consts/pr.h""
#include ""libc/sysv/consts/prot.h""
#include ""libc/sysv/consts/rusage.h""
#include ""libc/sysv/consts/s.h""
#include ""libc/sysv/consts/sa.h""
#include ""libc/sysv/consts/sig.h""
#include ""libc/sysv/consts/sock.h""
#include ""libc/sysv/consts/termios.h""
#include ""libc/sysv/consts/timer.h""
#include ""libc/sysv/consts/w.h""
#include ""libc/sysv/errfuns.h""
#include ""libc/thread/thread.h""
#include ""libc/thread/tls.h""
#include ""libc/x/x.h""
#include ""libc/x/xasprintf.h""
#include ""libc/zip.internal.h""
#include ""net/http/escape.h""
#include ""net/http/http.h""
#include ""net/http/ip.h""
#include ""net/http/tokenbucket.h""
#include ""net/http/url.h""
#include ""net/https/https.h""
#include ""third_party/getopt/getopt.internal.h""
#include ""third_party/lua/cosmo.h""
#include ""third_party/lua/lauxlib.h""
#include ""third_party/lua/lrepl.h""
#include ""third_party/lua/lualib.h""
#include ""third_party/lua/lunix.h""
#include ""third_party/mbedtls/ctr_drbg.h""
#include ""third_party/mbedtls/debug.h""
#include ""third_party/mbedtls/iana.h""
#include ""third_party/mbedtls/net_sockets.h""
#include ""third_party/mbedtls/oid.h""
#include ""third_party/mbedtls/san.h""
#include ""third_party/mbedtls/ssl.h""
#include ""third_party/mbedtls/ssl_ticket.h""
#include ""third_party/mbedtls/x509.h""
#include ""third_party/mbedtls/x509_crt.h""
#include ""third_party/musl/netdb.h""
#include ""third_party/zlib/zlib.h""
#include ""tool/args/args.h""
#include ""tool/build/lib/case.h""
#include ""tool/net/lfinger.h""
#include ""tool/net/lfuncs.h""
#include ""tool/net/ljson.h""
#include ""tool/net/lpath.h""
#include ""tool/net/luacheck.h""
#include ""tool/net/sandbox.h""

#pragma GCC diagnostic ignored ""-Wunused-variable""

STATIC_STACK_ALIGN(GetStackSize());

__static_yoink(""zipos"");

#ifdef USE_BLINK
__static_yoink(""blink_linux_aarch64"");  // for raspberry pi
__static_yoink(""blink_xnu_aarch64"");    // is apple silicon
#endif

/**
 * @fileoverview redbean - single-file distributable web server
 *
 * redbean makes it possible to share web applications that run offline
 * as a single-file αcτµαlly pδrταblε εxεcµταblε zip archive which
 * contains your assets.
 *
 * redbean can serve 1 million+ gzip encoded responses per second on a
 * cheap personal computer. That performance is thanks to zip and gzip
 * using the same compression format, which enables kernelspace copies.
 * Another reason redbean goes fast is that it's a tiny static binary,
 * which makes fork memory paging nearly free.
 *
 * redbean is also easy to modify to suit your own needs. The program
 * itself is written as a single .c file. It embeds the Lua programming
 * language and SQLite which let you write dynamic pages.
 */

#ifndef REDBEAN
#define REDBEAN ""redbean""
#endif

#define VERSION          0x020200
#define HASH_LOAD_FACTOR /* 1. / */ 4
#define MONITOR_MICROS   150000
#define READ(F, P, N)    readv(F, &(struct iovec){P, N}, 1)
#define WRITE(F, P, N)   writev(F, &(struct iovec){P, N}, 1)
#define AppendCrlf(P)    mempcpy(P, ""\r\n"", 2)
#define HasHeader(H)     (!!cpm.msg.headers[H].a)
#define HeaderData(H)    (inbuf.p + cpm.msg.headers[H].a)
#define HeaderLength(H)  (cpm.msg.headers[H].b - cpm.msg.headers[H].a)
#define HeaderEqualCase(H, S) \
  SlicesEqualCase(S, strlen(S), HeaderData(H), HeaderLength(H))
#define LockInc(P)                                            \
  atomic_fetch_add_explicit((_Atomic(typeof(*(P))) *)(P), +1, \
                            memory_order_relaxed)
#define LockDec(P)                                            \
  atomic_fetch_add_explicit((_Atomic(typeof(*(P))) *)(P), -1, \
                            memory_order_relaxed)

#define TRACE_BEGIN         \
  do {                      \
    if (!IsTiny()) {        \
      if (funtrace) {       \
        ftrace_enabled(+1); \
      }                     \
      if (systrace) {       \
        strace_enabled(+1); \
      }                     \
    }                       \
  } while (0)

#define TRACE_END           \
  do {                      \
    if (!IsTiny()) {        \
      if (funtrace) {       \
        ftrace_enabled(-1); \
      }                     \
      if (systrace) {       \
        strace_enabled(-1); \
      }                     \
    }                       \
  } while (0)

// letters not used: INOQYnoqwxy
// digits not used:  0123456789
// puncts not used:  !""#$&'()+,-./;<=>@[\]^_`{|}~
#define GETOPTS \
  ""*%BEJSVXZabdfghijkmsuvzA:C:D:F:G:H:K:L:M:P:R:T:U:W:c:e:l:p:r:t:w:""

static const uint8_t kGzipHeader[] = {
    0x1F,        // MAGNUM
    0x8B,        // MAGNUM
    0x08,        // CM: DEFLATE
    0x00,        // FLG: NONE
    0x00,        // MTIME: NONE
    0x00,        //
    0x00,        //
    0x00,        //
    0x00,        // XFL
    kZipOsUnix,  // OS
};

static const char *const kIndexPaths[] = {
#ifndef STATIC
    ""index.lua"",
#endif
    ""index.html"",
};

static const char *const kAlpn[] = {
    ""http/1.1"",
    NULL,
};

struct Buffer {
  size_t n, c;
  char *p;
};

struct TlsBio {
  int fd, c;
  unsigned a, b;
  unsigned char t[4000];
  unsigned char u[1430];
};

struct Strings {
  size_t n, c;
  struct String {
    size_t n;
    const char *s;
  } *p;
};

struct DeflateGenerator {
  int t;
  void *b;
  size_t i;
  uint32_t c;
  uint32_t z;
  z_stream s;
  struct Asset *a;
};

static struct Ips {
  size_t n;
  uint32_t *p;
} ips;

static struct Ports {
  size_t n;
  uint16_t *p;
} ports;

static struct Servers {
  size_t n;
  struct Server {
    int fd;
    struct sockaddr_in addr;
  } *p;
} servers;

static struct Freelist {
  size_t n, c;
  void **p;
} freelist;

static struct Unmaplist {
  size_t n, c;
  struct Unmap {
    int f;
    void *p;
    size_t n;
  } *p;
} unmaplist;

static struct Psks {
  size_t n;
  struct Psk {
    char *key;
    size_t key_len;
    char *identity;
    size_t identity_len;
    char *s;
  } *p;
} psks;

static struct Suites {
  size_t n;
  uint16_t *p;
} suites;

static struct Certs {
  size_t n;
  struct Cert *p;
} certs;

static struct Redirects {
  size_t n;
  struct Redirect {
    int code;
    struct String path;
    struct String location;
  } *p;
} redirects;

static struct Assets {
  uint32_t n;
  struct Asset {
    bool istext;
    uint32_t hash;
    uint64_t cf;
    uint64_t lf;
    int64_t lastmodified;
    char *lastmodifiedstr;
    struct File {
      struct String path;
      struct stat st;
    } *file;
  } *p;
} assets;

static struct TrustedIps {
  size_t n;
  struct TrustedIp {
    uint32_t ip;
    uint32_t mask;
  } *p;
} trustedips;

struct TokenBucket {
  signed char cidr;
  signed char reject;
  signed char ignore;
  signed char ban;
  struct timespec replenish;
  union {
    atomic_schar *b;
    atomic_uint_fast64_t *w;
  };
} tokenbucket;

struct Blackhole {
  struct sockaddr_un addr;
  int fd;
} blackhole;

static struct Shared {
  int workers;
  struct timespec nowish;
  struct timespec lastreindex;
  struct timespec lastmeltdown;
  char currentdate[32];
  struct rusage server;
  struct rusage children;
  struct Counters {
#define C(x) long x;
#include ""tool/net/counters.inc""
#undef C
  } c;
  pthread_spinlock_t montermlock;
} *shared;

static const char kCounterNames[] =
#define C(x) #x ""\0""
#include ""tool/net/counters.inc""
#undef C
    ;

typedef ssize_t (*reader_f)(int, void *, size_t);
typedef ssize_t (*writer_f)(int, struct iovec *, int);

struct ClearedPerMessage {
  bool istext;
  bool branded;
  bool hascontenttype;
  bool gotcachecontrol;
  bool gotxcontenttypeoptions;
  int frags;
  int statuscode;
  int isyielding;
  char *outbuf;
  char *content;
  size_t gzipped;
  size_t contentlength;
  char *luaheaderp;
  const char *referrerpolicy;
  size_t msgsize;
  ssize_t (*generator)(struct iovec[3]);
  struct Strings loops;
  struct HttpMessage msg;
} cpm;

static bool suiteb;
static bool killed;
static bool zombied;
static bool usingssl;
static bool funtrace;
static bool systrace;
static bool meltdown;
static bool unsecure;
static bool norsagen;
static bool printport;
static bool daemonize;
static bool logrusage;
static bool logbodies;
static bool requiressl;
static bool sslcliused;
static bool loglatency;
static bool terminated;
static bool uniprocess;
static bool invalidated;
static bool logmessages;
static bool isinitialized;
static bool sslinitialized;
static bool sslfetchverify;
static bool selfmodifiable;
static bool interpretermode;
static bool sslclientverify;
static bool connectionclose;
static bool hasonloglatency;
static bool hasonworkerstop;
static bool isexitingworker;
static bool hasonworkerstart;
static bool leakcrashreports;
static bool hasonhttprequest;
static bool hasonerror;
static bool ishandlingrequest;
static bool listeningonport443;
static bool hasonprocesscreate;
static bool hasonprocessdestroy;
static bool ishandlingconnection;
static bool hasonclientconnection;
static bool evadedragnetsurveillance;

static int zfd;
static int gmtoff;
static int client;
static int mainpid;
static int sandboxed;
static int changeuid;
static int changegid;
static int maxworkers;
static int shutdownsig;
static int sslpskindex;
static int oldloglevel;
static int messageshandled;
static int sslticketlifetime;
static uint32_t clientaddrsize;
static atomic_int terminatemonitor;

static char *brand;
static size_t zsize;
static lua_State *GL;
static lua_State *YL;
static uint8_t *zmap;
static uint8_t *zcdir;
static size_t hdrsize;
static size_t amtread;
static reader_f reader;
static writer_f writer;
static char *extrahdrs;
static const char *zpath;
static char *serverheader;
static char gzip_footer[8];
static long maxpayloadsize;
static const char *pidpath;
static const char *logpath;
static uint32_t *interfaces;
static struct pollfd *polls;
static size_t payloadlength;
static int64_t cacheseconds;
static char *cachedirective;
static const char *monitortty;
static struct Strings stagedirs;
static struct Strings hidepaths;
static const char *launchbrowser;
static const char ctIdx = 'c';  // a pseudo variable to get address of

static pthread_t monitorth;
static struct Buffer inbuf_actual;
static struct Buffer inbuf;
static struct Buffer oldin;
static struct Buffer hdrbuf;
static struct timeval timeout;
static struct Buffer effectivepath;
static struct timespec heartbeatinterval;

static struct Url url;

static struct stat zst;
static struct timespec startread;
static struct timespec lastrefresh;
static struct timespec startserver;
static struct timespec startrequest;
static struct timespec lastheartbeat;
static struct timespec startconnection;
static struct sockaddr_in clientaddr;
static struct sockaddr_in *serveraddr;

static mbedtls_ssl_config conf;
static mbedtls_ssl_context ssl;
static mbedtls_ctr_drbg_context rng;
static mbedtls_ssl_ticket_context ssltick;

static mbedtls_ssl_config confcli;
static mbedtls_ssl_context sslcli;
static mbedtls_ctr_drbg_context rngcli;

static struct TlsBio g_bio;
static char slashpath[PATH_MAX];
static struct DeflateGenerator dg;

static char *Route(const char *, size_t, const char *, size_t);
static char *RouteHost(const char *, size_t, const char *, size_t);
static char *RoutePath(const char *, size_t);
static char *HandleAsset(struct Asset *, const char *, size_t);
static char *ServeAsset(struct Asset *, const char *, size_t);
static char *SetStatus(unsigned, const char *);

static void TlsInit(void);

static void OnChld(void) {
  zombied = true;
}

static void OnUsr1(void) {
  invalidated = true;
}

static void OnUsr2(void) {
  meltdown = true;
}

static void OnTerm(int sig) {
  if (!terminated) {
    shutdownsig = sig;
    terminated = true;
  } else {
    killed = true;
  }
}

static void OnInt(int sig) {
  OnTerm(sig);
}

static void OnHup(int sig) {
  if (daemonize) {
    OnUsr1();
  } else {
    OnTerm(sig);
  }
}

static void Free(void *p) {
  free(*(void **)p);
  *(void **)p = 0;
}

static long ParseInt(const char *s) {
  return strtol(s, 0, 0);
}

static void *FreeLater(void *p) {
  if (p) {
    if (++freelist.n > freelist.c) {
      freelist.c = freelist.n + (freelist.n >> 1);
      freelist.p = xrealloc(freelist.p, freelist.c * sizeof(*freelist.p));
    }
    freelist.p[freelist.n - 1] = p;
  }
  return p;
}

static void UnmapLater(int f, void *p, size_t n) {
  if (++unmaplist.n > unmaplist.c) {
    unmaplist.c = unmaplist.n + (unmaplist.n >> 1);
    unmaplist.p = xrealloc(unmaplist.p, unmaplist.c * sizeof(*unmaplist.p));
  }
  unmaplist.p[unmaplist.n - 1].f = f;
  unmaplist.p[unmaplist.n - 1].p = p;
  unmaplist.p[unmaplist.n - 1].n = n;
}

static void CollectGarbage(void) {
  __log_level = oldloglevel;
  DestroyHttpMessage(&cpm.msg);
  while (freelist.n) {
    free(freelist.p[--freelist.n]);
  }
  while (unmaplist.n) {
    --unmaplist.n;
    LOGIFNEG1(munmap(unmaplist.p[unmaplist.n].p, unmaplist.p[unmaplist.n].n));
    LOGIFNEG1(close(unmaplist.p[unmaplist.n].f));
  }
}

static void UseOutput(void) {
  cpm.content = FreeLater(cpm.outbuf);
  cpm.contentlength = appendz(cpm.outbuf).i;
  cpm.outbuf = 0;
}

static void DropOutput(void) {
  FreeLater(cpm.outbuf);
  cpm.outbuf = 0;
}

static bool ShouldAvoidGzip(void) {
  return (IsGenuineBlink() && !X86_HAVE(JIT));
}

static char *MergePaths(const char *p, size_t n, const char *q, size_t m,
                        size_t *z) {
  char *r;
  if (n && p[n - 1] == '/') --n;
  if (m && q[0] == '/') ++q, --m;
  r = xmalloc(n + 1 + m + 1);
  mempcpy(mempcpy(mempcpy(mempcpy(r, p, n), ""/"", 1), q, m), """", 1);
  if (z) *z = n + 1 + m;
  return r;
}

static long FindRedirect(const char *s, size_t n) {
  int c, m, l, r;
  l = 0;
  r = redirects.n - 1;
  while (l <= r) {
    m = (l & r) + ((l ^ r) >> 1);  // floor((a+b)/2)
    c = CompareSlices(redirects.p[m].path.s, redirects.p[m].path.n, s, n);
    if (c < 0) {
      l = m + 1;
    } else if (c > 0) {
      r = m - 1;
    } else {
      return m;
    }
  }
  return -1;
}

static mbedtls_x509_crt *GetTrustedCertificate(mbedtls_x509_name *name) {
  size_t i;
  for (i = 0; i < certs.n; ++i) {
    if (certs.p[i].cert &&
        !mbedtls_x509_name_cmp(name, &certs.p[i].cert->subject)) {
      return certs.p[i].cert;
    }
  }
  return 0;
}

static void UseCertificate(mbedtls_ssl_config *c, struct Cert *kp,
                           const char *role) {
  VERBOSEF(""(ssl) using %s certificate %`'s for HTTPS %s"",
           mbedtls_pk_get_name(&kp->cert->pk),
           gc(FormatX509Name(&kp->cert->subject)), role);
  CHECK_EQ(0, mbedtls_ssl_conf_own_cert(c, kp->cert, kp->key));
}

static void AppendCert(mbedtls_x509_crt *cert, mbedtls_pk_context *key) {
  certs.p = realloc(certs.p, ++certs.n * sizeof(*certs.p));
  certs.p[certs.n - 1].cert = cert;
  certs.p[certs.n - 1].key = key;
}

static void InternCertificate(mbedtls_x509_crt *cert, mbedtls_x509_crt *prev) {
  int r;
  size_t i;
  if (cert->next) InternCertificate(cert->next, cert);
  if (prev) {
    if (mbedtls_x509_crt_check_parent(prev, cert, 1)) {
      DEBUGF(""(ssl) unbundling %`'s from %`'s"",
             gc(FormatX509Name(&prev->subject)),
             gc(FormatX509Name(&cert->subject)));
      prev->next = 0;
    } else if ((r = mbedtls_x509_crt_check_signature(prev, cert, 0))) {
      WARNF(""(ssl) invalid signature for %`'s -> %`'s (-0x%04x)"",
            gc(FormatX509Name(&prev->subject)),
            gc(FormatX509Name(&cert->subject)), -r);
    }
  }
  if (mbedtls_x509_time_is_past(&cert->valid_to)) {
    WARNF(""(ssl) certificate %`'s is expired"",
          gc(FormatX509Name(&cert->subject)));
  } else if (mbedtls_x509_time_is_future(&cert->valid_from)) {
    WARNF(""(ssl) certificate %`'s is from the future"",
          gc(FormatX509Name(&cert->subject)));
  }
  for (i = 0; i < certs.n; ++i) {
    if (!certs.p[i].cert && certs.p[i].key &&
        !mbedtls_pk_check_pair(&cert->pk, certs.p[i].key)) {
      certs.p[i].cert = cert;
      return;
    }
  }
  LogCertificate(""loaded certificate"", cert);
  if (!cert->next && !IsSelfSigned(cert) && cert->max_pathlen) {
    for (i = 0; i < certs.n; ++i) {
      if (!certs.p[i].cert) continue;
      if (mbedtls_pk_can_do(&cert->pk, certs.p[i].cert->sig_pk) &&
          !mbedtls_x509_crt_check_parent(cert, certs.p[i].cert, 1) &&
          !IsSelfSigned(certs.p[i].cert)) {
        if (ChainCertificate(cert, certs.p[i].cert)) break;
      }
    }
  }
  if (!IsSelfSigned(cert)) {
    for (i = 0; i < certs.n; ++i) {
      if (!certs.p[i].cert) continue;
      if (certs.p[i].cert->next) continue;
      if (certs.p[i].cert->max_pathlen &&
          mbedtls_pk_can_do(&certs.p[i].cert->pk, cert->sig_pk) &&
          !mbedtls_x509_crt_check_parent(certs.p[i].cert, cert, 1)) {
        ChainCertificate(certs.p[i].cert, cert);
      }
    }
  }
  AppendCert(cert, 0);
}

static void ProgramCertificate(const char *p, size_t n) {
  int rc;
  unsigned char *waqapi;
  mbedtls_x509_crt *cert;
  waqapi = malloc(n + 1);
  memcpy(waqapi, p, n);
  waqapi[n] = 0;
  cert = calloc(1, sizeof(mbedtls_x509_crt));
  rc = mbedtls_x509_crt_parse(cert, waqapi, n + 1);
  mbedtls_platform_zeroize(waqapi, n);
  free(waqapi);
  if (rc < 0) {
    WARNF(""(ssl) failed to load certificate (grep -0x%04x)"", rc);
    return;
  } else if (rc > 0) {
    VERBOSEF(""(ssl) certificate bundle partially loaded"");
  }
  InternCertificate(cert, 0);
}

static void ProgramPrivateKey(const char *p, size_t n) {
  int rc;
  size_t i;
  unsigned char *waqapi;
  mbedtls_pk_context *key;
  waqapi = malloc(n + 1);
  memcpy(waqapi, p, n);
  waqapi[n] = 0;
  key = calloc(1, sizeof(mbedtls_pk_context));
  rc = mbedtls_pk_parse_key(key, waqapi, n + 1, 0, 0);
  mbedtls_platform_zeroize(waqapi, n);
  free(waqapi);
  if (rc != 0) FATALF(""(ssl) error: load key (grep -0x%04x)"", -rc);
  for (i = 0; i < certs.n; ++i) {
    if (certs.p[i].cert && !certs.p[i].key &&
        !mbedtls_pk_check_pair(&certs.p[i].cert->pk, key)) {
      certs.p[i].key = key;
      return;
    }
  }
  VERBOSEF(""(ssl) loaded private key"");
  AppendCert(0, key);
}

static void ProgramFile(const char *path, void program(const char *, size_t)) {
  char *p;
  size_t n;
  DEBUGF(""(srvr) ProgramFile(%`'s)"", path);
  if ((p = xslurp(path, &n))) {
    program(p, n);
    mbedtls_platform_zeroize(p, n);
    free(p);
  } else {
    FATALF(""(srvr) error: failed to read file %`'s"", path);
  }
}

static void ProgramPort(long port) {
  if (!(0 <= port && port <= 65535)) {
    FATALF(""(cfg) error: bad port: %d"", port);
  }
  if (port == 443) listeningonport443 = true;
  ports.p = realloc(ports.p, ++ports.n * sizeof(*ports.p));
  ports.p[ports.n - 1] = port;
}

static void ProgramMaxPayloadSize(long x) {
  maxpayloadsize = MAX(1450, x);
}

static void ProgramSslTicketLifetime(long x) {
  sslticketlifetime = x;
}

static void ProgramAddr(const char *addr) {
  ssize_t rc;
  int64_t ip;
  if ((ip = ParseIp(addr, -1)) == -1) {
    if (!IsTiny()) {
      struct addrinfo *ai = NULL;
      struct addrinfo hint = {AI_NUMERICSERV, AF_INET, SOCK_STREAM,
                              IPPROTO_TCP};
      if ((rc = getaddrinfo(addr, ""0"", &hint, &ai)) != 0) {
        FATALF(""(cfg) error: bad addr: %s (EAI_%s)"", addr, gai_strerror(rc));
      }
      ip = ntohl(((struct sockaddr_in *)ai->ai_addr)->sin_addr.s_addr);
      freeaddrinfo(ai);
    } else {
      FATALF(""(cfg) error: ProgramAddr() needs an IP in MODE=tiny: %s"", addr);
    }
  }
  ips.p = realloc(ips.p, ++ips.n * sizeof(*ips.p));
  ips.p[ips.n - 1] = ip;
}

static void ProgramRedirect(int code, const char *sp, size_t sn, const char *dp,
                            size_t dn) {
  long i, j;
  struct Redirect r;
  if (code && code != 301 && code != 302 && code != 307 && code != 308) {
    FATALF(""(cfg) error: unsupported redirect code %d"", code);
  }

  if (!(FreeLater(EncodeHttpHeaderValue(dp, dn, 0)))) {
    FATALF(""(cfg) error: invalid location %s"", dp);
  }

  r.code = code;
  r.path.s = sp;
  r.path.n = sn;
  r.location.s = dp;
  r.location.n = dn;
  if ((i = FindRedirect(r.path.s, r.path.n)) != -1) {
    redirects.p[i] = r;
  } else {
    i = redirects.n;
    redirects.p = xrealloc(redirects.p, (i + 1) * sizeof(*redirects.p));
    for (j = i; j; --j) {
      if (CompareSlices(r.path.s, r.path.n, redirects.p[j - 1].path.s,
                        redirects.p[j - 1].path.n) < 0) {
        redirects.p[j] = redirects.p[j - 1];
      } else {
        break;
      }
    }
    redirects.p[j] = r;
    ++redirects.n;
  }
}

static void ProgramRedirectArg(int code, const char *s) {
  size_t n;
  const char *p;
  n = strlen(s);
  if (!(p = memchr(s, '=', n))) {
    FATALF(""(cfg) error: redirect arg missing '='"");
  }
  ProgramRedirect(code, s, p - s, p + 1, n - (p - s + 1));
}

static void ProgramTrustedIp(uint32_t ip, int cidr) {
  uint32_t mask;
  mask = 0xffffffffu << (32 - cidr);
  trustedips.p = xrealloc(trustedips.p, ++trustedips.n * sizeof(*trustedips.p));
  trustedips.p[trustedips.n - 1].ip = ip;
  trustedips.p[trustedips.n - 1].mask = mask;
}

static bool IsTrustedIp(uint32_t ip) {
  int i;
  uint32_t *p;
  if (interfaces) {
    for (p = interfaces; *p; ++p) {
      if (ip == *p && !IsTestnetIp(ip)) {
        DEBUGF(""(token) ip is trusted because it's %s"", ""a local interface"");
        return true;
      }
    }
  }
  if (trustedips.n) {
    for (i = 0; i < trustedips.n; ++i) {
      if ((ip & trustedips.p[i].mask) == trustedips.p[i].ip) {
        DEBUGF(""(token) ip is trusted because it's %s"", ""whitelisted"");
        return true;
      }
    }
    return false;
  } else if (IsPrivateIp(ip) && !IsTestnetIp(ip)) {
    DEBUGF(""(token) ip is trusted because it's %s"", ""private"");
    return true;
  } else if (IsLoopbackIp(ip)) {
    DEBUGF(""(token) ip is trusted because it's %s"", ""loopback"");
    return true;
  } else {
    return false;
  }
}

static void DescribeAddress(char buf[40], uint32_t addr, uint16_t port) {
  char *p;
  p = buf;
  p = FormatUint32(p, (addr & 0xFF000000) >> 030), *p++ = '.';
  p = FormatUint32(p, (addr & 0x00FF0000) >> 020), *p++ = '.';
  p = FormatUint32(p, (addr & 0x0000FF00) >> 010), *p++ = '.';
  p = FormatUint32(p, (addr & 0x000000FF) >> 000), *p++ = ':';
  p = FormatUint32(p, port);
  *p = '\0';
  assert(p - buf < 40);
}

static inline int GetServerAddr(uint32_t *ip, uint16_t *port) {
  *ip = ntohl(serveraddr->sin_addr.s_addr);
  if (port) *port = ntohs(serveraddr->sin_port);
  return 0;
}

static inline int GetClientAddr(uint32_t *ip, uint16_t *port) {
  *ip = ntohl(clientaddr.sin_addr.s_addr);
  if (port) *port = ntohs(clientaddr.sin_port);
  return 0;
}

static inline int GetRemoteAddr(uint32_t *ip, uint16_t *port) {
  GetClientAddr(ip, port);
  if (HasHeader(kHttpXForwardedFor)) {
    if (IsTrustedIp(*ip)) {
      if (ParseForwarded(HeaderData(kHttpXForwardedFor),
                         HeaderLength(kHttpXForwardedFor), ip, port) == -1) {
        VERBOSEF(""could not parse x-forwarded-for %`'.*s len=%ld"",
                 HeaderLength(kHttpXForwardedFor),
                 HeaderData(kHttpXForwardedFor),
                 HeaderLength(kHttpXForwardedFor));
        return -1;
      }
    } else {
      WARNF(
          ""%hhu.%hhu.%hhu.%hhu isn't authorized to send x-forwarded-for %`'.*s"",
          *ip >> 24, *ip >> 16, *ip >> 8, *ip, HeaderLength(kHttpXForwardedFor),
          HeaderData(kHttpXForwardedFor));
    }
  }
  return 0;
}

static char *DescribeClient(void) {
  char str[40];
  uint16_t port;
  uint32_t client;
  static char description[128];
  GetClientAddr(&client, &port);
  if (HasHeader(kHttpXForwardedFor) && IsTrustedIp(client)) {
    DescribeAddress(str, client, port);
    snprintf(description, sizeof(description), ""%'.*s via %s"",
             HeaderLength(kHttpXForwardedFor), HeaderData(kHttpXForwardedFor),
             str);
  } else {
    DescribeAddress(description, client, port);
  }
  return description;
}

static char *DescribeServer(void) {
  uint32_t ip;
  uint16_t port;
  static char serveraddrstr[40];
  GetServerAddr(&ip, &port);
  DescribeAddress(serveraddrstr, ip, port);
  return serveraddrstr;
}

static void ProgramBrand(const char *s) {
  char *p;
  free(brand);
  free(serverheader);
  if (!(p = EncodeHttpHeaderValue(s, -1, 0))) {
    FATALF(""(cfg) error: brand isn't latin1 encodable: %`'s"", s);
  }
  brand = strdup(s);
  serverheader = xasprintf(""Server: %s\r\n"", p);
  free(p);
}

static void ProgramUid(long x) {
  changeuid = x;
}

static void ProgramGid(long x) {
  changegid = x;
}

#define MINTIMEOUT 10
static void ProgramTimeout(long ms) {
  ldiv_t d;
  if (ms < 0) {
    timeout.tv_sec = ms; /* -(keepalive seconds) */
    timeout.tv_usec = 0;
  } else {
    if (ms < MINTIMEOUT) {
      FATALF(""(cfg) error: timeout needs to be %dms or greater"", MINTIMEOUT);
    }
    d = ldiv(ms, 1000);
    timeout.tv_sec = d.quot;
    timeout.tv_usec = d.rem * 1000;
  }
}

static void ProgramCache(long x, const char *s) {
  cacheseconds = x;
  if (s) cachedirective = strdup(s);
}

static void SetDefaults(void) {
  ProgramBrand(gc(xasprintf(""%s/%hhd.%hhd.%hhd"", REDBEAN, VERSION >> 020,
                            VERSION >> 010, VERSION >> 000)));
  __log_level = kLogInfo;
  maxpayloadsize = 64 * 1024;
  ProgramCache(-1, ""must-revalidate"");
  ProgramTimeout(60 * 1000);
  ProgramSslTicketLifetime(24 * 60 * 60);
  sslfetchverify = true;
}

static void AddString(struct Strings *l, const char *s, size_t n) {
  if (++l->n > l->c) {
    l->c = l->n + (l->n >> 1);
    l->p = realloc(l->p, l->c * sizeof(*l->p));
  }
  l->p[l->n - 1].s = s;
  l->p[l->n - 1].n = n;
}

static bool HasString(struct Strings *l, const char *s, size_t n) {
  size_t i;
  for (i = 0; i < l->n; ++i) {
    if (SlicesEqual(l->p[i].s, l->p[i].n, s, n)) {
      return true;
    }
  }
  return false;
}

const char *DEFAULTLUAPATH = ""/zip/.lua/?.lua;/zip/.lua/?/init.lua"";

static void UpdateLuaPath(const char *s) {
#ifndef STATIC
  lua_State *L = GL;
  char *curpath = """";
  char *respath = 0;
  char *t;
  int n = lua_gettop(L);
  lua_getglobal(L, ""package"");
  if (lua_istable(L, -1)) {
    lua_getfield(L, -1, ""path"");
    curpath = (void *)luaL_optstring(L, -1, """");
    if ((t = strstr(curpath, DEFAULTLUAPATH))) {
      // if the DEFAULT path is found, prepend the path in front of it
      respath = xasprintf(""%.*s%s/.lua/?.lua;%s/.lua/?/init.lua;%s"",
                          t - curpath, curpath, s, s, t);
    } else {
      // if the DEFAULT path is not found, append to the end
      respath = xasprintf(""%s;%s/.lua/?.lua;%s/.lua/?/init.lua"", curpath, s, s);
    }
    lua_pushstring(L, gc(respath));
    lua_setfield(L, -3, ""path"");
  }
  lua_settop(L, n);
#endif
}

static void ProgramDirectory(const char *path) {
  char *s;
  size_t n;
  struct stat st;
  if (stat(path, &st) == -1 || !S_ISDIR(st.st_mode)) {
    FATALF(""(cfg) error: not a directory: %`'s"", path);
  }
  s = strdup(path);
  n = strlen(s);
  INFOF(""(cfg) program directory: %s"", s);
  AddString(&stagedirs, s, n);
  UpdateLuaPath(s);
}

static void ProgramHeader(const char *s) {
  char *p, *v;
  if ((p = strchr(s, ':')) && IsValidHttpToken(s, p - s) &&
      (v = EncodeLatin1(p + 1, -1, 0, kControlC0 | kControlC1 | kControlWs))) {
    switch (GetHttpHeader(s, p - s)) {
      case kHttpDate:
      case kHttpConnection:
      case kHttpContentLength:
      case kHttpContentEncoding:
      case kHttpContentRange:
      case kHttpLocation:
        FATALF(""(cfg) error: can't program header: %`'s"", s);
      case kHttpServer:
        ProgramBrand(p + 1);
        break;
      default:
        p = xasprintf(""%s%.*s:%s\r\n"", extrahdrs ? extrahdrs : """", p - s, s, v);
        free(extrahdrs);
        extrahdrs = p;
        break;
    }
    free(v);
  } else {
    FATALF(""(cfg) error: illegal header: %`'s"", s);
  }
}

static void ProgramLogPath(const char *s) {
  int fd;
  logpath = strdup(s);
  fd = open(logpath, O_APPEND | O_WRONLY | O_CREAT, 0640);
  if (fd == -1) {
    WARNF(""(srvr) open(%`'s) failed: %m"", logpath);
    return;
  }
  if (fd != 2) {
    dup2(fd, 2);
    close(fd);
  }
}

static void ProgramPidPath(const char *s) {
  pidpath = strdup(s);
}

static bool IsServerFd(int fd) {
  size_t i;
  for (i = 0; i < servers.n; ++i) {
    if (servers.p[i].fd == fd) {
      return true;
    }
  }
  return false;
}

static void ChangeUser(void) {
  if (changegid) {
    if (setgid(changegid)) {
      FATALF(""(cfg) setgid() failed: %m"");
    }
  }
  // order matters
  if (changeuid) {
    if (setuid(changeuid)) {
      FATALF(""(cfg) setuid() failed: %m"");
    }
  }
}

static void Daemonize(void) {
  if (fork() > 0) exit(0);
  setsid();
  if (fork() > 0) _exit(0);
  umask(0);
}

static void LogLuaError(const char *hook, const char *err) {
  ERRORF(""(lua) failed to run %s: %s"", hook, err);
}

// handles `-e CODE` (frontloads web server code)
// handles `-i -e CODE` (interprets expression and exits)
static void LuaEvalCode(const char *code) {
  lua_State *L = GL;
  int status = luaL_loadstring(L, code);
  if (status != LUA_OK || LuaCallWithTrace(L, 0, 0, NULL) != LUA_OK) {
    LogLuaError(""lua code"", lua_tostring(L, -1));
    lua_pop(L, 1);  // pop error
    exit(1);
  }
  AssertLuaStackIsAt(L, 0);
}

// handle `-F PATH` arg
static void LuaEvalFile(const char *path) {
  char *f = gc(xslurp(path, 0));
  if (!f) FATALF(""(cfg) error: failed to read file %`'s"", path);
  LuaEvalCode(f);
}

static bool LuaOnClientConnection(void) {
  bool dropit = false;
#ifndef STATIC
  uint32_t ip, serverip;
  uint16_t port, serverport;
  lua_State *L = GL;
  lua_getglobal(L, ""OnClientConnection"");
  GetClientAddr(&ip, &port);
  GetServerAddr(&serverip, &serverport);
  lua_pushinteger(L, ip);
  lua_pushinteger(L, port);
  lua_pushinteger(L, serverip);
  lua_pushinteger(L, serverport);
  if (LuaCallWithTrace(L, 4, 1, NULL) == LUA_OK) {
    dropit = lua_toboolean(L, -1);
  } else {
    LogLuaError(""OnClientConnection"", lua_tostring(L, -1));
  }
  lua_pop(L, 1);  // pop result or error
  AssertLuaStackIsAt(L, 0);
#endif
  return dropit;
}

static void LuaOnLogLatency(long reqtime, long contime) {
#ifndef STATIC
  lua_State *L = GL;
  int n = lua_gettop(L);
  lua_getglobal(L, ""OnLogLatency"");
  lua_pushinteger(L, reqtime);
  lua_pushinteger(L, contime);
  if (LuaCallWithTrace(L, 2, 0, NULL) != LUA_OK) {
    LogLuaError(""OnLogLatency"", lua_tostring(L, -1));
    lua_pop(L, 1);  // pop error
  }
  AssertLuaStackIsAt(L, n);
#endif
}

static void LuaOnProcessCreate(int pid) {
#ifndef STATIC
  uint32_t ip, serverip;
  uint16_t port, serverport;
  lua_State *L = GL;
  lua_getglobal(L, ""OnProcessCreate"");
  GetClientAddr(&ip, &port);
  GetServerAddr(&serverip, &serverport);
  lua_pushinteger(L, pid);
  lua_pushinteger(L, ip);
  lua_pushinteger(L, port);
  lua_pushinteger(L, serverip);
  lua_pushinteger(L, serverport);
  if (LuaCallWithTrace(L, 5, 0, NULL) != LUA_OK) {
    LogLuaError(""OnProcessCreate"", lua_tostring(L, -1));
    lua_pop(L, 1);  // pop error
  }
  AssertLuaStackIsAt(L, 0);
#endif
}

static bool LuaOnServerListen(int fd, uint32_t ip, uint16_t port) {
  bool nouse = false;
#ifndef STATIC
  lua_State *L = GL;
  lua_getglobal(L, ""OnServerListen"");
  lua_pushinteger(L, fd);
  lua_pushinteger(L, ip);
  lua_pushinteger(L, port);
  if (LuaCallWithTrace(L, 3, 1, NULL) == LUA_OK) {
    nouse = lua_toboolean(L, -1);
  } else {
    LogLuaError(""OnServerListen"", lua_tostring(L, -1));
  }
  lua_pop(L, 1);  // pop result or error
  AssertLuaStackIsAt(L, 0);
#endif
  return nouse;
}

static void LuaOnProcessDestroy(int pid) {
#ifndef STATIC
  lua_State *L = GL;
  lua_getglobal(L, ""OnProcessDestroy"");
  lua_pushinteger(L, pid);
  if (LuaCallWithTrace(L, 1, 0, NULL) != LUA_OK) {
    LogLuaError(""OnProcessDestroy"", lua_tostring(L, -1));
    lua_pop(L, 1);  // pop error
  }
  AssertLuaStackIsAt(L, 0);
#endif
}

static inline bool IsHookDefined(const char *s) {
#ifndef STATIC
  lua_State *L = GL;
  bool res = !!lua_getglobal(L, s);
  lua_pop(L, 1);
  return res;
#else
  return false;
#endif
}

static void CallSimpleHook(const char *s) {
#ifndef STATIC
  lua_State *L = GL;
  int n = lua_gettop(L);
  lua_getglobal(L, s);
  if (LuaCallWithTrace(L, 0, 0, NULL) != LUA_OK) {
    LogLuaError(s, lua_tostring(L, -1));
    lua_pop(L, 1);  // pop error
  }
  AssertLuaStackIsAt(L, n);
#endif
}

static void CallSimpleHookIfDefined(const char *s) {
  if (IsHookDefined(s)) {
    CallSimpleHook(s);
  }
}

static void ReportWorkerExit(int pid, int ws) {
  int workers;
  workers = atomic_fetch_sub(&shared->workers, 1) - 1;
  if (WIFEXITED(ws)) {
    if (WEXITSTATUS(ws)) {
      LockInc(&shared->c.failedchildren);
      WARNF(""(stat) %d exited with %d (%,d workers remain)"", pid,
            WEXITSTATUS(ws), workers);
    } else {
      DEBUGF(""(stat) %d exited (%,d workers remain)"", pid, workers);
    }
  } else {
    LockInc(&shared->c.terminatedchildren);
    WARNF(""(stat) %d terminated with %s (%,d workers remain)"", pid,
          strsignal(WTERMSIG(ws)), workers);
  }
}

static void ReportWorkerResources(int pid, struct rusage *ru) {
  char *s, *b = 0;
  if (logrusage || LOGGABLE(kLogDebug)) {
    AppendResourceReport(&b, ru, ""\n"");
    if (b) {
      if ((s = IndentLines(b, appendz(b).i - 1, 0, 1))) {
        LOGF(kLogDebug, ""(stat) resource report for pid %d\n%s"", pid, s);
        free(s);
      }
      free(b);
    }
  }
}

static void HandleWorkerExit(int pid, int ws, struct rusage *ru) {
  LockInc(&shared->c.connectionshandled);
  rusage_add(&shared->children, ru);
  ReportWorkerExit(pid, ws);
  ReportWorkerResources(pid, ru);
  if (hasonprocessdestroy) {
    LuaOnProcessDestroy(pid);
  }
}

static void KillGroupImpl(int sig) {
  LOGIFNEG1(kill(0, sig));
}

static void KillGroup(void) {
  KillGroupImpl(SIGTERM);
}

static void WaitAll(void) {
  int ws, pid;
  struct rusage ru;
  for (;;) {
    if ((pid = wait4(-1, &ws, 0, &ru)) != -1) {
      HandleWorkerExit(pid, ws, &ru);
    } else {
      if (errno == ECHILD) {
        errno = 0;
        break;
      }
      if (errno == EINTR) {
        if (killed) {
          killed = false;
          terminated = false;
          WARNF(""(srvr) server shall terminate harder"");
          KillGroup();
        }
        errno = 0;
        continue;
      }
      DIEF(""(srvr) wait error: %m"");
    }
  }
}

static void ReapZombies(void) {
  int ws, pid;
  struct rusage ru;
  do {
    zombied = false;
    if ((pid = wait4(-1, &ws, WNOHANG, &ru)) != -1) {
      if (pid) {
        HandleWorkerExit(pid, ws, &ru);
      } else {
        break;
      }
    } else {
      if (errno == ECHILD) {
        errno = 0;
        break;
      }
      if (errno == EINTR) {
        errno = 0;
        continue;
      }
      DIEF(""(srvr) wait error: %m"");
    }
  } while (!terminated);
}

static ssize_t ReadAll(int fd, char *p, size_t n) {
  ssize_t rc;
  size_t i, got;
  for (i = 0; i < n;) {
    rc = READ(fd, p + i, n - i);
    if (rc != -1) {
      got = rc;
      i += got;
    } else if (errno != EINTR) {
      WARNF(""(file) read error: %m"");
      return -1;
    }
  }
  return i;
}

static bool IsTakingTooLong(void) {
  return meltdown && timespec_cmp(timespec_sub(timespec_real(), startread),
                                  (struct timespec){2}) >= 0;
}

static ssize_t WritevAll(int fd, struct iovec *iov, int iovlen) {
  int i;
  ssize_t rc;
  size_t wrote, total;
  i = 0;
  total = 0;
  do {
    if (i) {
      while (i < iovlen && !iov[i].iov_len) ++i;
      if (i == iovlen) break;
    }
    if ((rc = writev(fd, iov + i, iovlen - i)) != -1) {
      wrote = rc;
      total += wrote;
      do {
        if (wrote >= iov[i].iov_len) {
          wrote -= iov[i++].iov_len;
        } else {
          iov[i].iov_base = (char *)iov[i].iov_base + wrote;
          iov[i].iov_len -= wrote;
          wrote = 0;
        }
      } while (wrote);
    } else if (errno == EINTR) {
      errno = 0;
      LockInc(&shared->c.writeinterruputs);
      if (killed || IsTakingTooLong()) {
        return total ? total : -1;
      }
    } else {
      return total ? total : -1;
    }
  } while (i < iovlen);
  return total;
}

static int TlsFlush(struct TlsBio *bio, const unsigned char *buf, size_t len) {
  struct iovec v[2];
  if (len || bio->c > 0) {
    v[0].iov_base = bio->u;
    v[0].iov_len = MAX(0, bio->c);
    v[1].iov_base = (void *)buf;
    v[1].iov_len = len;
    if (WritevAll(bio->fd, v, 2) != -1) {
      if (bio->c > 0) bio->c = 0;
    } else if (errno == EINTR) {
      errno = 0;
      return MBEDTLS_ERR_NET_CONN_RESET;
    } else if (errno == EAGAIN) {
      errno = 0;
      return MBEDTLS_ERR_SSL_TIMEOUT;
    } else if (errno == EPIPE || errno == ECONNRESET || errno == ENETRESET) {
      return MBEDTLS_ERR_NET_CONN_RESET;
    } else {
      WARNF(""(ssl) TlsSend error: %m"");
      return MBEDTLS_ERR_NET_SEND_FAILED;
    }
  }
  return 0;
}

static int TlsSend(void *ctx, const unsigned char *buf, size_t len) {
  int rc;
  struct TlsBio *bio = ctx;
  if (bio->c >= 0 && bio->c + len <= sizeof(bio->u)) {
    memcpy(bio->u + bio->c, buf, len);
    bio->c += len;
    return len;
  }
  if ((rc = TlsFlush(bio, buf, len)) < 0) return rc;
  return len;
}

static int TlsRecvImpl(void *ctx, unsigned char *p, size_t n, uint32_t o) {
  int r;
  struct iovec v[2];
  struct TlsBio *bio = ctx;
  if ((r = TlsFlush(bio, 0, 0)) < 0) return r;
  if (bio->a < bio->b) {
    r = MIN(n, bio->b - bio->a);
    memcpy(p, bio->t + bio->a, r);
    if ((bio->a += r) == bio->b) bio->a = bio->b = 0;
    return r;
  }
  v[0].iov_base = p;
  v[0].iov_len = n;
  v[1].iov_base = bio->t;
  v[1].iov_len = sizeof(bio->t);
  while ((r = readv(bio->fd, v, 2)) == -1) {
    if (errno == EINTR) {
      errno = 0;
      return MBEDTLS_ERR_SSL_WANT_READ;
    } else if (errno == EAGAIN) {
      errno = 0;
      return MBEDTLS_ERR_SSL_TIMEOUT;
    } else if (errno == EPIPE || errno == ECONNRESET || errno == ENETRESET) {
      return MBEDTLS_ERR_NET_CONN_RESET;
    } else {
      WARNF(""(ssl) tls read() error: %m"");
      return MBEDTLS_ERR_NET_RECV_FAILED;
    }
  }
  if (r > n) bio->b = r - n;
  return MIN(n, r);
}

static int TlsRecv(void *ctx, unsigned char *buf, size_t len, uint32_t tmo) {
  int rc;
  if (oldin.n) {
    rc = MIN(oldin.n, len);
    memcpy(buf, oldin.p, rc);
    oldin.p += rc;
    oldin.n -= rc;
    return rc;
  }
  return TlsRecvImpl(ctx, buf, len, tmo);
}

static ssize_t SslRead(int fd, void *buf, size_t size) {
  int rc;
  rc = mbedtls_ssl_read(&ssl, buf, size);
  if (!rc) {
    errno = ECONNRESET;
    rc = -1;
  } else if (rc < 0) {
    if (rc == MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY) {
      rc = 0;
    } else if (rc == MBEDTLS_ERR_NET_CONN_RESET ||
               rc == MBEDTLS_ERR_SSL_TIMEOUT) {
      errno = ECONNRESET;
      rc = -1;
    } else if (rc == MBEDTLS_ERR_SSL_WANT_READ) {
      errno = EINTR;
      rc = -1;
      errno = 0;
    } else if (rc == MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE) {
      WARNF(""(ssl) %s SslRead error -0x%04x (%s)"", DescribeClient(), -rc,
            ""fatal alert message"");
      errno = EIO;
      rc = -1;
    } else if (rc == MBEDTLS_ERR_SSL_INVALID_RECORD) {
      WARNF(""(ssl) %s SslRead error -0x%04x (%s)"", DescribeClient(), -rc,
            ""invalid record"");
      errno = EIO;
      rc = -1;
    } else if (rc == MBEDTLS_ERR_SSL_INVALID_MAC) {
      WARNF(""(ssl) %s SslRead error -0x%04x (%s)"", DescribeClient(), -rc,
            ""hmac verification failed"");
      errno = EIO;
      rc = -1;
    } else {
      WARNF(""(ssl) %s SslRead error -0x%04x"", DescribeClient(), -rc);
      errno = EIO;
      rc = -1;
    }
  }
  return rc;
}

static ssize_t SslWrite(int fd, struct iovec *iov, int iovlen) {
  int i;
  size_t n;
  ssize_t rc;
  const unsigned char *p;
  for (i = 0; i < iovlen; ++i) {
    p = iov[i].iov_base;
    n = iov[i].iov_len;
    while (n) {
      if ((rc = mbedtls_ssl_write(&ssl, p, n)) > 0) {
        p += rc;
        n -= rc;
      } else if (rc == MBEDTLS_ERR_NET_CONN_RESET) {
        errno = ECONNRESET;
        return -1;
      } else if (rc == MBEDTLS_ERR_SSL_TIMEOUT) {
        errno = ETIMEDOUT;
        return -1;
      } else {
        WARNF(""(ssl) %s SslWrite error -0x%04x"", DescribeClient(), -rc);
        errno = EIO;
        return -1;
      }
    }
  }
  return 0;
}

static void NotifyClose(void) {
#ifndef UNSECURE
  if (usingssl) {
    DEBUGF(""(ssl) SSL notifying close"");
    mbedtls_ssl_close_notify(&ssl);
  }
#endif
}

static void WipeSigningKeys(void) {
  size_t i;
  if (uniprocess) return;
  for (i = 0; i < certs.n; ++i) {
    if (!certs.p[i].key) continue;
    if (!certs.p[i].cert) continue;
    if (!certs.p[i].cert->ca_istrue) continue;
    mbedtls_pk_free(certs.p[i].key);
    Free(&certs.p[i].key);
  }
}

static void PsksDestroy(void) {
  size_t i;
  for (i = 0; i < psks.n; ++i) {
    mbedtls_platform_zeroize(psks.p[i].key, psks.p[i].key_len);
    free(psks.p[i].key);
    free(psks.p[i].identity);
  }
  Free(&psks.p);
  psks.n = 0;
}

static void CertsDestroy(void) {
  size_t i;
  // break up certificate chains to prevent double free
  for (i = 0; i < certs.n; ++i) {
    if (certs.p[i].cert) {
      certs.p[i].cert->next = 0;
    }
  }
  for (i = 0; i < certs.n; ++i) {
    mbedtls_x509_crt_free(certs.p[i].cert);
    free(certs.p[i].cert);
    mbedtls_pk_free(certs.p[i].key);
    free(certs.p[i].key);
  }
  Free(&certs.p);
  certs.n = 0;
}

static void WipeServingKeys(void) {
  if (uniprocess) return;
  mbedtls_ssl_ticket_free(&ssltick);
  mbedtls_ssl_key_cert_free(conf.key_cert), conf.key_cert = 0;
  CertsDestroy();
  PsksDestroy();
}

static bool CertHasCommonName(const mbedtls_x509_crt *cert, const void *s,
                              size_t n) {
  const mbedtls_x509_name *name;
  for (name = &cert->subject; name; name = name->next) {
    if (!MBEDTLS_OID_CMP(MBEDTLS_OID_AT_CN, &name->oid)) {
      if (SlicesEqualCase(s, n, name->val.p, name->val.len)) {
        return true;
      }
      break;
    }
  }
  return false;
}

static bool TlsRouteFind(mbedtls_pk_type_t type, mbedtls_ssl_context *ssl,
                         const unsigned char *host, size_t size, int64_t ip) {
  int i;
  for (i = 0; i < certs.n; ++i) {
    if (IsServerCert(certs.p + i, type) &&
        (((certs.p[i].cert->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME) &&
          (ip == -1 ? CertHasHost(certs.p[i].cert, host, size)
                    : CertHasIp(certs.p[i].cert, ip))) ||
         CertHasCommonName(certs.p[i].cert, host, size))) {
      CHECK_EQ(
          0, mbedtls_ssl_set_hs_own_cert(ssl, certs.p[i].cert, certs.p[i].key));
      DEBUGF(""(ssl) TlsRoute(%s, %`'.*s) %s %`'s"", mbedtls_pk_type_name(type),
             size, host, mbedtls_pk_get_name(&certs.p[i].cert->pk),
             gc(FormatX509Name(&certs.p[i].cert->subject)));
      return true;
    }
  }
  return false;
}

static bool TlsRouteFirst(mbedtls_pk_type_t type, mbedtls_ssl_context *ssl) {
  int i;
  for (i = 0; i < certs.n; ++i) {
    if (IsServerCert(certs.p + i, type)) {
      CHECK_EQ(
          0, mbedtls_ssl_set_hs_own_cert(ssl, certs.p[i].cert, certs.p[i].key));
      DEBUGF(""(ssl) TlsRoute(%s) %s %`'s"", mbedtls_pk_type_name(type),
             mbedtls_pk_get_name(&certs.p[i].cert->pk),
             gc(FormatX509Name(&certs.p[i].cert->subject)));
      return true;
    }
  }
  return false;
}

static int TlsRoute(void *ctx, mbedtls_ssl_context *ssl,
                    const unsigned char *host, size_t size) {
  int64_t ip;
  bool ok1, ok2;
  ip = ParseIp((const char *)host, size);
  ok1 = TlsRouteFind(MBEDTLS_PK_ECKEY, ssl, host, size, ip);
  ok2 = TlsRouteFind(MBEDTLS_PK_RSA, ssl, host, size, ip);
  if (!ok1 && !ok2) {
    WARNF(""(ssl) TlsRoute(%`'.*s) not found"", size, host);
    ok1 = TlsRouteFirst(MBEDTLS_PK_ECKEY, ssl);
    ok2 = TlsRouteFirst(MBEDTLS_PK_RSA, ssl);
  }
  return ok1 || ok2 ? 0 : -1;
}

static int TlsRoutePsk(void *ctx, mbedtls_ssl_context *ssl,
                       const unsigned char *identity, size_t identity_len) {
  size_t i;
  for (i = 0; i < psks.n; ++i) {
    if (SlicesEqual((void *)identity, identity_len, psks.p[i].identity,
                    psks.p[i].identity_len)) {
      DEBUGF(""(ssl) TlsRoutePsk(%`'.*s)"", identity_len, identity);
      mbedtls_ssl_set_hs_psk(ssl, psks.p[i].key, psks.p[i].key_len);
      // keep track of selected psk to report its identity
      sslpskindex = i + 1;  // use index+1 to check against 0 (when not set)
      return 0;
    }
  }
  WARNF(""(ssl) TlsRoutePsk(%`'.*s) not found"", identity_len, identity);
  return -1;
}

static bool TlsSetup(void) {
  int r;
  oldin.p = inbuf.p;
  oldin.n = amtread;
  inbuf.p += amtread;
  inbuf.n -= amtread;
  inbuf.c = amtread;
  amtread = 0;
  g_bio.fd = client;
  g_bio.a = 0;
  g_bio.b = 0;
  g_bio.c = 0;
  sslpskindex = 0;
  for (;;) {
    if (!(r = mbedtls_ssl_handshake(&ssl)) && TlsFlush(&g_bio, 0, 0) != -1) {
      LockInc(&shared->c.sslhandshakes);
      g_bio.c = -1;
      usingssl = true;
      reader = SslRead;
      writer = SslWrite;
      WipeServingKeys();
      VERBOSEF(""(ssl) shaken %s %s %s%s %s"", DescribeClient(),
               mbedtls_ssl_get_ciphersuite(&ssl), mbedtls_ssl_get_version(&ssl),
               ssl.session->compression ? "" COMPRESSED"" : """",
               ssl.curve ? ssl.curve->name : ""uncurved"");
      DEBUGF(""(ssl) client ciphersuite preference was %s"",
             gc(FormatSslClientCiphers(&ssl)));
      return true;
    } else if (r == MBEDTLS_ERR_SSL_WANT_READ) {
      LockInc(&shared->c.handshakeinterrupts);
      if (terminated || killed || IsTakingTooLong()) {
        return false;
      }
    } else {
      LockInc(&shared->c.sslhandshakefails);
      mbedtls_ssl_session_reset(&ssl);
      switch (r) {
        case MBEDTLS_ERR_SSL_CONN_EOF:
          DEBUGF(""(ssl) %s SSL handshake EOF"", DescribeClient());
          return false;
        case MBEDTLS_ERR_NET_CONN_RESET:
          DEBUGF(""(ssl) %s SSL handshake reset"", DescribeClient());
          return false;
        case MBEDTLS_ERR_SSL_TIMEOUT:
          LockInc(&shared->c.ssltimeouts);
          DEBUGF(""(ssl) %s %s"", DescribeClient(), ""ssltimeouts"");
          return false;
        case MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN:
          LockInc(&shared->c.sslnociphers);
          WARNF(""(ssl) %s %s %s"", DescribeClient(), ""sslnociphers"",
                gc(FormatSslClientCiphers(&ssl)));
          return false;
        case MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE:
          LockInc(&shared->c.sslcantciphers);
          WARNF(""(ssl) %s %s %s"", DescribeClient(), ""sslcantciphers"",
                gc(FormatSslClientCiphers(&ssl)));
          return false;
        case MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION:
          LockInc(&shared->c.sslnoversion);
          WARNF(""(ssl) %s %s %s"", DescribeClient(), ""sslnoversion"",
                mbedtls_ssl_get_version(&ssl));
          return false;
        case MBEDTLS_ERR_SSL_INVALID_MAC:
          LockInc(&shared->c.sslshakemacs);
          WARNF(""(ssl) %s %s"", DescribeClient(), ""sslshakemacs"");
          return false;
        case MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE:
          LockInc(&shared->c.sslnoclientcert);
          WARNF(""(ssl) %s %s"", DescribeClient(), ""sslnoclientcert"");
          NotifyClose();
          return false;
        case MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:
          LockInc(&shared->c.sslverifyfailed);
          WARNF(""(ssl) %s SSL %s"", DescribeClient(),
                gc(DescribeSslVerifyFailure(
                    ssl.session_negotiate->verify_result)));
          return false;
        case MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE:
          switch (ssl.fatal_alert) {
            case MBEDTLS_SSL_ALERT_MSG_CERT_UNKNOWN:
              LockInc(&shared->c.sslunknowncert);
              DEBUGF(""(ssl) %s %s"", DescribeClient(), ""sslunknowncert"");
              return false;
            case MBEDTLS_SSL_ALERT_MSG_UNKNOWN_CA:
              LockInc(&shared->c.sslunknownca);
              DEBUGF(""(ssl) %s %s"", DescribeClient(), ""sslunknownca"");
              return false;
            default:
              WARNF(""(ssl) %s SSL shakealert %s"", DescribeClient(),
                    GetAlertDescription(ssl.fatal_alert));
              return false;
          }
        default:
          WARNF(""(ssl) %s SSL handshake failed -0x%04x"", DescribeClient(), -r);
          return false;
      }
    }
  }
}

static void ConfigureCertificate(mbedtls_x509write_cert *cw, struct Cert *ca,
                                 int usage, int type) {
  int nsan = 0;
  char *name = 0;
  struct mbedtls_san *san = 0;

  // for each ip address owned by this system
  //
  //   1. determine its full-qualified domain name
  //   2. add subject alt name (san) entry to cert for hostname
  //   3. add subject alt name (san) entry to cert for *.hostname
  //
  for (int i = 0; i < ips.n; ++i) {
    uint32_t ip = ips.p[i];
    if (IsLoopbackIp(ip)) continue;
    char rname[NI_MAXHOST];
    struct sockaddr_in addr4 = {AF_INET, 0, {htonl(ip)}};
    if (getnameinfo((struct sockaddr *)&addr4, sizeof(addr4), rname,
                    sizeof(rname), 0, 0, NI_NAMEREQD) == 0) {
      char *s = gc(strdup(rname));
      if (!name) name = s;
      bool isduplicate = false;
      for (int j = 0; j < nsan; ++j) {
        if (san[j].tag == MBEDTLS_X509_SAN_DNS_NAME &&
            !strcasecmp(s, san[j].val)) {
          isduplicate = true;
          break;
        }
      }
      if (!isduplicate) {
        san = realloc(san, (nsan += 2) * sizeof(*san));
        san[nsan - 2].tag = MBEDTLS_X509_SAN_DNS_NAME;
        san[nsan - 2].val = s;
        san[nsan - 1].tag = MBEDTLS_X509_SAN_DNS_NAME;
        san[nsan - 1].val = gc(xasprintf(""*.%s"", s));
      }
    }
  }

  // add san entry to cert for each ip address owned by system
  for (int i = 0; i < ips.n; ++i) {
    uint32_t ip = ips.p[i];
    if (IsLoopbackIp(ip)) continue;
    san = realloc(san, ++nsan * sizeof(*san));
    san[nsan - 1].tag = MBEDTLS_X509_SAN_IP_ADDRESS;
    san[nsan - 1].ip4 = ip;
  }
  char notbefore[16], notafter[16];
  ChooseCertificateLifetime(notbefore, notafter);

  // pick common name for certificate
  char hbuf[256];
  if (!name) {
    strcpy(hbuf, ""localhost"");
    gethostname(hbuf, sizeof(hbuf));
    name = hbuf;
  }
  char *subject = xasprintf(""CN=%s"", name);

  // pick issuer name for certificate
  char *issuer;
  if (ca) {
    issuer = calloc(1, 1000);
    CHECK_GT(mbedtls_x509_dn_gets(issuer, 1000, &ca->cert->subject), 0);
  } else {
    issuer = strdup(subject);
  }

  // call the mbedtls apis
  int r;
  if ((r = mbedtls_x509write_crt_set_subject_alternative_name(cw, san, nsan)) ||
      (r = mbedtls_x509write_crt_set_validity(cw, notbefore, notafter)) ||
      (r = mbedtls_x509write_crt_set_basic_constraints(cw, false, -1)) ||
#if defined(MBEDTLS_SHA1_C)
      (r = mbedtls_x509write_crt_set_subject_key_identifier(cw)) ||
      (r = mbedtls_x509write_crt_set_authority_key_identifier(cw)) ||
#endif
      (r = mbedtls_x509write_crt_set_key_usage(cw, usage)) ||
      (r = mbedtls_x509write_crt_set_ext_key_usage(cw, type)) ||
      (r = mbedtls_x509write_crt_set_subject_name(cw, subject)) ||
      (r = mbedtls_x509write_crt_set_issuer_name(cw, issuer))) {
    FATALF(""(ssl) configure certificate (grep -0x%04x)"", -r);
  }
  free(subject);
  free(issuer);
  free(san);
}

static struct Cert GetKeySigningKey(void) {
  size_t i;
  for (i = 0; i < certs.n; ++i) {
    if (!certs.p[i].key) continue;
    if (!certs.p[i].cert) continue;
    if (!certs.p[i].cert->ca_istrue) continue;
    if (mbedtls_x509_crt_check_key_usage(certs.p[i].cert,
                                         MBEDTLS_X509_KU_KEY_CERT_SIGN)) {
      continue;
    }
    return certs.p[i];
  }
  return (struct Cert){0};
}

static struct Cert GenerateEcpCertificate(struct Cert *ca) {
  mbedtls_pk_context *key;
  mbedtls_md_type_t md_alg;
  mbedtls_x509write_cert wcert;
  md_alg = suiteb ? MBEDTLS_MD_SHA384 : MBEDTLS_MD_SHA256;
  key = InitializeKey(ca, &wcert, md_alg, MBEDTLS_PK_ECKEY);
  CHECK_EQ(0, mbedtls_ecp_gen_key(
                  suiteb ? MBEDTLS_ECP_DP_SECP384R1 : MBEDTLS_ECP_DP_SECP256R1,
                  mbedtls_pk_ec(*key), GenerateHardRandom, 0));
  GenerateCertificateSerial(&wcert);
  ConfigureCertificate(&wcert, ca, MBEDTLS_X509_KU_DIGITAL_SIGNATURE,
                       MBEDTLS_X509_NS_CERT_TYPE_SSL_SERVER |
                           MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT);
  return FinishCertificate(ca, &wcert, key);
}

static struct Cert GenerateRsaCertificate(struct Cert *ca) {
  mbedtls_pk_context *key;
  mbedtls_md_type_t md_alg;
  mbedtls_x509write_cert wcert;
  md_alg = suiteb ? MBEDTLS_MD_SHA384 : MBEDTLS_MD_SHA256;
  key = InitializeKey(ca, &wcert, md_alg, MBEDTLS_PK_RSA);
  CHECK_EQ(0, mbedtls_rsa_gen_key(mbedtls_pk_rsa(*key), GenerateHardRandom, 0,
                                  suiteb ? 4096 : 2048, 65537));
  GenerateCertificateSerial(&wcert);
  ConfigureCertificate(
      &wcert, ca,
      MBEDTLS_X509_KU_DIGITAL_SIGNATURE | MBEDTLS_X509_KU_KEY_ENCIPHERMENT,
      MBEDTLS_X509_NS_CERT_TYPE_SSL_SERVER |
          MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT);
  return FinishCertificate(ca, &wcert, key);
}

static void LoadCertificates(void) {
  size_t i;
  struct Cert ksk, ecp, rsa;
  bool havecert, haveclientcert;
  havecert = false;
  haveclientcert = false;
  for (i = 0; i < certs.n; ++i) {
    if (certs.p[i].key && certs.p[i].cert && !certs.p[i].cert->ca_istrue &&
        !mbedtls_x509_crt_check_key_usage(certs.p[i].cert,
                                          MBEDTLS_X509_KU_DIGITAL_SIGNATURE)) {
      if (!mbedtls_x509_crt_check_extended_key_usage(
              certs.p[i].cert, MBEDTLS_OID_SERVER_AUTH,
              MBEDTLS_OID_SIZE(MBEDTLS_OID_SERVER_AUTH))) {
        LogCertificate(""using server certificate"", certs.p[i].cert);
        UseCertificate(&conf, certs.p + i, ""server"");
        havecert = true;
      }
      if (!mbedtls_x509_crt_check_extended_key_usage(
              certs.p[i].cert, MBEDTLS_OID_CLIENT_AUTH,
              MBEDTLS_OID_SIZE(MBEDTLS_OID_CLIENT_AUTH))) {
        LogCertificate(""using client certificate"", certs.p[i].cert);
        UseCertificate(&confcli, certs.p + i, ""client"");
        haveclientcert = true;
      }
    }
  }
  if (!havecert && (!psks.n || ksk.key)) {
    if ((ksk = GetKeySigningKey()).key) {
      DEBUGF(""(ssl) generating ssl certificates using %`'s"",
             gc(FormatX509Name(&ksk.cert->subject)));
    } else {
      VERBOSEF(""(ssl) could not find non-CA SSL certificate key pair with""
               "" -addext keyUsage=digitalSignature""
               "" -addext extendedKeyUsage=serverAuth"");
      VERBOSEF(""(ssl) could not find CA key signing key pair with""
               "" -addext keyUsage=keyCertSign"");
      VERBOSEF(""(ssl) generating self-signed ssl certificates"");
    }
#ifdef MBEDTLS_ECP_C
    ecp = GenerateEcpCertificate(ksk.key ? &ksk : 0);
    if (!havecert) UseCertificate(&conf, &ecp, ""server"");
    if (!haveclientcert && ksk.key) {
      UseCertificate(&confcli, &ecp, ""client"");
    }
    AppendCert(ecp.cert, ecp.key);
#endif
#ifdef MBEDTLS_RSA_C
    if (!norsagen) {
      rsa = GenerateRsaCertificate(ksk.key ? &ksk : 0);
      if (!havecert) UseCertificate(&conf, &rsa, ""server"");
      if (!haveclientcert && ksk.key) {
        UseCertificate(&confcli, &rsa, ""client"");
      }
      AppendCert(rsa.cert, rsa.key);
    }
#endif
  }
  WipeSigningKeys();
}

static bool ClientAcceptsGzip(void) {
  return cpm.msg.version >= 10 && /* RFC1945 § 3.5 */
         HeaderHas(&cpm.msg, inbuf.p, kHttpAcceptEncoding, ""gzip"", 4);
}

char *FormatUnixHttpDateTime(char *s, int64_t t) {
  struct tm tm;
  gmtime_r(&t, &tm);
  FormatHttpDateTime(s, &tm);
  return s;
}

static void UpdateCurrentDate(struct timespec now) {
  int64_t t;
  struct tm tm;
  t = now.tv_sec;
  shared->nowish = now;
  gmtime_r(&t, &tm);
  FormatHttpDateTime(shared->currentdate, &tm);
}

static int64_t GetGmtOffset(int64_t t) {
  struct tm tm;
  localtime_r(&t, &tm);
  return tm.tm_gmtoff;
}

forceinline bool IsCompressed(struct Asset *a) {
  return !a->file &&
         ZIP_LFILE_COMPRESSIONMETHOD(zmap + a->lf) == kZipCompressionDeflate;
}

forceinline int GetMode(struct Asset *a) {
  return a->file ? a->file->st.st_mode : GetZipCfileMode(zmap + a->cf);
}

forceinline bool IsCompressionMethodSupported(int method) {
  return method == kZipCompressionNone || method == kZipCompressionDeflate;
}

static inline unsigned Hash(const void *p, unsigned long n) {
  unsigned h, i;
  for (h = i = 0; i < n; i++) {
    h += ((unsigned char *)p)[i];
    h *= 0x9e3779b1;
  }
  return MAX(1, h);
}

static void FreeAssets(void) {
  size_t i;
  for (i = 0; i < assets.n; ++i) {
    Free(&assets.p[i].lastmodifiedstr);
  }
  Free(&assets.p);
  assets.n = 0;
}

static void FreeStrings(struct Strings *l) {
  size_t i;
  for (i = 0; i < l->n; ++i) {
    Free(&l->p[i].s);
  }
  Free(&l->p);
  l->n = 0;
}

static unsigned long roundup2pow(unsigned long x) {
  return x > 1 ? 2ul << bsrl(x - 1) : x ? 1 : 0;
}

static void IndexAssets(void) {
  uint64_t cf;
  struct Asset *p;
  struct timespec lm;
  uint32_t i, n, m, step, hash;
  DEBUGF(""(zip) indexing assets (inode %#lx)"", zst.st_ino);
  FreeAssets();
  CHECK_GE(HASH_LOAD_FACTOR, 2);
  CHECK(READ32LE(zcdir) == kZipCdir64HdrMagic ||
        READ32LE(zcdir) == kZipCdirHdrMagic);
  n = GetZipCdirRecords(zcdir);
  m = roundup2pow(MAX(1, n) * HASH_LOAD_FACTOR);
  p = xcalloc(m, sizeof(struct Asset));
  for (cf = GetZipCdirOffset(zcdir); n--; cf += ZIP_CFILE_HDRSIZE(zmap + cf)) {
    CHECK_EQ(kZipCfileHdrMagic, ZIP_CFILE_MAGIC(zmap + cf));
    if (!IsCompressionMethodSupported(ZIP_CFILE_COMPRESSIONMETHOD(zmap + cf))) {
      WARNF(""(zip) don't understand zip compression method %d used by %`'.*s"",
            ZIP_CFILE_COMPRESSIONMETHOD(zmap + cf),
            ZIP_CFILE_NAMESIZE(zmap + cf), ZIP_CFILE_NAME(zmap + cf));
      continue;
    }
    hash = Hash(ZIP_CFILE_NAME(zmap + cf), ZIP_CFILE_NAMESIZE(zmap + cf));
    step = 0;
    do {
      i = (hash + ((step * (step + 1)) >> 1)) & (m - 1);
      ++step;
    } while (p[i].hash);
    GetZipCfileTimestamps(zmap + cf, &lm, 0, 0, gmtoff);
    p[i].hash = hash;
    p[i].cf = cf;
    p[i].lf = GetZipCfileOffset(zmap + cf);
    p[i].istext = !!(ZIP_CFILE_INTERNALATTRIBUTES(zmap + cf) & kZipIattrText);
    p[i].lastmodified = lm.tv_sec;
    p[i].lastmodifiedstr = FormatUnixHttpDateTime(xmalloc(30), lm.tv_sec);
  }
  assets.p = p;
  assets.n = m;
}

static bool OpenZip(bool force) {
  int fd;
  size_t n;
  uint8_t *m, *d;
  struct stat st;
  if (stat(zpath, &st) != -1) {
    if (force || st.st_ino != zst.st_ino || st.st_size > zst.st_size) {
      if (st.st_ino == zst.st_ino) {
        fd = zfd;
      } else if ((fd = open(zpath, O_RDWR)) == -1) {
        WARNF(""(zip) open() error: %m"");
        return false;
      }
      if ((m = mmap(0, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0)) !=
          MAP_FAILED) {
        n = st.st_size;
        if ((d = GetZipEocd(m, n, 0))) {
          if (zmap) {
            LOGIFNEG1(munmap(zmap, zsize));
          }
          zmap = m;
          zsize = n;
          zcdir = d;
          DCHECK(IsZipEocd32(zmap, zsize, zcdir - zmap) == kZipOk ||
                 IsZipEocd64(zmap, zsize, zcdir - zmap) == kZipOk);
          memcpy(&zst, &st, sizeof(st));
          IndexAssets();
          return true;
        } else {
          WARNF(""(zip) couldn't locate central directory"");
        }
      } else {
        WARNF(""(zip) mmap() error: %m"");
      }
    }
  } else {
    // avoid noise if we setuid to user who can't see executable
    if (errno == EACCES) {
      VERBOSEF(""(zip) stat(%`'s) error: %m"", zpath);
    } else {
      WARNF(""(zip) stat(%`'s) error: %m"", zpath);
    }
  }
  return false;
}

static struct Asset *GetAssetZip(const char *path, size_t pathlen) {
  uint32_t i, step, hash;
  if (pathlen > 1 && path[0] == '/') ++path, --pathlen;
  hash = Hash(path, pathlen);
  for (step = 0;; ++step) {
    i = (hash + ((step * (step + 1)) >> 1)) & (assets.n - 1);
    if (!assets.p[i].hash) return NULL;
    if (hash == assets.p[i].hash &&
        pathlen == ZIP_CFILE_NAMESIZE(zmap + assets.p[i].cf) &&
        memcmp(path, ZIP_CFILE_NAME(zmap + assets.p[i].cf), pathlen) == 0) {
      return &assets.p[i];
    }
  }
}

static struct Asset *GetAssetFile(const char *path, size_t pathlen) {
  size_t i;
  struct Asset *a;
  if (stagedirs.n) {
    a = FreeLater(xcalloc(1, sizeof(struct Asset)));
    a->file = FreeLater(xmalloc(sizeof(struct File)));
    for (i = 0; i < stagedirs.n; ++i) {
      LockInc(&shared->c.stats);
      a->file->path.s = FreeLater(MergePaths(stagedirs.p[i].s, stagedirs.p[i].n,
                                             path, pathlen, &a->file->path.n));
      if (stat(a->file->path.s, &a->file->st) != -1) {
        a->lastmodifiedstr = FormatUnixHttpDateTime(
            FreeLater(xmalloc(30)),
            (a->lastmodified = a->file->st.st_mtim.tv_sec));
        return a;
      } else {
        LockInc(&shared->c.statfails);
      }
    }
  }
  return NULL;
}

static struct Asset *GetAsset(const char *path, size_t pathlen) {
  struct Asset *a;
  if (!(a = GetAssetFile(path, pathlen))) {
    if (!(a = GetAssetZip(path, pathlen))) {
      if (pathlen > 1 && path[pathlen - 1] != '/' &&
          pathlen + 1 <= sizeof(slashpath)) {
        memcpy(mempcpy(slashpath, path, pathlen), ""/"", 1);
        a = GetAssetZip(slashpath, pathlen + 1);
      }
    }
  }
  return a;
}

static char *AppendHeader(char *p, const char *k, const char *v) {
  if (!v) return p;
  return AppendCrlf(stpcpy(stpcpy(stpcpy(p, k), "": ""), v));
}

static char *AppendContentType(char *p, const char *ct) {
  p = stpcpy(p, ""Content-Type: "");
  p = stpcpy(p, ct);
  if ((cpm.istext = startswith(ct, ""text/""))) {
    if (!strchr(ct + 5, ';')) {
      p = stpcpy(p, ""; charset=utf-8"");
    }
    if (!cpm.referrerpolicy && startswith(ct + 5, ""html"")) {
      cpm.referrerpolicy = ""no-referrer-when-downgrade"";
    }
  }
  cpm.hascontenttype = true;
  return AppendCrlf(p);
}

static char *AppendExpires(char *p, int64_t t) {
  struct tm tm;
  gmtime_r(&t, &tm);
  p = stpcpy(p, ""Expires: "");
  p = FormatHttpDateTime(p, &tm);
  return AppendCrlf(p);
}

static char *AppendCache(char *p, int64_t seconds, char *directive) {
  if (seconds < 0) return p;
  p = stpcpy(p, ""Cache-Control: max-age="");
  p = FormatUint64(p, seconds);
  if (!seconds) {
    p = stpcpy(p, "", no-store"");
  } else if (directive && *directive) {
    p = stpcpy(p, "", "");
    p = stpcpy(p, directive);
  }
  p = AppendCrlf(p);
  return AppendExpires(p, shared->nowish.tv_sec + seconds);
}

static inline char *AppendContentLength(char *p, size_t n) {
  p = stpcpy(p, ""Content-Length: "");
  p = FormatUint64(p, n);
  return AppendCrlf(p);
}

static char *AppendContentRange(char *p, long a, long b, long c) {
  p = stpcpy(p, ""Content-Range: bytes "");
  if (a >= 0 && b > 0) {
    p = FormatUint64(p, a);
    *p++ = '-';
    p = FormatUint64(p, a + b - 1);
  } else {
    *p++ = '*';
  }
  *p++ = '/';
  p = FormatUint64(p, c);
  return AppendCrlf(p);
}

static bool Inflate(void *dp, size_t dn, const void *sp, size_t sn) {
  LockInc(&shared->c.inflates);
  return !__inflate(dp, dn, sp, sn);
}

static bool Verify(void *data, size_t size, uint32_t crc) {
  uint32_t got;
  LockInc(&shared->c.verifies);
  if (crc == (got = crc32_z(0, data, size))) {
    return true;
  } else {
    LockInc(&shared->c.thiscorruption);
    WARNF(""(zip) corrupt zip file at %`'.*s had crc 0x%08x but expected 0x%08x"",
          cpm.msg.uri.b - cpm.msg.uri.a, inbuf.p + cpm.msg.uri.a, got, crc);
    return false;
  }
}

static void *Deflate(const void *data, size_t size, size_t *out_size) {
  void *res;
  z_stream zs = {0};
  LockInc(&shared->c.deflates);
  CHECK_EQ(Z_OK, deflateInit2(&zs, 4, Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL,
                              Z_DEFAULT_STRATEGY));
  zs.next_in = data;
  zs.avail_in = size;
  zs.avail_out = compressBound(size);
  zs.next_out = res = xmalloc(zs.avail_out);
  CHECK_EQ(Z_STREAM_END, deflate(&zs, Z_FINISH));
  CHECK_EQ(Z_OK, deflateEnd(&zs));
  *out_size = zs.total_out;
  return xrealloc(res, zs.total_out);
}

static void *LoadAsset(struct Asset *a, size_t *out_size) {
  size_t size;
  uint8_t *data;
  if (S_ISDIR(GetMode(a))) {
    WARNF(""(srvr) can't load directory"");
    return NULL;
  }
  if (!a->file) {
    size = GetZipLfileUncompressedSize(zmap + a->lf);
    if (size == SIZE_MAX || !(data = malloc(size + 1))) return NULL;
    if (IsCompressed(a)) {
      if (!Inflate(data, size, ZIP_LFILE_CONTENT(zmap + a->lf),
                   GetZipCfileCompressedSize(zmap + a->cf))) {
        free(data);
        return NULL;
      }
    } else {
      memcpy(data, ZIP_LFILE_CONTENT(zmap + a->lf), size);
    }
    if (!Verify(data, size, ZIP_LFILE_CRC32(zmap + a->lf))) {
      free(data);
      return NULL;
    }
    data[size] = '\0';
    if (out_size) *out_size = size;
    return data;
  } else {
    LockInc(&shared->c.slurps);
    return xslurp(a->file->path.s, out_size);
  }
}

static wontreturn void PrintUsage(int fd, int rc) {
  size_t n;
  const char *p;
  struct Asset *a;
  if (!(a = GetAssetZip(""/help.txt"", 9)) || !(p = LoadAsset(a, &n))) {
    fprintf(stderr, ""error: /help.txt is not a zip asset\n"");
    exit(1);
  }
  if (IsTiny()) {
    write(fd, p, strlen(p));
  } else {
    __paginate(fd, p);
  }
  exit(rc);
}

static void AppendLogo(void) {
  size_t n;
  char *p, *q;
  struct Asset *a;
  if ((a = GetAsset(""/redbean.png"", 12)) && (p = LoadAsset(a, &n))) {
    if ((q = EncodeBase64(p, n, &n))) {
      appends(&cpm.outbuf, ""<img alt=\""[logo]\"" src=\""data:image/png;base64,"");
      appendd(&cpm.outbuf, q, n);
      appends(&cpm.outbuf, ""\"">\r\n"");
      free(q);
    }
    free(p);
  }
}

static ssize_t Send(struct iovec *iov, int iovlen) {
  ssize_t rc;
  if ((rc = writer(client, iov, iovlen)) == -1) {
    if (errno == ECONNRESET) {
      LockInc(&shared->c.writeresets);
      DEBUGF(""(rsp) %s write reset"", DescribeClient());
    } else if (errno == EAGAIN) {
      LockInc(&shared->c.writetimeouts);
      WARNF(""(rsp) %s write timeout"", DescribeClient());
      errno = 0;
    } else {
      LockInc(&shared->c.writeerrors);
      if (errno == EBADF) {  // don't warn on close/bad fd
        DEBUGF(""(rsp) %s write badf"", DescribeClient());
      } else {
        WARNF(""(rsp) %s write error: %m"", DescribeClient());
      }
    }
    connectionclose = true;
  }
  return rc;
}

static bool IsSslCompressed(void) {
  return usingssl && ssl.session->compression;
}

static char *CommitOutput(char *p) {
  uint32_t crc;
  size_t outbuflen;
  if (!cpm.contentlength) {
    outbuflen = appendz(cpm.outbuf).i;
    if (cpm.istext && !cpm.isyielding && outbuflen >= 100) {
      if (!IsTiny() && !IsSslCompressed()) {
        p = stpcpy(p, ""Vary: Accept-Encoding\r\n"");
      }
      if (!IsTiny() &&            //
          !IsSslCompressed() &&   //
          ClientAcceptsGzip() &&  //
          !ShouldAvoidGzip()) {
        cpm.gzipped = outbuflen;
        crc = crc32_z(0, cpm.outbuf, outbuflen);
        WRITE32LE(gzip_footer + 0, crc);
        WRITE32LE(gzip_footer + 4, outbuflen);
        cpm.content =
            FreeLater(Deflate(cpm.outbuf, outbuflen, &cpm.contentlength));
        DropOutput();
      } else {
        UseOutput();
      }
    } else {
      UseOutput();
    }
  } else {
    DropOutput();
  }
  return p;
}

static char *ServeDefaultErrorPage(char *p, unsigned code, const char *reason,
                                   const char *details) {
  p = AppendContentType(p, ""text/html; charset=ISO-8859-1"");
  reason = FreeLater(EscapeHtml(reason, -1, 0));
  appends(&cpm.outbuf, ""\
<!doctype html>\r\n\
<title>"");
  appendf(&cpm.outbuf, ""%d %s"", code, reason);
  appends(&cpm.outbuf, ""\
</title>\r\n\
<style>\r\n\
html { color: #111; font-family: sans-serif; }\r\n\
img { vertical-align: middle; }\r\n\
</style>\r\n\
<h1>\r\n"");
  AppendLogo();
  appendf(&cpm.outbuf, ""%d %s\r\n"", code, reason);
  appends(&cpm.outbuf, ""</h1>\r\n"");
  if (details) {
    appendf(&cpm.outbuf, ""<pre>%s</pre>\r\n"",
            FreeLater(EscapeHtml(details, -1, 0)));
  }
  UseOutput();
  return p;
}

static char *ServeErrorImplDefault(unsigned code, const char *reason,
                                   const char *details) {
  size_t n;
  char *p, *s;
  struct Asset *a;
  LockInc(&shared->c.errors);
  DropOutput();
  p = SetStatus(code, reason);
  s = xasprintf(""/%d.html"", code);
  a = GetAsset(s, strlen(s));
  free(s);
  if (!a) {
    return ServeDefaultErrorPage(p, code, reason, details);
  } else if (a->file) {
    LockInc(&shared->c.slurps);
    cpm.content = FreeLater(xslurp(a->file->path.s, &cpm.contentlength));
    return AppendContentType(p, ""text/html; charset=utf-8"");
  } else {
    cpm.content = (char *)ZIP_LFILE_CONTENT(zmap + a->lf);
    cpm.contentlength = GetZipCfileCompressedSize(zmap + a->cf);
    if (IsCompressed(a)) {
      n = GetZipLfileUncompressedSize(zmap + a->lf);
      if ((s = FreeLater(malloc(n))) &&
          Inflate(s, n, cpm.content, cpm.contentlength)) {
        cpm.content = s;
        cpm.contentlength = n;
      } else {
        return ServeDefaultErrorPage(p, code, reason, details);
      }
    }
    if (Verify(cpm.content, cpm.contentlength, ZIP_LFILE_CRC32(zmap + a->lf))) {
      return AppendContentType(p, ""text/html; charset=utf-8"");
    } else {
      return ServeDefaultErrorPage(p, code, reason, details);
    }
  }
}

static char *GetLuaResponse(void) {
  return cpm.luaheaderp ? cpm.luaheaderp : SetStatus(200, ""OK"");
}

static char *ServeErrorImpl(unsigned code, const char *reason,
                            const char *details) {
  lua_State *L = GL;
  if (hasonerror) {
    lua_getglobal(L, ""OnError"");
    lua_pushinteger(L, code);
    lua_pushstring(L, reason);
    if (LuaCallWithTrace(L, 2, 0, NULL) == LUA_OK) {
      return CommitOutput(GetLuaResponse());
    } else {
      return ServeErrorImplDefault(code, reason, details);
    }
  } else {
    return ServeErrorImplDefault(code, reason, details);
  }
}

static char *ServeErrorWithPath(unsigned code, const char *reason,
                                const char *path, size_t pathlen) {
  ERRORF(""(srvr) server error: %d %s %`'.*s"", code, reason, pathlen, path);
  return ServeErrorImpl(code, reason, NULL);
}

static char *ServeErrorWithDetail(unsigned code, const char *reason,
                                  const char *details) {
  ERRORF(""(srvr) server error: %d %s"", code, reason);
  return ServeErrorImpl(code, reason, details);
}

static char *ServeError(unsigned code, const char *reason) {
  return ServeErrorWithDetail(code, reason, NULL);
}

static char *ServeFailure(unsigned code, const char *reason) {
  char method[9] = {0};
  WRITE64LE(method, cpm.msg.method);
  ERRORF(""(srvr) failure: %d %s %s HTTP%02d %s %`'.*s %`'.*s %`'.*s %`'.*s"",
         code, reason, DescribeClient(), cpm.msg.version, method,
         HeaderLength(kHttpHost), HeaderData(kHttpHost),
         cpm.msg.uri.b - cpm.msg.uri.a, inbuf.p + cpm.msg.uri.a,
         HeaderLength(kHttpReferer), HeaderData(kHttpReferer),
         HeaderLength(kHttpUserAgent), HeaderData(kHttpUserAgent));
  return ServeErrorImpl(code, reason, NULL);
}

static ssize_t YieldGenerator(struct iovec v[3]) {
  int nresults, status;
  if (cpm.isyielding > 1) {
    do {
      if (!YL || lua_status(YL) != LUA_YIELD) return 0;  // done yielding
      cpm.contentlength = 0;
      status = lua_resume(YL, NULL, 0, &nresults);
      if (status != LUA_OK && status != LUA_YIELD) {
        LogLuaError(""resume"", lua_tostring(YL, -1));
        lua_pop(YL, 1);
        return -1;
      }
      lua_pop(YL, nresults);
      if (!cpm.contentlength) UseOutput();
      // continue yielding if nothing to return to keep generator running
    } while (!cpm.contentlength);
  }
  DEBUGF(""(lua) yielded with %ld bytes generated"", cpm.contentlength);
  cpm.isyielding++;
  v[0].iov_base = cpm.content;
  v[0].iov_len = cpm.contentlength;
  return cpm.contentlength;
}

static void OnLuaServerPageCtrlc(int i) {
  lua_sigint(GL, i);
}

static int LuaCallWithYield(lua_State *L) {
  int status;
  // since yield may happen in OnHttpRequest and in ServeLua,
  // need to fully restart the yield generator;
  // the second set of headers is not going to be sent
  struct sigaction sa, saold;
  lua_State *co = lua_newthread(L);
  if (__ttyconf.replmode) {
    sa.sa_flags = SA_RESETHAND;
    sa.sa_handler = OnLuaServerPageCtrlc;
    sigemptyset(&sa.sa_mask);
    sigaction(SIGINT, &sa, &saold);
  }
  status = LuaCallWithTrace(L, 0, 0, co);
  if (__ttyconf.replmode) {
    sigaction(SIGINT, &saold, 0);
  }
  if (status == LUA_YIELD) {
    CHECK_GT(lua_gettop(L), 0);  // make sure that coroutine is anchored
    YL = co;
    cpm.generator = YieldGenerator;
    if (!cpm.isyielding) cpm.isyielding = 1;
    status = LUA_OK;
  }
  return status;
}

static ssize_t DeflateGenerator(struct iovec v[3]) {
  int i, rc;
  size_t no;
  i = 0;
  if (!dg.t) {
    v[0].iov_base = (void *)kGzipHeader;
    v[0].iov_len = sizeof(kGzipHeader);
    ++dg.t;
    ++i;
  } else if (dg.t == 3) {
    return 0;
  }
  if (dg.t != 2) {
    CHECK_EQ(0, dg.s.avail_in);
    dg.s.next_in = (void *)(cpm.content + dg.i);
    dg.s.avail_in = MIN(dg.z, cpm.contentlength - dg.i);
    dg.c = crc32_z(dg.c, dg.s.next_in, dg.s.avail_in);
    dg.i += dg.s.avail_in;
  }
  dg.s.next_out = dg.b;
  dg.s.avail_out = dg.z;
  no = dg.s.avail_in;
  rc = deflate(&dg.s, dg.i < cpm.contentlength ? Z_SYNC_FLUSH : Z_FINISH);
  if (rc != Z_OK && rc != Z_STREAM_END) {
    DIEF(""(zip) deflate()→%d oldin:%,zu/%,zu in:%,zu/%,zu out:%,zu/%,zu"", rc,
         no, dg.z, dg.s.avail_in, dg.z, dg.s.avail_out, dg.z);
  } else {
    NOISEF(""(zip) deflate()→%d oldin:%,zu/%,zu in:%,zu/%,zu out:%,zu/%,zu"", rc,
           no, dg.z, dg.s.avail_in, dg.z, dg.s.avail_out, dg.z);
  }
  no = dg.z - dg.s.avail_out;
  if (no) {
    v[i].iov_base = dg.b;
    v[i].iov_len = no;
    ++i;
  }
  if (rc == Z_OK) {
    CHECK_GT(no, 0);
    if (dg.s.avail_out) {
      dg.t = 1;
    } else {
      dg.t = 2;
    }
  } else if (rc == Z_STREAM_END) {
    CHECK_EQ(cpm.contentlength, dg.i);
    CHECK_EQ(Z_OK, deflateEnd(&dg.s));
    WRITE32LE(gzip_footer + 0, dg.c);
    WRITE32LE(gzip_footer + 4, cpm.contentlength);
    v[i].iov_base = gzip_footer;
    v[i].iov_len = sizeof(gzip_footer);
    dg.t = 3;
  }
  return v[0].iov_len + v[1].iov_len + v[2].iov_len;
}

static char *ServeAssetCompressed(struct Asset *a) {
  char *p;
  LockInc(&shared->c.deflates);
  LockInc(&shared->c.compressedresponses);
  DEBUGF(""(srvr) ServeAssetCompressed()"");
  dg.t = 0;
  dg.i = 0;
  dg.c = 0;
  if (usingssl) {
    dg.z = 512 + (_rand64() & 1023);
  } else {
    dg.z = 65536;
  }
  cpm.gzipped = -1;  // signal generator usage with the exact size unknown
  cpm.generator = DeflateGenerator;
  bzero(&dg.s, sizeof(dg.s));
  CHECK_EQ(Z_OK, deflateInit2(&dg.s, 4, Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL,
                              Z_DEFAULT_STRATEGY));
  dg.b = FreeLater(malloc(dg.z));
  p = SetStatus(200, ""OK"");
  p = stpcpy(p, ""Content-Encoding: gzip\r\n"");
  return p;
}

static ssize_t InflateGenerator(struct iovec v[3]) {
  int i, rc;
  size_t no;
  i = 0;
  if (!dg.t) {
    ++dg.t;
  } else if (dg.t == 3) {
    return 0;
  }
  if (dg.t != 2) {
    CHECK_EQ(0, dg.s.avail_in);
    dg.s.next_in = (void *)(cpm.content + dg.i);
    dg.s.avail_in = MIN(dg.z, cpm.contentlength - dg.i);
    dg.i += dg.s.avail_in;
  }
  dg.s.next_out = dg.b;
  dg.s.avail_out = dg.z;
  rc = inflate(&dg.s, Z_NO_FLUSH);
  if (rc != Z_OK && rc != Z_STREAM_END) DIEF(""(zip) inflate()→%d"", rc);
  no = dg.z - dg.s.avail_out;
  if (no) {
    v[i].iov_base = dg.b;
    v[i].iov_len = no;
    dg.c = crc32_z(dg.c, dg.b, no);
    ++i;
  }
  if (rc == Z_OK) {
    CHECK_GT(no, 0);
    dg.t = dg.s.avail_out ? 1 : 2;
  } else if (rc == Z_STREAM_END) {
    CHECK_EQ(Z_OK, inflateEnd(&dg.s));
    CHECK_EQ(ZIP_CFILE_CRC32(zmap + dg.a->cf), dg.c);
    dg.t = 3;
  }
  return v[0].iov_len + v[1].iov_len + v[2].iov_len;
}

static char *ServeAssetDecompressed(struct Asset *a) {
  char *p;
  size_t size;
  LockInc(&shared->c.inflates);
  LockInc(&shared->c.decompressedresponses);
  size = GetZipCfileUncompressedSize(zmap + a->cf);
  DEBUGF(""(srvr) ServeAssetDecompressed(%ld)→%ld"", cpm.contentlength, size);
  if (cpm.msg.method == kHttpHead) {
    cpm.content = 0;
    cpm.contentlength = size;
    return SetStatus(200, ""OK"");
  } else if (!IsTiny()) {
    dg.t = 0;
    dg.i = 0;
    dg.c = 0;
    dg.a = a;
    dg.z = 65536;
    CHECK_EQ(Z_OK, inflateInit2(&dg.s, -MAX_WBITS));
    cpm.generator = InflateGenerator;
    dg.b = FreeLater(malloc(dg.z));
    return SetStatus(200, ""OK"");
  } else if ((p = FreeLater(malloc(size))) &&
             Inflate(p, size, cpm.content, cpm.contentlength) &&
             Verify(p, size, ZIP_CFILE_CRC32(zmap + a->cf))) {
    cpm.content = p;
    cpm.contentlength = size;
    return SetStatus(200, ""OK"");
  } else {
    return ServeError(500, ""Internal Server Error"");
  }
}

static inline char *ServeAssetIdentity(struct Asset *a, const char *ct) {
  LockInc(&shared->c.identityresponses);
  DEBUGF(""(srvr) ServeAssetIdentity(%`'s)"", ct);
  return SetStatus(200, ""OK"");
}

static inline char *ServeAssetPrecompressed(struct Asset *a) {
  size_t size;
  uint32_t crc;
  DEBUGF(""(srvr) ServeAssetPrecompressed()"");
  LockInc(&shared->c.precompressedresponses);
  crc = ZIP_CFILE_CRC32(zmap + a->cf);
  size = GetZipCfileUncompressedSize(zmap + a->cf);
  cpm.gzipped = size;
  WRITE32LE(gzip_footer + 0, crc);
  WRITE32LE(gzip_footer + 4, size);
  return SetStatus(200, ""OK"");
}

static char *ServeAssetRange(struct Asset *a) {
  char *p;
  long rangestart, rangelength;
  DEBUGF(""(srvr) ServeAssetRange()"");
  if (ParseHttpRange(HeaderData(kHttpRange), HeaderLength(kHttpRange),
                     cpm.contentlength, &rangestart, &rangelength) &&
      rangestart >= 0 && rangelength >= 0 && rangestart < cpm.contentlength &&
      rangestart + rangelength <= cpm.contentlength) {
    LockInc(&shared->c.partialresponses);
    p = SetStatus(206, ""Partial Content"");
    p = AppendContentRange(p, rangestart, rangelength, cpm.contentlength);
    cpm.content += rangestart;
    cpm.contentlength = rangelength;
    return p;
  } else {
    LockInc(&shared->c.badranges);
    WARNF(""(client) bad range %`'.*s"", HeaderLength(kHttpRange),
          HeaderData(kHttpRange));
    p = SetStatus(416, ""Range Not Satisfiable"");
    p = AppendContentRange(p, -1, -1, cpm.contentlength);
    cpm.content = """";
    cpm.contentlength = 0;
    return p;
  }
}

static char *GetAssetPath(uint8_t *zcf, size_t *out_size) {
  char *p2;
  size_t n1, n2;
  const char *p1;
  p1 = ZIP_CFILE_NAME(zcf);
  n1 = ZIP_CFILE_NAMESIZE(zcf);
  n2 = 1 + n1 + 1;
  p2 = xmalloc(n2);
  p2[0] = '/';
  memcpy(p2 + 1, p1, n1);
  p2[1 + n1] = '\0';
  if (out_size) *out_size = 1 + n1;
  return p2;
}

static bool IsHiddenPath(const char *s, size_t n) {
  size_t i;
  for (i = 0; i < hidepaths.n; ++i) {
    if (n >= hidepaths.p[i].n &&
        !memcmp(s, hidepaths.p[i].s, hidepaths.p[i].n)) {
      return true;
    }
  }
  return false;
}

static char *GetBasicAuthorization(size_t *z) {
  size_t n;
  const char *p, *q;
  struct HttpSlice *g;
  g = cpm.msg.headers + (HasHeader(kHttpProxyAuthorization)
                             ? kHttpProxyAuthorization
                             : kHttpAuthorization);
  p = inbuf.p + g->a;
  n = g->b - g->a;
  if ((q = memchr(p, ' ', n)) && SlicesEqualCase(p, q - p, ""Basic"", 5)) {
    return DecodeBase64(q + 1, n - (q + 1 - p), z);
  } else {
    return NULL;
  }
}

static const char *GetSystemUrlLauncherCommand(void) {
  if (IsWindows()) {
    return ""explorer.exe"";
  } else if (IsXnu()) {
    return ""open"";
  } else {
    return ""xdg-open"";
  }
}

static void LaunchBrowser(const char *path) {
  uint16_t port = 80;
  struct in_addr addr;
  path = firstnonnull(path, ""/"");
  // use the first server address if there is at least one server
  if (servers.n) {
    addr = servers.p[0].addr.sin_addr;
    port = ntohs(servers.p[0].addr.sin_port);
  }
  // assign a loopback address if no server or unknown server address
  if (!servers.n || !addr.s_addr) addr.s_addr = htonl(INADDR_LOOPBACK);
  if (*path != '/') path = gc(xasprintf(""/%s"", path));
  launch_browser(gc(xasprintf(""http://%s:%d%s"", inet_ntoa(addr), port, path)));
}

static char *BadMethod(void) {
  LockInc(&shared->c.badmethods);
  return stpcpy(ServeError(405, ""Method Not Allowed""), ""Allow: GET, HEAD\r\n"");
}

static int GetDecimalWidth(long x) {
  return LengthInt64Thousands(x);
}

static int GetOctalWidth(int x) {
  return !x ? 1 : x < 8 ? 2 : 1 + bsr(x) / 3;
}

static const char *DescribeCompressionRatio(char rb[8], uint8_t *zcf) {
  long percent;
  if (ZIP_CFILE_COMPRESSIONMETHOD(zcf) == kZipCompressionNone) {
    return ""n/a"";
  } else {
    percent = lround(100 - (double)GetZipCfileCompressedSize(zcf) /
                               GetZipCfileUncompressedSize(zcf) * 100);
    sprintf(rb, ""%ld%%"", MIN(999, MAX(-999, percent)));
    return rb;
  }
}

static char *ServeListing(void) {
  long x;
  ldiv_t y;
  int w[3];
  uint8_t *zcf;
  struct tm tm;
  char *p, *path;
  const char *and;
  struct timespec lastmod;
  size_t n, pathlen, rn[6];
  char rb[8], tb[20], *rp[6];
  LockInc(&shared->c.listingrequests);
  if (cpm.msg.method != kHttpGet && cpm.msg.method != kHttpHead)
    return BadMethod();
  appends(&cpm.outbuf, ""\
<!doctype html>\r\n\
<meta charset=\""utf-8\"">\r\n\
<title>redbean zip listing</title>\r\n\
<style>\r\n\
html { color: #111; font-family: sans-serif; }\r\n\
a { text-decoration: none; }\r\n\
pre a:hover { color: #00e; border-bottom: 1px solid #ccc; }\r\n\
h1 a { color: #111; }\r\n\
img { vertical-align: middle; }\r\n\
footer { color: #555; font-size: 10pt; }\r\n\
td { padding-right: 3em; }\r\n\
.eocdcomment { max-width: 800px; color: #333; font-size: 11pt; }\r\n\
</style>\r\n\
<header><h1>\r\n"");
  AppendLogo();
  rp[0] = EscapeHtml(brand, -1, &rn[0]);
  appendd(&cpm.outbuf, rp[0], rn[0]);
  free(rp[0]);
  appendf(&cpm.outbuf,
          ""</h1>\r\n""
          ""<div class=\""eocdcomment\"">%.*s</div>\r\n""
          ""<hr>\r\n""
          ""</header>\r\n""
          ""<pre>\r\n"",
          strnlen(GetZipCdirComment(zcdir), GetZipCdirCommentSize(zcdir)),
          GetZipCdirComment(zcdir));
  bzero(w, sizeof(w));
  n = GetZipCdirRecords(zcdir);
  for (zcf = zmap + GetZipCdirOffset(zcdir); n--;
       zcf += ZIP_CFILE_HDRSIZE(zcf)) {
    CHECK_EQ(kZipCfileHdrMagic, ZIP_CFILE_MAGIC(zcf));
    path = GetAssetPath(zcf, &pathlen);
    if (!IsHiddenPath(path, pathlen)) {
      w[0] = min(80, max(w[0], strwidth(path, 0) + 2));
      w[1] = max(w[1], GetOctalWidth(GetZipCfileMode(zcf)));
      w[2] = max(w[2], GetDecimalWidth(GetZipCfileUncompressedSize(zcf)));
    }
    free(path);
  }
  n = GetZipCdirRecords(zcdir);
  for (zcf = zmap + GetZipCdirOffset(zcdir); n--;
       zcf += ZIP_CFILE_HDRSIZE(zcf)) {
    CHECK_EQ(kZipCfileHdrMagic, ZIP_CFILE_MAGIC(zcf));
    path = GetAssetPath(zcf, &pathlen);
    if (!IsHiddenPath(path, pathlen)) {
      rp[0] = VisualizeControlCodes(path, pathlen, &rn[0]);
      rp[1] = EscapePath(path, pathlen, &rn[1]);
      rp[2] = EscapeHtml(rp[1], rn[1], &rn[2]);
      rp[3] = VisualizeControlCodes(
          ZIP_CFILE_COMMENT(zcf),
          strnlen(ZIP_CFILE_COMMENT(zcf), ZIP_CFILE_COMMENTSIZE(zcf)), &rn[3]);
      rp[4] = EscapeHtml(rp[0], rn[0], &rn[4]);
      GetZipCfileTimestamps(zcf, &lastmod, 0, 0, gmtoff);
      localtime_r(&lastmod.tv_sec, &tm);
      iso8601(tb, &tm);
      if (IsCompressionMethodSupported(ZIP_CFILE_COMPRESSIONMETHOD(zcf)) &&
          IsAcceptablePath(path, pathlen)) {
        appendf(&cpm.outbuf,
                ""<a href=\""%.*s\"">%-*.*s</a> %s  %0*o %4s  %,*ld  %'s\r\n"",
                rn[2], rp[2], w[0], rn[4], rp[4], tb, w[1],
                GetZipCfileMode(zcf), DescribeCompressionRatio(rb, zcf), w[2],
                GetZipCfileUncompressedSize(zcf), rp[3]);
      } else {
        appendf(&cpm.outbuf, ""%-*.*s %s  %0*o %4s  %,*ld  %'s\r\n"", w[0], rn[4],
                rp[4], tb, w[1], GetZipCfileMode(zcf),
                DescribeCompressionRatio(rb, zcf), w[2],
                GetZipCfileUncompressedSize(zcf), rp[3]);
      }
      free(rp[4]);
      free(rp[3]);
      free(rp[2]);
      free(rp[1]);
      free(rp[0]);
    }
    free(path);
  }
  appends(&cpm.outbuf, ""\
</pre><footer><hr>\r\n\
<table border=\""0\""><tr>\r\n\
<td valign=\""top\"">\r\n\
<a href=\""/statusz\"">/statusz</a>\r\n\
"");
  if (shared->c.connectionshandled) {
    appends(&cpm.outbuf, ""says your redbean<br>\r\n"");
    AppendResourceReport(&cpm.outbuf, &shared->children, ""<br>\r\n"");
  }
  appends(&cpm.outbuf, ""<td valign=\""top\"">\r\n"");
  and = """";
  x = timespec_sub(timespec_real(), startserver).tv_sec;
  y = ldiv(x, 24L * 60 * 60);
  if (y.quot) {
    appendf(&cpm.outbuf, ""%,ld day%s "", y.quot, y.quot == 1 ? """" : ""s"");
    and = ""and "";
  }
  y = ldiv(y.rem, 60 * 60);
  if (y.quot) {
    appendf(&cpm.outbuf, ""%,ld hour%s "", y.quot, y.quot == 1 ? """" : ""s"");
    and = ""and "";
  }
  y = ldiv(y.rem, 60);
  if (y.quot) {
    appendf(&cpm.outbuf, ""%,ld minute%s "", y.quot, y.quot == 1 ? """" : ""s"");
    and = ""and "";
  }
  appendf(&cpm.outbuf, ""%s%,ld second%s of operation<br>\r\n"", and, y.rem,
          y.rem == 1 ? """" : ""s"");
  x = shared->c.messageshandled;
  appendf(&cpm.outbuf, ""%,ld message%s handled<br>\r\n"", x, x == 1 ? """" : ""s"");
  x = shared->c.connectionshandled;
  appendf(&cpm.outbuf, ""%,ld connection%s handled<br>\r\n"", x,
          x == 1 ? """" : ""s"");
  x = shared->workers;
  appendf(&cpm.outbuf, ""%,ld connection%s active<br>\r\n"", x,
          x == 1 ? """" : ""s"");
  appends(&cpm.outbuf, ""</table>\r\n"");
  appends(&cpm.outbuf, ""</footer>\r\n"");
  p = SetStatus(200, ""OK"");
  p = AppendContentType(p, ""text/html"");
  if (cpm.msg.version >= 11) {
    p = stpcpy(p, ""Cache-Control: no-store\r\n"");
  }
  return CommitOutput(p);
}

static const char *MergeNames(const char *a, const char *b) {
  return FreeLater(xasprintf(""%s.%s"", a, b));
}

static void AppendLong1(const char *a, long x) {
  if (x) appendf(&cpm.outbuf, ""%s: %ld\r\n"", a, x);
}

static void AppendLong2(const char *a, const char *b, long x) {
  if (x) appendf(&cpm.outbuf, ""%s.%s: %ld\r\n"", a, b, x);
}

static void AppendTimeval(const char *a, struct timeval *tv) {
  AppendLong2(a, ""tv_sec"", tv->tv_sec);
  AppendLong2(a, ""tv_usec"", tv->tv_usec);
}

static void AppendRusage(const char *a, struct rusage *ru) {
  AppendTimeval(MergeNames(a, ""ru_utime""), &ru->ru_utime);
  AppendTimeval(MergeNames(a, ""ru_stime""), &ru->ru_stime);
  AppendLong2(a, ""ru_maxrss"", ru->ru_maxrss);
  AppendLong2(a, ""ru_ixrss"", ru->ru_ixrss);
  AppendLong2(a, ""ru_idrss"", ru->ru_idrss);
  AppendLong2(a, ""ru_isrss"", ru->ru_isrss);
  AppendLong2(a, ""ru_minflt"", ru->ru_minflt);
  AppendLong2(a, ""ru_majflt"", ru->ru_majflt);
  AppendLong2(a, ""ru_nswap"", ru->ru_nswap);
  AppendLong2(a, ""ru_inblock"", ru->ru_inblock);
  AppendLong2(a, ""ru_oublock"", ru->ru_oublock);
  AppendLong2(a, ""ru_msgsnd"", ru->ru_msgsnd);
  AppendLong2(a, ""ru_msgrcv"", ru->ru_msgrcv);
  AppendLong2(a, ""ru_nsignals"", ru->ru_nsignals);
  AppendLong2(a, ""ru_nvcsw"", ru->ru_nvcsw);
  AppendLong2(a, ""ru_nivcsw"", ru->ru_nivcsw);
}

static void ServeCounters(void) {
  const long *c;
  const char *s;
  for (c = (const long *)&shared->c, s = kCounterNames; *s;
       ++c, s += strlen(s) + 1) {
    AppendLong1(s, *c);
  }
}

static char *ServeStatusz(void) {
  char *p;
  LockInc(&shared->c.statuszrequests);
  if (cpm.msg.method != kHttpGet && cpm.msg.method != kHttpHead) {
    return BadMethod();
  }
  AppendLong1(""pid"", getpid());
  AppendLong1(""ppid"", getppid());
  AppendLong1(""now"", timespec_real().tv_sec);
  AppendLong1(""nowish"", shared->nowish.tv_sec);
  AppendLong1(""gmtoff"", gmtoff);
  AppendLong1(""CLK_TCK"", CLK_TCK);
  AppendLong1(""startserver"", startserver.tv_sec);
  AppendLong1(""lastmeltdown"", shared->lastmeltdown.tv_sec);
  AppendLong1(""workers"", shared->workers);
  AppendLong1(""assets.n"", assets.n);
#ifndef STATIC
  lua_State *L = GL;
  AppendLong1(""lua.memory"",
              lua_gc(L, LUA_GCCOUNT) * 1024 + lua_gc(L, LUA_GCCOUNTB));
#endif
  ServeCounters();
  AppendRusage(""server"", &shared->server);
  AppendRusage(""children"", &shared->children);
  p = SetStatus(200, ""OK"");
  p = AppendContentType(p, ""text/plain"");
  if (cpm.msg.version >= 11) {
    p = stpcpy(p, ""Cache-Control: no-store\r\n"");
  }
  return CommitOutput(p);
}

static char *RedirectSlash(void) {
  size_t n, i;
  char *p, *e;
  LockInc(&shared->c.redirects);
  p = SetStatus(307, ""Temporary Redirect"");
  p = stpcpy(p, ""Location: "");
  e = EscapePath(url.path.p, url.path.n, &n);
  p = mempcpy(p, e, n);
  p = stpcpy(p, ""/"");

  for (i = 0; i < url.params.n; ++i) {
    p = stpcpy(p, i == 0 ? ""?"" : ""&"");
    p = mempcpy(p, url.params.p[i].key.p, url.params.p[i].key.n);
    if (url.params.p[i].val.p) {
      p = stpcpy(p, ""="");
      p = mempcpy(p, url.params.p[i].val.p, url.params.p[i].val.n);
    }
  }

  p = stpcpy(p, ""\r\n"");
  free(e);
  return p;
}

static char *ServeIndex(const char *path, size_t pathlen) {
  size_t i, n;
  char *p, *q;
  for (p = 0, i = 0; !p && i < ARRAYLEN(kIndexPaths); ++i) {
    q = MergePaths(path, pathlen, kIndexPaths[i], strlen(kIndexPaths[i]), &n);
    p = RoutePath(q, n);
    free(q);
  }
  return p;
}

static bool ShouldServeCrashReportDetails(void) {
  uint32_t ip;
  uint16_t port;
  if (leakcrashreports) {
    return true;
  } else {
    return !GetRemoteAddr(&ip, &port) && (IsLoopbackIp(ip) || IsPrivateIp(ip));
  }
}

static char *LuaOnHttpRequest(void) {
  char *error;
  lua_State *L = GL;
  effectivepath.p = url.path.p;
  effectivepath.n = url.path.n;
  lua_settop(L, 0);  // clear Lua stack, as it needs to start fresh
  lua_getglobal(L, ""OnHttpRequest"");
  if (LuaCallWithYield(L) == LUA_OK) {
    return CommitOutput(GetLuaResponse());
  } else {
    LogLuaError(""OnHttpRequest"", lua_tostring(L, -1));
    error = ServeErrorWithDetail(
        500, ""Internal Server Error"",
        ShouldServeCrashReportDetails() ? lua_tostring(L, -1) : NULL);
    lua_pop(L, 1);  // pop error
    return error;
  }
}

static char *ServeLua(struct Asset *a, const char *s, size_t n) {
  char *code;
  size_t codelen;
  lua_State *L = GL;
  LockInc(&shared->c.dynamicrequests);
  effectivepath.p = (void *)s;
  effectivepath.n = n;
  if ((code = FreeLater(LoadAsset(a, &codelen)))) {
    int status =
        luaL_loadbuffer(L, code, codelen,
                        FreeLater(xasprintf(""@%s"", FreeLater(strndup(s, n)))));
    if (status == LUA_OK && LuaCallWithYield(L) == LUA_OK) {
      return CommitOutput(GetLuaResponse());
    } else {
      char *error;
      LogLuaError(""lua code"", lua_tostring(L, -1));
      error = ServeErrorWithDetail(
          500, ""Internal Server Error"",
          ShouldServeCrashReportDetails() ? lua_tostring(L, -1) : NULL);
      lua_pop(L, 1);  // pop error
      return error;
    }
  }
  return ServeError(500, ""Internal Server Error"");
}

static char *HandleRedirect(struct Redirect *r) {
  int code;
  struct Asset *a;
  if (!r->code && (a = GetAsset(r->location.s, r->location.n))) {
    LockInc(&shared->c.rewrites);
    DEBUGF(""(rsp) internal redirect to %`'s"", r->location.s);
    if (!HasString(&cpm.loops, r->location.s, r->location.n)) {
      AddString(&cpm.loops, r->location.s, r->location.n);
      return RoutePath(r->location.s, r->location.n);
    } else {
      LockInc(&shared->c.loops);
      return SetStatus(508, ""Loop Detected"");
    }
  } else if (cpm.msg.version < 10) {
    return ServeError(505, ""HTTP Version Not Supported"");
  } else {
    LockInc(&shared->c.redirects);
    code = r->code;
    if (!code) code = 307;
    DEBUGF(""(rsp) %d redirect to %`'s"", code, r->location.s);
    return AppendHeader(
        SetStatus(code, GetHttpReason(code)), ""Location"",
        FreeLater(EncodeHttpHeaderValue(r->location.s, r->location.n, 0)));
  }
}

static char *HandleFolder(const char *path, size_t pathlen) {
  char *p;
  if (url.path.n && url.path.p[url.path.n - 1] != '/' &&
      SlicesEqual(path, pathlen, url.path.p, url.path.n)) {
    return RedirectSlash();
  }
  if ((p = ServeIndex(path, pathlen))) {
    return p;
  } else {
    LockInc(&shared->c.forbiddens);
    WARNF(""(srvr) directory %`'.*s lacks index page"", pathlen, path);
    return ServeErrorWithPath(403, ""Forbidden"", path, pathlen);
  }
}

static bool Reindex(void) {
  if (OpenZip(false)) {
    LockInc(&shared->c.reindexes);
    return true;
  } else {
    return false;
  }
}

static const char *LuaCheckPath(lua_State *L, int idx, size_t *pathlen) {
  const char *path;
  if (lua_isnoneornil(L, idx)) {
    path = url.path.p;
    *pathlen = url.path.n;
  } else {
    path = luaL_checklstring(L, idx, pathlen);
    if (!IsReasonablePath(path, *pathlen)) {
      WARNF(""(srvr) bad path %`'.*s"", *pathlen, path);
      luaL_argerror(L, idx, ""bad path"");
      __builtin_unreachable();
    }
  }
  return path;
}

static const char *LuaCheckHost(lua_State *L, int idx, size_t *hostlen) {
  const char *host;
  if (lua_isnoneornil(L, idx)) {
    host = url.host.p;
    *hostlen = url.host.n;
  } else {
    host = luaL_checklstring(L, idx, hostlen);
    if (!IsAcceptableHost(host, *hostlen)) {
      WARNF(""(srvr) bad host %`'.*s"", *hostlen, host);
      luaL_argerror(L, idx, ""bad host"");
      __builtin_unreachable();
    }
  }
  return host;
}

static void OnlyCallFromInitLua(lua_State *L, const char *api) {
  if (isinitialized) {
    luaL_error(L, ""%s() should be called %s"", api,
               ""from the global scope of .init.lua"");
    __builtin_unreachable();
  }
}

static void OnlyCallFromMainProcess(lua_State *L, const char *api) {
  if (__isworker) {
    luaL_error(L, ""%s() should be called %s"", api,
               ""from .init.lua or the repl"");
    __builtin_unreachable();
  }
}

static void OnlyCallDuringConnection(lua_State *L, const char *api) {
  if (!ishandlingconnection) {
    luaL_error(L, ""%s() can only be called %s"", api,
               ""while handling a connection"");
    __builtin_unreachable();
  }
}

static void OnlyCallDuringRequest(lua_State *L, const char *api) {
  if (!ishandlingrequest) {
    luaL_error(L, ""%s() can only be called %s"", api,
               ""while handling a request"");
    __builtin_unreachable();
  }
}

static int LuaServe(lua_State *L, const char *api, char *impl(void)) {
  OnlyCallDuringRequest(L, api);
  cpm.luaheaderp = impl();
  return 0;
}

static int LuaServeListing(lua_State *L) {
  return LuaServe(L, ""ServeListing"", ServeListing);
}

static int LuaServeStatusz(lua_State *L) {
  return LuaServe(L, ""ServeStatusz"", ServeStatusz);
}

static int LuaServeAsset(lua_State *L) {
  size_t pathlen;
  struct Asset *a;
  const char *path;
  OnlyCallDuringRequest(L, ""ServeAsset"");
  path = LuaCheckPath(L, 1, &pathlen);
  if ((a = GetAsset(path, pathlen)) && !S_ISDIR(GetMode(a))) {
    cpm.luaheaderp = ServeAsset(a, path, pathlen);
    lua_pushboolean(L, true);
  } else {
    lua_pushboolean(L, false);
  }
  return 1;
}

static int LuaServeIndex(lua_State *L) {
  size_t pathlen;
  const char *path;
  OnlyCallDuringRequest(L, ""ServeIndex"");
  path = LuaCheckPath(L, 1, &pathlen);
  lua_pushboolean(L, !!(cpm.luaheaderp = ServeIndex(path, pathlen)));
  return 1;
}

static int LuaServeRedirect(lua_State *L) {
  int code;
  char *eval;
  size_t loclen;
  const char *location;
  OnlyCallDuringRequest(L, ""ServeRedirect"");

  code = luaL_checkinteger(L, 1);
  if (!(300 <= code && code <= 399)) {
    luaL_argerror(L, 1, ""bad status code"");
    __builtin_unreachable();
  }
  location = luaL_checklstring(L, 2, &loclen);
  if (cpm.msg.version < 10) {
    (void)ServeError(505, ""HTTP Version Not Supported"");
    lua_pushboolean(L, false);
  } else {
    if (!(eval = EncodeHttpHeaderValue(location, loclen, 0))) {
      luaL_argerror(L, 2, ""invalid location"");
      __builtin_unreachable();
    }
    VERBOSEF(""(rsp) %d redirect to %`'s"", code, location);
    cpm.luaheaderp =
        AppendHeader(SetStatus(code, GetHttpReason(code)), ""Location"", eval);
    free(eval);
    lua_pushboolean(L, true);
  }
  return 1;
}

static int LuaRoutePath(lua_State *L) {
  size_t pathlen;
  const char *path;
  OnlyCallDuringRequest(L, ""RoutePath"");
  path = LuaCheckPath(L, 1, &pathlen);
  lua_pushboolean(L, !!(cpm.luaheaderp = RoutePath(path, pathlen)));
  return 1;
}

static int LuaRouteHost(lua_State *L) {
  size_t hostlen, pathlen;
  const char *host, *path;
  OnlyCallDuringRequest(L, ""RouteHost"");
  host = LuaCheckHost(L, 1, &hostlen);
  path = LuaCheckPath(L, 2, &pathlen);
  lua_pushboolean(L,
                  !!(cpm.luaheaderp = RouteHost(host, hostlen, path, pathlen)));
  return 1;
}

static int LuaRoute(lua_State *L) {
  size_t hostlen, pathlen;
  const char *host, *path;
  OnlyCallDuringRequest(L, ""Route"");
  host = LuaCheckHost(L, 1, &hostlen);
  path = LuaCheckPath(L, 2, &pathlen);
  lua_pushboolean(L, !!(cpm.luaheaderp = Route(host, hostlen, path, pathlen)));
  return 1;
}

static int LuaProgramTrustedIp(lua_State *L) {
  lua_Integer ip, cidr;
  uint32_t ip32, imask;
  ip = luaL_checkinteger(L, 1);
  cidr = luaL_optinteger(L, 2, 32);
  if (!(0 <= ip && ip <= 0xffffffff)) {
    luaL_argerror(L, 1, ""ip out of range"");
    __builtin_unreachable();
  }
  if (!(0 <= cidr && cidr <= 32)) {
    luaL_argerror(L, 2, ""cidr should be 0 .. 32"");
    __builtin_unreachable();
  }
  ip32 = ip;
  imask = ~(0xffffffffu << (32 - cidr));
  if (ip32 & imask) {
    luaL_argerror(L, 1,
                  ""ip address isn't the network address; ""
                  ""it has bits masked by the cidr"");
    __builtin_unreachable();
  }
  ProgramTrustedIp(ip, cidr);
  return 0;
}

static int LuaIsTrusted(lua_State *L) {
  lua_Integer ip;
  ip = luaL_checkinteger(L, 1);
  if (!(0 <= ip && ip <= 0xffffffff)) {
    luaL_argerror(L, 1, ""ip out of range"");
    __builtin_unreachable();
  }
  lua_pushboolean(L, IsTrustedIp(ip));
  return 1;
}

static int LuaRespond(lua_State *L, char *R(unsigned, const char *)) {
  char *p;
  int code;
  size_t reasonlen;
  const char *reason;
  OnlyCallDuringRequest(L, ""Respond"");
  code = luaL_checkinteger(L, 1);
  if (!(100 <= code && code <= 999)) {
    luaL_argerror(L, 1, ""bad status code"");
    __builtin_unreachable();
  }
  if (lua_isnoneornil(L, 2)) {
    cpm.luaheaderp = R(code, GetHttpReason(code));
  } else {
    reason = lua_tolstring(L, 2, &reasonlen);
    if ((p = EncodeHttpHeaderValue(reason, MIN(reasonlen, 128), 0))) {
      cpm.luaheaderp = R(code, p);
      free(p);
    } else {
      luaL_argerror(L, 2, ""invalid"");
      __builtin_unreachable();
    }
  }
  return 0;
}

static int LuaSetStatus(lua_State *L) {
  return LuaRespond(L, SetStatus);
}

static int LuaGetStatus(lua_State *L) {
  OnlyCallDuringRequest(L, ""GetStatus"");
  if (!cpm.statuscode) {
    lua_pushnil(L);
  } else {
    lua_pushinteger(L, cpm.statuscode);
  }
  return 1;
}

static int LuaGetSslIdentity(lua_State *L) {
  const mbedtls_x509_crt *cert;
  OnlyCallDuringRequest(L, ""GetSslIdentity"");
  if (!usingssl) {
    lua_pushnil(L);
  } else {
    if (sslpskindex) {
      CHECK((sslpskindex - 1) >= 0 && (sslpskindex - 1) < psks.n);
      lua_pushlstring(L, psks.p[sslpskindex - 1].identity,
                      psks.p[sslpskindex - 1].identity_len);
    } else {
      cert = mbedtls_ssl_get_peer_cert(&ssl);
      lua_pushstring(L, cert ? gc(FormatX509Name(&cert->subject)) : """");
    }
  }
  return 1;
}

static int LuaServeError(lua_State *L) {
  return LuaRespond(L, ServeError);
}

static int LuaLoadAsset(lua_State *L) {
  void *data;
  struct Asset *a;
  const char *path;
  size_t size, pathlen;
  path = LuaCheckPath(L, 1, &pathlen);
  if ((a = GetAsset(path, pathlen))) {
    if (!a->file && !IsCompressed(a)) {
      /* fast path: this avoids extra copy */
      data = ZIP_LFILE_CONTENT(zmap + a->lf);
      size = GetZipLfileUncompressedSize(zmap + a->lf);
      if (Verify(data, size, ZIP_LFILE_CRC32(zmap + a->lf))) {
        lua_pushlstring(L, data, size);
        return 1;
      }
      // any error from Verify has already been reported
    } else if ((data = LoadAsset(a, &size))) {
      lua_pushlstring(L, data, size);
      free(data);
      return 1;
    } else {
      WARNF(""(srvr) could not load asset: %`'.*s"", pathlen, path);
    }
  } else {
    WARNF(""(srvr) could not find asset: %`'.*s"", pathlen, path);
  }
  return 0;
}

static void GetDosLocalTime(int64_t utcunixts, uint16_t *out_time,
                            uint16_t *out_date) {
  struct tm tm;
  CHECK_NOTNULL(localtime_r(&utcunixts, &tm));
  *out_time = DOS_TIME(tm.tm_hour, tm.tm_min, tm.tm_sec);
  *out_date = DOS_DATE(tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday + 1);
}

static void StoreAsset(const char *path, size_t pathlen, const char *data,
                       size_t datalen, int mode) {
  int64_t ft;
  uint32_t crc;
  char *comp, *p;
  struct timespec now;
  struct Asset *a;
  struct iovec v[13];
  uint8_t era;
  const char *use;
  uint16_t gflags, iattrs, mtime, mdate, dosmode, method, disk;
  size_t oldcdirsize, oldcdiroffset, records, cdiroffset, cdirsize, complen,
      uselen;
  if (IsOpenbsd() || IsNetbsd() || IsWindows()) {
    FATALF(""(cfg) StoreAsset() not available on Windows/NetBSD/OpenBSD yet"");
  }
  INFOF(""(srvr) storing asset %`'s"", path);
  disk = gflags = iattrs = 0;
  if (isutf8(path, pathlen)) gflags |= kZipGflagUtf8;
  if (istext(data, datalen)) iattrs |= kZipIattrText;
  crc = crc32_z(0, data, datalen);
  if (datalen < 100) {
    method = kZipCompressionNone;
    comp = 0;
    use = data;
    uselen = datalen;
    era = kZipEra1989;
  } else {
    comp = Deflate(data, datalen, &complen);
    if (complen < datalen) {
      method = kZipCompressionDeflate;
      use = comp;
      uselen = complen;
      era = kZipEra1993;
    } else {
      method = kZipCompressionNone;
      use = data;
      uselen = datalen;
      era = kZipEra1989;
    }
  }
  //////////////////////////////////////////////////////////////////////////////
  if (-1 == fcntl(zfd, F_SETLKW, &(struct flock){F_WRLCK})) {
    WARNF(""(srvr) can't place write lock on file descriptor %d: %s"", zfd,
          strerror(errno));
    return;
  }
  OpenZip(false);
  now = timespec_real();
  a = GetAssetZip(path, pathlen);
  if (!mode) mode = a ? GetMode(a) : 0644;
  if (!(mode & S_IFMT)) mode |= S_IFREG;
  if (pathlen > 1 && path[0] == '/') ++path, --pathlen;
  dosmode = !(mode & 0200) ? kNtFileAttributeReadonly : 0;
  ft = (now.tv_sec + MODERNITYSECONDS) * HECTONANOSECONDS;
  GetDosLocalTime(now.tv_sec, &mtime, &mdate);
  // local file header
  if (uselen >= 0xffffffff || datalen >= 0xffffffff) {
    era = kZipEra2001;
    v[2].iov_base = p = alloca((v[2].iov_len = 2 + 2 + 8 + 8));
    p = WRITE16LE(p, kZipExtraZip64);
    p = WRITE16LE(p, 8 + 8);
    p = WRITE64LE(p, uselen);
    p = WRITE64LE(p, datalen);
  } else {
    v[2].iov_len = 0;
    v[2].iov_base = 0;
  }
  v[0].iov_base = p = alloca((v[0].iov_len = kZipLfileHdrMinSize));
  p = WRITE32LE(p, kZipLfileHdrMagic);
  *p++ = era;
  *p++ = kZipOsDos;
  p = WRITE16LE(p, gflags);
  p = WRITE16LE(p, method);
  p = WRITE16LE(p, mtime);
  p = WRITE16LE(p, mdate);
  p = WRITE32LE(p, crc);
  p = WRITE32LE(p, 0xffffffffu);
  p = WRITE32LE(p, 0xffffffffu);
  p = WRITE16LE(p, pathlen);
  p = WRITE16LE(p, v[2].iov_len);
  v[1].iov_len = pathlen;
  v[1].iov_base = (void *)path;
  // file data
  v[3].iov_len = uselen;
  v[3].iov_base = (void *)use;
  // old central directory entries
  oldcdirsize = GetZipCdirSize(zcdir);
  oldcdiroffset = GetZipCdirOffset(zcdir);
  if (a) {
    // to remove an existing asset,
    // first copy the central directory part before its record
    v[4].iov_base = zmap + oldcdiroffset;
    v[4].iov_len = a->cf - oldcdiroffset;
    // and then the rest of the central directory
    v[5].iov_base =
        zmap + oldcdiroffset + (v[4].iov_len + ZIP_CFILE_HDRSIZE(zmap + a->cf));
    v[5].iov_len =
        oldcdirsize - (v[4].iov_len + ZIP_CFILE_HDRSIZE(zmap + a->cf));
  } else {
    v[4].iov_base = zmap + oldcdiroffset;
    v[4].iov_len = oldcdirsize;
    v[5].iov_base = 0;
    v[5].iov_len = 0;
  }
  // new central directory entry
  if (uselen >= 0xffffffff || datalen >= 0xffffffff || zsize >= 0xffffffff) {
    v[8].iov_base = p = alloca((v[8].iov_len = 2 + 2 + 8 + 8 + 8));
    p = WRITE16LE(p, kZipExtraZip64);
    p = WRITE16LE(p, 8 + 8 + 8);
    p = WRITE64LE(p, uselen);
    p = WRITE64LE(p, datalen);
    p = WRITE64LE(p, zsize);
  } else {
    v[8].iov_len = 0;
    v[8].iov_base = 0;
  }
  v[9].iov_base = p = alloca((v[9].iov_len = 2 + 2 + 4 + 2 + 2 + 8 + 8 + 8));
  p = WRITE16LE(p, kZipExtraNtfs);
  p = WRITE16LE(p, 4 + 2 + 2 + 8 + 8 + 8);
  p = WRITE32LE(p, 0);
  p = WRITE16LE(p, 1);
  p = WRITE16LE(p, 8 + 8 + 8);
  p = WRITE64LE(p, ft);
  p = WRITE64LE(p, ft);
  p = WRITE64LE(p, ft);
  v[6].iov_base = p = alloca((v[6].iov_len = kZipCfileHdrMinSize));
  p = WRITE32LE(p, kZipCfileHdrMagic);
  *p++ = kZipCosmopolitanVersion;
  *p++ = kZipOsUnix;
  *p++ = era;
  *p++ = kZipOsDos;
  p = WRITE16LE(p, gflags);
  p = WRITE16LE(p, method);
  p = WRITE16LE(p, mtime);
  p = WRITE16LE(p, mdate);
  p = WRITE32LE(p, crc);
  p = WRITE32LE(p, 0xffffffffu);
  p = WRITE32LE(p, 0xffffffffu);
  p = WRITE16LE(p, pathlen);
  p = WRITE16LE(p, v[8].iov_len + v[9].iov_len);
  p = WRITE16LE(p, 0);
  p = WRITE16LE(p, disk);
  p = WRITE16LE(p, iattrs);
  p = WRITE16LE(p, dosmode);
  p = WRITE16LE(p, mode);
  p = WRITE32LE(p, 0xffffffffu);
  v[7].iov_len = pathlen;
  v[7].iov_base = (void *)path;
  // zip64 end of central directory
  cdiroffset =
      zsize + v[0].iov_len + v[1].iov_len + v[2].iov_len + v[3].iov_len;
  cdirsize = v[4].iov_len + v[5].iov_len + v[6].iov_len + v[7].iov_len +
             v[8].iov_len + v[9].iov_len;
  records = GetZipCdirRecords(zcdir) + !a;
  if (records >= 0xffff || cdiroffset >= 0xffffffff || cdirsize >= 0xffffffff) {
    v[10].iov_base = p =
        alloca((v[10].iov_len = kZipCdir64HdrMinSize + kZipCdir64LocatorSize));
    p = WRITE32LE(p, kZipCdir64HdrMagic);
    p = WRITE64LE(p, 2 + 2 + 4 + 4 + 8 + 8 + 8 + 8);
    p = WRITE16LE(p, kZipCosmopolitanVersion);
    p = WRITE16LE(p, kZipEra2001);
    p = WRITE32LE(p, disk);
    p = WRITE32LE(p, disk);
    p = WRITE64LE(p, records);
    p = WRITE64LE(p, records);
    p = WRITE64LE(p, cdirsize);
    p = WRITE64LE(p, cdiroffset);
    p = WRITE32LE(p, kZipCdir64LocatorMagic);
    p = WRITE32LE(p, disk);
    p = WRITE64LE(p, cdiroffset + cdirsize);
    p = WRITE32LE(p, disk);
  } else {
    v[10].iov_len = 0;
    v[10].iov_base = 0;
  }
  // end of central directory
  v[12].iov_base = (void *)GetZipCdirComment(zcdir);
  v[12].iov_len = GetZipCdirCommentSize(zcdir);
  v[11].iov_base = p = alloca((v[11].iov_len = kZipCdirHdrMinSize));
  p = WRITE32LE(p, kZipCdirHdrMagic);
  p = WRITE16LE(p, disk);
  p = WRITE16LE(p, disk);
  p = WRITE16LE(p, MIN(records, 0xffff));
  p = WRITE16LE(p, MIN(records, 0xffff));
  p = WRITE32LE(p, MIN(cdirsize, 0xffffffff));
  p = WRITE32LE(p, MIN(cdiroffset, 0xffffffff));
  p = WRITE16LE(p, v[12].iov_len);
  CHECK_NE(-1, lseek(zfd, zmap + zsize - zmap, SEEK_SET));
  CHECK_NE(-1, WritevAll(zfd, v, 13));
  CHECK_NE(-1, fcntl(zfd, F_SETLK, &(struct flock){F_UNLCK}));
  //////////////////////////////////////////////////////////////////////////////
  OpenZip(false);
  free(comp);
}

static void StoreFile(const char *path) {
  char *p;
  struct stat st;
  size_t plen, tlen;
  const char *target = path;
  if (startswith(target, ""./"")) target += 2;
  tlen = strlen(target);
  if (!IsReasonablePath(target, tlen))
    FATALF(""(cfg) error: can't store %`'s: contains '.' or '..' segments"",
           target);
  if (lstat(path, &st) == -1) FATALF(""(cfg) error: can't stat %`'s: %m"", path);
  if (!(p = xslurp(path, &plen)))
    FATALF(""(cfg) error: can't read %`'s: %m"", path);
  StoreAsset(target, tlen, p, plen, st.st_mode & 0777);
  free(p);
}

static void StorePath(const char *dirpath) {
  DIR *d;
  char *path;
  struct dirent *e;
  if (!isdirectory(dirpath) && !endswith(dirpath, ""/"")) {
    return StoreFile(dirpath);
  }
  if (!(d = opendir(dirpath))) FATALF(""(cfg) error: can't open %`'s"", dirpath);
  while ((e = readdir(d))) {
    if (strcmp(e->d_name, ""."") == 0) continue;
    if (strcmp(e->d_name, "".."") == 0) continue;
    path = gc(xjoinpaths(dirpath, e->d_name));
    if (e->d_type == DT_DIR) {
      StorePath(path);
    } else {
      StoreFile(path);
    }
  }
  closedir(d);
}

static int LuaStoreAsset(lua_State *L) {
  const char *path, *data;
  size_t pathlen, datalen;
  int mode;
  path = LuaCheckPath(L, 1, &pathlen);
  if (pathlen > 0xffff) {
    return luaL_argerror(L, 1, ""path too long"");
  }
  data = luaL_checklstring(L, 2, &datalen);
  mode = luaL_optinteger(L, 3, 0);
  StoreAsset(path, pathlen, data, datalen, mode);
  return 0;
}

static void ReseedRng(mbedtls_ctr_drbg_context *r, const char *s) {
#ifndef UNSECURE
  if (unsecure) return;
  CHECK_EQ(0, mbedtls_ctr_drbg_reseed(r, (void *)s, strlen(s)));
#endif
}

static void LogMessage(const char *d, const char *s, size_t n) {
  size_t n2, n3;
  char *s2, *s3;
  if (!LOGGABLE(kLogInfo)) return;
  while (n && (s[n - 1] == '\r' || s[n - 1] == '\n')) --n;
  if ((s2 = DecodeLatin1(s, n, &n2))) {
    if ((s3 = IndentLines(s2, n2, &n3, 1))) {
      INFOF(""(stat) %s %,ld byte message\r\n%.*s"", d, n, n3, s3);
      free(s3);
    }
    free(s2);
  }
}

static void LogBody(const char *d, const char *s, size_t n) {
  char *s2, *s3;
  size_t n2, n3;
  if (!n) return;
  if (!LOGGABLE(kLogInfo)) return;
  while (n && (s[n - 1] == '\r' || s[n - 1] == '\n')) --n;
  if ((s2 = VisualizeControlCodes(s, n, &n2))) {
    if ((s3 = IndentLines(s2, n2, &n3, 1))) {
      INFOF(""(stat) %s %,ld byte payload\r\n%.*s"", d, n, n3, s3);
      free(s3);
    }
    free(s2);
  }
}

static int LuaNilError(lua_State *L, const char *fmt, ...) {
  va_list argp;
  va_start(argp, fmt);
  lua_pushnil(L);
  lua_pushvfstring(L, fmt, argp);
  va_end(argp);
  return 2;
}

static int LuaNilTlsError(lua_State *L, const char *s, int r) {
  return LuaNilError(L, ""tls %s failed (%s %s)"", s,
                     IsTiny() ? ""grep"" : GetTlsError(r),
                     gc(xasprintf(""-0x%04x"", -r)));
}

#include ""tool/net/fetch.inc""

static int LuaGetDate(lua_State *L) {
  lua_pushinteger(L, shared->nowish.tv_sec);
  return 1;
}

static int LuaGetHttpVersion(lua_State *L) {
  OnlyCallDuringRequest(L, ""GetHttpVersion"");
  lua_pushinteger(L, cpm.msg.version);
  return 1;
}

static int LuaGetRedbeanVersion(lua_State *L) {
  lua_pushinteger(L, VERSION);
  return 1;
}

static int LuaGetMethod(lua_State *L) {
  OnlyCallDuringRequest(L, ""GetMethod"");
  char method[9] = {0};
  WRITE64LE(method, cpm.msg.method);
  lua_pushstring(L, method);
  return 1;
}

static int LuaGetAddr(lua_State *L, int GetAddr(uint32_t *, uint16_t *)) {
  uint32_t ip;
  uint16_t port;
  if (!GetAddr(&ip, &port)) {
    lua_pushinteger(L, ip);
    lua_pushinteger(L, port);
    return 2;
  } else {
    lua_pushnil(L);
    return 1;
  }
}

static int LuaGetServerAddr(lua_State *L) {
  OnlyCallDuringConnection(L, ""GetServerAddr"");
  return LuaGetAddr(L, GetServerAddr);
}

static int LuaGetClientAddr(lua_State *L) {
  OnlyCallDuringConnection(L, ""GetClientAddr"");
  return LuaGetAddr(L, GetClientAddr);
}

static int LuaGetRemoteAddr(lua_State *L) {
  OnlyCallDuringRequest(L, ""GetRemoteAddr"");
  return LuaGetAddr(L, GetRemoteAddr);
}

static int LuaLog(lua_State *L) {
  int level, line;
  lua_Debug ar;
  const char *msg, *module;
  level = luaL_checkinteger(L, 1);
  if (LOGGABLE(level)) {
    msg = luaL_checkstring(L, 2);
    if (lua_getstack(L, 1, &ar) && lua_getinfo(L, ""Sl"", &ar)) {
      module = ar.short_src;
      line = ar.currentline;
    } else {
      module = gc(strndup(effectivepath.p, effectivepath.n));
      line = -1;
    }
    flogf(level, module, line, NULL, ""%s"", msg);
  }
  return 0;
}

static int LuaEncodeSmth(lua_State *L, int Encoder(lua_State *, char **, int,
                                                   struct EncoderConfig)) {
  char *p = 0;
  int useoutput = false;
  struct EncoderConfig conf = {
      .maxdepth = 64,
      .sorted = true,
      .pretty = false,
      .indent = ""  "",
  };
  if (lua_istable(L, 2)) {
    lua_settop(L, 2);  // discard any extra arguments
    lua_getfield(L, 2, ""useoutput"");
    // ignore useoutput outside of request handling
    if (ishandlingrequest && lua_isboolean(L, -1)) {
      useoutput = lua_toboolean(L, -1);
    }
    lua_getfield(L, 2, ""maxdepth"");
    if (!lua_isnoneornil(L, -1)) {
      lua_Integer n = lua_tointeger(L, -1);
      n = MAX(0, MIN(n, SHRT_MAX));
      conf.maxdepth = n;
    }
    lua_getfield(L, 2, ""sorted"");
    if (!lua_isnoneornil(L, -1)) {
      conf.sorted = lua_toboolean(L, -1);
    }
    lua_getfield(L, 2, ""pretty"");
    if (!lua_isnoneornil(L, -1)) {
      conf.pretty = lua_toboolean(L, -1);
      lua_getfield(L, 2, ""indent"");
      if (!lua_isnoneornil(L, -1)) {
        conf.indent = luaL_checkstring(L, -1);
      }
    }
  }
  lua_settop(L, 1);  // keep the passed argument on top
  if (Encoder(L, useoutput ? &cpm.outbuf : &p, -1, conf) == -1) {
    free(p);
    return 2;
  }
  if (useoutput) {
    lua_pushboolean(L, true);
  } else {
    lua_pushstring(L, p);
    free(p);
  }
  return 1;
}

static int LuaEncodeJson(lua_State *L) {
  return LuaEncodeSmth(L, LuaEncodeJsonData);
}

static int LuaEncodeLua(lua_State *L) {
  return LuaEncodeSmth(L, LuaEncodeLuaData);
}

static int LuaDecodeJson(lua_State *L) {
  size_t n;
  const char *p;
  struct DecodeJson r;
  p = luaL_checklstring(L, 1, &n);
  r = DecodeJson(L, p, n);
  if (UNLIKELY(!r.rc)) {
    lua_pushnil(L);
    lua_pushstring(L, ""unexpected eof"");
    return 2;
  }
  if (UNLIKELY(r.rc == -1)) {
    lua_pushnil(L);
    lua_pushstring(L, r.p);
    return 2;
  }
  r = DecodeJson(L, r.p, n - (r.p - p));
  if (UNLIKELY(r.rc)) {
    lua_pushnil(L);
    lua_pushstring(L, ""junk after expression"");
    return 2;
  }
  return 1;
}

static int LuaGetUrl(lua_State *L) {
  char *p;
  size_t n;
  OnlyCallDuringRequest(L, ""GetUrl"");
  p = EncodeUrl(&url, &n);
  lua_pushlstring(L, p, n);
  free(p);
  return 1;
}

static int LuaGetScheme(lua_State *L) {
  OnlyCallDuringRequest(L, ""GetScheme"");
  LuaPushUrlView(L, &url.scheme);
  return 1;
}

static int LuaGetPath(lua_State *L) {
  OnlyCallDuringRequest(L, ""GetPath"");
  LuaPushUrlView(L, &url.path);
  return 1;
}

static int LuaGetEffectivePath(lua_State *L) {
  OnlyCallDuringRequest(L, ""GetEffectivePath"");
  lua_pushlstring(L, effectivepath.p, effectivepath.n);
  return 1;
}

static int LuaGetFragment(lua_State *L) {
  OnlyCallDuringRequest(L, ""GetFragment"");
  LuaPushUrlView(L, &url.fragment);
  return 1;
}

static int LuaGetUser(lua_State *L) {
  size_t n;
  const char *p, *q;
  OnlyCallDuringRequest(L, ""GetUser"");
  if (url.user.p) {
    LuaPushUrlView(L, &url.user);
  } else if ((p = gc(GetBasicAuthorization(&n)))) {
    if (!(q = memchr(p, ':', n))) q = p + n;
    lua_pushlstring(L, p, q - p);
  } else {
    lua_pushnil(L);
  }
  return 1;
}

static int LuaGetPass(lua_State *L) {
  size_t n;
  const char *p, *q;
  OnlyCallDuringRequest(L, ""GetPass"");
  if (url.user.p) {
    LuaPushUrlView(L, &url.pass);
  } else if ((p = gc(GetBasicAuthorization(&n)))) {
    if ((q = memchr(p, ':', n))) {
      lua_pushlstring(L, q + 1, p + n - (q + 1));
    } else {
      lua_pushnil(L);
    }
  } else {
    lua_pushnil(L);
  }
  return 1;
}

static int LuaGetHost(lua_State *L) {
  char b[16];
  OnlyCallDuringRequest(L, ""GetHost"");
  if (url.host.n) {
    lua_pushlstring(L, url.host.p, url.host.n);
  } else {
    inet_ntop(AF_INET, &serveraddr->sin_addr.s_addr, b, sizeof(b));
    lua_pushstring(L, b);
  }
  return 1;
}

static int LuaGetPort(lua_State *L) {
  int i, x = 0;
  OnlyCallDuringRequest(L, ""GetPort"");
  for (i = 0; i < url.port.n; ++i) x = url.port.p[i] - '0' + x * 10;
  if (!x) x = ntohs(serveraddr->sin_port);
  lua_pushinteger(L, x);
  return 1;
}

static int LuaGetBody(lua_State *L) {
  OnlyCallDuringRequest(L, ""GetBody"");
  lua_pushlstring(L, inbuf.p + hdrsize, payloadlength);
  return 1;
}

static int LuaGetResponseBody(lua_State *L) {
  char *s = """";
  // response can be gzipped (>0), text (=0), or generator (<0)
  int size = cpm.gzipped > 0    ? cpm.gzipped  // original size
             : cpm.gzipped == 0 ? cpm.contentlength
                                : 0;
  OnlyCallDuringRequest(L, ""GetResponseBody"");
  if (cpm.gzipped > 0 &&
      (!(s = FreeLater(malloc(cpm.gzipped))) ||
       !Inflate(s, cpm.gzipped, cpm.content, cpm.contentlength))) {
    return LuaNilError(L, ""failed to decompress response"");
  }
  lua_pushlstring(L,
                  cpm.gzipped > 0    ? s  // return decompressed
                  : cpm.gzipped == 0 ? cpm.content
                                     : """",
                  size);
  return 1;
}

static int LuaGetHeader(lua_State *L) {
  int h;
  const char *key;
  size_t i, keylen;
  OnlyCallDuringRequest(L, ""GetHeader"");
  key = luaL_checklstring(L, 1, &keylen);
  if ((h = GetHttpHeader(key, keylen)) != -1) {
    if (cpm.msg.headers[h].a) {
      return LuaPushHeader(L, &cpm.msg, inbuf.p, h);
    }
  } else {
    for (i = 0; i < cpm.msg.xheaders.n; ++i) {
      if (SlicesEqualCase(
              key, keylen, inbuf.p + cpm.msg.xheaders.p[i].k.a,
              cpm.msg.xheaders.p[i].k.b - cpm.msg.xheaders.p[i].k.a)) {
        LuaPushLatin1(L, inbuf.p + cpm.msg.xheaders.p[i].v.a,
                      cpm.msg.xheaders.p[i].v.b - cpm.msg.xheaders.p[i].v.a);
        return 1;
      }
    }
  }
  lua_pushnil(L);
  return 1;
}

static int LuaGetHeaders(lua_State *L) {
  OnlyCallDuringRequest(L, ""GetHeaders"");
  return LuaPushHeaders(L, &cpm.msg, inbuf.p);
}

static int LuaSetHeader(lua_State *L) {
  int h;
  char *eval;
  char *p, *q;
  const char *key, *val;
  size_t keylen, vallen, evallen;
  OnlyCallDuringRequest(L, ""SetHeader"");
  key = luaL_checklstring(L, 1, &keylen);
  val = luaL_optlstring(L, 2, 0, &vallen);
  if (!val) return 0;
  if ((h = GetHttpHeader(key, keylen)) == -1) {
    if (!IsValidHttpToken(key, keylen)) {
      luaL_argerror(L, 1, ""invalid"");
      __builtin_unreachable();
    }
  }
  if (!(eval = EncodeHttpHeaderValue(val, vallen, &evallen))) {
    luaL_argerror(L, 2, ""invalid"");
    __builtin_unreachable();
  }
  p = GetLuaResponse();
  while (p - hdrbuf.p + keylen + 2 + evallen + 2 + 512 > hdrbuf.n) {
    hdrbuf.n += hdrbuf.n >> 1;
    q = xrealloc(hdrbuf.p, hdrbuf.n);
    cpm.luaheaderp = p = q + (p - hdrbuf.p);
    hdrbuf.p = q;
  }
  switch (h) {
    case kHttpConnection:
      connectionclose = SlicesEqualCase(eval, evallen, ""close"", 5);
      break;
    case kHttpContentType:
      p = AppendContentType(p, eval);
      break;
    case kHttpReferrerPolicy:
      cpm.referrerpolicy = FreeLater(strdup(eval));
      break;
    case kHttpServer:
      cpm.branded = true;
      p = AppendHeader(p, ""Server"", eval);
      break;
    case kHttpExpires:
    case kHttpCacheControl:
      cpm.gotcachecontrol = true;
      p = AppendHeader(p, key, eval);
      break;
    case kHttpXContentTypeOptions:
      cpm.gotxcontenttypeoptions = true;
      p = AppendHeader(p, key, eval);
      break;
    default:
      p = AppendHeader(p, key, eval);
      break;
  }
  cpm.luaheaderp = p;
  free(eval);
  return 0;
}

static int LuaGetCookie(lua_State *L) {
  char *cookie = 0, *cookietmpl, *cookieval;
  OnlyCallDuringRequest(L, ""GetCookie"");
  cookietmpl = gc(xasprintf("" %s="", luaL_checkstring(L, 1)));
  if (HasHeader(kHttpCookie)) {
    appends(&cookie, "" "");  // prepend space to simplify cookie search
    appendd(&cookie, HeaderData(kHttpCookie), HeaderLength(kHttpCookie));
  }
  if (cookie && (cookieval = strstr(cookie, cookietmpl))) {
    cookieval += strlen(cookietmpl);
    lua_pushlstring(L, cookieval, strchrnul(cookieval, ';') - cookieval);
  } else {
    lua_pushnil(L);
  }
  if (cookie) free(cookie);
  return 1;
}

static int LuaSetCookie(lua_State *L) {
  const char *key, *val;
  size_t keylen, vallen;
  char *expires, *samesite = """";
  char *buf = 0;
  bool ishostpref, issecurepref;
  const char *hostpref = ""__Host-"";
  const char *securepref = ""__Secure-"";

  OnlyCallDuringRequest(L, ""SetCookie"");
  key = luaL_checklstring(L, 1, &keylen);
  val = luaL_checklstring(L, 2, &vallen);

  if (!IsValidHttpToken(key, keylen)) {
    luaL_argerror(L, 1, ""invalid"");
    __builtin_unreachable();
  }
  if (!IsValidCookieValue(val, vallen)) {
    luaL_argerror(L, 2, ""invalid"");
    __builtin_unreachable();
  }

  ishostpref = keylen > strlen(hostpref) &&
               SlicesEqual(key, strlen(hostpref), hostpref, strlen(hostpref));
  issecurepref =
      keylen > strlen(securepref) &&
      SlicesEqual(key, strlen(securepref), securepref, strlen(securepref));
  if ((ishostpref || issecurepref) && !usingssl) {
    luaL_argerror(
        L, 1,
        gc(xasprintf(""%s and %s prefixes require SSL"", hostpref, securepref)));
    __builtin_unreachable();
  }

  appends(&buf, key);
  appends(&buf, ""="");
  appends(&buf, val);

  if (lua_istable(L, 3)) {
    if (lua_getfield(L, 3, ""expires"") != LUA_TNIL ||
        lua_getfield(L, 3, ""Expires"") != LUA_TNIL) {
      if (lua_isnumber(L, -1)) {
        expires =
            FormatUnixHttpDateTime(FreeLater(xmalloc(30)), lua_tonumber(L, -1));
      } else {
        expires = (void *)lua_tostring(L, -1);
        if (!ParseHttpDateTime(expires, -1)) {
          luaL_argerror(L, 3, ""invalid data format in Expires"");
          __builtin_unreachable();
        }
      }
      appends(&buf, ""; Expires="");
      appends(&buf, expires);
    }

    if ((lua_getfield(L, 3, ""maxage"") == LUA_TNUMBER ||
         lua_getfield(L, 3, ""MaxAge"") == LUA_TNUMBER) &&
        lua_isinteger(L, -1)) {
      appends(&buf, ""; Max-Age="");
      appends(&buf, lua_tostring(L, -1));
    }

    if (lua_getfield(L, 3, ""samesite"") == LUA_TSTRING ||
        lua_getfield(L, 3, ""SameSite"") == LUA_TSTRING) {
      samesite = (void *)lua_tostring(L, -1);  // also used in the Secure check
      appends(&buf, ""; SameSite="");
      appends(&buf, samesite);
    }

    // Secure attribute is required for __Host and __Secure prefixes
    // as well as for the SameSite=None
    if (ishostpref || issecurepref || !strcmp(samesite, ""None"") ||
        ((lua_getfield(L, 3, ""secure"") == LUA_TBOOLEAN ||
          lua_getfield(L, 3, ""Secure"") == LUA_TBOOLEAN) &&
         lua_toboolean(L, -1))) {
      appends(&buf, ""; Secure"");
    }

    if (!ishostpref && (lua_getfield(L, 3, ""domain"") == LUA_TSTRING ||
                        lua_getfield(L, 3, ""Domain"") == LUA_TSTRING)) {
      appends(&buf, ""; Domain="");
      appends(&buf, lua_tostring(L, -1));
    }

    if (ishostpref || lua_getfield(L, 3, ""path"") == LUA_TSTRING ||
        lua_getfield(L, 3, ""Path"") == LUA_TSTRING) {
      appends(&buf, ""; Path="");
      appends(&buf, ishostpref ? ""/"" : lua_tostring(L, -1));
    }

    if ((lua_getfield(L, 3, ""httponly"") == LUA_TBOOLEAN ||
         lua_getfield(L, 3, ""HttpOnly"") == LUA_TBOOLEAN) &&
        lua_toboolean(L, -1)) {
      appends(&buf, ""; HttpOnly"");
    }
  }
  DEBUGF(""(srvr) Set-Cookie: %s"", buf);

  // empty the stack and push header name/value
  lua_settop(L, 0);
  lua_pushliteral(L, ""Set-Cookie"");
  lua_pushstring(L, buf);
  free(buf);
  return LuaSetHeader(L);
}

static int LuaHasParam(lua_State *L) {
  size_t i, n;
  const char *s;
  OnlyCallDuringRequest(L, ""HasParam"");
  s = luaL_checklstring(L, 1, &n);
  for (i = 0; i < url.params.n; ++i) {
    if (SlicesEqual(s, n, url.params.p[i].key.p, url.params.p[i].key.n)) {
      lua_pushboolean(L, true);
      return 1;
    }
  }
  lua_pushboolean(L, false);
  return 1;
}

static int LuaGetParam(lua_State *L) {
  size_t i, n;
  const char *s;
  OnlyCallDuringRequest(L, ""GetParam"");
  s = luaL_checklstring(L, 1, &n);
  for (i = 0; i < url.params.n; ++i) {
    if (SlicesEqual(s, n, url.params.p[i].key.p, url.params.p[i].key.n)) {
      if (url.params.p[i].val.p) {
        lua_pushlstring(L, url.params.p[i].val.p, url.params.p[i].val.n);
        return 1;
      } else {
        break;
      }
    }
  }
  lua_pushnil(L);
  return 1;
}

static int LuaGetParams(lua_State *L) {
  OnlyCallDuringRequest(L, ""GetParams"");
  LuaPushUrlParams(L, &url.params);
  return 1;
}

static int LuaWrite(lua_State *L) {
  size_t size;
  const char *data;
  OnlyCallDuringRequest(L, ""Write"");
  if (!lua_isnil(L, 1)) {
    data = luaL_checklstring(L, 1, &size);
    appendd(&cpm.outbuf, data, size);
  }
  return 0;
}

static dontinline int LuaProgramInt(lua_State *L, void P(long)) {
  P(luaL_checkinteger(L, 1));
  return 0;
}

static int LuaProgramPort(lua_State *L) {
  OnlyCallFromInitLua(L, ""ProgramPort"");
  return LuaProgramInt(L, ProgramPort);
}

static int LuaProgramCache(lua_State *L) {
  OnlyCallFromMainProcess(L, ""ProgramCache"");
  ProgramCache(luaL_checkinteger(L, 1), luaL_optstring(L, 2, NULL));
  return 0;
}

static int LuaProgramTimeout(lua_State *L) {
  OnlyCallFromInitLua(L, ""ProgramTimeout"");
  return LuaProgramInt(L, ProgramTimeout);
}

static int LuaProgramUid(lua_State *L) {
  OnlyCallFromInitLua(L, ""ProgramUid"");
  return LuaProgramInt(L, ProgramUid);
}

static int LuaProgramGid(lua_State *L) {
  OnlyCallFromInitLua(L, ""ProgramGid"");
  return LuaProgramInt(L, ProgramGid);
}

static int LuaProgramMaxPayloadSize(lua_State *L) {
  OnlyCallFromInitLua(L, ""ProgramMaxPayloadSize"");
  return LuaProgramInt(L, ProgramMaxPayloadSize);
}

static int LuaGetClientFd(lua_State *L) {
  OnlyCallDuringConnection(L, ""GetClientFd"");
  lua_pushinteger(L, client);
  return 1;
}

static int LuaIsClientUsingSsl(lua_State *L) {
  OnlyCallDuringConnection(L, ""IsClientUsingSsl"");
  lua_pushboolean(L, usingssl);
  return 1;
}

static int LuaProgramSslTicketLifetime(lua_State *L) {
  OnlyCallFromInitLua(L, ""ProgramSslTicketLifetime"");
  return LuaProgramInt(L, ProgramSslTicketLifetime);
}

static int LuaProgramUniprocess(lua_State *L) {
  OnlyCallFromInitLua(L, ""ProgramUniprocess"");
  if (!lua_isboolean(L, 1) && !lua_isnoneornil(L, 1)) {
    return luaL_argerror(L, 1, ""invalid uniprocess mode; boolean expected"");
  }
  lua_pushboolean(L, uniprocess);
  if (lua_isboolean(L, 1)) uniprocess = lua_toboolean(L, 1);
  return 1;
}

static int LuaProgramHeartbeatInterval(lua_State *L) {
  int64_t millis;
  OnlyCallFromMainProcess(L, ""ProgramHeartbeatInterval"");
  if (!lua_isnoneornil(L, 1)) {
    millis = luaL_checkinteger(L, 1);
    millis = MAX(100, millis);
    heartbeatinterval = timespec_frommillis(millis);
  }
  lua_pushinteger(L, timespec_tomillis(heartbeatinterval));
  return 1;
}

static int LuaProgramMaxWorkers(lua_State *L) {
  OnlyCallFromMainProcess(L, ""ProgramMaxWorkers"");
  if (!lua_isinteger(L, 1) && !lua_isnoneornil(L, 1)) {
    return luaL_argerror(L, 1, ""invalid number of workers; integer expected"");
  }
  lua_pushinteger(L, maxworkers);
  if (lua_isinteger(L, 1)) maxworkers = lua_tointeger(L, 1);
  maxworkers = MAX(maxworkers, 1);
  return 1;
}

static int LuaProgramAddr(lua_State *L) {
  uint32_t ip;
  OnlyCallFromInitLua(L, ""ProgramAddr"");
  if (lua_isinteger(L, 1)) {
    ip = luaL_checkinteger(L, 1);
    ips.p = realloc(ips.p, ++ips.n * sizeof(*ips.p));
    ips.p[ips.n - 1] = ip;
  } else {
    ProgramAddr(luaL_checkstring(L, 1));
  }
  return 0;
}

static dontinline int LuaProgramString(lua_State *L, void P(const char *)) {
  P(luaL_checkstring(L, 1));
  return 0;
}

static int LuaProgramBrand(lua_State *L) {
  OnlyCallFromMainProcess(L, ""ProgramBrand"");
  return LuaProgramString(L, ProgramBrand);
}

static int LuaProgramDirectory(lua_State *L) {
  size_t i;
  // if no parameter is provided, then return current directories
  if (lua_isnoneornil(L, 1)) {
    lua_newtable(L);
    if (stagedirs.n) {
      for (i = 0; i < stagedirs.n; ++i) {
        lua_pushlstring(L, stagedirs.p[i].s, stagedirs.p[i].n);
        lua_seti(L, -2, i + 1);
      }
    }
    return 1;
  }
  struct stat st;
  const char *path = luaL_checkstring(L, 1);
  // check to raise a Lua error, to allow it to be handled
  if (stat(path, &st) == -1 || !S_ISDIR(st.st_mode)) {
    return luaL_argerror(L, 1, ""not a directory"");
  }
  return LuaProgramString(L, ProgramDirectory);
}

static int LuaProgramLogPath(lua_State *L) {
  OnlyCallFromInitLua(L, ""ProgramLogPath"");
  return LuaProgramString(L, ProgramLogPath);
}

static int LuaProgramPidPath(lua_State *L) {
  OnlyCallFromInitLua(L, ""ProgramPidPath"");
  return LuaProgramString(L, ProgramPidPath);
}

static int LuaProgramSslPresharedKey(lua_State *L) {
  struct Psk psk;
  size_t n1, n2, i;
  const char *p1, *p2;
  OnlyCallFromMainProcess(L, ""ProgramSslPresharedKey"");
  p1 = luaL_checklstring(L, 1, &n1);
  p2 = luaL_checklstring(L, 2, &n2);
  if (!n1 || n1 > MBEDTLS_PSK_MAX_LEN || !n2) {
    luaL_argerror(L, 1, ""bad preshared key length"");
    __builtin_unreachable();
  }
  psk.key = memcpy(malloc(n1), p1, n1);
  psk.key_len = n1;
  psk.identity = memcpy(malloc(n2), p2, n2);
  psk.identity_len = n2;
  for (i = 0; i < psks.n; ++i) {
    if (SlicesEqual(psk.identity, psk.identity_len, psks.p[i].identity,
                    psks.p[i].identity_len)) {
      mbedtls_platform_zeroize(psks.p[i].key, psks.p[i].key_len);
      free(psks.p[i].key);
      free(psks.p[i].identity);
      psks.p[i] = psk;
      return 0;
    }
  }
  psks.p = realloc(psks.p, ++psks.n * sizeof(*psks.p));
  psks.p[psks.n - 1] = psk;
  return 0;
}

static int LuaProgramSslCiphersuite(lua_State *L) {
  const mbedtls_ssl_ciphersuite_t *suite;
  OnlyCallFromInitLua(L, ""ProgramSslCiphersuite"");
  if (!(suite = GetCipherSuite(luaL_checkstring(L, 1)))) {
    luaL_argerror(L, 1, ""unsupported or unknown ciphersuite"");
    __builtin_unreachable();
  }
  suites.p = realloc(suites.p, (++suites.n + 1) * sizeof(*suites.p));
  suites.p[suites.n - 1] = suite->id;
  suites.p[suites.n - 0] = 0;
  return 0;
}

static int LuaProgramPrivateKey(lua_State *L) {
  size_t n;
  const char *p;
  OnlyCallFromInitLua(L, ""ProgramPrivateKey"");
  p = luaL_checklstring(L, 1, &n);
  ProgramPrivateKey(p, n);
  return 0;
}

static int LuaProgramCertificate(lua_State *L) {
  size_t n;
  const char *p;
  OnlyCallFromInitLua(L, ""ProgramCertificate"");
  p = luaL_checklstring(L, 1, &n);
  ProgramCertificate(p, n);
  return 0;
}

static int LuaProgramHeader(lua_State *L) {
  ProgramHeader(
      gc(xasprintf(""%s: %s"", luaL_checkstring(L, 1), luaL_checkstring(L, 2))));
  return 0;
}

static int LuaProgramRedirect(lua_State *L) {
  int code;
  const char *from, *to;
  code = luaL_checkinteger(L, 1);
  from = luaL_checkstring(L, 2);
  to = luaL_checkstring(L, 3);
  ProgramRedirect(code, strdup(from), strlen(from), strdup(to), strlen(to));
  return 0;
}

static dontinline int LuaProgramBool(lua_State *L, bool *b) {
  *b = lua_toboolean(L, 1);
  return 0;
}

static int LuaProgramSslClientVerify(lua_State *L) {
  OnlyCallFromInitLua(L, ""ProgramSslClientVerify"");
  return LuaProgramBool(L, &sslclientverify);
}

static int LuaProgramSslRequired(lua_State *L) {
  OnlyCallFromInitLua(L, ""ProgramSslRequired"");
  return LuaProgramBool(L, &requiressl);
}

static int LuaProgramSslFetchVerify(lua_State *L) {
  OnlyCallFromMainProcess(L, ""ProgramSslFetchVerify"");
  return LuaProgramBool(L, &sslfetchverify);
}

static int LuaProgramSslInit(lua_State *L) {
  OnlyCallFromInitLua(L, ""SslInit"");
  TlsInit();
  return 0;
}

static int LuaProgramLogMessages(lua_State *L) {
  return LuaProgramBool(L, &logmessages);
}

static int LuaProgramLogBodies(lua_State *L) {
  return LuaProgramBool(L, &logbodies);
}

static int LuaEvadeDragnetSurveillance(lua_State *L) {
  return LuaProgramBool(L, &evadedragnetsurveillance);
}

static int LuaHidePath(lua_State *L) {
  size_t pathlen;
  const char *path;
  path = luaL_checklstring(L, 1, &pathlen);
  AddString(&hidepaths, memcpy(malloc(pathlen), path, pathlen), pathlen);
  return 0;
}

static int LuaIsHiddenPath(lua_State *L) {
  size_t n;
  const char *s;
  s = luaL_checklstring(L, 1, &n);
  lua_pushboolean(L, IsHiddenPath(s, n));
  return 1;
}

static int LuaGetZipPaths(lua_State *L) {
  char *path;
  uint8_t *zcf;
  size_t i, n, pathlen, prefixlen;
  const char *prefix = luaL_optlstring(L, 1, """", &prefixlen);
  lua_newtable(L);
  i = 0;
  n = GetZipCdirRecords(zcdir);
  for (zcf = zmap + GetZipCdirOffset(zcdir); n--;
       zcf += ZIP_CFILE_HDRSIZE(zcf)) {
    CHECK_EQ(kZipCfileHdrMagic, ZIP_CFILE_MAGIC(zcf));
    path = GetAssetPath(zcf, &pathlen);
    if (prefixlen == 0 || startswith(path, prefix)) {
      lua_pushlstring(L, path, pathlen);
      lua_seti(L, -2, ++i);
    }
    free(path);
  }
  return 1;
}

static int LuaGetAssetMode(lua_State *L) {
  size_t pathlen;
  struct Asset *a;
  const char *path;
  path = LuaCheckPath(L, 1, &pathlen);
  if ((a = GetAsset(path, pathlen))) {
    lua_pushinteger(L, GetMode(a));
  } else {
    lua_pushnil(L);
  }
  return 1;
}

static int LuaGetAssetLastModifiedTime(lua_State *L) {
  size_t pathlen;
  struct Asset *a;
  const char *path;
  struct timespec lm;
  int64_t zuluseconds;
  path = LuaCheckPath(L, 1, &pathlen);
  if ((a = GetAsset(path, pathlen))) {
    if (a->file) {
      zuluseconds = a->file->st.st_mtim.tv_sec;
    } else {
      GetZipCfileTimestamps(zmap + a->cf, &lm, 0, 0, gmtoff);
      zuluseconds = lm.tv_sec;
    }
    lua_pushinteger(L, zuluseconds);
  } else {
    lua_pushnil(L);
  }
  return 1;
}

static int LuaGetAssetSize(lua_State *L) {
  size_t pathlen;
  struct Asset *a;
  const char *path;
  path = LuaCheckPath(L, 1, &pathlen);
  if ((a = GetAsset(path, pathlen))) {
    if (a->file) {
      lua_pushinteger(L, a->file->st.st_size);
    } else {
      lua_pushinteger(L, GetZipLfileUncompressedSize(zmap + a->lf));
    }
  } else {
    lua_pushnil(L);
  }
  return 1;
}

static int LuaIsAssetCompressed(lua_State *L) {
  size_t pathlen;
  struct Asset *a;
  const char *path;
  path = LuaCheckPath(L, 1, &pathlen);
  if ((a = GetAsset(path, pathlen))) {
    lua_pushboolean(L, IsCompressed(a));
  } else {
    lua_pushnil(L);
  }
  return 1;
}

static bool Blackhole(uint32_t ip) {
  char buf[4];
  if (blackhole.fd <= 0) return false;
  WRITE32BE(buf, ip);
  if (sendto(blackhole.fd, &buf, 4, 0, (struct sockaddr *)&blackhole.addr,
             sizeof(blackhole.addr)) != -1) {
    return true;
  } else {
    VERBOSEF(""(token) sendto(%s) failed: %m"", blackhole.addr.sun_path);
    errno = 0;
    return false;
  }
}

static int LuaBlackhole(lua_State *L) {
  lua_Integer ip;
  ip = luaL_checkinteger(L, 1);
  if (!(0 <= ip && ip <= 0xffffffff)) {
    luaL_argerror(L, 1, ""ip out of range"");
    __builtin_unreachable();
  }
  lua_pushboolean(L, Blackhole(ip));
  return 1;
}

static void BlockSignals(void) {
}

wontreturn static void Replenisher(void) {
  struct timespec ts;
  VERBOSEF(""(token) replenish worker started"");
  strace_enabled(-1);
  signal(SIGINT, OnTerm);
  signal(SIGHUP, OnTerm);
  signal(SIGTERM, OnTerm);
  signal(SIGUSR1, SIG_IGN);  // make sure reload won't kill this
  signal(SIGUSR2, SIG_IGN);  // make sure meltdown won't kill this
  ts = timespec_real();
  while (!terminated) {
    if (clock_nanosleep(CLOCK_REALTIME, TIMER_ABSTIME, &ts, 0)) {
      errno = 0;
      continue;
    }
    ReplenishTokens(tokenbucket.w, (1ul << tokenbucket.cidr) / 8);
    ts = timespec_add(ts, tokenbucket.replenish);
    DEBUGF(""(token) replenished tokens"");
  }
  VERBOSEF(""(token) replenish worker exiting"");
  _Exit(0);
}

static int LuaAcquireToken(lua_State *L) {
  uint32_t ip;
  if (!tokenbucket.cidr) {
    luaL_error(L, ""ProgramTokenBucket() needs to be called first"");
    __builtin_unreachable();
  }
  GetClientAddr(&ip, 0);
  lua_pushinteger(L, AcquireToken(tokenbucket.b, luaL_optinteger(L, 1, ip),
                                  tokenbucket.cidr));
  return 1;
}

static int LuaCountTokens(lua_State *L) {
  uint32_t ip;
  if (!tokenbucket.cidr) {
    luaL_error(L, ""ProgramTokenBucket() needs to be called first"");
    __builtin_unreachable();
  }
  GetClientAddr(&ip, 0);
  lua_pushinteger(L, CountTokens(tokenbucket.b, luaL_optinteger(L, 1, ip),
                                 tokenbucket.cidr));
  return 1;
}

static int LuaProgramTokenBucket(lua_State *L) {
  if (tokenbucket.cidr) {
    luaL_error(L, ""ProgramTokenBucket() can only be called once"");
    __builtin_unreachable();
  }
  lua_Number replenish = luaL_optnumber(L, 1, 1);  // per second
  lua_Integer cidr = luaL_optinteger(L, 2, 24);
  lua_Integer reject = luaL_optinteger(L, 3, 30);
  lua_Integer ignore = luaL_optinteger(L, 4, MIN(reject / 2, 15));
  lua_Integer ban = luaL_optinteger(L, 5, MIN(ignore / 10, 1));
  if (!(1 / 3600. <= replenish && replenish <= 1e6)) {
    luaL_argerror(L, 1, ""require 1/3600 <= replenish <= 1e6"");
    __builtin_unreachable();
  }
  if (!(8 <= cidr && cidr <= 32)) {
    luaL_argerror(L, 2, ""require 8 <= cidr <= 32"");
    __builtin_unreachable();
  }
  if (!(-1 <= reject && reject <= 126)) {
    luaL_argerror(L, 3, ""require -1 <= reject <= 126"");
    __builtin_unreachable();
  }
  if (!(-1 <= ignore && ignore <= 126)) {
    luaL_argerror(L, 4, ""require -1 <= ignore <= 126"");
    __builtin_unreachable();
  }
  if (!(-1 <= ban && ban <= 126)) {
    luaL_argerror(L, 5, ""require -1 <= ban <= 126"");
    __builtin_unreachable();
  }
  if (!(ignore <= reject)) {
    luaL_argerror(L, 4, ""require ignore <= reject"");
    __builtin_unreachable();
  }
  if (!(ban <= ignore)) {
    luaL_argerror(L, 5, ""require ban <= ignore"");
    __builtin_unreachable();
  }
  VERBOSEF(""(token) deploying %,ld buckets ""
           ""(one for every %ld ips) ""
           ""each holding 127 tokens which ""
           ""replenish %g times per second, ""
           ""reject at %d tokens, ""
           ""ignore at %d tokens, and ""
           ""ban at %d tokens"",
           1L << cidr,                 //
           4294967296 / (1L << cidr),  //
           replenish,                  //
           reject,                     //
           ignore,                     //
           ban);
  if (ignore == -1) ignore = -128;
  if (ban == -1) ban = -128;
  if (ban >= 0 && (IsLinux() || IsBsd())) {
    uint32_t testip = 0;
    blackhole.addr.sun_family = AF_UNIX;
    strlcpy(blackhole.addr.sun_path, ""/var/run/blackhole.sock"",
            sizeof(blackhole.addr.sun_path));
    if ((blackhole.fd = socket(AF_UNIX, SOCK_DGRAM, 0)) == -1) {
      WARNF(""(token) socket(AF_UNIX) failed: %m"");
      ban = -1;
    } else if (sendto(blackhole.fd, &testip, 4, 0,
                      (struct sockaddr *)&blackhole.addr,
                      sizeof(blackhole.addr)) == -1) {
      VERBOSEF(""(token) error: sendto(%`'s) failed: %m"",
               blackhole.addr.sun_path);
      VERBOSEF(""(token) redbean isn't able to protect your kernel from ddos"");
      VERBOSEF(""(token) please run the blackholed program; see our website!"");
    }
  }
  tokenbucket.b = _mapshared(ROUNDUP(1ul << cidr, FRAMESIZE));
  memset(tokenbucket.b, 127, 1ul << cidr);
  tokenbucket.cidr = cidr;
  tokenbucket.reject = reject;
  tokenbucket.ignore = ignore;
  tokenbucket.ban = ban;
  tokenbucket.replenish = timespec_fromnanos(1 / replenish * 1e9);
  int pid = fork();
  npassert(pid != -1);
  if (!pid) Replenisher();
  ++shared->workers;
  return 0;
}

static const char *GetContentTypeExt(const char *path, size_t n) {
  const char *r = NULL, *e;
  if ((r = FindContentType(path, n))) return r;
#ifndef STATIC
  int top;
  lua_State *L = GL;

  // extract the last .; use the entire path if none is present
  if ((e = memrchr(path, '.', n))) {
    n -= e - path + 1;
    path = e + 1;
  }
  top = lua_gettop(L);
  lua_pushlightuserdata(L, (void *)&ctIdx);  // push address as unique key
  CHECK_EQ(lua_gettable(L, LUA_REGISTRYINDEX), LUA_TTABLE);

  lua_pushlstring(L, path, n);
  if (lua_gettable(L, -2) == LUA_TSTRING)
    r = FreeLater(strdup(lua_tostring(L, -1)));
  lua_settop(L, top);
#endif
  return r;
}

static int LuaProgramContentType(lua_State *L) {
  const char *ext = luaL_checkstring(L, 1);
  const char *ct;
  int n = lua_gettop(L);

  lua_pushlightuserdata(L, (void *)&ctIdx);  // push address as unique key
  CHECK_EQ(lua_gettable(L, LUA_REGISTRYINDEX), LUA_TTABLE);

  if (n == 1) {
    ext = FreeLater(xasprintf("".%s"", ext));
    if ((ct = GetContentTypeExt(ext, strlen(ext)))) {
      lua_pushstring(L, ct);
    } else {
      lua_pushnil(L);
    }
    return 1;
  } else {
    ct = luaL_checkstring(L, 2);
    lua_pushstring(L, ext);
    lua_pushstring(L, ct);
    lua_settable(L, -3);  // table[ext] = ct
    return 0;
  }
}

static int LuaIsDaemon(lua_State *L) {
  lua_pushboolean(L, daemonize);
  return 1;
}

static int LuaGetAssetComment(lua_State *L) {
  struct Asset *a;
  const char *path;
  size_t pathlen, m;
  path = LuaCheckPath(L, 1, &pathlen);
  if ((a = GetAssetZip(path, pathlen)) &&
      (m = strnlen(ZIP_CFILE_COMMENT(zmap + a->cf),
                   ZIP_CFILE_COMMENTSIZE(zmap + a->cf)))) {
    lua_pushlstring(L, ZIP_CFILE_COMMENT(zmap + a->cf), m);
  } else {
    lua_pushnil(L);
  }
  return 1;
}

static int LuaLaunchBrowser(lua_State *L) {
  OnlyCallFromInitLua(L, ""LaunchBrowser"");
  launchbrowser = strdup(luaL_optstring(L, 1, ""/""));
  return 0;
}

static bool LuaRunAsset(const char *path, bool mandatory) {
  int status;
  struct Asset *a;
  const char *code;
  size_t pathlen, codelen;
  pathlen = strlen(path);
  if ((a = GetAsset(path, pathlen))) {
    if ((code = FreeLater(LoadAsset(a, &codelen)))) {
      lua_State *L = GL;
      effectivepath.p = (void *)path;
      effectivepath.n = pathlen;
      DEBUGF(""(lua) LuaRunAsset(%`'s)"", path);
      status = luaL_loadbuffer(
          L, code, codelen,
          FreeLater(xasprintf(""@%s%s"", a->file ? """" : ""/zip"", path)));
      if (status != LUA_OK || LuaCallWithTrace(L, 0, 0, NULL) != LUA_OK) {
        LogLuaError(""lua code"", lua_tostring(L, -1));
        lua_pop(L, 1);  // pop error
        if (mandatory) exit(1);
      }
    }
  }
  return !!a;
}

// <SORTED>
// list of functions that can't be run from the repl
static const char *const kDontAutoComplete[] = {
    ""Compress"",                  // deprecated
    ""GetBody"",                   //
    ""GetClientAddr"",             //
    ""GetClientFd"",               //
    ""GetComment"",                // deprecated
    ""GetCookie"",                 //
    ""GetEffectivePath"",          //
    ""GetFragment"",               //
    ""GetHeader"",                 //
    ""GetHeaders"",                //
    ""GetHost"",                   //
    ""GetHttpVersion"",            //
    ""GetLastModifiedTime"",       // deprecated
    ""GetMethod"",                 //
    ""GetParam"",                  //
    ""GetParams"",                 //
    ""GetPass"",                   //
    ""GetPath"",                   //
    ""GetPayload"",                // deprecated
    ""GetPort"",                   //
    ""GetRemoteAddr"",             //
    ""GetResponseBody"",           //
    ""GetScheme"",                 //
    ""GetServerAddr"",             //
    ""GetSslIdentity"",            //
    ""GetStatus"",                 //
    ""GetUrl"",                    //
    ""GetUser"",                   //
    ""GetVersion"",                // deprecated
    ""HasParam"",                  //
    ""IsClientUsingSsl"",          //
    ""IsCompressed"",              // deprecated
    ""LaunchBrowser"",             //
    ""LuaProgramSslRequired"",     // TODO
    ""ProgramAddr"",               // TODO
    ""ProgramBrand"",              //
    ""ProgramCertificate"",        // TODO
    ""ProgramGid"",                //
    ""ProgramLogPath"",            // TODO
    ""ProgramMaxPayloadSize"",     // TODO
    ""ProgramPidPath"",            // TODO
    ""ProgramPort"",               // TODO
    ""ProgramPrivateKey"",         // TODO
    ""ProgramSslCiphersuite"",     // TODO
    ""ProgramSslClientVerify"",    // TODO
    ""ProgramSslTicketLifetime"",  //
    ""ProgramTimeout"",            // TODO
    ""ProgramUid"",                //
    ""ProgramUniprocess"",         //
    ""Respond"",                   //
    ""Route"",                     //
    ""RouteHost"",                 //
    ""RoutePath"",                 //
    ""ServeAsset"",                //
    ""ServeIndex"",                //
    ""ServeListing"",              //
    ""ServeRedirect"",             //
    ""ServeStatusz"",              //
    ""SetCookie"",                 //
    ""SetHeader"",                 //
    ""SslInit"",                   // TODO
    ""Uncompress"",                // deprecated
    ""Write"",                     //
};
// </SORTED>

static const luaL_Reg kLuaFuncs[] = {
    {""Barf"", LuaBarf},                                          //
    {""Benchmark"", LuaBenchmark},                                //
    {""Bsf"", LuaBsf},                                            //
    {""Bsr"", LuaBsr},                                            //
    {""CategorizeIp"", LuaCategorizeIp},                          //
    {""Compress"", LuaCompress},                                  //
    {""Crc32"", LuaCrc32},                                        //
    {""Crc32c"", LuaCrc32c},                                      //
    {""Curve25519"", LuaCurve25519},                              //
    {""Decimate"", LuaDecimate},                                  //
    {""DecodeBase32"", LuaDecodeBase32},                          //
    {""DecodeBase64"", LuaDecodeBase64},                          //
    {""DecodeHex"", LuaDecodeHex},                                //
    {""DecodeJson"", LuaDecodeJson},                              //
    {""DecodeLatin1"", LuaDecodeLatin1},                          //
    {""Deflate"", LuaDeflate},                                    //
    {""EncodeBase32"", LuaEncodeBase32},                          //
    {""EncodeBase64"", LuaEncodeBase64},                          //
    {""EncodeHex"", LuaEncodeHex},                                //
    {""EncodeJson"", LuaEncodeJson},                              //
    {""EncodeLatin1"", LuaEncodeLatin1},                          //
    {""EncodeLua"", LuaEncodeLua},                                //
    {""EncodeUrl"", LuaEncodeUrl},                                //
    {""EscapeFragment"", LuaEscapeFragment},                      //
    {""EscapeHost"", LuaEscapeHost},                              //
    {""EscapeHtml"", LuaEscapeHtml},                              //
    {""EscapeIp"", LuaEscapeIp},                                  //
    {""EscapeLiteral"", LuaEscapeLiteral},                        //
    {""EscapeParam"", LuaEscapeParam},                            //
    {""EscapePass"", LuaEscapePass},                              //
    {""EscapePath"", LuaEscapePath},                              //
    {""EscapeSegment"", LuaEscapeSegment},                        //
    {""EscapeUser"", LuaEscapeUser},                              //
    {""Fetch"", LuaFetch},                                        //
    {""FormatHttpDateTime"", LuaFormatHttpDateTime},              //
    {""FormatIp"", LuaFormatIp},                                  //
    {""GetAssetComment"", LuaGetAssetComment},                    //
    {""GetAssetLastModifiedTime"", LuaGetAssetLastModifiedTime},  //
    {""GetAssetMode"", LuaGetAssetMode},                          //
    {""GetAssetSize"", LuaGetAssetSize},                          //
    {""GetBody"", LuaGetBody},                                    //
    {""GetClientAddr"", LuaGetClientAddr},                        //
    {""GetClientFd"", LuaGetClientFd},                            //
    {""GetCookie"", LuaGetCookie},                                //
    {""GetCpuCore"", LuaGetCpuCore},                              //
    {""GetCpuCount"", LuaGetCpuCount},                            //
    {""GetCpuNode"", LuaGetCpuNode},                              //
    {""GetCryptoHash"", LuaGetCryptoHash},                        //
    {""GetDate"", LuaGetDate},                                    //
    {""GetEffectivePath"", LuaGetEffectivePath},                  //
    {""GetFragment"", LuaGetFragment},                            //
    {""GetHeader"", LuaGetHeader},                                //
    {""GetHeaders"", LuaGetHeaders},                              //
    {""GetHost"", LuaGetHost},                                    //
    {""GetHostIsa"", LuaGetHostIsa},                              //
    {""GetHostOs"", LuaGetHostOs},                                //
    {""GetHttpReason"", LuaGetHttpReason},                        //
    {""GetHttpVersion"", LuaGetHttpVersion},                      //
    {""GetLogLevel"", LuaGetLogLevel},                            //
    {""GetMethod"", LuaGetMethod},                                //
    {""GetMonospaceWidth"", LuaGetMonospaceWidth},                //
    {""GetParam"", LuaGetParam},                                  //
    {""GetParams"", LuaGetParams},                                //
    {""GetPass"", LuaGetPass},                                    //
    {""GetPath"", LuaGetPath},                                    //
    {""GetPort"", LuaGetPort},                                    //
    {""GetRandomBytes"", LuaGetRandomBytes},                      //
    {""GetRedbeanVersion"", LuaGetRedbeanVersion},                //
    {""GetRemoteAddr"", LuaGetRemoteAddr},                        //
    {""GetResponseBody"", LuaGetResponseBody},                    //
    {""GetScheme"", LuaGetScheme},                                //
    {""GetServerAddr"", LuaGetServerAddr},                        //
    {""GetStatus"", LuaGetStatus},                                //
    {""GetTime"", LuaGetTime},                                    //
    {""GetUrl"", LuaGetUrl},                                      //
    {""GetUser"", LuaGetUser},                                    //
    {""GetZipPaths"", LuaGetZipPaths},                            //
    {""HasControlCodes"", LuaHasControlCodes},                    //
    {""HasParam"", LuaHasParam},                                  //
    {""HidePath"", LuaHidePath},                                  //
    {""HighwayHash64"", LuaHighwayHash64},                        //
    {""IndentLines"", LuaIndentLines},                            //
    {""Inflate"", LuaInflate},                                    //
    {""IsAcceptableHost"", LuaIsAcceptableHost},                  //
    {""IsAcceptablePath"", LuaIsAcceptablePath},                  //
    {""IsAcceptablePort"", LuaIsAcceptablePort},                  //
    {""IsAssetCompressed"", LuaIsAssetCompressed},                //
    {""IsClientUsingSsl"", LuaIsClientUsingSsl},                  //
    {""IsDaemon"", LuaIsDaemon},                                  //
    {""IsHeaderRepeatable"", LuaIsHeaderRepeatable},              //
    {""IsHiddenPath"", LuaIsHiddenPath},                          //
    {""IsLoopbackIp"", LuaIsLoopbackIp},                          //
    {""IsPrivateIp"", LuaIsPrivateIp},                            //
    {""IsPublicIp"", LuaIsPublicIp},                              //
    {""IsReasonablePath"", LuaIsReasonablePath},                  //
    {""IsTrustedIp"", LuaIsTrusted},                              // undocumented
    {""IsValidHttpToken"", LuaIsValidHttpToken},                  //
    {""LaunchBrowser"", LuaLaunchBrowser},                        //
    {""Lemur64"", LuaLemur64},                                    //
    {""LoadAsset"", LuaLoadAsset},                                //
    {""Log"", LuaLog},                                            //
    {""Md5"", LuaMd5},                                            //
    {""MeasureEntropy"", LuaMeasureEntropy},                      //
    {""ParseHost"", LuaParseHost},                                //
    {""ParseHttpDateTime"", LuaParseHttpDateTime},                //
    {""ParseIp"", LuaParseIp},                                    //
    {""ParseParams"", LuaParseParams},                            //
    {""ParseUrl"", LuaParseUrl},                                  //
    {""Popcnt"", LuaPopcnt},                                      //
    {""ProgramAddr"", LuaProgramAddr},                            //
    {""ProgramBrand"", LuaProgramBrand},                          //
    {""ProgramCache"", LuaProgramCache},                          //
    {""ProgramContentType"", LuaProgramContentType},              //
    {""ProgramDirectory"", LuaProgramDirectory},                  //
    {""ProgramGid"", LuaProgramGid},                              //
    {""ProgramHeader"", LuaProgramHeader},                        //
    {""ProgramHeartbeatInterval"", LuaProgramHeartbeatInterval},  //
    {""ProgramLogBodies"", LuaProgramLogBodies},                  //
    {""ProgramLogMessages"", LuaProgramLogMessages},              //
    {""ProgramLogPath"", LuaProgramLogPath},                      //
    {""ProgramMaxPayloadSize"", LuaProgramMaxPayloadSize},        //
    {""ProgramMaxWorkers"", LuaProgramMaxWorkers},                //
    {""ProgramPidPath"", LuaProgramPidPath},                      //
    {""ProgramPort"", LuaProgramPort},                            //
    {""ProgramRedirect"", LuaProgramRedirect},                    //
    {""ProgramTimeout"", LuaProgramTimeout},                      //
    {""ProgramTrustedIp"", LuaProgramTrustedIp},                  // undocumented
    {""ProgramUid"", LuaProgramUid},                              //
    {""ProgramUniprocess"", LuaProgramUniprocess},                //
    {""Rand64"", LuaRand64},                                      //
    {""Rdrand"", LuaRdrand},                                      //
    {""Rdseed"", LuaRdseed},                                      //
    {""Rdtsc"", LuaRdtsc},                                        //
    {""ResolveIp"", LuaResolveIp},                                //
    {""Route"", LuaRoute},                                        //
    {""RouteHost"", LuaRouteHost},                                //
    {""RoutePath"", LuaRoutePath},                                //
    {""ServeAsset"", LuaServeAsset},                              //
    {""ServeError"", LuaServeError},                              //
    {""ServeIndex"", LuaServeIndex},                              //
    {""ServeListing"", LuaServeListing},                          //
    {""ServeRedirect"", LuaServeRedirect},                        //
    {""ServeStatusz"", LuaServeStatusz},                          //
    {""SetCookie"", LuaSetCookie},                                //
    {""SetHeader"", LuaSetHeader},                                //
    {""SetLogLevel"", LuaSetLogLevel},                            //
    {""SetStatus"", LuaSetStatus},                                //
    {""Sha1"", LuaSha1},                                          //
    {""Sha224"", LuaSha224},                                      //
    {""Sha256"", LuaSha256},                                      //
    {""Sha384"", LuaSha384},                                      //
    {""Sha512"", LuaSha512},                                      //
    {""Sleep"", LuaSleep},                                        //
    {""Slurp"", LuaSlurp},                                        //
    {""StoreAsset"", LuaStoreAsset},                              //
    {""Uncompress"", LuaUncompress},                              //
    {""Underlong"", LuaUnderlong},                                //
    {""VisualizeControlCodes"", LuaVisualizeControlCodes},        //
    {""Write"", LuaWrite},                                        //
    {""bin"", LuaBin},                                            //
    {""hex"", LuaHex},                                            //
    {""oct"", LuaOct},                                            //
#ifndef UNSECURE
    {""AcquireToken"", LuaAcquireToken},                          //
    {""Blackhole"", LuaBlackhole},                                // undocumented
    {""CountTokens"", LuaCountTokens},                            //
    {""EvadeDragnetSurveillance"", LuaEvadeDragnetSurveillance},  //
    {""GetSslIdentity"", LuaGetSslIdentity},                      //
    {""ProgramCertificate"", LuaProgramCertificate},              //
    {""ProgramPrivateKey"", LuaProgramPrivateKey},                //
    {""ProgramSslCiphersuite"", LuaProgramSslCiphersuite},        //
    {""ProgramSslClientVerify"", LuaProgramSslClientVerify},      //
    {""ProgramSslFetchVerify"", LuaProgramSslFetchVerify},        //
    {""ProgramSslInit"", LuaProgramSslInit},                      //
    {""ProgramSslPresharedKey"", LuaProgramSslPresharedKey},      //
    {""ProgramSslRequired"", LuaProgramSslRequired},              //
    {""ProgramSslTicketLifetime"", LuaProgramSslTicketLifetime},  //
    {""ProgramTokenBucket"", LuaProgramTokenBucket},              //
#endif
    // deprecated
    {""GetPayload"", LuaGetBody},                            //
    {""GetComment"", LuaGetAssetComment},                    //
    {""GetVersion"", LuaGetHttpVersion},                     //
    {""IsCompressed"", LuaIsAssetCompressed},                //
    {""GetLastModifiedTime"", LuaGetAssetLastModifiedTime},  //
};

static const luaL_Reg kLuaLibs[] = {
    {""argon2"", luaopen_argon2},      //
    {""lsqlite3"", luaopen_lsqlite3},  //
    {""maxmind"", LuaMaxmind},         //
    {""finger"", LuaFinger},           //
    {""path"", LuaPath},               //
    {""re"", LuaRe},                   //
    {""unix"", LuaUnix},               //
};

static void LuaSetArgv(lua_State *L) {
  int i, j = -1;
  lua_newtable(L);
  lua_pushstring(L, __argv[0]);
  lua_seti(L, -2, j++);
  if (!interpretermode) {
    lua_pushstring(L, ""/zip/.init.lua"");
    lua_seti(L, -2, j++);
  }
  for (i = optind; i < __argc; ++i) {
    lua_pushstring(L, __argv[i]);
    lua_seti(L, -2, j++);
  }
  lua_pushvalue(L, -1);
  lua_setglobal(L, ""argv"");  // deprecated
  lua_setglobal(L, ""arg"");
}

static void LuaSetConstant(lua_State *L, const char *s, long x) {
  lua_pushinteger(L, x);
  lua_setglobal(L, s);
}

static void LuaStart(void) {
#ifndef STATIC
  size_t i;
  lua_State *L = GL = luaL_newstate();
  g_lua_path_default = DEFAULTLUAPATH;
  luaL_openlibs(L);
  for (i = 0; i < ARRAYLEN(kLuaLibs); ++i) {
    luaL_requiref(L, kLuaLibs[i].name, kLuaLibs[i].func, 1);
    lua_pop(L, 1);
  }
  for (i = 0; i < ARRAYLEN(kLuaFuncs); ++i) {
    lua_pushcfunction(L, kLuaFuncs[i].func);
    lua_setglobal(L, kLuaFuncs[i].name);
  }
  LuaSetConstant(L, ""kLogDebug"", kLogDebug);
  LuaSetConstant(L, ""kLogVerbose"", kLogVerbose);
  LuaSetConstant(L, ""kLogInfo"", kLogInfo);
  LuaSetConstant(L, ""kLogWarn"", kLogWarn);
  LuaSetConstant(L, ""kLogError"", kLogError);
  LuaSetConstant(L, ""kLogFatal"", kLogFatal);
  LuaSetConstant(L, ""kUrlPlus"", kUrlPlus);
  LuaSetConstant(L, ""kUrlLatin1"", kUrlLatin1);
  // create a list of custom content types
  lua_pushlightuserdata(L, (void *)&ctIdx);  // push address as unique key
  lua_newtable(L);
  lua_settable(L, LUA_REGISTRYINDEX);  // registry[&ctIdx] = {}
#endif
}

static bool ShouldAutocomplete(const char *s) {
  int c, m, l, r;
  l = 0;
  r = ARRAYLEN(kDontAutoComplete) - 1;
  while (l <= r) {
    m = (l & r) + ((l ^ r) >> 1);  // floor((a+b)/2)
    c = strcmp(kDontAutoComplete[m], s);
    if (c < 0) {
      l = m + 1;
    } else if (c > 0) {
      r = m - 1;
    } else {
      return false;
    }
  }
  return true;
}

static void HandleCompletions(const char *p, linenoiseCompletions *c) {
  size_t i, j;
  for (j = i = 0; i < c->len; ++i) {
    if (ShouldAutocomplete(c->cvec[i])) {
      c->cvec[j++] = c->cvec[i];
    } else {
      free(c->cvec[i]);
    }
  }
  c->len = j;
}

static void LuaPrint(lua_State *L) {
  int i, n;
  char *b = 0;
  n = lua_gettop(L);
  if (n > 0) {
    for (i = 1; i <= n; i++) {
      if (i > 1) appendw(&b, '\t');
      struct EncoderConfig conf = {
          .maxdepth = 64,
          .sorted = true,
          .pretty = true,
          .indent = ""  "",
      };
      LuaEncodeLuaData(L, &b, i, conf);
    }
    appendw(&b, '\n');
    WRITE(1, b, appendz(b).i);
    free(b);
  }
}

static void EnableRawMode(void) {
  if (lua_repl_isterminal) {
    strace_enabled(-1);
    linenoiseEnableRawMode(0);
    strace_enabled(+1);
  }
}

static void DisableRawMode(void) {
  strace_enabled(-1);
  linenoiseDisableRawMode();
  strace_enabled(+1);
}

static int LuaInterpreter(lua_State *L) {
  int i, n, sig, status;
  const char *script;
  if (optind < __argc) {
    script = __argv[optind];
    if (!strcmp(script, ""-"")) script = 0;
    if ((status = luaL_loadfile(L, script)) == LUA_OK) {
      lua_getglobal(L, ""arg"");
      n = luaL_len(L, -1);
      luaL_checkstack(L, n + 3, ""too many script args"");
      for (i = 1; i <= n; i++) lua_rawgeti(L, -i, i);
      lua_remove(L, -i);  // remove arg table from stack
      TRACE_BEGIN;
      status = lua_runchunk(L, n, LUA_MULTRET);
      TRACE_END;
    }
    return lua_report(L, status);
  } else {
    lua_repl_blocking = true;
    lua_repl_completions_callback = HandleCompletions;
    lua_initrepl(GL);
    EnableRawMode();
    for (;;) {
      status = lua_loadline(L);
      if (status == -1) break;  // eof
      if (status == -2) {
        if (errno == EINTR) {
          if ((sig = linenoiseGetInterrupt())) {
            kill(0, sig);
          }
        }
        fprintf(stderr, ""i/o error: %m\n"");
        exit(1);
      }
      if (status == LUA_OK) {
        TRACE_BEGIN;
        status = lua_runchunk(GL, 0, LUA_MULTRET);
        TRACE_END;
      }
      if (status == LUA_OK) {
        LuaPrint(GL);
      } else {
        lua_report(GL, status);
      }
    }
    DisableRawMode();
    lua_freerepl();
    lua_settop(GL, 0);  // clear stack
    if ((sig = linenoiseGetInterrupt())) {
      raise(sig);
    }
    return status;
  }
}

static void LuaDestroy(void) {
#ifndef STATIC
  lua_State *L = GL;
  lua_close(L);
#endif
}

static void MemDestroy(void) {
  FreeAssets();
  CollectGarbage();
  inbuf.p = 0, inbuf.n = 0, inbuf.c = 0;
  Free(&inbuf_actual.p), inbuf_actual.n = inbuf_actual.c = 0;
  Free(&unmaplist.p), unmaplist.n = unmaplist.c = 0;
  Free(&freelist.p), freelist.n = freelist.c = 0;
  Free(&hdrbuf.p), hdrbuf.n = hdrbuf.c = 0;
  Free(&servers.p), servers.n = 0;
  Free(&ports.p), ports.n = 0;
  Free(&ips.p), ips.n = 0;
  Free(&cpm.outbuf);
  FreeStrings(&stagedirs);
  FreeStrings(&hidepaths);
  Free(&cachedirective);
  Free(&launchbrowser);
  Free(&serverheader);
  Free(&trustedips.p);
  Free(&interfaces);
  Free(&extrahdrs);
  Free(&pidpath);
  Free(&logpath);
  Free(&brand);
  Free(&polls);
}

static void LuaInit(void) {
#ifndef STATIC
  lua_State *L = GL;
  LuaSetArgv(L);
  if (interpretermode) {
    int rc = LuaInterpreter(L);
    LuaDestroy();
    MemDestroy();
    if (IsModeDbg()) {
      CheckForMemoryLeaks();
    }
    exit(rc);
  }
  if (LuaRunAsset(""/.init.lua"", true)) {
    hasonhttprequest = IsHookDefined(""OnHttpRequest"");
    hasonerror = IsHookDefined(""OnError"");
    hasonclientconnection = IsHookDefined(""OnClientConnection"");
    hasonprocesscreate = IsHookDefined(""OnProcessCreate"");
    hasonprocessdestroy = IsHookDefined(""OnProcessDestroy"");
    hasonworkerstart = IsHookDefined(""OnWorkerStart"");
    hasonworkerstop = IsHookDefined(""OnWorkerStop"");
    hasonloglatency = IsHookDefined(""OnLogLatency"");
  } else {
    DEBUGF(""(srvr) no /.init.lua defined"");
  }
#endif
}

static void LuaOnServerReload(bool reindex) {
#ifndef STATIC
  if (!LuaRunAsset(""/.reload.lua"", false)) {
    DEBUGF(""(srvr) no /.reload.lua defined"");
  }

  lua_State *L = GL;
  lua_getglobal(L, ""OnServerReload"");
  lua_pushboolean(L, reindex);
  if (LuaCallWithTrace(L, 1, 0, NULL) != LUA_OK) {
    LogLuaError(""OnServerReload"", lua_tostring(L, -1));
    lua_pop(L, 1);  // pop error
  }
  AssertLuaStackIsAt(L, 0);
#endif
}

static const char *DescribeClose(void) {
  if (killed) return ""killed"";
  if (meltdown) return ""meltdown"";
  if (terminated) return ""terminated"";
  if (connectionclose) return ""connection closed"";
  return ""destroyed"";
}

static void LogClose(const char *reason) {
  if (amtread || meltdown || killed) {
    LockInc(&shared->c.fumbles);
    INFOF(""(stat) %s %s with %,ld unprocessed and %,d handled (%,d workers)"",
          DescribeClient(), reason, amtread, messageshandled, shared->workers);
  } else {
    DEBUGF(""(stat) %s %s with %,d messages handled"", DescribeClient(), reason,
           messageshandled);
  }
}

static ssize_t SendString(const char *s) {
  size_t n;
  ssize_t rc;
  struct iovec iov;
  n = strlen(s);
  iov.iov_base = (void *)s;
  iov.iov_len = n;
  if (logmessages) {
    LogMessage(""sending"", s, n);
  }
  for (;;) {
    if ((rc = writer(client, &iov, 1)) != -1 || errno != EINTR) {
      return rc;
    }
    errno = 0;
  }
}

static ssize_t SendContinue(void) {
  return SendString(""\
HTTP/1.1 100 Continue\r\n\
\r\n"");
}

static ssize_t SendTimeout(void) {
  return SendString(""\
HTTP/1.1 408 Request Timeout\r\n\
Connection: close\r\n\
Content-Length: 0\r\n\
\r\n"");
}

static ssize_t SendServiceUnavailable(void) {
  return SendString(""\
HTTP/1.1 503 Service Unavailable\r\n\
Connection: close\r\n\
Content-Length: 0\r\n\
\r\n"");
}

static ssize_t SendTooManyRequests(void) {
  return SendString(""\
HTTP/1.1 429 Too Many Requests\r\n\
Connection: close\r\n\
Content-Type: text/plain\r\n\
Content-Length: 22\r\n\
\r\n\
429 Too Many Requests\n"");
}

static void EnterMeltdownMode(void) {
  if (timespec_cmp(timespec_sub(timespec_real(), shared->lastmeltdown),
                   (struct timespec){1}) < 0) {
    return;
  }
  WARNF(""(srvr) server is melting down (%,d workers)"", shared->workers);
  LOGIFNEG1(kill(0, SIGUSR2));
  shared->lastmeltdown = timespec_real();
  ++shared->c.meltdowns;
}

static char *HandlePayloadDisconnect(void) {
  LockInc(&shared->c.payloaddisconnects);
  LogClose(""payload disconnect"");
  return ServeFailure(400, ""Bad Request""); /* XXX */
}

static char *HandlePayloadDrop(void) {
  LockInc(&shared->c.dropped);
  LogClose(DescribeClose());
  return ServeFailure(503, ""Service Unavailable"");
}

static char *HandleBadContentLength(void) {
  LockInc(&shared->c.badlengths);
  return ServeFailure(400, ""Bad Content Length"");
}

static char *HandleLengthRequired(void) {
  LockInc(&shared->c.missinglengths);
  return ServeFailure(411, ""Length Required"");
}

static char *HandleVersionNotSupported(void) {
  LockInc(&shared->c.http12);
  return ServeFailure(505, ""HTTP Version Not Supported"");
}

static char *HandleConnectRefused(void) {
  LockInc(&shared->c.connectsrefused);
  return ServeFailure(501, ""Not Implemented"");
}

static char *HandleExpectFailed(void) {
  LockInc(&shared->c.expectsrefused);
  return ServeFailure(417, ""Expectation Failed"");
}

static char *HandleHugePayload(void) {
  LockInc(&shared->c.hugepayloads);
  return ServeFailure(413, ""Payload Too Large"");
}

static char *HandleTransferRefused(void) {
  LockInc(&shared->c.transfersrefused);
  return ServeFailure(501, ""Not Implemented"");
}

static char *HandleMapFailed(struct Asset *a, int fd) {
  LockInc(&shared->c.mapfails);
  WARNF(""(srvr) mmap(%`'s) error: %m"", a->file->path);
  close(fd);
  return ServeError(500, ""Internal Server Error"");
}

static void LogAcceptError(const char *s) {
  LockInc(&shared->c.accepterrors);
  WARNF(""(srvr) %s accept error: %s"", DescribeServer(), s);
}

static char *HandleOpenFail(struct Asset *a) {
  LockInc(&shared->c.openfails);
  WARNF(""(srvr) open(%`'s) error: %m"", a->file->path);
  if (errno == ENFILE) {
    LockInc(&shared->c.enfiles);
    return ServeError(503, ""Service Unavailable"");
  } else if (errno == EMFILE) {
    LockInc(&shared->c.emfiles);
    return ServeError(503, ""Service Unavailable"");
  } else {
    return ServeError(500, ""Internal Server Error"");
  }
}

static char *HandlePayloadReadError(void) {
  if (errno == ECONNRESET) {
    LockInc(&shared->c.readresets);
    LogClose(""payload reset"");
    return ServeFailure(400, ""Bad Request""); /* XXX */
  } else if (errno == EAGAIN || errno == EWOULDBLOCK) {
    LockInc(&shared->c.readtimeouts);
    LogClose(""payload read timeout"");
    return ServeFailure(408, ""Request Timeout"");
  } else {
    LockInc(&shared->c.readerrors);
    INFOF(""(clnt) %s payload read error: %m"", DescribeClient());
    return ServeFailure(500, ""Internal Server Error"");
  }
}

static void HandleForkFailure(void) {
  LockInc(&shared->c.forkerrors);
  LockInc(&shared->c.dropped);
  EnterMeltdownMode();
  SendServiceUnavailable();
  close(client);
  WARNF(""(srvr) too many processes: %m"");
}

static void HandleFrag(size_t got) {
  LockInc(&shared->c.frags);
  DEBUGF(""(stat) %s fragged msg added %,ld bytes to %,ld byte buffer"",
         DescribeClient(), amtread, got);
}

static void HandleReload(void) {
  LockInc(&shared->c.reloads);
  LuaOnServerReload(Reindex());
  invalidated = false;
}

static void HandleHeartbeat(void) {
  size_t i;
  UpdateCurrentDate(timespec_real());
  Reindex();
  getrusage(RUSAGE_SELF, &shared->server);
#ifndef STATIC
  CallSimpleHookIfDefined(""OnServerHeartbeat"");
  CollectGarbage();
#endif
  for (i = 1; i < servers.n; ++i) {
    if (polls[i].fd < 0) {
      polls[i].fd = -polls[i].fd;
    }
  }
}

// returns 0 on success or response on error
static char *OpenAsset(struct Asset *a) {
  int fd;
  void *data;
  size_t size;
  struct stat *st;
  if (a->file->st.st_size) {
    size = a->file->st.st_size;
    if (cpm.msg.method == kHttpHead) {
      cpm.content = 0;
      cpm.contentlength = size;
    } else {
    OpenAgain:
      if ((fd = open(a->file->path.s, O_RDONLY)) != -1) {
        data = mmap(0, size, PROT_READ, MAP_PRIVATE, fd, 0);
        if (data != MAP_FAILED) {
          LockInc(&shared->c.maps);
          UnmapLater(fd, data, size);
          cpm.content = data;
          cpm.contentlength = size;
        } else if ((st = gc(malloc(sizeof(struct stat)))) &&
                   fstat(fd, st) != -1 && (data = malloc(st->st_size))) {
          /* probably empty file or zipos handle */
          LockInc(&shared->c.slurps);
          FreeLater(data);
          if (ReadAll(fd, data, st->st_size) != -1) {
            cpm.content = data;
            cpm.contentlength = st->st_size;
            close(fd);
          } else {
            return HandleMapFailed(a, fd);
          }
        } else {
          return HandleMapFailed(a, fd);
        }
      } else if (errno == EINTR) {
        errno = 0;
        goto OpenAgain;
      } else {
        return HandleOpenFail(a);
      }
    }
  } else {
    cpm.content = """";
    cpm.contentlength = 0;
  }
  return 0;
}

static char *ServeServerOptions(void) {
  char *p;
  LockInc(&shared->c.serveroptions);
  p = SetStatus(200, ""OK"");
#ifdef STATIC
  p = stpcpy(p, ""Allow: GET, HEAD, OPTIONS\r\n"");
#else
  p = stpcpy(p, ""Accept: */*\r\n""
                ""Accept-Charset: utf-8,ISO-8859-1;q=0.7,*;q=0.5\r\n""
                ""Allow: GET, HEAD, POST, PUT, DELETE, OPTIONS\r\n"");
#endif
  return p;
}

static void SendContinueIfNeeded(void) {
  if (cpm.msg.version >= 11 && HeaderEqualCase(kHttpExpect, ""100-continue"")) {
    LockInc(&shared->c.continues);
    SendContinue();
  }
}

static char *ReadMore(void) {
  size_t got;
  ssize_t rc;
  LockInc(&shared->c.frags);
  if ((rc = reader(client, inbuf.p + amtread, inbuf.n - amtread)) != -1) {
    if (!(got = rc)) return HandlePayloadDisconnect();
    amtread += got;
  } else if (errno == EINTR) {
    LockInc(&shared->c.readinterrupts);
    if (killed || ((meltdown || terminated) &&
                   timespec_cmp(timespec_sub(timespec_real(), startread),
                                (struct timespec){1}) >= 0)) {
      return HandlePayloadDrop();
    }
  } else {
    return HandlePayloadReadError();
  }
  return NULL;
}

static char *SynchronizeLength(void) {
  char *p;
  if (hdrsize + payloadlength > amtread) {
    if (hdrsize + payloadlength > inbuf.n) return HandleHugePayload();
    SendContinueIfNeeded();
    while (amtread < hdrsize + payloadlength) {
      if ((p = ReadMore())) return p;
    }
  }
  cpm.msgsize = hdrsize + payloadlength;
  return NULL;
}

static char *SynchronizeChunked(void) {
  char *p;
  ssize_t transferlength;
  struct HttpUnchunker u = {0};
  SendContinueIfNeeded();
  while (!(transferlength = Unchunk(&u, inbuf.p + hdrsize, amtread - hdrsize,
                                    &payloadlength))) {
    if ((p = ReadMore())) return p;
  }
  if (transferlength == -1) return HandleHugePayload();
  cpm.msgsize = hdrsize + transferlength;
  return NULL;
}

static char *SynchronizeStream(void) {
  int64_t cl;
  if (HasHeader(kHttpTransferEncoding) &&
      !HeaderEqualCase(kHttpTransferEncoding, ""identity"")) {
    if (HeaderEqualCase(kHttpTransferEncoding, ""chunked"")) {
      return SynchronizeChunked();
    } else {
      return HandleTransferRefused();
    }
  } else if (HasHeader(kHttpContentLength)) {
    if ((cl = ParseContentLength(HeaderData(kHttpContentLength),
                                 HeaderLength(kHttpContentLength))) != -1) {
      payloadlength = cl;
      return SynchronizeLength();
    } else {
      return HandleBadContentLength();
    }
  } else if (cpm.msg.method == kHttpPost || cpm.msg.method == kHttpPut) {
    return HandleLengthRequired();
  } else {
    cpm.msgsize = hdrsize;
    payloadlength = 0;
    return NULL;
  }
}

static void ParseRequestParameters(void) {
  uint32_t ip;
  FreeLater(ParseUrl(inbuf.p + cpm.msg.uri.a, cpm.msg.uri.b - cpm.msg.uri.a,
                     &url, kUrlPlus | kUrlLatin1));
  if (!url.host.p) {
    if (HasHeader(kHttpXForwardedHost) &&  //
        !GetRemoteAddr(&ip, 0) && IsTrustedIp(ip)) {
      FreeLater(ParseHost(HeaderData(kHttpXForwardedHost),
                          HeaderLength(kHttpXForwardedHost), &url));
    } else if (HasHeader(kHttpHost)) {
      FreeLater(
          ParseHost(HeaderData(kHttpHost), HeaderLength(kHttpHost), &url));
    } else {
      FreeLater(ParseHost(DescribeServer(), -1, &url));
    }
  } else if (!url.path.n) {
    url.path.p = ""/"";
    url.path.n = 1;
  }
  if (!url.scheme.n) {
    if (usingssl) {
      url.scheme.p = ""https"";
      url.scheme.n = 5;
    } else {
      url.scheme.p = ""http"";
      url.scheme.n = 4;
    }
  }
}

static bool HasAtMostThisElement(int h, const char *s) {
  size_t i, n;
  struct HttpHeader *x;
  if (HasHeader(h)) {
    n = strlen(s);
    if (!SlicesEqualCase(s, n, HeaderData(h), HeaderLength(h))) {
      return false;
    }
    for (i = 0; i < cpm.msg.xheaders.n; ++i) {
      x = cpm.msg.xheaders.p + i;
      if (GetHttpHeader(inbuf.p + x->k.a, x->k.b - x->k.a) == h &&
          !SlicesEqualCase(inbuf.p + x->v.a, x->v.b - x->v.a, s, n)) {
        return false;
      }
    }
  }
  return true;
}

static char *HandleRequest(void) {
  char *p;
  if (cpm.msg.version == 11) {
    LockInc(&shared->c.http11);
  } else if (cpm.msg.version < 10) {
    LockInc(&shared->c.http09);
  } else if (cpm.msg.version == 10) {
    LockInc(&shared->c.http10);
  } else {
    return HandleVersionNotSupported();
  }
  if ((p = SynchronizeStream())) return p;
  if (logbodies) LogBody(""received"", inbuf.p + hdrsize, payloadlength);
  if (cpm.msg.version < 11 || HeaderEqualCase(kHttpConnection, ""close"")) {
    connectionclose = true;
  }
  if (cpm.msg.method == kHttpOptions &&
      SlicesEqual(inbuf.p + cpm.msg.uri.a, cpm.msg.uri.b - cpm.msg.uri.a, ""*"",
                  1)) {
    return ServeServerOptions();
  }
  if (cpm.msg.method == kHttpConnect) {
    return HandleConnectRefused();
  }
  if (!HasAtMostThisElement(kHttpExpect, ""100-continue"")) {
    return HandleExpectFailed();
  }
  ParseRequestParameters();
  if (!url.host.n || !url.path.n || url.path.p[0] != '/' ||
      !IsAcceptablePath(url.path.p, url.path.n) ||
      !IsAcceptableHost(url.host.p, url.host.n) ||
      !IsAcceptablePort(url.port.p, url.port.n)) {
    free(url.params.p);
    LockInc(&shared->c.urisrefused);
    return ServeFailure(400, ""Bad URI"");
  }
  char method[9] = {0};
  WRITE64LE(method, cpm.msg.method);
  INFOF(""(req) received %s HTTP%02d %s %s %`'.*s %`'.*s"", DescribeClient(),
        cpm.msg.version, method, FreeLater(EncodeUrl(&url, 0)),
        HeaderLength(kHttpReferer), HeaderData(kHttpReferer),
        HeaderLength(kHttpUserAgent), HeaderData(kHttpUserAgent));
  if (HasHeader(kHttpContentType) &&
      IsMimeType(HeaderData(kHttpContentType), HeaderLength(kHttpContentType),
                 ""application/x-www-form-urlencoded"")) {
    FreeLater(ParseParams(inbuf.p + hdrsize, payloadlength, &url.params));
  }
  FreeLater(url.params.p);
#ifndef STATIC
  if (hasonhttprequest) return LuaOnHttpRequest();
#endif
  return Route(url.host.p, url.host.n, url.path.p, url.path.n);
}

static char *Route(const char *host, size_t hostlen, const char *path,
                   size_t pathlen) {
  char *p;
  // reset the redirect loop check, as it can only be looping inside
  // this function (as it always serves something); otherwise
  // successful RoutePath and Route may fail with ""508 loop detected""
  cpm.loops.n = 0;
  if (hostlen && (p = RouteHost(host, hostlen, path, pathlen))) {
    return p;
  }
  if (SlicesEqual(path, pathlen, ""/"", 1)) {
    if ((p = ServeIndex(""/"", 1))) return p;
    return ServeListing();
  } else if ((p = RoutePath(path, pathlen))) {
    return p;
  } else if (SlicesEqual(path, pathlen, ""/statusz"", 8)) {
    return ServeStatusz();
  } else {
    LockInc(&shared->c.notfounds);
    return ServeErrorWithPath(404, ""Not Found"", path, pathlen);
  }
}

static char *RoutePath(const char *path, size_t pathlen) {
  int m;
  long r;
  struct Asset *a;
  DEBUGF(""(srvr) RoutePath(%`'.*s)"", pathlen, path);
  if ((a = GetAsset(path, pathlen))) {
    // only allow ""read other"" permissions for security
    // and consistency with handling of ""external"" files
    // in this and other webservers
    if ((m = GetMode(a)) & 0004) {
      if (!S_ISDIR(m)) {
        return HandleAsset(a, path, pathlen);
      } else {
        return HandleFolder(path, pathlen);
      }
    } else {
      LockInc(&shared->c.forbiddens);
      WARNF(""(srvr) asset %`'.*s %#o isn't readable"", pathlen, path, m);
      return ServeErrorWithPath(403, ""Forbidden"", path, pathlen);
    }
  } else if ((r = FindRedirect(path, pathlen)) != -1) {
    return HandleRedirect(redirects.p + r);
  } else {
    return NULL;
  }
}

static char *RouteHost(const char *host, size_t hostlen, const char *path,
                       size_t pathlen) {
  size_t hn, hm;
  char *hp, *p, b[96];
  if (hostlen) {
    hn = 1 + hostlen + url.path.n;
    hm = 3 + 1 + hn;
    hp = hm <= sizeof(b) ? b : FreeLater(xmalloc(hm));
    hp[0] = '/';
    mempcpy(mempcpy(hp + 1, host, hostlen), path, pathlen);
    if ((p = RoutePath(hp, hn))) return p;
    if (!isdigit(host[0])) {
      if (hostlen > 4 &&
          READ32LE(host) == ('w' | 'w' << 8 | 'w' << 16 | '.' << 24)) {
        mempcpy(mempcpy(hp + 1, host + 4, hostlen - 4), path, pathlen);
        if ((p = RoutePath(hp, hn - 4))) return p;
      } else {
        mempcpy(mempcpy(mempcpy(hp + 1, ""www."", 4), host, hostlen), path,
                pathlen);
        if ((p = RoutePath(hp, hn + 4))) return p;
      }
    }
  }
  return NULL;
}

static inline bool IsLua(struct Asset *a) {
  size_t n;
  const char *p;
  if (a->file && a->file->path.n >= 4 &&
      READ32LE(a->file->path.s + a->file->path.n - 4) ==
          ('.' | 'l' << 8 | 'u' << 16 | 'a' << 24)) {
    return true;
  }
  p = ZIP_CFILE_NAME(zmap + a->cf);
  n = ZIP_CFILE_NAMESIZE(zmap + a->cf);
  return n > 4 &&
         READ32LE(p + n - 4) == ('.' | 'l' << 8 | 'u' << 16 | 'a' << 24);
}

static char *HandleAsset(struct Asset *a, const char *path, size_t pathlen) {
  char *p;
#ifndef STATIC
  if (IsLua(a)) return ServeLua(a, path, pathlen);
#endif
  if (cpm.msg.method == kHttpGet || cpm.msg.method == kHttpHead) {
    LockInc(&shared->c.staticrequests);
    p = ServeAsset(a, path, pathlen);
    if (!cpm.gotxcontenttypeoptions) {
      p = stpcpy(p, ""X-Content-Type-Options: nosniff\r\n"");
    }
    return p;
  } else {
    return BadMethod();
  }
}

static const char *GetContentType(struct Asset *a, const char *path, size_t n) {
  const char *r;
  if (a->file && (r = GetContentTypeExt(a->file->path.s, a->file->path.n))) {
    return r;
  }
  return firstnonnull(
      GetContentTypeExt(path, n),
      firstnonnull(GetContentTypeExt(ZIP_CFILE_NAME(zmap + a->cf),
                                     ZIP_CFILE_NAMESIZE(zmap + a->cf)),
                   a->istext ? ""text/plain"" : ""application/octet-stream""));
}

static bool IsNotModified(struct Asset *a) {
  if (cpm.msg.version < 10) return false;
  if (!HasHeader(kHttpIfModifiedSince)) return false;
  return a->lastmodified <=
         ParseHttpDateTime(HeaderData(kHttpIfModifiedSince),
                           HeaderLength(kHttpIfModifiedSince));
}

static char *ServeAsset(struct Asset *a, const char *path, size_t pathlen) {
  char *p;
  const char *ct;
  ct = GetContentType(a, path, pathlen);
  if (IsNotModified(a)) {
    LockInc(&shared->c.notmodifieds);
    p = SetStatus(304, ""Not Modified"");
  } else {
    if (!a->file) {
      cpm.content = (char *)ZIP_LFILE_CONTENT(zmap + a->lf);
      cpm.contentlength = GetZipCfileCompressedSize(zmap + a->cf);
    } else if ((p = OpenAsset(a))) {
      return p;
    }
    if (IsCompressed(a)) {
      if (ClientAcceptsGzip()) {
        p = ServeAssetPrecompressed(a);
      } else {
        p = ServeAssetDecompressed(a);
      }
    } else if (cpm.msg.version >= 11 && HasHeader(kHttpRange)) {
      p = ServeAssetRange(a);
    } else if (!a->file) {
      LockInc(&shared->c.identityresponses);
      DEBUGF(""(zip) ServeAssetZipIdentity(%`'s)"", ct);
      if (Verify(cpm.content, cpm.contentlength,
                 ZIP_LFILE_CRC32(zmap + a->lf))) {
        p = SetStatus(200, ""OK"");
      } else {
        return ServeError(500, ""Internal Server Error"");
      }
    } else if (!IsTiny() && cpm.msg.method != kHttpHead && !IsSslCompressed() &&
               ClientAcceptsGzip() && !ShouldAvoidGzip() &&
               !(a->file &&
                 IsNoCompressExt(a->file->path.s, a->file->path.n)) &&
               ((cpm.contentlength >= 100 && startswithi(ct, ""text/"")) ||
                (cpm.contentlength >= 1000 &&
                 MeasureEntropy(cpm.content, 1000) < 7))) {
      VERBOSEF(""serving compressed asset"");
      p = ServeAssetCompressed(a);
    } else {
      p = ServeAssetIdentity(a, ct);
    }
  }
  p = AppendContentType(p, ct);
  p = stpcpy(p, ""Vary: Accept-Encoding\r\n"");
  p = AppendHeader(p, ""Last-Modified"", a->lastmodifiedstr);
  if (cpm.msg.version >= 11) {
    if (!cpm.gotcachecontrol) {
      p = AppendCache(p, cacheseconds, cachedirective);
    }
    if (!IsCompressed(a)) {
      p = stpcpy(p, ""Accept-Ranges: bytes\r\n"");
    }
  }
  return p;
}

static char *SetStatus(unsigned code, const char *reason) {
  if (cpm.msg.version == 10) {
    if (code == 307) code = 302;
    if (code == 308) code = 301;
  }
  cpm.statuscode = code;
  cpm.hascontenttype = false;
  // reset, as the headers are reset.
  // istext is `true`, as the default content type
  // is text/html, which will be set later
  cpm.istext = true;
  cpm.gotxcontenttypeoptions = 0;
  cpm.gotcachecontrol = 0;
  cpm.referrerpolicy = 0;
  cpm.branded = 0;
  stpcpy(hdrbuf.p, ""HTTP/1.0 000 "");
  hdrbuf.p[7] += cpm.msg.version & 1;
  hdrbuf.p[9] += code / 100;
  hdrbuf.p[10] += code / 10 % 10;
  hdrbuf.p[11] += code % 10;
  VERBOSEF(""(rsp) %d %s"", code, reason);
  return AppendCrlf(stpcpy(hdrbuf.p + 13, reason));
}

static inline bool MustNotIncludeMessageBody(void) { /* RFC2616 § 4.4 */
  return cpm.msg.method == kHttpHead ||
         (100 <= cpm.statuscode && cpm.statuscode <= 199) ||
         cpm.statuscode == 204 || cpm.statuscode == 304;
}

static bool TransmitResponse(char *p) {
  int iovlen;
  struct iovec iov[4];
  long actualcontentlength;
  if (cpm.msg.version >= 10) {
    actualcontentlength = cpm.contentlength;
    if (cpm.gzipped) {
      actualcontentlength += sizeof(kGzipHeader) + sizeof(gzip_footer);
      p = stpcpy(p, ""Content-Encoding: gzip\r\n"");
    }
    p = AppendContentLength(p, actualcontentlength);
    p = AppendCrlf(p);
    CHECK_LE(p - hdrbuf.p, hdrbuf.n);
    if (logmessages) {
      LogMessage(""sending"", hdrbuf.p, p - hdrbuf.p);
    }
    iov[0].iov_base = hdrbuf.p;
    iov[0].iov_len = p - hdrbuf.p;
    iovlen = 1;
    if (!MustNotIncludeMessageBody()) {
      if (cpm.gzipped) {
        iov[iovlen].iov_base = (void *)kGzipHeader;
        iov[iovlen].iov_len = sizeof(kGzipHeader);
        ++iovlen;
      }
      iov[iovlen].iov_base = cpm.content;
      iov[iovlen].iov_len = cpm.contentlength;
      ++iovlen;
      if (cpm.gzipped) {
        iov[iovlen].iov_base = gzip_footer;
        iov[iovlen].iov_len = sizeof(gzip_footer);
        ++iovlen;
      }
    }
  } else {
    iov[0].iov_base = cpm.content;
    iov[0].iov_len = cpm.contentlength;
    iovlen = 1;
  }
  Send(iov, iovlen);
  LockInc(&shared->c.messageshandled);
  ++messageshandled;
  return true;
}

static bool StreamResponse(char *p) {
  int rc;
  struct iovec iov[6];
  char *s, chunkbuf[23];
  assert(!MustNotIncludeMessageBody());
  if (cpm.msg.version >= 11) {
    p = stpcpy(p, ""Transfer-Encoding: chunked\r\n"");
  } else {
    assert(connectionclose);
  }
  p = AppendCrlf(p);
  CHECK_LE(p - hdrbuf.p, hdrbuf.n);
  if (logmessages) {
    LogMessage(""sending"", hdrbuf.p, p - hdrbuf.p);
  }
  bzero(iov, sizeof(iov));
  if (cpm.msg.version >= 10) {
    iov[0].iov_base = hdrbuf.p;
    iov[0].iov_len = p - hdrbuf.p;
  }
  if (cpm.msg.version >= 11) {
    iov[5].iov_base = ""\r\n"";
    iov[5].iov_len = 2;
  }
  for (;;) {
    iov[2].iov_base = 0;
    iov[2].iov_len = 0;
    iov[3].iov_base = 0;
    iov[3].iov_len = 0;
    iov[4].iov_base = 0;
    iov[4].iov_len = 0;
    if ((rc = cpm.generator(iov + 2)) <= 0) break;
    if (cpm.msg.version >= 11) {
      s = chunkbuf;
      s += uint64toarray_radix16(rc, s);
      s = AppendCrlf(s);
      iov[1].iov_base = chunkbuf;
      iov[1].iov_len = s - chunkbuf;
    }
    if (Send(iov, 6) == -1) break;
    iov[0].iov_base = 0;
    iov[0].iov_len = 0;
  }
  if (rc != -1) {
    if (cpm.msg.version >= 11) {
      iov[0].iov_base = ""0\r\n\r\n"";
      iov[0].iov_len = 5;
      Send(iov, 1);
    }
  } else {
    connectionclose = true;
  }
  return true;
}

static bool HandleMessageActual(void) {
  int rc;
  long reqtime, contime;
  char *p;
  struct timespec now;
  if ((rc = ParseHttpMessage(&cpm.msg, inbuf.p, amtread)) != -1) {
    if (!rc) return false;
    hdrsize = rc;
    if (logmessages) {
      LogMessage(""received"", inbuf.p, hdrsize);
    }
    p = HandleRequest();
  } else {
    LockInc(&shared->c.badmessages);
    connectionclose = true;
    if ((p = DumpHexc(inbuf.p, MIN(amtread, 256), 0))) {
      INFOF(""(clnt) %s sent garbage %s"", DescribeClient(), p);
    }
    return true;
  }
  if (!cpm.msgsize) {
    amtread = 0;
    connectionclose = true;
    LockInc(&shared->c.synchronizationfailures);
    DEBUGF(""(clnt) could not synchronize message stream"");
  }
  if (cpm.msg.version >= 10) {
    p = AppendCrlf(stpcpy(stpcpy(p, ""Date: ""), shared->currentdate));
    if (!cpm.branded) p = stpcpy(p, serverheader);
    if (extrahdrs) p = stpcpy(p, extrahdrs);
    if (connectionclose) {
      p = stpcpy(p, ""Connection: close\r\n"");
    } else if (timeout.tv_sec < 0 && cpm.msg.version >= 11) {
      p = stpcpy(p, ""Connection: keep-alive\r\n"");
    }
  }
  // keep content-type update *before* referrerpolicy
  // https://datatracker.ietf.org/doc/html/rfc2616#section-7.2.1
  if (!cpm.hascontenttype && cpm.contentlength > 0) {
    p = AppendContentType(p, ""text/html"");
  }
  if (cpm.referrerpolicy) {
    p = stpcpy(p, ""Referrer-Policy: "");
    p = stpcpy(p, cpm.referrerpolicy);
    p = stpcpy(p, ""\r\n"");
  }
  if (loglatency || LOGGABLE(kLogDebug) || hasonloglatency) {
    now = timespec_real();
    reqtime = timespec_tomicros(timespec_sub(now, startrequest));
    contime = timespec_tomicros(timespec_sub(now, startconnection));
    if (hasonloglatency) LuaOnLogLatency(reqtime, contime);
    if (loglatency || LOGGABLE(kLogDebug))
      LOGF(kLogDebug, ""(stat) %`'.*s latency r: %,ldµs c: %,ldµs"",
           cpm.msg.uri.b - cpm.msg.uri.a, inbuf.p + cpm.msg.uri.a, reqtime,
           contime);
  }
  if (!cpm.generator) {
    return TransmitResponse(p);
  } else {
    return StreamResponse(p);
  }
}

static bool HandleMessage(void) {
  bool r;
  ishandlingrequest = true;
  r = HandleMessageActual();
  ishandlingrequest = false;
  return r;
}

static void InitRequest(void) {
  assert(!cpm.outbuf);
  bzero(&cpm, sizeof(cpm));
}

static bool IsSsl(unsigned char c) {
  if (c == 22) return true;
  if (!(c & 128)) return false;
  /* RHEL5 sends SSLv2 hello but supports TLS */
  DEBUGF(""(ssl) %s SSLv2 hello D:"", DescribeClient());
  return true;
}

static void HandleMessages(void) {
  bool once;
  ssize_t rc;
  size_t got;
  (void)once;
  for (once = false;;) {
    InitRequest();
    startread = timespec_real();
    for (;;) {
      if (!cpm.msg.i && amtread) {
        startrequest = timespec_real();
        if (HandleMessage()) break;
      }
      if ((rc = reader(client, inbuf.p + amtread, inbuf.n - amtread)) != -1) {
        startrequest = timespec_real();
        got = rc;
        amtread += got;
        if (amtread) {
#ifndef UNSECURE
          if (!once) {
            once = true;
            if (!unsecure) {
              if (IsSsl(inbuf.p[0])) {
                if (TlsSetup()) {
                  continue;
                } else {
                  return;
                }
              } else if (requiressl) {
                INFOF(""(clnt) %s didn't send an ssl hello"", DescribeClient());
                return;
              } else {
                WipeServingKeys();
              }
            }
          }
#endif
          DEBUGF(""(stat) %s read %,zd bytes"", DescribeClient(), got);
          if (HandleMessage()) {
            break;
          } else if (got) {
            HandleFrag(got);
          }
        }
        if (!got) {
          NotifyClose();
          LogClose(""disconnect"");
          return;
        }
      } else if (errno == EINTR) {
        LockInc(&shared->c.readinterrupts);
        errno = 0;
      } else if (errno == EAGAIN) {
        LockInc(&shared->c.readtimeouts);
        if (amtread) SendTimeout();
        NotifyClose();
        LogClose(""read timeout"");
        return;
      } else if (errno == ECONNRESET) {
        LockInc(&shared->c.readresets);
        LogClose(""read reset"");
        return;
      } else {
        LockInc(&shared->c.readerrors);
        if (errno == EBADF) {  // don't warn on close/bad fd
          LogClose(""read badf"");
        } else {
          WARNF(""(clnt) %s read error: %m"", DescribeClient());
        }
        return;
      }
      if (killed || (terminated && !amtread) ||
          (meltdown &&
           (!amtread || timespec_cmp(timespec_sub(timespec_real(), startread),
                                     (struct timespec){1}) >= 0))) {
        if (amtread) {
          LockInc(&shared->c.dropped);
          SendServiceUnavailable();
        }
        NotifyClose();
        LogClose(DescribeClose());
        return;
      }
      if (invalidated) {
        HandleReload();
      }
    }
    if (cpm.msgsize == amtread) {
      amtread = 0;
      if (killed) {
        LogClose(DescribeClose());
        return;
      } else if (connectionclose || terminated || meltdown) {
        NotifyClose();
        LogClose(DescribeClose());
        return;
      }
    } else {
      CHECK_LT(cpm.msgsize, amtread);
      LockInc(&shared->c.pipelinedrequests);
      DEBUGF(""(stat) %,ld pipelinedrequest bytes"", amtread - cpm.msgsize);
      memmove(inbuf.p, inbuf.p + cpm.msgsize, amtread - cpm.msgsize);
      amtread -= cpm.msgsize;
      if (killed) {
        LogClose(DescribeClose());
        return;
      } else if (connectionclose) {
        NotifyClose();
        LogClose(DescribeClose());
        return;
      }
    }
    CollectGarbage();
    if (invalidated) {
      HandleReload();
    }
  }
}

static void CloseServerFds(void) {
  size_t i;
  for (i = 0; i < servers.n; ++i) {
    close(servers.p[i].fd);
  }
}

static int ExitWorker(void) {
  if (IsModeDbg() && !sandboxed) {
    isexitingworker = true;
    return eintr();
  }
  if (monitortty) {
    terminatemonitor = true;
    if (monitorth) {
      pthread_join(monitorth, 0);
      monitorth = 0;
    }
  }
  LuaDestroy();
  _Exit(0);
}

static void UnveilRedbean(void) {
  size_t i;
  for (i = 0; i < stagedirs.n; ++i) {
    unveil(stagedirs.p[i].s, ""r"");
  }
  unveil(0, 0);
}

static int EnableSandbox(void) {
  __pledge_mode = PLEDGE_PENALTY_RETURN_EPERM | PLEDGE_STDERR_LOGGING;
  switch (sandboxed) {
    case 0:
      return 0;
    case 1:  // -S
      DEBUGF(""(stat) applying '%s' sandbox policy"", ""online"");
      UnveilRedbean();
      return pledge(""stdio rpath inet dns id"", 0);
    case 2:  // -SS
      DEBUGF(""(stat) applying '%s' sandbox policy"", ""offline"");
      UnveilRedbean();
      return pledge(""stdio rpath id"", 0);
    default:  // -SSS
      DEBUGF(""(stat) applying '%s' sandbox policy"", ""contained"");
      UnveilRedbean();
      return pledge(""stdio"", 0);
  }
}

static void *MemoryMonitor(void *arg) {
  static struct termios oldterm;
  static int tty;
  sigset_t ss;
  bool ok;
  size_t intervals;
  struct winsize ws;
  unsigned char rez;
  struct termios term;
  char *b, *addr;
  struct MemoryInterval *mi, *mi2;
  long i, j, gen, pages;
  int rc, id, color, color2, workers;
  id = atomic_load_explicit(&shared->workers, memory_order_relaxed);
  DEBUGF(""(memv) started for pid %d on tid %d"", getpid(), gettid());

  sigemptyset(&ss);
  sigaddset(&ss, SIGHUP);
  sigaddset(&ss, SIGINT);
  sigaddset(&ss, SIGQUIT);
  sigaddset(&ss, SIGTERM);
  sigaddset(&ss, SIGPIPE);
  sigaddset(&ss, SIGUSR1);
  sigaddset(&ss, SIGUSR2);
  sigprocmask(SIG_BLOCK, &ss, 0);

  pthread_spin_lock(&shared->montermlock);
  if (!id) {
    if ((tty = open(monitortty, O_RDWR | O_NOCTTY)) != -1) {
      tcgetattr(tty, &oldterm);
      term = oldterm;
      term.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
      term.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
      term.c_oflag |= OPOST | ONLCR;
      term.c_iflag |= IUTF8;
      term.c_cflag |= CS8;
      term.c_cc[VMIN] = 1;
      term.c_cc[VTIME] = 0;
      tcsetattr(tty, TCSANOW, &term);
      WRITE(tty, ""\e[?25l"", 6);
    }
  }
  pthread_spin_unlock(&shared->montermlock);

  if (tty != -1) {
    for (gen = 0, mi = 0, b = 0; !terminatemonitor;) {
      workers = atomic_load_explicit(&shared->workers, memory_order_relaxed);
      if (id) id = MAX(1, MIN(id, workers));
      if (!id && workers) {
        usleep(50000);
        continue;
      }

      ++gen;
      intervals = atomic_load_explicit(&_mmi.i, memory_order_relaxed);
      if ((mi2 = realloc(mi, (intervals += 3) * sizeof(*mi)))) {
        mi = mi2;
        mi[0].x = (intptr_t)__executable_start >> 16;
        mi[0].size = _etext - __executable_start;
        mi[0].flags = 0;
        mi[1].x = (intptr_t)_etext >> 16;
        mi[1].size = _edata - _etext;
        mi[1].flags = 0;
        mi[2].x = (intptr_t)_edata >> 16;
        mi[2].size = _end - _edata;
        mi[2].flags = 0;
        __mmi_lock();
        if (_mmi.i == intervals - 3) {
          memcpy(mi + 3, _mmi.p, _mmi.i * sizeof(*mi));
          ok = true;
        } else {
          ok = false;
        }
        __mmi_unlock();
        if (!ok) {
          VERBOSEF(""(memv) retrying due to contention on mmap table"");
          continue;
        }

        ws.ws_col = 80;
        ws.ws_row = 40;
        tcgetwinsize(tty, &ws);

        appendr(&b, 0);
        appends(&b, ""\e[H\e[1m"");

        for (i = 0; i < intervals; ++i) {
          addr = (char *)((int64_t)((uint64_t)mi[i].x << 32) >> 16);
          color = 0;
          appendf(&b, ""\e[0m%lx"", addr);
          int pagesz = getauxval(AT_PAGESZ);
          pages = (mi[i].size + pagesz - 1) / pagesz;
          for (j = 0; j < pages; ++j) {
            rc = mincore(addr + j * pagesz, pagesz, &rez);
            if (!rc) {
              if (rez & 1) {
                if (mi[i].flags & MAP_SHARED) {
                  color2 = 105;
                } else {
                  color2 = 42;
                }
              } else {
                color2 = 41;
              }
            } else {
              errno = 0;
              color2 = 0;
            }
            if (color != color2) {
              color = color2;
              appendf(&b, ""\e[%dm"", color);
            }
            if (mi[i].flags & MAP_ANONYMOUS) {
              appendw(&b, ' ');
            } else {
              appendw(&b, '/');
            }
          }
        }

        appendf(&b,
                ""\e[0m ID=%d PID=%d WS=%dx%d WORKERS=%d MODE="" MODE
                "" GEN=%ld\e[J"",
                id, getpid(), ws.ws_col, ws.ws_row, workers, gen);

        pthread_spin_lock(&shared->montermlock);
        WRITE(tty, b, appendz(b).i);
        appendr(&b, 0);
        usleep(MONITOR_MICROS);
        pthread_spin_unlock(&shared->montermlock);
      } else {
        // running out of memory temporarily is a real possibility here
        // the right thing to do, is stand aside and let lua try to fix
        WARNF(""(memv) we require more vespene gas"");
        usleep(MONITOR_MICROS);
      }
    }

    if (!id) {
      appendr(&b, 0);
      appends(&b, ""\e[H\e[J\e[?25h"");
      WRITE(tty, b, appendz(b).i);
      tcsetattr(tty, TCSANOW, &oldterm);
    }

    DEBUGF(""(memv) exiting..."");
    close(tty);
    free(mi);
    free(b);
  }

  DEBUGF(""(memv) done"");
  return 0;
}

static void MonitorMemory(void) {
  errno_t err;
  if ((err = pthread_create(&monitorth, 0, MemoryMonitor, 0))) {
    WARNF(""(memv) failed to start memory monitor %s"", strerror(err));
  }
}

static int HandleConnection(size_t i) {
  uint32_t ip;
  int pid, tok, rc = 0;
  clientaddrsize = sizeof(clientaddr);
  if ((client = accept4(servers.p[i].fd, (struct sockaddr *)&clientaddr,
                        &clientaddrsize, SOCK_CLOEXEC)) != -1) {
    LockInc(&shared->c.accepts);
    GetClientAddr(&ip, 0);
    if (tokenbucket.cidr && tokenbucket.reject >= 0) {
      if (!IsTrustedIp(ip)) {
        tok = AcquireToken(tokenbucket.b, ip, tokenbucket.cidr);
        if (tok <= tokenbucket.ban && tokenbucket.ban >= 0) {
          WARNF(""(token) banning %hhu.%hhu.%hhu.%hhu who only has %d tokens"",
                ip >> 24, ip >> 16, ip >> 8, ip, tok);
          LockInc(&shared->c.bans);
          Blackhole(ip);
          close(client);
          return 0;
        } else if (tok <= tokenbucket.ignore && tokenbucket.ignore >= 0) {
          DEBUGF(""(token) ignoring %hhu.%hhu.%hhu.%hhu who only has %d tokens"",
                 ip >> 24, ip >> 16, ip >> 8, ip, tok);
          LockInc(&shared->c.ignores);
          close(client);
          return 0;
        } else if (tok < tokenbucket.reject) {
          WARNF(""(token) rejecting %hhu.%hhu.%hhu.%hhu who only has %d tokens"",
                ip >> 24, ip >> 16, ip >> 8, ip, tok);
          LockInc(&shared->c.rejects);
          SendTooManyRequests();
          close(client);
          return 0;
        } else {
          DEBUGF(""(token) %hhu.%hhu.%hhu.%hhu has %d tokens"", ip >> 24,
                 ip >> 16, ip >> 8, ip, tok - 1);
        }
      } else {
        DEBUGF(""(token) won't acquire token for trusted ip %hhu.%hhu.%hhu.%hhu"",
               ip >> 24, ip >> 16, ip >> 8, ip);
      }
    } else {
      DEBUGF(""(token) can't acquire accept() token for client"");
    }
    startconnection = timespec_real();
    if (UNLIKELY(maxworkers) && shared->workers >= maxworkers) {
      EnterMeltdownMode();
      SendServiceUnavailable();
      close(client);
      return 0;
    }
    VERBOSEF(""(srvr) accept %s via %s"", DescribeClient(), DescribeServer());
    messageshandled = 0;
    if (hasonclientconnection && LuaOnClientConnection()) {
      close(client);
      return 0;
    }
    if (uniprocess) {
      pid = -1;
      connectionclose = true;
    } else {
      switch ((pid = fork())) {
        case 0:
          if (!IsTiny() && monitortty) {
            MonitorMemory();
          }
          meltdown = false;
          __isworker = true;
          connectionclose = false;
          if (!IsTiny() && systrace) {
            kStartTsc = rdtsc();
          }
          TRACE_BEGIN;
          if (sandboxed) {
            CHECK_NE(-1, EnableSandbox());
          }
          if (hasonworkerstart) {
            CallSimpleHook(""OnWorkerStart"");
          }
          break;
        case -1:
          HandleForkFailure();
          return 0;
        default:
          LockInc(&shared->workers);
          close(client);
          ReseedRng(&rng, ""parent"");
          if (hasonprocesscreate) {
            LuaOnProcessCreate(pid);
          }
          return 0;
      }
    }
    if (!pid && !IsWindows()) {
      CloseServerFds();
    }
    HandleMessages();
    DEBUGF(""(stat) %s closing after %,ldµs"", DescribeClient(),
           timespec_tomicros(timespec_sub(timespec_real(), startconnection)));
    if (!pid) {
      if (hasonworkerstop) {
        CallSimpleHook(""OnWorkerStop"");
      }
      rc = ExitWorker();
    } else {
      close(client);
      oldin.p = 0;
      oldin.n = 0;
      if (inbuf.c) {
        inbuf.p -= inbuf.c;
        inbuf.n += inbuf.c;
        inbuf.c = 0;
      }
#ifndef UNSECURE
      if (usingssl) {
        usingssl = false;
        reader = read;
        writer = WritevAll;
        mbedtls_ssl_session_reset(&ssl);
      }
#endif
    }
    CollectGarbage();
  } else {
    if (errno == EINTR || errno == EAGAIN) {
      LockInc(&shared->c.acceptinterrupts);
    } else if (errno == ENFILE) {
      LockInc(&shared->c.enfiles);
      LogAcceptError(""enfile: too many open files"");
      meltdown = true;
    } else if (errno == EMFILE) {
      LockInc(&shared->c.emfiles);
      LogAcceptError(""emfile: ran out of open file quota"");
      meltdown = true;
    } else if (errno == ENOMEM) {
      LockInc(&shared->c.enomems);
      LogAcceptError(""enomem: ran out of memory"");
      meltdown = true;
    } else if (errno == ENOBUFS) {
      LockInc(&shared->c.enobufs);
      LogAcceptError(""enobuf: ran out of buffer"");
      meltdown = true;
    } else if (errno == ENONET) {
      LockInc(&shared->c.enonets);
      LogAcceptError(""enonet: network gone"");
      polls[i].fd = -polls[i].fd;
    } else if (errno == ENETDOWN) {
      LockInc(&shared->c.enetdowns);
      LogAcceptError(""enetdown: network down"");
      polls[i].fd = -polls[i].fd;
    } else if (errno == ECONNABORTED) {
      LockInc(&shared->c.accepterrors);
      LockInc(&shared->c.acceptresets);
      WARNF(""(srvr) %s accept error: %s"", DescribeServer(),
            ""acceptreset: connection reset before accept"");
    } else if (errno == ENETUNREACH || errno == EHOSTUNREACH ||
               errno == EOPNOTSUPP || errno == ENOPROTOOPT || errno == EPROTO) {
      LockInc(&shared->c.accepterrors);
      LockInc(&shared->c.acceptflakes);
      WARNF(""(srvr) accept error: %s ephemeral accept error: %m"",
            DescribeServer());
    } else {
      WARNF(""(srvr) %s accept error: %m"", DescribeServer());
    }
    errno = 0;
  }
  return rc;
}

static void MakeExecutableModifiable(void) {
#ifdef __x86_64__
  int ft;
  if (!(SUPPORT_VECTOR & (_HOSTMETAL | _HOSTWINDOWS | _HOSTXNU))) return;
  if (IsWindows()) return;  // TODO
  if (IsOpenbsd()) return;  // TODO
  if (IsNetbsd()) return;   // TODO
  if (endswith(zpath, "".dbg"")) return;
  close(zfd);
  ft = ftrace_enabled(0);
  if ((zfd = __open_executable()) == -1) {
    WARNF(""(srvr) can't open executable for modification: %m"");
  }
  if (ft > 0) {
    __ftrace = 0;
    ftrace_install();
    ftrace_enabled(ft);
  }
#else
  // TODO
#endif
}

static int HandleReadline(void) {
  int status;
  lua_State *L = GL;
  for (;;) {
    status = lua_loadline(L);
    if (status < 0) {
      if (status == -1) {
        OnTerm(SIGHUP);  // eof
        VERBOSEF(""(repl) eof"");
        return -1;
      } else if (errno == EINTR) {
        errno = 0;
        VERBOSEF(""(repl) interrupt"");
        shutdownsig = SIGINT;
        OnInt(SIGINT);
        kill(0, SIGINT);
        return -1;
      } else if (errno == EAGAIN) {
        errno = 0;
        return 0;
      } else {
        WARNF(""(srvr) unexpected terminal error %d% m"", status);
        errno = 0;
        return 0;
      }
    }
    DisableRawMode();
    lua_repl_lock();
    if (status == LUA_OK) {
      status = lua_runchunk(L, 0, LUA_MULTRET);
    }
    if (status == LUA_OK) {
      LuaPrint(L);
    } else {
      lua_report(L, status);
    }
    lua_repl_unlock();
    EnableRawMode();
  }
}

static int HandlePoll(int ms) {
  int rc, nfds;
  size_t pollid, serverid;
  if ((nfds = poll(polls, 1 + servers.n, ms)) != -1) {
    if (nfds) {
      // handle pollid/o events
      for (pollid = 0; pollid < 1 + servers.n; ++pollid) {
        if (!polls[pollid].revents) continue;
        if (polls[pollid].fd < 0) continue;
        if (polls[pollid].fd) {
          // handle listen socket
          lua_repl_lock();
          serverid = pollid - 1;
          assert(0 <= serverid && serverid < servers.n);
          serveraddr = &servers.p[serverid].addr;
          ishandlingconnection = true;
          rc = HandleConnection(serverid);
          ishandlingconnection = false;
          lua_repl_unlock();
          if (rc == -1) return -1;
#ifndef STATIC
        } else {
          // handle standard input
          rc = HandleReadline();
          if (rc == -1) return rc;
#endif
        }
      }
#ifndef STATIC
    } else if (__ttyconf.replmode) {
      // handle refresh repl line
      rc = HandleReadline();
      if (rc < 0) return rc;
#endif
    }
  } else {
    if (errno == EINTR || errno == EAGAIN) {
      LockInc(&shared->c.pollinterrupts);
    } else if (errno == ENOMEM) {
      LockInc(&shared->c.enomems);
      WARNF(""(srvr) poll error: ran out of memory"");
      meltdown = true;
    } else {
      DIEF(""(srvr) poll error: %m"");
    }
    errno = 0;
  }
  return 0;
}

static void Listen(void) {
  char ipbuf[16];
  size_t i, j, n;
  uint32_t ip, port, addrsize, *ifp;
  bool hasonserverlisten = IsHookDefined(""OnServerListen"");
  if (!ports.n) {
    ProgramPort(8080);
  }
  if (!ips.n) {
    if (interfaces && *interfaces) {
      for (ifp = interfaces; *ifp; ++ifp) {
        sprintf(ipbuf, ""%hhu.%hhu.%hhu.%hhu"", *ifp >> 24, *ifp >> 16, *ifp >> 8,
                *ifp);
        ProgramAddr(ipbuf);
      }
    } else {
      ProgramAddr(""0.0.0.0"");
    }
  }
  servers.p = malloc(ips.n * ports.n * sizeof(*servers.p));
  for (n = i = 0; i < ips.n; ++i) {
    for (j = 0; j < ports.n; ++j, ++n) {
      bzero(servers.p + n, sizeof(*servers.p));
      servers.p[n].addr.sin_family = AF_INET;
      servers.p[n].addr.sin_port = htons(ports.p[j]);
      servers.p[n].addr.sin_addr.s_addr = htonl(ips.p[i]);
      if ((servers.p[n].fd = GoodSocket(AF_INET, SOCK_STREAM | SOCK_CLOEXEC,
                                        IPPROTO_TCP, true, &timeout)) == -1) {
        DIEF(""(srvr) socket: %m"");
      }
      if (hasonserverlisten &&
          LuaOnServerListen(servers.p[n].fd, ips.p[i], ports.p[j])) {
        close(servers.p[n].fd);
        n--;  // skip this server instance
        continue;
      }

      if (bind(servers.p[n].fd, (struct sockaddr *)&servers.p[n].addr,
               sizeof(servers.p[n].addr)) == -1) {
        DIEF(""(srvr) bind error: %m: %hhu.%hhu.%hhu.%hhu:%hu"", ips.p[i] >> 24,
             ips.p[i] >> 16, ips.p[i] >> 8, ips.p[i], ports.p[j]);
      }
      if (listen(servers.p[n].fd, 10) == -1) {
        DIEF(""(srvr) listen error: %m"");
      }
      addrsize = sizeof(servers.p[n].addr);
      if (getsockname(servers.p[n].fd, (struct sockaddr *)&servers.p[n].addr,
                      &addrsize) == -1) {
        DIEF(""(srvr) getsockname error: %m"");
      }
      port = ntohs(servers.p[n].addr.sin_port);
      ip = ntohl(servers.p[n].addr.sin_addr.s_addr);
      if (ip == INADDR_ANY) ip = INADDR_LOOPBACK;
      INFOF(""(srvr) listen http://%hhu.%hhu.%hhu.%hhu:%d"", ip >> 24, ip >> 16,
            ip >> 8, ip, port);
      if (printport && !ports.p[j]) {
        printf(""%d\r\n"", port);
        fflush(stdout);
      }
    }
  }
  // shrink allocated memory in case some of the sockets were skipped
  if (n < ips.n * ports.n)
    servers.p = realloc(servers.p, n * sizeof(*servers.p));
  servers.n = n;
  polls = malloc((1 + n) * sizeof(*polls));
  polls[0].fd = -1;
  polls[0].events = POLLIN;
  polls[0].revents = 0;
  for (i = 0; i < n; ++i) {
    polls[1 + i].fd = servers.p[i].fd;
    polls[1 + i].events = POLLIN;
    polls[1 + i].revents = 0;
  }
}

static void HandleShutdown(void) {
  CloseServerFds();
  INFOF(""(srvr) received %s"", strsignal(shutdownsig));
  if (shutdownsig != SIGINT && shutdownsig != SIGQUIT) {
    if (!killed) terminated = false;
    INFOF(""(srvr) killing process group"");
    KillGroup();
  }
  WaitAll();
  INFOF(""(srvr) shutdown complete"");
}

// this function coroutines with linenoise
int EventLoop(int ms) {
  struct timespec t;
  DEBUGF(""(repl) event loop"");
  while (!terminated) {
    errno = 0;
    if (zombied) {
      lua_repl_lock();
      ReapZombies();
      lua_repl_unlock();
    } else if (invalidated) {
      lua_repl_lock();
      HandleReload();
      lua_repl_unlock();
    } else if (meltdown) {
      lua_repl_lock();
      EnterMeltdownMode();
      lua_repl_unlock();
      meltdown = false;
    } else if (timespec_cmp(timespec_sub((t = timespec_real()), lastheartbeat),
                            heartbeatinterval) >= 0) {
      lastheartbeat = t;
      HandleHeartbeat();
    } else if (HandlePoll(ms) == -1) {
      break;
    }
  }
  return -1;
}

static void ReplEventLoop(void) {
  lua_State *L = GL;
  DEBUGF(""ReplEventLoop()"");
  polls[0].fd = 0;
  lua_repl_completions_callback = HandleCompletions;
  lua_initrepl(L);
  EnableRawMode();
  EventLoop(-1);
  DisableRawMode();
  lua_freerepl();
  lua_settop(L, 0);  // clear stack
  polls[0].fd = -1;
}

static void InstallSignalHandler(int sig, void *handler) {
  struct sigaction sa = {.sa_sigaction = handler};
  if (sigaction(sig, &sa, 0) == -1)
    WARNF(""(srvr) failed to set signal handler #%d: %m"", sig);
}

static void SigInit(void) {
  InstallSignalHandler(SIGINT, OnInt);
  InstallSignalHandler(SIGHUP, OnHup);
  InstallSignalHandler(SIGTERM, OnTerm);
  InstallSignalHandler(SIGCHLD, OnChld);
  InstallSignalHandler(SIGUSR1, OnUsr1);
  InstallSignalHandler(SIGUSR2, OnUsr2);
  InstallSignalHandler(SIGPIPE, SIG_IGN);
}

static void TlsInit(void) {
#ifndef UNSECURE
  int suite;
  if (unsecure) return;

  if (suiteb && !mbedtls_aes_uses_hardware()) {
    WARNF(""(srvr) requested suiteb crypto, but hardware aes not present"");
  }

  if (!sslinitialized) {
    InitializeRng(&rng);
    InitializeRng(&rngcli);
    suite = suiteb ? MBEDTLS_SSL_PRESET_SUITEB : MBEDTLS_SSL_PRESET_SUITEC;
    mbedtls_ssl_config_defaults(&conf, MBEDTLS_SSL_IS_SERVER,
                                MBEDTLS_SSL_TRANSPORT_STREAM, suite);
    mbedtls_ssl_config_defaults(&confcli, MBEDTLS_SSL_IS_CLIENT,
                                MBEDTLS_SSL_TRANSPORT_STREAM, suite);
  }

  // the following setting can be re-applied even when SSL/TLS is initialized
  if (suites.n) {
    mbedtls_ssl_conf_ciphersuites(&conf, suites.p);
    mbedtls_ssl_conf_ciphersuites(&confcli, suites.p);
  }
  if (psks.n) {
    mbedtls_ssl_conf_psk_cb(&conf, TlsRoutePsk, 0);
    DCHECK_EQ(0,
              mbedtls_ssl_conf_psk(&confcli, psks.p[0].key, psks.p[0].key_len,
                                   psks.p[0].identity, psks.p[0].identity_len));
  }
  if (sslticketlifetime > 0) {
    mbedtls_ssl_ticket_setup(&ssltick, mbedtls_ctr_drbg_random, &rng,
                             MBEDTLS_CIPHER_AES_256_GCM, sslticketlifetime);
    mbedtls_ssl_conf_session_tickets_cb(&conf, mbedtls_ssl_ticket_write,
                                        mbedtls_ssl_ticket_parse, &ssltick);
  }

  if (sslinitialized) return;
  sslinitialized = true;

  LoadCertificates();
  mbedtls_ssl_conf_sni(&conf, TlsRoute, 0);
  mbedtls_ssl_conf_dbg(&conf, TlsDebug, 0);
  mbedtls_ssl_conf_dbg(&confcli, TlsDebug, 0);
  mbedtls_ssl_conf_rng(&conf, mbedtls_ctr_drbg_random, &rng);
  mbedtls_ssl_conf_rng(&confcli, mbedtls_ctr_drbg_random, &rngcli);
  if (sslclientverify) {
    mbedtls_ssl_conf_ca_chain(&conf, GetSslRoots(), 0);
    mbedtls_ssl_conf_authmode(&conf, MBEDTLS_SSL_VERIFY_REQUIRED);
  }
  if (sslfetchverify) {
    mbedtls_ssl_conf_ca_chain(&confcli, GetSslRoots(), 0);
    mbedtls_ssl_conf_authmode(&confcli, MBEDTLS_SSL_VERIFY_REQUIRED);
  } else {
    mbedtls_ssl_conf_authmode(&confcli, MBEDTLS_SSL_VERIFY_NONE);
  }
  mbedtls_ssl_set_bio(&ssl, &g_bio, TlsSend, 0, TlsRecv);
  conf.disable_compression = confcli.disable_compression = true;
  DCHECK_EQ(0, mbedtls_ssl_conf_alpn_protocols(&conf, (void *)kAlpn));
  DCHECK_EQ(0, mbedtls_ssl_conf_alpn_protocols(&confcli, (void *)kAlpn));
  DCHECK_EQ(0, mbedtls_ssl_setup(&ssl, &conf));
  DCHECK_EQ(0, mbedtls_ssl_setup(&sslcli, &confcli));
#endif
}

static void TlsDestroy(void) {
#ifndef UNSECURE
  if (unsecure) return;
  mbedtls_ssl_free(&ssl);
  mbedtls_ssl_free(&sslcli);
  mbedtls_ctr_drbg_free(&rng);
  mbedtls_ctr_drbg_free(&rngcli);
  mbedtls_ssl_config_free(&conf);
  mbedtls_ssl_config_free(&confcli);
  mbedtls_ssl_ticket_free(&ssltick);
  CertsDestroy();
  PsksDestroy();
  Free(&suites.p), suites.n = 0;
#endif
}

static void GetOpts(int argc, char *argv[]) {
  int opt;
  bool got_e_arg = false;
  bool storeasset = false;
  // only generate ecp cert under blinkenlights (rsa is slow)
  norsagen = IsGenuineBlink();
  while ((opt = getopt(argc, argv, GETOPTS)) != -1) {
    switch (opt) {
      CASE('S', ++sandboxed);
      CASE('v', ++__log_level);
      CASE('s', --__log_level);
      CASE('X', unsecure = true);
      CASE('%', norsagen = true);
      CASE('Z', systrace = true);
      CASE('b', logbodies = true);
      CASE('z', printport = true);
      CASE('d', daemonize = true);
      CASE('a', logrusage = true);
      CASE('J', requiressl = true);
      CASE('u', uniprocess = true);
      CASE('g', loglatency = true);
      CASE('m', logmessages = true);
      CASE('w', launchbrowser = strdup(optarg));
      CASE('l', ProgramAddr(optarg));
      CASE('H', ProgramHeader(optarg));
      CASE('L', ProgramLogPath(optarg));
      CASE('P', ProgramPidPath(optarg));
      CASE('D', ProgramDirectory(optarg));
      CASE('U', ProgramUid(atoi(optarg)));
      CASE('G', ProgramGid(atoi(optarg)));
      CASE('p', ProgramPort(ParseInt(optarg)));
      CASE('R', ProgramRedirectArg(0, optarg));
      case 'c':;  // accept ""num"" or ""num,directive""
        char *p;
        long ret = strtol(optarg, &p, 0);
        ProgramCache(ret, *p ? p + 1 : NULL);  // skip separator, if any
        break;
        CASE('r', ProgramRedirectArg(307, optarg));
        CASE('t', ProgramTimeout(ParseInt(optarg)));
        CASE('h', PrintUsage(1, EXIT_SUCCESS));
        CASE('M', ProgramMaxPayloadSize(ParseInt(optarg)));
#if !IsTiny()
        CASE('W', monitortty = optarg);
      case 'f':
        funtrace = true;
        if (ftrace_install() == -1) {
          WARNF(""(srvr) ftrace failed to install %m"");
        }
        break;
#endif
#ifndef STATIC
        CASE('F', LuaEvalFile(optarg));
        CASE('*', selfmodifiable = true);
        CASE('i', interpretermode = true);
        CASE('E', leakcrashreports = true);
      case 'e':
        got_e_arg = true;
        LuaEvalCode(optarg);
        break;
      case 'A':
        if (!storeasset) {
          storeasset = true;
          MakeExecutableModifiable();
        }
        StorePath(optarg);
        break;
#endif
#ifndef UNSECURE
        CASE('B', suiteb = true);
        CASE('V', ++mbedtls_debug_threshold);
        CASE('k', sslfetchverify = false);
        CASE('j', sslclientverify = true);
        CASE('T', ProgramSslTicketLifetime(ParseInt(optarg)));
        CASE('C', ProgramFile(optarg, ProgramCertificate));
        CASE('K', ProgramFile(optarg, ProgramPrivateKey));
#endif
      default:
        PrintUsage(2, EX_USAGE);
    }
  }
  // if storing asset(s) is requested, don't need to continue
  if (storeasset) exit(0);
  // we don't want to drop into a repl after using -e in -i mode
  if (interpretermode && got_e_arg) exit(0);
}

void RedBean(int argc, char *argv[]) {
  char ibuf[21];
  int fd;
  // don't complain about --assimilate if it's the only parameter,
  // as it can only get here if it's already native or assimilated
  if (argc == 2 && strcmp(argv[1], ""--assimilate"") == 0) return;
  if (IsLinux()) {
    // disable weird linux capabilities
    for (int e = errno, i = 0;; ++i) {
      if (prctl(PR_CAPBSET_DROP, i) == -1) {
        errno = e;
        break;
      }
    }
    // disable sneak privilege since we don't use them
    // seccomp will fail later if this fails
    prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
  }
  reader = read;
  writer = WritevAll;
  gmtoff = GetGmtOffset((lastrefresh = startserver = timespec_real()).tv_sec);
  mainpid = getpid();
  heartbeatinterval.tv_sec = 5;
  CHECK_GT(CLK_TCK, 0);
  CHECK_NE(MAP_FAILED,
           (shared = mmap(NULL, ROUNDUP(sizeof(struct Shared), FRAMESIZE),
                          PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS,
                          -1, 0)));
  if (daemonize) {
    for (int i = 0; i < 256; ++i) {
      close(i);
    }
    open(""/dev/null"", O_RDONLY);
    open(""/dev/null"", O_WRONLY);
    open(""/dev/null"", O_WRONLY);
  }
  zpath = GetProgramExecutableName();
  CHECK_NE(-1, (zfd = open(zpath, O_RDONLY)));
  CHECK_NE(-1, fstat(zfd, &zst));
  OpenZip(true);
  SetDefaults();
  // this can fail with EPERM if we're running under pledge()
  if (!interpretermode && !(interfaces = GetHostIps())) {
    WARNF(""(srvr) failed to query system network interface addresses: %m"");
  }
  LuaStart();
  GetOpts(argc, argv);
#ifndef STATIC
  if (selfmodifiable) {
    MakeExecutableModifiable();
  }
#endif
  LuaInit();
  oldloglevel = __log_level;
  if (uniprocess) {
    shared->workers = 1;
  }
  if (daemonize) {
    if (!logpath) ProgramLogPath(""/dev/null"");
    dup2(2, 1);
  }
  SigInit();
  Listen();
  TlsInit();
  if (launchbrowser) {
    LaunchBrowser(launchbrowser);
  }
  if (daemonize) {
    Daemonize();
  }
  if (pidpath) {
    fd = open(pidpath, O_CREAT | O_WRONLY | O_TRUNC, 0644);
    WRITE(fd, ibuf, FormatInt32(ibuf, getpid()) - ibuf);
    close(fd);
  }
  ChangeUser();
  UpdateCurrentDate(timespec_real());
  CollectGarbage();
  hdrbuf.n = 4 * 1024;
  hdrbuf.p = xmalloc(hdrbuf.n);
  inbuf_actual.n = maxpayloadsize;
  inbuf_actual.p = xmalloc(inbuf_actual.n);
  inbuf = inbuf_actual;
  isinitialized = true;
  CallSimpleHookIfDefined(""OnServerStart"");
  if (!IsTiny()) {
    if (monitortty && (daemonize || uniprocess)) {
      monitortty = 0;
    }
    if (monitortty) {
      MonitorMemory();
    }
  }
#ifdef STATIC
  EventLoop(timespec_tomillis(heartbeatinterval));
#else
  if (daemonize || uniprocess || !linenoiseIsTerminal()) {
    EventLoop(timespec_tomillis(heartbeatinterval));
  } else {
    ReplEventLoop();
  }
#endif
  if (!isexitingworker) {
    if (!IsTiny()) {
      terminatemonitor = true;
      if (monitorth) {
        pthread_join(monitorth, 0);
        monitorth = 0;
      }
    }
    HandleShutdown();
    CallSimpleHookIfDefined(""OnServerStop"");
  }
  if (!IsTiny()) {
    LuaDestroy();
    TlsDestroy();
    MemDestroy();
  }
}

int main(int argc, char *argv[]) {
  lua_progname = ""redbean"";

#if !IsTiny()
  ShowCrashReports();
#endif

  LoadZipArgs(&argc, &argv);
  RedBean(argc, argv);

  // try to detect memory leaks upon:
  // 1. main process exit
  // 2. unwound worker exit
  if (IsModeDbg()) {
    if (isexitingworker) {
      linenoiseDisableRawMode();
      linenoiseHistoryFree();
    }
    CheckForMemoryLeaks();
  }

  return 0;
}
"
./repos/cosmopolitan/tool/net/getadaptersaddresses.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2024 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/assert.h""
#include ""libc/calls/calls.h""
#include ""libc/calls/internal.h""
#include ""libc/calls/syscall-sysv.internal.h""
#include ""libc/dce.h""
#include ""libc/log/check.h""
#include ""libc/log/log.h""
#include ""libc/mem/mem.h""
#include ""libc/nt/enum/formatmessageflags.h""
#include ""libc/nt/enum/lang.h""
#include ""libc/nt/errors.h""
#include ""libc/nt/iphlpapi.h""
#include ""libc/nt/memory.h""
#include ""libc/nt/process.h""
#include ""libc/nt/struct/ipadapteraddresses.h""
#include ""libc/runtime/runtime.h""
#include ""libc/serialize.h""
#include ""libc/sock/sock.h""
#include ""libc/sock/struct/sockaddr6.h""
#include ""libc/stdalign.internal.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#include ""libc/sysv/consts/af.h""
#include ""libc/sysv/consts/ipproto.h""
#include ""libc/sysv/consts/sio.h""
#include ""libc/sysv/consts/sock.h""

/**
 * @fileoverview prints detailed network interface info on windows
 */

const char *DescribeIfType(int x) {
  switch (x) {
    case kNtIfTypeOther:
      return ""OTHER"";
    case kNtIfTypeEthernetCsmacd:
      return ""ETHERNET"";
    case kNtIfTypeIso88025Tokenring:
      return ""TOKENRING"";
    case kNtIfTypePpp:
      return ""PPP"";
    case kNtIfTypeSoftwareLoopback:
      return ""LOOPBACK"";
    case kNtIfTypeAtm:
      return ""ATM"";
    case kNtIfTypeIeee80211:
      return ""WIFI"";
    case kNtIfTypeTunnel:
      return ""TUNNEL"";
    case kNtIfTypeIeee1394:
      return ""FIREWIRE"";
    default:
      return ""WUT"";
  }
}

const char *DescribeTunnelType(int x) {
  switch (x) {
    case kNtTunnelTypeNone:
      return ""NONE"";
    case kNtTunnelTypeOther:
      return ""OTHER"";
    case kNtTunnelTypeDirect:
      return ""DIRECT"";
    case kNtTunnelType6to4:
      return ""6TO4"";
    case kNtTunnelTypeIsatap:
      return ""ISATAP"";
    case kNtTunnelTypeTeredo:
      return ""TEREDO"";
    case kNtTunnelTypeIphttps:
      return ""IPHTTPS"";
    default:
      return ""WUT"";
  }
}

const char *DescribeOperStatus(int x) {
  switch (x) {
    case kNtIfOperStatusUp:
      return ""UP"";
    case kNtIfOperStatusDown:
      return ""DOWN"";
    case kNtIfOperStatusTesting:
      return ""TESTING"";
    case kNtIfOperStatusUnknown:
      return ""UNKNOWN"";
    case kNtIfOperStatusDormant:
      return ""DORMANT"";
    case kNtIfOperStatusNotPresent:
      return ""NOTPRESENT"";
    case kNtIfOperStatusLowerLayerDown:
      return ""LOWERLAYERDOWN"";
    default:
      return ""WUT"";
  }
}

const char *DescribeDadState(int x) {
  switch (x) {
    case kNtIpDadStateInvalid:
      return ""INVALID"";
    case kNtIpDadStateTentative:
      return ""TENTATIVE"";
    case kNtIpDadStateDuplicate:
      return ""DUPLICATE"";
    case kNtIpDadStateDeprecated:
      return ""DEPRECATED"";
    case kNtIpDadStatePreferred:
      return ""PREFERRED"";
    default:
      return ""WUT"";
  }
}

const char *DescribeSuffixOrigin(int x) {
  switch (x) {
    case kNtIpPrefixOriginOther:
      return ""OTHER"";
    case kNtIpPrefixOriginManual:
      return ""MANUAL"";
    case kNtIpPrefixOriginWellKnown:
      return ""WELLKNOWN"";
    case kNtIpPrefixOriginDhcp:
      return ""DHCP"";
    case kNtIpPrefixOriginRouterAdvertisement:
      return ""ROUTERADVERTISEMENT"";
    case kNtIpPrefixOriginUnchanged:
      return ""UNCHANGED"";
    default:
      return ""WUT"";
  }
}

const char *DescribePrefixOrigin(int x) {
  switch (x) {
    case kNtIpPrefixOriginOther:
      return ""OTHER"";
    case kNtIpPrefixOriginManual:
      return ""MANUAL"";
    case kNtIpPrefixOriginWellKnown:
      return ""WELLKNOWN"";
    case kNtIpPrefixOriginDhcp:
      return ""DHCP"";
    case kNtIpPrefixOriginRouterAdvertisement:
      return ""ROUTERADVERTISEMENT"";
    case kNtIpPrefixOriginUnchanged:
      return ""UNCHANGED"";
    default:
      return ""WUT"";
  }
}

const char *DescribeIpAdapterFlags(int x) {
  char *p;
  static char buf[256];
  p = buf;
  if (x & kNtIpAdapterDdnsEnabled) {
    if (p > buf) *p++ = ' ';
    p = stpcpy(p, ""DDNS"");
  }
  if (x & kNtIpAdapterDhcpv4Enabled) {
    if (p > buf) *p++ = ' ';
    p = stpcpy(p, ""DHCPv4"");
  }
  if (x & kNtIpAdapterReceiveOnly) {
    if (p > buf) *p++ = ' ';
    p = stpcpy(p, ""RECV_ONLY"");
  }
  if (x & kNtIpAdapterNoMulticast) {
    if (p > buf) *p++ = ' ';
    p = stpcpy(p, ""NO_MULTICAST"");
  }
  if (x & kNtIpAdapterIpv4Enabled) {
    if (p > buf) *p++ = ' ';
    p = stpcpy(p, ""IPv4"");
  }
  if (x & kNtIpAdapterIpv6Enabled) {
    if (p > buf) *p++ = ' ';
    p = stpcpy(p, ""IPv6"");
  }
  if (x & kNtIpAdapterIpv6Managed) {
    if (p > buf) *p++ = ' ';
    p = stpcpy(p, ""IPv6_MANAGED"");
  }
  if (x & kNtIpAdapterIpv6OtherStatefulConfig) {
    if (p > buf) *p++ = ' ';
    p = stpcpy(p, ""IPv6_OTHER_STATEFUL_CONFIG"");
  }
  if (x & kNtIpAdapterNetbiosOverTcpipEnabled) {
    if (p > buf) *p++ = ' ';
    p = stpcpy(p, ""NETBIOS_OVER_TCP"");
  }
  if (x & kNtIpAdapterRegisterAdapterSuffix) {
    if (p > buf) *p++ = ' ';
    p = stpcpy(p, ""REGISTER_ADAPTER_SUFFIX"");
  }
  return buf;
}

char *ConvertIpv6ToStr(const struct in6_addr *addr) {
  char *p;
  int i, t, a, b, c, d;
  static char buf[16 * 4 + 8];
  t = 0;
  i = 0;
  p = buf;
  for (i = 0; i < 16; i += 2) {
    switch (t) {
      case 0:
        if (!addr->s6_addr[i] && !addr->s6_addr[i + 1]) {
          t = 1;
          *p++ = ':';
          *p++ = ':';
          continue;
        } else if (i) {
          *p++ = ':';
        }
        break;
      case 1:
        if (!addr->s6_addr[i] && !addr->s6_addr[i + 1]) {
          continue;
        } else {
          t = 2;
        }
        break;
      case 2:
        *p++ = ':';
        break;
      default:
        __builtin_unreachable();
    }
    a = (addr->s6_addr[i + 0] & 0xF0) >> 4;
    b = (addr->s6_addr[i + 0] & 0x0F) >> 0;
    c = (addr->s6_addr[i + 1] & 0xF0) >> 4;
    d = (addr->s6_addr[i + 1] & 0x0F) >> 0;
    if (a) *p++ = ""0123456789abcdef""[a];
    if (a || b) *p++ = ""0123456789abcdef""[b];
    if (a || b || c) *p++ = ""0123456789abcdef""[c];
    *p++ = ""0123456789abcdef""[d];
  }
  *p = '\0';
  return buf;
}

void PrintSockAddr(struct sockaddr *addr) {
  if (addr->sa_family == AF_INET) {
    printf(""%s"", inet_ntoa(((struct sockaddr_in *)addr)->sin_addr));
  } else if (addr->sa_family == AF_INET6) {
    printf(""%s"", ConvertIpv6ToStr(&((struct sockaddr_in6 *)addr)->sin6_addr));
  } else {
    printf(""[UNKNOWN FAMILY: %d]"", addr->sa_family);
  }
}

void ShowWinNicCidrs(void) {
  // uint32_t dwSize = 0;
  uint32_t dwRetVal = 0;
  unsigned int i = 0;
  // default to unspecified address family (both)
  uint32_t family = AF_UNSPEC;
  void *lpMsgBuf = NULL;
  struct NtIpAdapterAddresses *pAddresses = NULL;
  uint32_t outBufLen = 0;
  uint32_t Iterations = 0;
  struct NtIpAdapterAddresses *p = NULL;
  struct NtIpAdapterUnicastAddress *pu = NULL;
  struct NtIpAdapterAnycastAddress *pa = NULL;
  struct NtIpAdapterMulticastAddress *pm = NULL;
  struct NtIpAdapterDnsServerAddress *pd = NULL;
  struct NtIpAdapterGatewayAddress *pg = NULL;
  struct NtIpAdapterWinsServerAddress *pw = NULL;
  struct NtIpAdapterPrefix *pp = NULL;
  outBufLen = 15000;

  do {
    pAddresses = malloc(outBufLen);
    if (pAddresses == NULL) {
      printf(""Memory allocation failed for IP_ADAPTER_ADDRESSES struct\n"");
      exit(1);
    }
    dwRetVal = GetAdaptersAddresses(
        family,
        kNtGaaFlagIncludePrefix | kNtGaaFlagIncludeWinsInfo |
            kNtGaaFlagIncludeGateways | kNtGaaFlagIncludeAllInterfaces,
        NULL, pAddresses, &outBufLen);
    if (dwRetVal == kNtErrorBufferOverflow) {
      free(pAddresses);
      pAddresses = NULL;
    } else {
      break;
    }
    Iterations++;
  } while ((dwRetVal == kNtErrorBufferOverflow) && (Iterations < 3));

  if (dwRetVal == kNtNoError) {
    for (p = pAddresses; p; p = p->Next) {
      /* if (p->OperStatus != kNtIfOperStatusUp) continue; */

      printf(""\t%s %s %s\n"", DescribeOperStatus(p->OperStatus),
             DescribeIfType(p->IfType), p->AdapterName);
      printf(""\t%hs (%hs)\n"", p->Description, p->FriendlyName);

      if (p->PhysicalAddressLength != 0) {
        printf(""\tPhysical address: "");
        for (i = 0; i < (int)p->PhysicalAddressLength; i++) {
          if (i == (p->PhysicalAddressLength - 1))
            printf(""%.2X\n"", (int)p->PhysicalAddress[i]);
          else
            printf(""%.2X-"", (int)p->PhysicalAddress[i]);
        }
      }

      for (pu = p->FirstUnicastAddress; pu; pu = pu->Next) {
        printf(""\tAddress: "");
        PrintSockAddr(pu->Address.lpSockaddr);
        printf(""/%d %s %s %s VALID:%u PREFERRED:%u LEASE:%u"",
               pu->OnLinkPrefixLength,
               inet_ntoa((struct in_addr){
                   htonl((uint32_t)-1 << (32 - pu->OnLinkPrefixLength))}),
               DescribePrefixOrigin(pu->PrefixOrigin),
               DescribeSuffixOrigin(pu->SuffixOrigin),
               DescribeDadState(pu->DadState), pu->ValidLifetime,
               pu->PreferredLifetime);
        printf(""\n"");
      }

      for (pg = p->FirstGatewayAddress; pg; pg = pg->Next) {
        printf(""\tGateway: "");
        PrintSockAddr(pg->Address.lpSockaddr);
        printf(""\n"");
      }

      for (pd = p->FirstDnsServerAddress; pd; pd = pd->Next) {
        printf(""\tDNS Server: "");
        PrintSockAddr(pd->Address.lpSockaddr);
        printf(""\n"");
      }
      if (p->DnsSuffix && p->DnsSuffix[0]) {
        printf(""\tDNS Suffix: %hs\n"", p->DnsSuffix);
      }

      for (pp = p->FirstPrefix; pp; pp = pp->Next) {
        printf(""\tRoute: "");
        PrintSockAddr(pp->Address.lpSockaddr);
        printf(""/%d"", pp->PrefixLength);
        printf(""\n"");
      }

      for (pm = p->FirstMulticastAddress; pm; pm = pm->Next) {
        printf(""\tMulticast: "");
        PrintSockAddr(pm->Address.lpSockaddr);
        printf(""\n"");
      }

      for (pa = p->FirstAnycastAddress; pa; pa = pa->Next) {
        printf(""\tAnycast: "");
        PrintSockAddr(pa->Address.lpSockaddr);
        printf(""\n"");
      }

      for (pw = p->FirstWinsServerAddress; pw; pw = pw->Next) {
        printf(""\tWINS: "");
        PrintSockAddr(pw->Address.lpSockaddr);
        printf(""\n"");
      }

      if (p->TunnelType) {
        printf(""\tTunnel Type: %s\n"", DescribeTunnelType(p->TunnelType));
      }

      printf(""\tFlags: %ld %s\n"", p->Flags, DescribeIpAdapterFlags(p->Flags));
      printf(""\tMTU: %lu\n"", p->Mtu);
      printf(""\tTx Speed: %,lu\n"", p->TransmitLinkSpeed);
      printf(""\tRx Speed: %,lu\n"", p->ReceiveLinkSpeed);
      printf(""\n"");
    }
  } else {
    printf(""Call to GetAdaptersAddresses failed with error: %d\n"", dwRetVal);
    if (dwRetVal == kNtErrorNoData)
      printf(""\tNo addresses were found for the requested parameters\n"");
    else {
      if (FormatMessage(
              kNtFormatMessageAllocateBuffer | kNtFormatMessageFromSystem |
                  kNtFormatMessageIgnoreInserts,
              NULL, dwRetVal, MAKELANGID(kNtLangNeutral, kNtSublangDefault),
              // Default language
              (char16_t *)&lpMsgBuf, 0, NULL)) {
        printf(""\tError: %s"", lpMsgBuf);
        LocalFree(lpMsgBuf);
        if (pAddresses) free(pAddresses);
        exit(1);
      }
    }
  }
  if (pAddresses) {
    free(pAddresses);
  }
}

int main(int argc, char *argv[]) {
  if (!IsWindows()) {
    fprintf(stderr, ""error: this tool is intended for windows\n"");
    return 1;
  }
  ShowWinNicCidrs();
  return 0;
}
"
./repos/cosmopolitan/tool/net/redbean-original.c,https://github.com/jart/cosmopolitan.git,"#define STATIC
#define UNSECURE
#define REDBEAN ""redbean-original""
#include ""tool/net/redbean.c""
"
./repos/cosmopolitan/tool/net/largon2.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:t;c-basic-offset:8;tab-width:8;coding:utf-8   -*-│
│ vi: set et ft=c ts=8 sw=8 fenc=utf-8                                     :vi │
╚──────────────────────────────────────────────────────────────────────────────╝
│                                                                              │
│  largon2                                                                     │
│  Copyright © 2016 Thibault Charbonnier                                       │
│                                                                              │
│  Permission is hereby granted, free of charge, to any person obtaining       │
│  a copy of this software and associated documentation files (the             │
│  ""Software""), to deal in the Software without restriction, including         │
│  without limitation the rights to use, copy, modify, merge, publish,         │
│  distribute, sublicense, and/or sell copies of the Software, and to          │
│  permit persons to whom the Software is furnished to do so, subject to       │
│  the following conditions:                                                   │
│                                                                              │
│  The above copyright notice and this permission notice shall be              │
│  included in all copies or substantial portions of the Software.             │
│                                                                              │
│  THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,             │
│  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF          │
│  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.      │
│  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY        │
│  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,        │
│  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE           │
│  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                      │
│                                                                              │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/isystem/stdio.h""
#include ""libc/isystem/string.h""
#include ""third_party/argon2/argon2.h""
#include ""third_party/lua/lauxlib.h""
#include ""third_party/lua/lua.h""
#include ""third_party/lua/lualib.h""

__notice(largon2_notice, ""\
largon2 (MIT License)\n\
Copyright 2016 Thibault Charbonnier"");

// clang-format off
/***
Lua C binding for the Argon2 password hashing function.
Compatible with Lua 5.x and LuaJIT.

See the [Argon2 documentation](https://github.com/P-H-C/phc-winner-argon2)
for in-depth instructions and details about Argon2.

This module's version is compatible with Argon2
[20161029](https://github.com/P-H-C/phc-winner-argon2/releases/tag/20161029)
and later.

Note: this document is also valid for the
[lua-argon2-ffi](https://github.com/thibaultcha/lua-argon2-ffi) module: an FFI
implementation of this binding for LuaJIT which uses the same API as this
original implementation.

@module argon2
@author Thibault Charbonnier
@license MIT
@release 3.0.1
*/


/***
Argon2 hashing variants. Those fields are `userdatums`, read-only values that
can be fed to the module's configuration or the `hash_encoded` function.
See the [Argon2 documentation](https://github.com/P-H-C/phc-winner-argon2)
for a description of those variants.
@field argon2_i
@field argon2_d
@field argon2_id
@table variants
*/


/***
Argon2 hashing options. Those options can be given to `hash_encoded` as a table.
If values are omitted, the default values of this module will be used.
Default values of this module can be overridden with `m_cost()`, `t_cost()`,
`parallelism()`, `hash_len()`, and `variant()`.
@field t_cost Number of iterations (`number`, default: `3`).
    argon2.hash_encoded(""password"", ""salt"", { t_cost = 4 })
Can be set to a new default in lua-argon2 (C binding only) by calling:
    argon2.t_cost(4)
@field m_cost Sets memory usage as KiB (`number`, default: `4096`).
    argon2.hash_encoded(""password"", ""salt"", {
      m_cost = math.pow(2, 16) -- 2^16 aka 65536 KiB
    })
Can be set to a new default in lua-argon2 (C binding only) by calling:
    argon2.m_cost(16)
@field parallelism Number of threads and compute lanes (`number`, default: `1`).
    argon2.hash_encoded(""password"", ""salt"", { parallelism = 2 })
Can be set to a new default in lua-argon2 (C binding only) by calling:
    argon2.parallelism(2)
@field hash_len Length of the hash output length (`number`, default: `32`).
    argon2.hash_encoded(""password"", ""salt"", { hash_len = 64 })
Can be set to a new default in lua-argon2 (C binding only) by calling:
    argon2.hash_len(64)
@field variant Choose the Argon2 variant to use (Argon2i, Argon2d, Argon2id)
from the `variants` table. (`userdata`, default: `argon2.variants.argon2_i`).
    argon2.hash_encoded(""password"", ""salt"", { variant = argon2.variants.argon2_d })
Can be set to a new default in lua-argon2 (C binding only) by calling:
    argon2.variant(argon2.variants.argon2_i)
    argon2.variant(argon2.variants.argon2_d)
    argon2.variant(argon2.variants.argon2_id)
@table options
*/
#define LUA_ARGON2_DEFAULT_T_COST 3
#define LUA_ARGON2_DEFAULT_M_COST 4096
#define LUA_ARGON2_DEFAULT_PARALLELISM 1
#define LUA_ARGON2_DEFAULT_HASH_LEN 32


typedef struct largon2_config_s largon2_config_t;
struct largon2_config_s {
    uint32_t         m_cost;
    uint32_t         t_cost;
    uint32_t         parallelism;
    uint32_t         hash_len;
    argon2_type      variant;
};


/* CONFIGURATION */


static void
largon2_create_config(lua_State *L)
{
    largon2_config_t *cfg;

    cfg              = lua_newuserdata(L, sizeof(*cfg));
    cfg->t_cost      = LUA_ARGON2_DEFAULT_T_COST;
    cfg->m_cost      = LUA_ARGON2_DEFAULT_M_COST;
    cfg->parallelism = LUA_ARGON2_DEFAULT_PARALLELISM;
    cfg->hash_len    = LUA_ARGON2_DEFAULT_HASH_LEN;
    cfg->variant     = Argon2_id;
}


static largon2_config_t *
largon2_fetch_config(lua_State *L)
{
    largon2_config_t *cfg;

    cfg = lua_touserdata(L, lua_upvalueindex(1));
    if (!cfg)
        luaL_error(L, ""could not retrieve argon2 config"");

    return cfg;
}


static largon2_config_t *
largon2_arg_init(lua_State *L, int nargs)
{
    if (lua_gettop(L) > nargs) {
        luaL_error(L, ""expecting no more than %d arguments, but got %d"",
                   nargs, lua_gettop(L));
    }

    lua_settop(L, nargs);

    return largon2_fetch_config(L);
}


static void
largon2_integer_opt(lua_State *L, uint32_t optidx, uint32_t argidx,
                    uint32_t *property, const char *key)
{
    uint32_t        value;
    char            errmsg[64];

    if (!lua_isnil(L, optidx)) {
        if (lua_isnumber(L, optidx)) {
            value = lua_tonumber(L, optidx);
            *property = value;

        } else {
            sprintf(errmsg, ""expected %s to be a number, got %s"",
                    key, luaL_typename(L, optidx));
            luaL_argerror(L, argidx, errmsg);
        }
    }
}


static int
largon2_cfg_t_cost(lua_State *L)
{
    largon2_config_t *cfg = largon2_arg_init(L, 1);

    largon2_integer_opt(L, 1, 1, &cfg->t_cost, ""t_cost"");
    lua_pushinteger(L, cfg->t_cost);

    return 1;
}


static int
largon2_cfg_m_cost(lua_State *L)
{
    largon2_config_t *cfg = largon2_arg_init(L, 1);

    largon2_integer_opt(L, 1, 1, &cfg->m_cost, ""m_cost"");
    lua_pushinteger(L, cfg->m_cost);

    return 1;
}


static int
largon2_cfg_parallelism(lua_State *L)
{
    largon2_config_t *cfg = largon2_arg_init(L, 1);

    largon2_integer_opt(L, 1, 1, &cfg->parallelism, ""parallelism"");
    lua_pushinteger(L, cfg->parallelism);

    return 1;
}


static int
largon2_cfg_hash_len(lua_State *L)
{
    largon2_config_t *cfg = largon2_arg_init(L, 1);

    largon2_integer_opt(L, 1, 1, &cfg->hash_len, ""hash_len"");
    lua_pushinteger(L, cfg->hash_len);

    return 1;
}


static int
largon2_cfg_variant(lua_State *L)
{
    largon2_config_t *cfg = largon2_arg_init(L, 1);

    luaL_checktype(L, 1, LUA_TLIGHTUSERDATA);

    cfg->variant = (argon2_type) lua_touserdata(L, 1);

    return 1;
}


/* BINDINGS */


/***
Hashes a password with Argon2i, Argon2d, or Argon2id, producing an encoded
hash.
@function hash_encoded
@param[type=string] plain Plain string to hash_encoded.
@param[type=string] salt Salt to use to hash the plain string.
@param[type=table] options Options with which to hash the plain string. See
`options`. This parameter is optional, if values are omitted the default ones
will be used.
@treturn string `encoded`: Encoded hash computed by Argon2, or `nil` if an
error occurred.
@treturn string `err`: `nil`, or a string describing the error if any.

@usage
local hash, err = argon2.hash_encoded(""password"", ""somesalt"")
if err then
  error(""could not hash_encoded: "" .. err)
end

-- with options and variant
local hash, err = argon2.hash_encoded(""password"", ""somesalt"", {
  t_cost = 4,
  m_cost = math.pow(2, 16), -- 65536 KiB
  variant = argon2.variants.argon2_d
})
*/
static int
largon2_hash_encoded(lua_State *L)
{
    const char             *plain, *salt;
    char                   *encoded, *err_msg;
    size_t                  plainlen, saltlen;
    size_t                  encoded_len;
    uint32_t                t_cost;
    uint32_t                m_cost;
    uint32_t                hash_len;
    uint32_t                parallelism;
    argon2_type             variant;
    argon2_error_codes      ret_code;
    largon2_config_t       *cfg;
    luaL_Buffer             buf;

    plain = luaL_checklstring(L, 1, &plainlen);
    salt  = luaL_checklstring(L, 2, &saltlen);

    cfg = largon2_arg_init(L, 3);

    t_cost      = cfg->t_cost;
    m_cost      = cfg->m_cost;
    parallelism = cfg->parallelism;
    hash_len    = cfg->hash_len;
    variant     = cfg->variant;

    if (!lua_isnil(L, 3)) {
        if (!lua_istable(L, 3)) {
            luaL_argerror(L, 3, ""expected to be a table"");
        }

        lua_getfield(L, 3, ""t_cost"");
        largon2_integer_opt(L, -1, 3, &t_cost, ""t_cost"");
        lua_pop(L, 1);

        lua_getfield(L, 3, ""m_cost"");
        largon2_integer_opt(L, -1, 3, &m_cost, ""m_cost"");
        lua_pop(L, 1);

        lua_getfield(L, 3, ""parallelism"");
        largon2_integer_opt(L, -1, 3, &parallelism, ""parallelism"");
        lua_pop(L, 1);

        lua_getfield(L, 3, ""hash_len"");
        largon2_integer_opt(L, -1, 3, &hash_len, ""hash_len"");
        lua_pop(L, 1);

        lua_getfield(L, 3, ""variant"");
        if (!lua_isnil(L, -1)) {
            if (!lua_islightuserdata(L, -1)) {
                char errmsg[64];
                sprintf(errmsg, ""expected variant to be a number, got %s"",
                        luaL_typename(L, -1));
                luaL_argerror(L, 3, errmsg);
            }

            variant = (argon2_type) lua_touserdata(L, -1);
        }

        lua_pop(L, 1);
    }

    encoded_len = argon2_encodedlen(t_cost, m_cost, parallelism, saltlen,
                                    hash_len, variant);

    encoded = luaL_buffinitsize(L, &buf, encoded_len);

    if (variant == Argon2_d) {
        ret_code =
          argon2d_hash_encoded(t_cost, m_cost, parallelism, plain, plainlen,
                               salt, saltlen, hash_len, encoded, encoded_len);

    } else if (variant == Argon2_id) {
        ret_code =
          argon2id_hash_encoded(t_cost, m_cost, parallelism, plain, plainlen,
                                salt, saltlen, hash_len, encoded, encoded_len);

    } else {
        ret_code =
          argon2i_hash_encoded(t_cost, m_cost, parallelism, plain, plainlen,
                               salt, saltlen, hash_len, encoded, encoded_len);
    }

    luaL_pushresultsize(&buf, encoded_len - 1);

    if (ret_code != ARGON2_OK) {
        err_msg = (char *) argon2_error_message(ret_code);
        lua_pushnil(L);
        lua_pushstring(L, err_msg);
        return 2;
    }

    return 1;
}


/***
Verifies a password against an encoded string.
@function verify
@param[type=string] encoded Encoded string to verify the plain password against.
@param[type=string] password Plain password to verify.
@treturn boolean `ok`: `true` if the password matches, `false` if it is a
mismatch. If an error occurs during the verification, will be `nil`.
@treturn string `err`: `nil`, or a string describing the error if any. A
password mismatch will not return an error, but will return `ok = false`
instead.

@usage
local ok, err = argon2.verify(argon2i_hash, ""password"")
if err then
  -- failure to verify (*not* a password mismatch)
  error(""could not verify: "" .. err)
end

if not ok then
  -- password mismatch
  error(""The password does not match the supplied hash"")
end

-- with a argon2d hash
local ok, err = argon2.verify(argon2d_hash, ""password"")
*/
static int
largon2_verify(lua_State *L)
{
    const char             *plain, *encoded;
    size_t                  plainlen;
    argon2_type             variant;
    argon2_error_codes      ret_code;
    char                   *err_msg;

    if (lua_gettop(L) != 2) {
        return luaL_error(L, ""expecting 2 arguments, but got %d"",
                          lua_gettop(L));
    }

    encoded = luaL_checkstring(L, 1);
    plain   = luaL_checklstring(L, 2, &plainlen);

    if (strstr(encoded, ""argon2d"")) {
        variant = Argon2_d;

    } else if (strstr(encoded, ""argon2id"")) {
        variant = Argon2_id;

    } else {
        variant = Argon2_i;
    }

    ret_code = argon2_verify(encoded, plain, plainlen, variant);
    if (ret_code == ARGON2_VERIFY_MISMATCH) {
        lua_pushboolean(L, 0);
        return 1;
    }

    if (ret_code != ARGON2_OK) {
        err_msg = (char *) argon2_error_message(ret_code);
        lua_pushnil(L);
        lua_pushstring(L, err_msg);
        return 2;
    }

    lua_pushboolean(L, 1);

    return 1;
}


/* MODULE */


static void
largon2_push_argon2_variants_table(lua_State *L)
{
    lua_newtable(L);

    lua_pushlightuserdata(L, (void *) Argon2_i);
    lua_setfield(L, -2, ""argon2_i"");

    lua_pushlightuserdata(L, (void *) Argon2_d);
    lua_setfield(L, -2, ""argon2_d"");

    lua_pushlightuserdata(L, (void *) Argon2_id);
    lua_setfield(L, -2, ""argon2_id"");

    return;
}


static const luaL_Reg largon2[] = { { ""verify"", largon2_verify },
                                    { ""hash_encoded"", largon2_hash_encoded },
                                    { ""t_cost"", largon2_cfg_t_cost },
                                    { ""m_cost"", largon2_cfg_m_cost },
                                    { ""parallelism"", largon2_cfg_parallelism },
                                    { ""hash_len"", largon2_cfg_hash_len },
                                    { ""variant"", largon2_cfg_variant },
                                    { NULL, NULL } };


int
luaopen_argon2(lua_State *L)
{
    lua_newtable(L);

    largon2_create_config(L);
    luaL_setfuncs(L, largon2, 1);

    /* push argon2.variants table */

    largon2_push_argon2_variants_table(L);
    lua_setfield(L, -2, ""variants"");

    lua_pushliteral(L, ""3.0.1"");
    lua_setfield(L, -2, ""_VERSION"");

    lua_pushliteral(L, ""Thibault Charbonnier"");
    lua_setfield(L, -2, ""_AUTHOR"");

    lua_pushliteral(L, ""MIT"");
    lua_setfield(L, -2, ""_LICENSE"");

    lua_pushliteral(L, ""https://github.com/thibaultcha/lua-argon2"");
    lua_setfield(L, -2, ""_URL"");

    return 1;
}
"
./repos/cosmopolitan/tool/net/libresolv_query.c,https://github.com/jart/cosmopolitan.git,"/*
 * Copyright (c) 2013 by Wil Tan <wil@cloudregistry.net>
 *
 * Based on dump_dns.c from the dnscap <https://www.dns-oarc.net/tools/dnscap>
 * originally written by Paul Vixie.
 *
 * Copyright (c) 2007 by Internet Systems Consortium, Inc. (""ISC"")
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"" AND ISC DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include ""libc/calls/typedef/u.h""
#include ""libc/errno.h""
#include ""libc/runtime/runtime.h""
#include ""libc/sock/sock.h""
#include ""libc/stdio/internal.h""
#include ""libc/str/str.h""
#include ""libc/sysv/consts/af.h""
#include ""third_party/musl/nameser.h""
#include ""third_party/musl/resolv.h""

const char *_res_opcodes[] = {
    ""QUERY"",     //
    ""IQUERY"",    //
    ""CQUERYM"",   //
    ""CQUERYU"",   //
    ""NOTIFY"",    //
    ""UPDATE"",    //
    ""6"",         //
    ""7"",         //
    ""8"",         //
    ""9"",         //
    ""10"",        //
    ""11"",        //
    ""12"",        //
    ""13"",        //
    ""ZONEINIT"",  //
    ""ZONEREF"",   //
};

#define MY_GET16(s, cp)                                     \
  do {                                                      \
    register const u_char *t_cp = (const u_char *)(cp);     \
    (s) = ((u_int16_t)t_cp[0] << 8) | ((u_int16_t)t_cp[1]); \
    (cp) += NS_INT16SZ;                                     \
  } while (0)

#define MY_GET32(l, cp)                                             \
  do {                                                              \
    register const u_char *t_cp = (const u_char *)(cp);             \
    (l) = ((u_int32_t)t_cp[0] << 24) | ((u_int32_t)t_cp[1] << 16) | \
          ((u_int32_t)t_cp[2] << 8) | ((u_int32_t)t_cp[3]);         \
    (cp) += NS_INT32SZ;                                             \
  } while (0)

static void dump_dns_rr(ns_msg *msg, ns_rr *rr, ns_sect sect, FILE *trace) {
  char buf[NS_MAXDNAME];
  u_int class, type;
  const u_char *rd;
  u_int32_t soa[5];
  u_int16_t mx;
  int n;

  class = ns_rr_class(*rr);
  type = ns_rr_type(*rr);
  fprintf(trace, ""%s,%d,%d"", ns_rr_name(*rr), class, type);
  if (sect == ns_s_qd) return;
  fprintf(trace, "",%lu"", (u_long)ns_rr_ttl(*rr));
  rd = ns_rr_rdata(*rr);
  switch (type) {
    case ns_t_soa:
      n = ns_name_uncompress(ns_msg_base(*msg), ns_msg_end(*msg), rd, buf,
                             sizeof buf);
      if (n < 0) goto error;
      putc(',', trace);
      fputs(buf, trace);
      rd += n;
      n = ns_name_uncompress(ns_msg_base(*msg), ns_msg_end(*msg), rd, buf,
                             sizeof buf);
      if (n < 0) goto error;
      putc(',', trace);
      fputs(buf, trace);
      rd += n;
      if (ns_msg_end(*msg) - rd < 5 * NS_INT32SZ) goto error;
      for (n = 0; n < 5; n++) MY_GET32(soa[n], rd);
      sprintf(buf, ""%u,%u,%u,%u,%u"", soa[0], soa[1], soa[2], soa[3], soa[4]);
      break;
    case ns_t_a:
      inet_ntop(AF_INET, rd, buf, sizeof buf);
      break;
    case ns_t_aaaa:
      inet_ntop(AF_INET6, rd, buf, sizeof buf);
      break;
    case ns_t_mx:
      MY_GET16(mx, rd);
      fprintf(trace, "",%u"", mx);
      /* FALLTHROUGH */
    case ns_t_ns:
    case ns_t_ptr:
    case ns_t_cname:
      n = ns_name_uncompress(ns_msg_base(*msg), ns_msg_end(*msg), rd, buf,
                             sizeof buf);
      if (n < 0) goto error;
      break;
    case ns_t_txt:
      snprintf(buf, (size_t)rd[0] + 1, ""%s"", rd + 1);
      break;
    default:
    error:
      sprintf(buf, ""[%u]"", ns_rr_rdlen(*rr));
  }
  if (buf[0] != '\0') {
    putc(',', trace);
    fputs(buf, trace);
  }
}

static void dump_dns_sect(ns_msg *msg, ns_sect sect, FILE *trace,
                          const char *endline) {
  int rrnum, rrmax;
  const char *sep;
  ns_rr rr;

  rrmax = ns_msg_count(*msg, sect);
  if (rrmax == 0) {
    fputs("" 0"", trace);
    return;
  }
  fprintf(trace, "" %s%d"", endline, rrmax);
  sep = """";
  for (rrnum = 0; rrnum < rrmax; rrnum++) {
    if (ns_parserr(msg, sect, rrnum, &rr)) {
      fputs(strerror(errno), trace);
      return;
    }
    fprintf(trace, "" %s"", sep);
    dump_dns_rr(msg, &rr, sect, trace);
    sep = endline;
  }
}

void dump_dns(const u_char *payload, size_t paylen, FILE *trace,
              const char *endline) {
  u_int opcode, rcode, id;
  const char *sep;
  ns_msg msg;

  fprintf(trace, "" %sdns "", endline);
  if (ns_initparse(payload, paylen, &msg) < 0) {
    fputs(strerror(errno), trace);
    return;
  }
  opcode = ns_msg_getflag(msg, ns_f_opcode);
  rcode = ns_msg_getflag(msg, ns_f_rcode);
  id = ns_msg_id(msg);
  fprintf(trace, ""%s,%d,%u"", _res_opcodes[opcode], rcode, id);
  sep = "","";
#define FLAG(t, f)                  \
  if (ns_msg_getflag(msg, f)) {     \
    fprintf(trace, ""%s%s"", sep, t); \
    sep = ""|"";                      \
  }
  FLAG(""qr"", ns_f_qr);
  FLAG(""aa"", ns_f_aa);
  FLAG(""tc"", ns_f_tc);
  FLAG(""rd"", ns_f_rd);
  FLAG(""ra"", ns_f_ra);
  FLAG(""z"", ns_f_z);
  FLAG(""ad"", ns_f_ad);
  FLAG(""cd"", ns_f_cd);
#undef FLAG

  dump_dns_sect(&msg, ns_s_an, trace, endline);
}

int main() {
  ShowCrashReports();
  u_char answer[1024] = """";
  res_init();
  int rv = res_query(""google.com"", ns_c_in, ns_t_txt, answer, sizeof(answer));
  // printf(""rv=%d\n"", rv);
  dump_dns(answer, rv, stdout, ""\n"");
  printf(""\n"");
}
"
./repos/cosmopolitan/tool/net/dig.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/log/log.h""
#include ""libc/runtime/runtime.h""
#include ""libc/sock/sock.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#include ""libc/sysv/consts/af.h""
#include ""libc/sysv/consts/ipproto.h""
#include ""libc/sysv/consts/sock.h""
#include ""third_party/musl/netdb.h""
#include ""tool/decode/lib/flagger.h""
#include ""tool/decode/lib/idname.h""
#include ""tool/decode/lib/socknames.h""

void lookup(const char *name) {
  int rc;
  struct addrinfo *ai = NULL;
  struct addrinfo hint = {AI_NUMERICSERV, AF_INET, SOCK_STREAM, IPPROTO_TCP};
  switch ((rc = getaddrinfo(name, ""80"", &hint, &ai))) {
    case 0:
      break;
    case EAI_SYSTEM:
      perror(""getaddrinfo"");
      exit(1);
    default:
      fprintf(stderr, ""getaddrinfo failed: %d (EAI_%s)\n"", rc,
              gai_strerror(rc));
      exit(1);
  }
  if (ai) {
    for (struct addrinfo *addr = ai; addr; addr = addr->ai_next) {
      const unsigned char *ip =
          addr->ai_family == AF_INET
              ? (const unsigned char *)&((struct sockaddr_in *)addr->ai_addr)
                    ->sin_addr
              : (const unsigned char *)""\0\0\0\0"";
      printf(""%-12s = %s\n"", ""ai_flags"",
             RecreateFlags(kAddrInfoFlagNames, addr->ai_flags), addr->ai_flags);
      printf(""%-12s = %s (%d)\n"", ""ai_family"",
             findnamebyid(kAddressFamilyNames, addr->ai_family),
             addr->ai_family);
      printf(""%-12s = %s (%d)\n"", ""ai_socktype"",
             findnamebyid(kSockTypeNames, addr->ai_socktype),
             addr->ai_socktype);
      printf(""%-12s = %s (%d)\n"", ""ai_protocol"",
             findnamebyid(kProtocolNames, addr->ai_protocol),
             addr->ai_protocol);
      printf(""%-12s = %d\n"", ""ai_addrlen"", addr->ai_addrlen);
      printf(""%-12s = %hhu.%hhu.%hhu.%hhu\n"", ""ai_addr"", ip[0], ip[1], ip[2],
             ip[3]);
      printf(""%-12s = %s\n"", ""ai_canonname"", addr->ai_canonname);
    }
    freeaddrinfo(ai);
  } else {
    fprintf(stderr, ""%s: %s\n"", name, ""no results"");
  }
}

int main(int argc, char *argv[]) {
  int i;
  ShowCrashReports();
  for (i = 1; i < argc; ++i) lookup(argv[i]);
  return 0;
}
"
./repos/cosmopolitan/tool/net/lsqlite3.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:4;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=4 sts=4 sw=4 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ lsqlite3                                                                     │
│ Copyright (C) 2002-2016 Tiago Dionizio, Doug Currie                          │
│ All rights reserved.                                                         │
│ Author    : Tiago Dionizio <tiago.dionizio@ist.utl.pt>                       │
│ Author    : Doug Currie <doug.currie@alum.mit.edu>                           │
│ Library   : lsqlite3 - an SQLite 3 database binding for Lua 5                │
│                                                                              │
│ Permission is hereby granted, free of charge, to any person obtaining        │
│ a copy of this software and associated documentation files (the              │
│ ""Software""), to deal in the Software without restriction, including          │
│ without limitation the rights to use, copy, modify, merge, publish,          │
│ distribute, sublicense, and/or sell copies of the Software, and to           │
│ permit persons to whom the Software is furnished to do so, subject to        │
│ the following conditions:                                                    │
│                                                                              │
│ The above copyright notice and this permission notice shall be               │
│ included in all copies or substantial portions of the Software.              │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,              │
│ EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF           │
│ MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.       │
│ IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY         │
│ CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,         │
│ TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE            │
│ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                       │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/calls/weirdtypes.h""
#include ""libc/mem/gc.h""
#include ""libc/mem/mem.h""
#include ""libc/str/str.h""
#include ""third_party/lua/lauxlib.h""
#include ""third_party/lua/lua.h""
#include ""third_party/lua/luaconf.h""
#include ""third_party/sqlite3/extensions.h""
#include ""third_party/sqlite3/sqlite3.h""
// clang-format off

__notice(lsqlite3_notice, ""\
lsqlite3 (MIT License)\n\
Copyright 2002-2016 Tiago Dionizio, Doug Currie"");

// LOCAL CHANGES
//
//   - Remove online backup code
//   - Remove trace callback code
//   - Remove progress callback code
//   - Removed extension loading code
//   - Relocate static .data to .rodata
//   - Changed lua_strlen() to lua_rawlen()
//
#define LSQLITE_VERSION ""0.9.5""

/* luaL_typerror always used with arg at ndx == NULL */
#define luaL_typerror(L,ndx,str) luaL_error(L,""bad argument %d (%s expected, got nil)"",ndx,str)
/* luaL_register used once, so below expansion is OK for this case */
#define luaL_register(L,name,reg) lua_newtable(L);luaL_setfuncs(L,reg,0)
/* luaL_openlib always used with name == NULL */
#define luaL_openlib(L,name,reg,nup) luaL_setfuncs(L,reg,nup)
#define luaL_checkint(L,n)  ((int)luaL_checkinteger(L, (n)))

#define PUSH_INT64(L,i64in,fallback) \
    do { \
        sqlite_int64 i64 = i64in; \
        lua_Integer i = (lua_Integer )i64; \
        if (i == i64) lua_pushinteger(L, i);\
        else { \
            lua_Number n = (lua_Number)i64; \
            if (n == i64) lua_pushnumber(L, n); \
            else fallback; \
        } \
    } while (0)

typedef struct sdb sdb;
typedef struct sdb_vm sdb_vm;
typedef struct sdb_bu sdb_bu;
typedef struct sdb_func sdb_func;

/* to use as C user data so i know what function sqlite is calling */
struct sdb_func {
    /* references to associated lua values */
    int fn_step;
    int fn_finalize;
    int udata;

    sdb *db;
    char aggregate;

    sdb_func *next;
};

/* information about database */
struct sdb {
    /* associated lua state */
    lua_State *L;
    /* sqlite database handle */
    sqlite3 *db;

    /* sql functions stack usage */
    sdb_func *func;         /* top SQL function being called */

    /* references */
    int busy_cb;        /* busy callback */
    int busy_udata;

    int wal_hook_cb;    /* wal_hook callback */
    int wal_hook_udata;

    int update_hook_cb; /* update_hook callback */
    int update_hook_udata;

    int commit_hook_cb; /* commit_hook callback */
    int commit_hook_udata;

    int rollback_hook_cb; /* rollback_hook callback */
    int rollback_hook_udata;
};

static const char *const sqlite_meta      = "":sqlite3"";
static const char *const sqlite_vm_meta   = "":sqlite3:vm"";
static const char *const sqlite_ctx_meta  = "":sqlite3:ctx"";
static int sqlite_ctx_meta_ref;
#ifdef SQLITE_ENABLE_SESSION
static const char *const sqlite_ses_meta  = "":sqlite3:ses"";
static const char *const sqlite_reb_meta  = "":sqlite3:reb"";
static const char *const sqlite_itr_meta  = "":sqlite3:itr"";
static int sqlite_ses_meta_ref;
static int sqlite_reb_meta_ref;
static int sqlite_itr_meta_ref;
#endif
/* global config configuration */
static int log_cb = LUA_NOREF; /* log callback */
static int log_udata;

/*
** =======================================================
** Database Virtual Machine Operations
** =======================================================
*/

static void vm_push_column(lua_State *L, sqlite3_stmt *vm, int idx) {
    switch (sqlite3_column_type(vm, idx)) {
        case SQLITE_INTEGER:
            PUSH_INT64(L, sqlite3_column_int64(vm, idx)
                     , lua_pushlstring(L, (const char*)sqlite3_column_text(vm, idx)
                                        , sqlite3_column_bytes(vm, idx)));
            break;
        case SQLITE_FLOAT:
            lua_pushnumber(L, sqlite3_column_double(vm, idx));
            break;
        case SQLITE_TEXT:
            lua_pushlstring(L, (const char*)sqlite3_column_text(vm, idx), sqlite3_column_bytes(vm, idx));
            break;
        case SQLITE_BLOB:
            lua_pushlstring(L, sqlite3_column_blob(vm, idx), sqlite3_column_bytes(vm, idx));
            break;
        case SQLITE_NULL:
            lua_pushnil(L);
            break;
        default:
            lua_pushnil(L);
            break;
    }
}

/* virtual machine information */
struct sdb_vm {
    sdb *db;                /* associated database handle */
    sqlite3_stmt *vm;       /* virtual machine */

    /* sqlite3_step info */
    int columns;            /* number of columns in result */
    char has_values;        /* true when step succeeds */

    char temp;              /* temporary vm used in db:rows */
};

/* called with db,sql text on the lua stack */
static sdb_vm *newvm(lua_State *L, sdb *db) {
    sdb_vm *svm = (sdb_vm*)lua_newuserdata(L, sizeof(sdb_vm)); /* db sql svm_ud -- */

    luaL_getmetatable(L, sqlite_vm_meta);
    lua_setmetatable(L, -2);        /* set metatable */

    svm->db = db;
    svm->columns = 0;
    svm->has_values = 0;
    svm->vm = NULL;
    svm->temp = 0;

    /* add an entry on the database table: svm -> db to keep db live while svm is live */
    lua_pushlightuserdata(L, db);     /* db sql svm_ud db_lud -- */
    lua_rawget(L, LUA_REGISTRYINDEX); /* db sql svm_ud reg[db_lud] -- */
    lua_pushvalue(L, -2);             /* db sql svm_ud reg[db_lud] svm_ud -- */
    lua_pushvalue(L, -5);             /* db sql svm_ud reg[db_lud] svm_ud db -- */
    lua_rawset(L, -3);                /* (reg[db_lud])[svm_ud] = db ; set the db for this vm */
    lua_pop(L, 1);                    /* db sql svm_ud -- */

    return svm;
}

static int cleanupvm(lua_State *L, sdb_vm *svm) {
    svm->columns = 0;
    svm->has_values = 0;

    if (!svm->vm) return 0;
    lua_pushinteger(L, sqlite3_finalize(svm->vm));
    svm->vm = NULL;
    return 1;
}

static int stepvm(lua_State *L, sdb_vm *svm) {
    return sqlite3_step(svm->vm);
}

static sdb_vm *lsqlite_getvm(lua_State *L, int index) {
    sdb_vm *svm = (sdb_vm*)luaL_checkudata(L, index, sqlite_vm_meta);
    if (svm == NULL) luaL_argerror(L, index, ""bad sqlite virtual machine"");
    return svm;
}

static sdb_vm *lsqlite_checkvm(lua_State *L, int index) {
    sdb_vm *svm = lsqlite_getvm(L, index);
    if (svm->vm == NULL) luaL_argerror(L, index, ""attempt to use closed sqlite virtual machine"");
    return svm;
}

static int dbvm_isopen(lua_State *L) {
    sdb_vm *svm = lsqlite_getvm(L, 1);
    lua_pushboolean(L, svm->vm != NULL ? 1 : 0);
    return 1;
}

static int dbvm_readonly(lua_State *L) {
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    lua_pushboolean(L, sqlite3_stmt_readonly(svm->vm));
    return 1;
}

static int dbvm_tostring(lua_State *L) {
    char buff[40];
    sdb_vm *svm = lsqlite_getvm(L, 1);
    if (svm->vm == NULL)
        strcpy(buff, ""closed"");
    else
        sprintf(buff, ""%p"", svm);
    lua_pushfstring(L, ""sqlite virtual machine (%s)"", buff);
    return 1;
}

static int dbvm_gc(lua_State *L) {
    cleanupvm(L, lsqlite_getvm(L, 1));
    return 0;
}

static int dbvm_step(lua_State *L) {
    int result;
    sdb_vm *svm = lsqlite_checkvm(L, 1);

    result = stepvm(L, svm);
    svm->has_values = result == SQLITE_ROW ? 1 : 0;
    svm->columns = sqlite3_data_count(svm->vm);

    lua_pushinteger(L, result);
    return 1;
}

static int dbvm_finalize(lua_State *L) {
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    return cleanupvm(L, svm);
}

static int dbvm_reset(lua_State *L) {
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    sqlite3_reset(svm->vm);
    lua_pushinteger(L, sqlite3_errcode(svm->db->db));
    return 1;
}

static void dbvm_check_contents(lua_State *L, sdb_vm *svm) {
    if (!svm->has_values) {
        luaL_error(L, ""misuse of function"");
    }
}

static void dbvm_check_index(lua_State *L, sdb_vm *svm, int index) {
    if (index < 0 || index >= svm->columns) {
        luaL_error(L, ""index out of range [0..%d]"", svm->columns - 1);
    }
}

static void dbvm_check_bind_index(lua_State *L, sdb_vm *svm, int index) {
    if (index < 1 || index > sqlite3_bind_parameter_count(svm->vm)) {
        luaL_error(L, ""bind index out of range [1..%d]"", sqlite3_bind_parameter_count(svm->vm));
    }
}

static int dbvm_last_insert_rowid(lua_State *L) {
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    /* conversion warning: int64 -> luaNumber */
    sqlite_int64 rowid = sqlite3_last_insert_rowid(svm->db->db);
    PUSH_INT64(L, rowid, lua_pushfstring(L, ""%ll"", rowid));
    return 1;
}

/*
** =======================================================
** Virtual Machine - generic info
** =======================================================
*/
static int dbvm_columns(lua_State *L) {
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    lua_pushinteger(L, sqlite3_column_count(svm->vm));
    return 1;
}

/*
** =======================================================
** Virtual Machine - getters
** =======================================================
*/

static int dbvm_get_value(lua_State *L) {
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    int index = luaL_checkint(L, 2);
    dbvm_check_contents(L, svm);
    dbvm_check_index(L, svm, index);
    vm_push_column(L, svm->vm, index);
    return 1;
}

static int dbvm_get_name(lua_State *L) {
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    int index = luaL_checknumber(L, 2);
    dbvm_check_index(L, svm, index);
    lua_pushstring(L, sqlite3_column_name(svm->vm, index));
    return 1;
}

static int dbvm_get_type(lua_State *L) {
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    int index = luaL_checknumber(L, 2);
    dbvm_check_index(L, svm, index);
    lua_pushstring(L, sqlite3_column_decltype(svm->vm, index));
    return 1;
}

static int dbvm_get_values(lua_State *L) {
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    sqlite3_stmt *vm = svm->vm;
    int columns = svm->columns;
    int n;
    dbvm_check_contents(L, svm);

    lua_createtable(L, columns, 0);
    for (n = 0; n < columns;) {
        vm_push_column(L, vm, n++);
        lua_rawseti(L, -2, n);
    }
    return 1;
}

static int dbvm_get_names(lua_State *L) {
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    sqlite3_stmt *vm = svm->vm;
    int columns = sqlite3_column_count(vm); /* valid as soon as statement prepared */
    int n;

    lua_createtable(L, columns, 0);
    for (n = 0; n < columns;) {
        lua_pushstring(L, sqlite3_column_name(vm, n++));
        lua_rawseti(L, -2, n);
    }
    return 1;
}

static int dbvm_get_types(lua_State *L) {
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    sqlite3_stmt *vm = svm->vm;
    int columns = sqlite3_column_count(vm); /* valid as soon as statement prepared */
    int n;

    lua_createtable(L, columns, 0);
    for (n = 0; n < columns;) {
        lua_pushstring(L, sqlite3_column_decltype(vm, n++));
        lua_rawseti(L, -2, n);
    }
    return 1;
}

static int dbvm_get_uvalues(lua_State *L) {
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    sqlite3_stmt *vm = svm->vm;
    int columns = svm->columns;
    int n;
    dbvm_check_contents(L, svm);

    lua_checkstack(L, columns);
    for (n = 0; n < columns; ++n)
        vm_push_column(L, vm, n);
    return columns;
}

static int dbvm_get_unames(lua_State *L) {
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    sqlite3_stmt *vm = svm->vm;
    int columns = sqlite3_column_count(vm); /* valid as soon as statement prepared */
    int n;

    lua_checkstack(L, columns);
    for (n = 0; n < columns; ++n)
        lua_pushstring(L, sqlite3_column_name(vm, n));
    return columns;
}

static int dbvm_get_utypes(lua_State *L) {
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    sqlite3_stmt *vm = svm->vm;
    int columns = sqlite3_column_count(vm); /* valid as soon as statement prepared */
    int n;

    lua_checkstack(L, columns);
    for (n = 0; n < columns; ++n)
        lua_pushstring(L, sqlite3_column_decltype(vm, n));
    return columns;
}

static int dbvm_get_named_values(lua_State *L) {
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    sqlite3_stmt *vm = svm->vm;
    int columns = svm->columns;
    int n;
    dbvm_check_contents(L, svm);

    lua_createtable(L, 0, columns);
    for (n = 0; n < columns; ++n) {
        lua_pushstring(L, sqlite3_column_name(vm, n));
        vm_push_column(L, vm, n);
        lua_rawset(L, -3);
    }
    return 1;
}

static int dbvm_get_named_types(lua_State *L) {
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    sqlite3_stmt *vm = svm->vm;
    int columns = sqlite3_column_count(vm);
    int n;

    lua_createtable(L, 0, columns);
    for (n = 0; n < columns; ++n) {
        lua_pushstring(L, sqlite3_column_name(vm, n));
        lua_pushstring(L, sqlite3_column_decltype(vm, n));
        lua_rawset(L, -3);
    }
    return 1;
}

/*
** =======================================================
** Virtual Machine - Bind
** =======================================================
*/

static int dbvm_bind_index(lua_State *L, sqlite3_stmt *vm, int index, int lindex) {
    switch (lua_type(L, lindex)) {
        case LUA_TSTRING:
            return sqlite3_bind_text(vm, index, lua_tostring(L, lindex), lua_rawlen(L, lindex), SQLITE_TRANSIENT);
        case LUA_TNUMBER:
#if LUA_VERSION_NUM > 502
            if (lua_isinteger(L, lindex))
                return sqlite3_bind_int64(vm, index, lua_tointeger(L, lindex));
#endif
            return sqlite3_bind_double(vm, index, lua_tonumber(L, lindex));
        case LUA_TBOOLEAN:
            return sqlite3_bind_int(vm, index, lua_toboolean(L, lindex) ? 1 : 0);
        case LUA_TNONE:
        case LUA_TNIL:
            return sqlite3_bind_null(vm, index);
        default:
            luaL_error(L, ""index (%d) - invalid data type for bind (%s)"", index, lua_typename(L, lua_type(L, lindex)));
            return SQLITE_MISUSE; /*!*/
    }
}


static int dbvm_bind_parameter_count(lua_State *L) {
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    lua_pushinteger(L, sqlite3_bind_parameter_count(svm->vm));
    return 1;
}

static int dbvm_bind_parameter_name(lua_State *L) {
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    int index = luaL_checknumber(L, 2);
    dbvm_check_bind_index(L, svm, index);
    lua_pushstring(L, sqlite3_bind_parameter_name(svm->vm, index));
    return 1;
}

static int dbvm_bind(lua_State *L) {
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    sqlite3_stmt *vm = svm->vm;
    int index = luaL_checkint(L, 2);
    int result;

    dbvm_check_bind_index(L, svm, index);
    result = dbvm_bind_index(L, vm, index, 3);

    lua_pushinteger(L, result);
    return 1;
}

static int dbvm_bind_blob(lua_State *L) {
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    int index = luaL_checkint(L, 2);
    const char *value = luaL_checkstring(L, 3);
    int len = lua_rawlen(L, 3);

    lua_pushinteger(L, sqlite3_bind_blob(svm->vm, index, value, len, SQLITE_TRANSIENT));
    return 1;
}

static int dbvm_bind_values(lua_State *L) {
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    sqlite3_stmt *vm = svm->vm;
    int top = lua_gettop(L);
    int result, n;

    if (top - 1 != sqlite3_bind_parameter_count(vm))
        luaL_error(L,
            ""incorrect number of parameters to bind (%d given, %d to bind)"",
            top - 1,
            sqlite3_bind_parameter_count(vm)
        );

    for (n = 2; n <= top; ++n) {
        if ((result = dbvm_bind_index(L, vm, n - 1, n)) != SQLITE_OK) {
            lua_pushinteger(L, result);
            return 1;
        }
    }

    lua_pushinteger(L, SQLITE_OK);
    return 1;
}

static int dbvm_bind_names(lua_State *L) {
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    sqlite3_stmt *vm = svm->vm;
    int count = sqlite3_bind_parameter_count(vm);
    const char *name;
    int result, n;
    luaL_checktype(L, 2, LUA_TTABLE);

    for (n = 1; n <= count; ++n) {
        name = sqlite3_bind_parameter_name(vm, n);
        if (name && (name[0] == ':' || name[0] == '$')) {
            lua_pushstring(L, ++name);
            lua_gettable(L, 2);
            result = dbvm_bind_index(L, vm, n, -1);
            lua_pop(L, 1);
        }
        else {
            lua_pushinteger(L, n);
            lua_gettable(L, 2);
            result = dbvm_bind_index(L, vm, n, -1);
            lua_pop(L, 1);
        }

        if (result != SQLITE_OK) {
            lua_pushinteger(L, result);
            return 1;
        }
    }

    lua_pushinteger(L, SQLITE_OK);
    return 1;
}

/*
** =======================================================
** Database (internal management)
** =======================================================
*/

/*
** When creating database handles, always creates a `closed' database handle
** before opening the actual database; so, if there is a memory error, the
** database is not left opened.
**
** Creates a new 'table' and leaves it in the stack
*/
static sdb *newdb (lua_State *L) {
    sdb *db = (sdb*)lua_newuserdata(L, sizeof(sdb));
    db->L = L;
    db->db = NULL;  /* database handle is currently `closed' */
    db->func = NULL;

    db->busy_cb =
    db->busy_udata =
    db->wal_hook_cb =
    db->wal_hook_udata =
    db->update_hook_cb =
    db->update_hook_udata =
    db->commit_hook_cb =
    db->commit_hook_udata =
    db->rollback_hook_cb =
    db->rollback_hook_udata =
        LUA_NOREF;

    luaL_getmetatable(L, sqlite_meta);
    lua_setmetatable(L, -2);        /* set metatable */

    /* to keep track of 'open' virtual machines; make keys week */
    lua_pushlightuserdata(L, db);
    lua_newtable(L);                    // t
    lua_newtable(L);                    // t mt
    lua_pushstring(L, ""k"");             // t mt v
    lua_setfield(L, -2, ""__mode"");      // t mt
    lua_setmetatable(L, -2);            // t
    lua_rawset(L, LUA_REGISTRYINDEX);

    return db;
}

/* cleanup all vms or just temporary ones */
static void closevms(lua_State *L, sdb *db, int temp) {
    /* free associated virtual machines */
    lua_pushlightuserdata(L, db);
    lua_rawget(L, LUA_REGISTRYINDEX);

    /* close all used handles */
    lua_pushnil(L);
    while (lua_next(L, -2)) {
        sdb_vm *svm = lua_touserdata(L, -2); /* key: vm; val: sql text */
        if ((!temp || svm->temp)) lua_pop(L, cleanupvm(L, svm));
        lua_pop(L, 1); /* pop value; leave key in the stack */
    }
}

static int cleanupdb(lua_State *L, sdb *db) {
    sdb_func *func;
    sdb_func *func_next;
    int top = lua_gettop(L);
    int result;

    if (!db->db) return SQLITE_MISUSE;

    closevms(L, db, 0);

    /* remove entry in lua registry table */
    lua_pushlightuserdata(L, db);
    lua_pushnil(L);
    lua_rawset(L, LUA_REGISTRYINDEX);

    /* 'free' all references */
    luaL_unref(L, LUA_REGISTRYINDEX, db->busy_cb);
    luaL_unref(L, LUA_REGISTRYINDEX, db->busy_udata);
    luaL_unref(L, LUA_REGISTRYINDEX, db->wal_hook_cb);
    luaL_unref(L, LUA_REGISTRYINDEX, db->wal_hook_udata);
    luaL_unref(L, LUA_REGISTRYINDEX, db->update_hook_cb);
    luaL_unref(L, LUA_REGISTRYINDEX, db->update_hook_udata);
    luaL_unref(L, LUA_REGISTRYINDEX, db->commit_hook_cb);
    luaL_unref(L, LUA_REGISTRYINDEX, db->commit_hook_udata);
    luaL_unref(L, LUA_REGISTRYINDEX, db->rollback_hook_cb);
    luaL_unref(L, LUA_REGISTRYINDEX, db->rollback_hook_udata);

    /* close database; _v2 is intended for use with garbage collected languages
       and where the order in which destructors are called is arbitrary. */
    result = sqlite3_close_v2(db->db);
    db->db = NULL;

    /* free associated memory with created functions */
    func = db->func;
    while (func) {
        func_next = func->next;
        luaL_unref(L, LUA_REGISTRYINDEX, func->fn_step);
        luaL_unref(L, LUA_REGISTRYINDEX, func->fn_finalize);
        luaL_unref(L, LUA_REGISTRYINDEX, func->udata);
        free(func);
        func = func_next;
    }
    db->func = NULL;

    lua_settop(L, top);
    return result;
}

static sdb *lsqlite_getdb(lua_State *L, int index) {
    sdb *db = (sdb*)luaL_checkudata(L, index, sqlite_meta);
    if (db == NULL) luaL_typerror(L, index, ""sqlite database"");
    return db;
}

static sdb *lsqlite_checkdb(lua_State *L, int index) {
    sdb *db = lsqlite_getdb(L, index);
    if (db->db == NULL) luaL_argerror(L, index, ""attempt to use closed sqlite database"");
    return db;
}


/*
** =======================================================
** User Defined Functions - Context Methods
** =======================================================
*/
typedef struct {
    sqlite3_context *ctx;
    int ud;
} lcontext;

static lcontext *lsqlite_make_context(lua_State *L) {
    lcontext *ctx = (lcontext*)lua_newuserdata(L, sizeof(lcontext));
    lua_rawgeti(L, LUA_REGISTRYINDEX, sqlite_ctx_meta_ref);
    lua_setmetatable(L, -2);
    ctx->ctx = NULL;
    ctx->ud = LUA_NOREF;
    return ctx;
}

static lcontext *lsqlite_getcontext(lua_State *L, int index) {
    lcontext *ctx = (lcontext*)luaL_checkudata(L, index, sqlite_ctx_meta);
    if (ctx == NULL) luaL_typerror(L, index, ""sqlite context"");
    return ctx;
}

static lcontext *lsqlite_checkcontext(lua_State *L, int index) {
    lcontext *ctx = lsqlite_getcontext(L, index);
    if (ctx->ctx == NULL) luaL_argerror(L, index, ""invalid sqlite context"");
    return ctx;
}

static int lcontext_tostring(lua_State *L) {
    char buff[41];
    lcontext *ctx = lsqlite_getcontext(L, 1);
    if (ctx->ctx == NULL)
        strcpy(buff, ""closed"");
    else
        sprintf(buff, ""%p"", ctx->ctx);
    lua_pushfstring(L, ""sqlite function context (%s)"", buff);
    return 1;
}

static void lcontext_check_aggregate(lua_State *L, lcontext *ctx) {
    sdb_func *func = (sdb_func*)sqlite3_user_data(ctx->ctx);
    if (!func->aggregate) {
        luaL_error(L, ""attempt to call aggregate method from scalar function"");
    }
}

static int lcontext_user_data(lua_State *L) {
    lcontext *ctx = lsqlite_checkcontext(L, 1);
    sdb_func *func = (sdb_func*)sqlite3_user_data(ctx->ctx);
    lua_rawgeti(L, LUA_REGISTRYINDEX, func->udata);
    return 1;
}

static int lcontext_get_aggregate_context(lua_State *L) {
    lcontext *ctx = lsqlite_checkcontext(L, 1);
    lcontext_check_aggregate(L, ctx);
    lua_rawgeti(L, LUA_REGISTRYINDEX, ctx->ud);
    return 1;
}

static int lcontext_set_aggregate_context(lua_State *L) {
    lcontext *ctx = lsqlite_checkcontext(L, 1);
    lcontext_check_aggregate(L, ctx);
    lua_settop(L, 2);
    luaL_unref(L, LUA_REGISTRYINDEX, ctx->ud);
    ctx->ud = luaL_ref(L, LUA_REGISTRYINDEX);
    return 0;
}

#if 0
void *sqlite3_get_auxdata(sqlite3_context*, int);
void sqlite3_set_auxdata(sqlite3_context*, int, void*, void (*)(void*));
#endif

static int lcontext_result(lua_State *L) {
    lcontext *ctx = lsqlite_checkcontext(L, 1);
    switch (lua_type(L, 2)) {
        case LUA_TNUMBER:
#if LUA_VERSION_NUM > 502
            if (lua_isinteger(L, 2))
                sqlite3_result_int64(ctx->ctx, luaL_checkinteger(L, 2));
            else
#endif
            sqlite3_result_double(ctx->ctx, luaL_checknumber(L, 2));
            break;
        case LUA_TSTRING:
            sqlite3_result_text(ctx->ctx, luaL_checkstring(L, 2), lua_rawlen(L, 2), SQLITE_TRANSIENT);
            break;
        case LUA_TNIL:
        case LUA_TNONE:
            sqlite3_result_null(ctx->ctx);
            break;
        default:
            luaL_error(L, ""invalid result type %s"", lua_typename(L, 2));
            break;
    }

    return 0;
}

static int lcontext_result_blob(lua_State *L) {
    lcontext *ctx = lsqlite_checkcontext(L, 1);
    const char *blob = luaL_checkstring(L, 2);
    int size = lua_rawlen(L, 2);
    sqlite3_result_blob(ctx->ctx, (const void*)blob, size, SQLITE_TRANSIENT);
    return 0;
}

static int lcontext_result_double(lua_State *L) {
    lcontext *ctx = lsqlite_checkcontext(L, 1);
    double d = luaL_checknumber(L, 2);
    sqlite3_result_double(ctx->ctx, d);
    return 0;
}

static int lcontext_result_error(lua_State *L) {
    lcontext *ctx = lsqlite_checkcontext(L, 1);
    const char *err = luaL_checkstring(L, 2);
    int size = lua_rawlen(L, 2);
    sqlite3_result_error(ctx->ctx, err, size);
    return 0;
}

static int lcontext_result_int(lua_State *L) {
    lcontext *ctx = lsqlite_checkcontext(L, 1);
    int i = luaL_checkint(L, 2);
    sqlite3_result_int(ctx->ctx, i);
    return 0;
}

static int lcontext_result_null(lua_State *L) {
    lcontext *ctx = lsqlite_checkcontext(L, 1);
    sqlite3_result_null(ctx->ctx);
    return 0;
}

static int lcontext_result_text(lua_State *L) {
    lcontext *ctx = lsqlite_checkcontext(L, 1);
    const char *text = luaL_checkstring(L, 2);
    int size = lua_rawlen(L, 2);
    sqlite3_result_text(ctx->ctx, text, size, SQLITE_TRANSIENT);
    return 0;
}

/*
** =======================================================
** Database Methods
** =======================================================
*/

static int db_isopen(lua_State *L) {
    sdb *db = lsqlite_getdb(L, 1);
    lua_pushboolean(L, db->db != NULL ? 1 : 0);
    return 1;
}

static int db_last_insert_rowid(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);
    /* conversion warning: int64 -> luaNumber */
    sqlite_int64 rowid = sqlite3_last_insert_rowid(db->db);
    PUSH_INT64(L, rowid, lua_pushfstring(L, ""%ll"", rowid));
    return 1;
}

static int db_changes(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);
    lua_pushinteger(L, sqlite3_changes(db->db));
    return 1;
}

static int db_total_changes(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);
    lua_pushinteger(L, sqlite3_total_changes(db->db));
    return 1;
}

static int db_errcode(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);
    lua_pushinteger(L, sqlite3_errcode(db->db));
    return 1;
}

static int db_errmsg(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);
    lua_pushstring(L, sqlite3_errmsg(db->db));
    return 1;
}

static int db_interrupt(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);
    sqlite3_interrupt(db->db);
    return 0;
}

static int db_db_filename(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);
    const char *db_name = luaL_checkstring(L, 2);
    // sqlite3_db_filename may return NULL, in that case Lua pushes nil...
    lua_pushstring(L, sqlite3_db_filename(db->db, db_name));
    return 1;
}

static int pusherr(lua_State *L, int rc) {
    lua_pushnil(L);
    lua_pushinteger(L, rc);
    return 2;
}

static int pusherrstr(lua_State *L, char *str) {
    lua_pushnil(L);
    lua_pushstring(L, str);
    return 2;
}

static int db_readonly(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);
    const char *zDb = luaL_optstring(L, 2, ""main"");
    int res = sqlite3_db_readonly(db->db, zDb);
    if (res == -1) return pusherrstr(L, ""unknown (not attached) database name"");
    lua_pushboolean(L, res);
    return 1;
}

static int db_wal_checkpoint(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);
    int eMode = luaL_optinteger(L, 2, SQLITE_CHECKPOINT_PASSIVE);
    const char *db_name = luaL_optstring(L, 3, NULL);
    int nLog, nCkpt;
    if (sqlite3_wal_checkpoint_v2(db->db, db_name, eMode, &nLog, &nCkpt) != SQLITE_OK) {
        return pusherr(L, sqlite3_errcode(db->db));
    }
    lua_pushinteger(L, nLog);
    lua_pushinteger(L, nCkpt);
    return 2;
}

/*
** Registering SQL functions:
*/

static void db_push_value(lua_State *L, sqlite3_value *value) {
    switch (sqlite3_value_type(value)) {
        case SQLITE_TEXT:
            lua_pushlstring(L, (const char*)sqlite3_value_text(value), sqlite3_value_bytes(value));
            break;

        case SQLITE_INTEGER:
            PUSH_INT64(L, sqlite3_value_int64(value)
                        , lua_pushlstring(L, (const char*)sqlite3_value_text(value)
                                            , sqlite3_value_bytes(value)));
            break;

        case SQLITE_FLOAT:
            lua_pushnumber(L, sqlite3_value_double(value));
            break;

        case SQLITE_BLOB:
            lua_pushlstring(L, sqlite3_value_blob(value), sqlite3_value_bytes(value));
            break;

        case SQLITE_NULL:
            lua_pushnil(L);
            break;

        default:
            /* things done properly (SQLite + Lua SQLite)
            ** this should never happen */
            lua_pushnil(L);
            break;
    }
}

/*
** callback functions used when calling registered sql functions
*/

/* scalar function to be called
** callback params: context, values... */
static void db_sql_normal_function(sqlite3_context *context, int argc, sqlite3_value **argv) {
    sdb_func *func = (sdb_func*)sqlite3_user_data(context);
    lua_State *L = func->db->L;
    int n;
    lcontext *ctx;

    int top = lua_gettop(L);

    /* ensure there is enough space in the stack */
    lua_checkstack(L, argc + 3);

    lua_rawgeti(L, LUA_REGISTRYINDEX, func->fn_step);   /* function to call */

    if (!func->aggregate) {
        ctx = lsqlite_make_context(L); /* push context - used to set results */
    }
    else {
        /* reuse context userdata value */
        void *p = sqlite3_aggregate_context(context, 1);
        /* i think it is OK to use assume that using a light user data
        ** as an entry on LUA REGISTRY table will be unique */
        lua_pushlightuserdata(L, p);
        lua_rawget(L, LUA_REGISTRYINDEX);       /* context table */

        if (lua_isnil(L, -1)) { /* not yet created? */
            lua_pop(L, 1);
            ctx = lsqlite_make_context(L);
            lua_pushlightuserdata(L, p);
            lua_pushvalue(L, -2);
            lua_rawset(L, LUA_REGISTRYINDEX);
        }
        else
            ctx = lsqlite_getcontext(L, -1);
    }

    /* push params */
    for (n = 0; n < argc; ++n) {
        db_push_value(L, argv[n]);
    }

    /* set context */
    ctx->ctx = context;

    if (lua_pcall(L, argc + 1, 0, 0)) {
        const char *errmsg = lua_tostring(L, -1);
        int size = lua_rawlen(L, -1);
        sqlite3_result_error(context, errmsg, size);
    }

    /* invalidate context */
    ctx->ctx = NULL;

    if (!func->aggregate) {
        luaL_unref(L, LUA_REGISTRYINDEX, ctx->ud);
    }

    lua_settop(L, top);
}

static void db_sql_finalize_function(sqlite3_context *context) {
    sdb_func *func = (sdb_func*)sqlite3_user_data(context);
    lua_State *L = func->db->L;
    void *p = sqlite3_aggregate_context(context, 1); /* minimal mem usage */
    lcontext *ctx;
    int top = lua_gettop(L);

    lua_rawgeti(L, LUA_REGISTRYINDEX, func->fn_finalize);   /* function to call */

    /* i think it is OK to use assume that using a light user data
    ** as an entry on LUA REGISTRY table will be unique */
    lua_pushlightuserdata(L, p);
    lua_rawget(L, LUA_REGISTRYINDEX);       /* context table */

    if (lua_isnil(L, -1)) { /* not yet created? - shouldn't happen in finalize function */
        lua_pop(L, 1);
        ctx = lsqlite_make_context(L);
        lua_pushlightuserdata(L, p);
        lua_pushvalue(L, -2);
        lua_rawset(L, LUA_REGISTRYINDEX);
    }
    else
        ctx = lsqlite_getcontext(L, -1);

    /* set context */
    ctx->ctx = context;

    if (lua_pcall(L, 1, 0, 0)) {
        sqlite3_result_error(context, lua_tostring(L, -1), -1);
    }

    /* invalidate context */
    ctx->ctx = NULL;

    /* cleanup context */
    luaL_unref(L, LUA_REGISTRYINDEX, ctx->ud);
    /* remove it from registry */
    lua_pushlightuserdata(L, p);
    lua_pushnil(L);
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_settop(L, top);
}

/*
** Register a normal function
** Params: db, function name, number arguments, [ callback | step, finalize], user data
** Returns: true on success
**
** Normal function:
** Params: context, params
**
** Aggregate function:
** Params of step: context, params
** Params of finalize: context
*/
static int db_register_function(lua_State *L, int aggregate) {
    sdb *db = lsqlite_checkdb(L, 1);
    const char *name;
    int args;
    int result;
    sdb_func *func;

    /* safety measure */
    if (aggregate) aggregate = 1;

    name = luaL_checkstring(L, 2);
    args = luaL_checkint(L, 3);
    luaL_checktype(L, 4, LUA_TFUNCTION);
    if (aggregate) luaL_checktype(L, 5, LUA_TFUNCTION);

    /* maybe an alternative way to allocate memory should be used/avoided */
    func = (sdb_func*)malloc(sizeof(sdb_func));
    if (func == NULL) {
        luaL_error(L, ""out of memory"");
    }

    result = sqlite3_create_function(
        db->db, name, args, SQLITE_UTF8, func,
        aggregate ? NULL : db_sql_normal_function,
        aggregate ? db_sql_normal_function : NULL,
        aggregate ? db_sql_finalize_function : NULL
    );

    if (result == SQLITE_OK) {
        /* safety measures for userdata field to be present in the stack */
        lua_settop(L, 5 + aggregate);

        /* save registered function in db function list */
        func->db = db;
        func->aggregate = aggregate;
        func->next = db->func;
        db->func = func;

        /* save the setp/normal function callback */
        lua_pushvalue(L, 4);
        func->fn_step = luaL_ref(L, LUA_REGISTRYINDEX);
        /* save user data */
        lua_pushvalue(L, 5+aggregate);
        func->udata = luaL_ref(L, LUA_REGISTRYINDEX);

        if (aggregate) {
            lua_pushvalue(L, 5);
            func->fn_finalize = luaL_ref(L, LUA_REGISTRYINDEX);
        }
        else
            func->fn_finalize = LUA_NOREF;
    }
    else {
        /* free allocated memory */
        free(func);
    }

    lua_pushboolean(L, result == SQLITE_OK ? 1 : 0);
    return 1;
}

static int db_create_function(lua_State *L) {
    return db_register_function(L, 0);
}

static int db_create_aggregate(lua_State *L) {
    return db_register_function(L, 1);
}

/* create_collation; contributed by Thomas Lauer
*/

typedef struct {
    lua_State *L;
    int ref;
} scc;

static int collwrapper(scc *co,int l1,const void *p1,
                        int l2,const void *p2) {
    int res=0;
    lua_State *L=co->L;
    lua_rawgeti(L,LUA_REGISTRYINDEX,co->ref);
    lua_pushlstring(L,p1,l1);
    lua_pushlstring(L,p2,l2);
    if (lua_pcall(L,2,1,0)==0) res=(int)lua_tonumber(L,-1);
    lua_pop(L,1);
    return res;
}

static void collfree(scc *co) {
    if (co) {
        luaL_unref(co->L,LUA_REGISTRYINDEX,co->ref);
        free(co);
    }
}

static int db_create_collation(lua_State *L) {
    sdb *db=lsqlite_checkdb(L,1);
    const char *collname=luaL_checkstring(L,2);
    scc *co=NULL;
    int (*collfunc)(scc *,int,const void *,int,const void *)=NULL;
    lua_settop(L,3); /* default args to nil, and exclude extras */
    if (lua_isfunction(L,3)) collfunc=collwrapper;
    else if (!lua_isnil(L,3))
        luaL_error(L,""create_collation: function or nil expected"");
    if (collfunc != NULL) {
        co=(scc *)malloc(sizeof(scc)); /* userdata is a no-no as it
                                          will be garbage-collected */
        if (co) {
            co->L=L;
            /* lua_settop(L,3) above means we don't need: lua_pushvalue(L,3); */
            co->ref=luaL_ref(L,LUA_REGISTRYINDEX);
        }
        else luaL_error(L,""create_collation: could not allocate callback"");
    }
    sqlite3_create_collation_v2(db->db, collname, SQLITE_UTF8,
        (void *)co,
        (int(*)(void*,int,const void*,int,const void*))collfunc,
        (void(*)(void*))collfree);
    return 0;
}

/*
** wal_hook callback:
** Params: database, callback function, userdata
**
** callback function:
** Params: userdata, db handle, database name, number of wal file pages
*/
static int db_wal_hook_callback(void *user, sqlite3 *dbh, char const *dbname, int pnum) {
    sdb *db = (sdb*)user;
    lua_State *L = db->L;
    int top = lua_gettop(L);

    /* setup lua callback call */
    lua_rawgeti(L, LUA_REGISTRYINDEX, db->wal_hook_cb);    /* get callback */
    lua_rawgeti(L, LUA_REGISTRYINDEX, db->wal_hook_udata); /* get callback user data */
    lua_pushstring(L, dbname); /* hook database name */
    lua_pushinteger(L, pnum);

    if (lua_pcall(L, 3, 0, 0) != LUA_OK) return lua_error(L);

    lua_settop(L, top);
    return SQLITE_OK;
}

static int db_wal_hook(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);

    luaL_unref(L, LUA_REGISTRYINDEX, db->wal_hook_cb);
    luaL_unref(L, LUA_REGISTRYINDEX, db->wal_hook_udata);
    if (lua_gettop(L) < 2 || lua_isnil(L, 2)) {
        db->wal_hook_cb =
        db->wal_hook_udata = LUA_NOREF;

        /* clear hook handler */
        sqlite3_wal_hook(db->db, NULL, NULL);
    }
    else {
        luaL_checktype(L, 2, LUA_TFUNCTION);

        /* make sure we have an userdata field (even if nil) */
        lua_settop(L, 3);

        db->wal_hook_udata = luaL_ref(L, LUA_REGISTRYINDEX);
        db->wal_hook_cb = luaL_ref(L, LUA_REGISTRYINDEX);

        /* set hook handler */
        sqlite3_wal_hook(db->db, db_wal_hook_callback, db);
    }

    return 0;
}

/*
** update_hook callback:
** Params: database, callback function, userdata
**
** callback function:
** Params: userdata, {one of SQLITE_INSERT, SQLITE_DELETE, or SQLITE_UPDATE},
**          database name, table name (containing the affected row), rowid of the row
*/
static void db_update_hook_callback(void *user, int op, char const *dbname, char const *tblname, sqlite3_int64 rowid) {
    sdb *db = (sdb*)user;
    lua_State *L = db->L;
    int top = lua_gettop(L);

    /* setup lua callback call */
    lua_rawgeti(L, LUA_REGISTRYINDEX, db->update_hook_cb);    /* get callback */
    lua_rawgeti(L, LUA_REGISTRYINDEX, db->update_hook_udata); /* get callback user data */
    lua_pushinteger(L, op);
    lua_pushstring(L, dbname); /* update_hook database name */
    lua_pushstring(L, tblname); /* update_hook database name */

    PUSH_INT64(L, rowid, lua_pushfstring(L, ""%ll"", rowid));

    /* call lua function */
    lua_pcall(L, 5, 0, 0);
    /* ignore any error generated by this function */

    lua_settop(L, top);
}

static int db_update_hook(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);

    luaL_unref(L, LUA_REGISTRYINDEX, db->update_hook_cb);
    luaL_unref(L, LUA_REGISTRYINDEX, db->update_hook_udata);
    if (lua_gettop(L) < 2 || lua_isnil(L, 2)) {

        db->update_hook_cb =
        db->update_hook_udata = LUA_NOREF;

        /* clear update_hook handler */
        sqlite3_update_hook(db->db, NULL, NULL);
    }
    else {
        luaL_checktype(L, 2, LUA_TFUNCTION);

        /* make sure we have an userdata field (even if nil) */
        lua_settop(L, 3);

        db->update_hook_udata = luaL_ref(L, LUA_REGISTRYINDEX);
        db->update_hook_cb = luaL_ref(L, LUA_REGISTRYINDEX);

        /* set update_hook handler */
        sqlite3_update_hook(db->db, db_update_hook_callback, db);
    }

    return 0;
}

/*
** commit_hook callback:
** Params: database, callback function, userdata
**
** callback function:
** Params: userdata
** Returned value: Return false or nil to continue the COMMIT operation normally.
**  return true (non false, non nil), then the COMMIT is converted into a ROLLBACK.
*/
static int db_commit_hook_callback(void *user) {
    sdb *db = (sdb*)user;
    lua_State *L = db->L;
    int top = lua_gettop(L);
    int rollback = 0;

    /* setup lua callback call */
    lua_rawgeti(L, LUA_REGISTRYINDEX, db->commit_hook_cb);    /* get callback */
    lua_rawgeti(L, LUA_REGISTRYINDEX, db->commit_hook_udata); /* get callback user data */

    /* call lua function */
    if (!lua_pcall(L, 1, 1, 0))
        rollback = lua_toboolean(L, -1); /* use result if there was no error */

    lua_settop(L, top);
    return rollback;
}

static int db_commit_hook(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);

    luaL_unref(L, LUA_REGISTRYINDEX, db->commit_hook_cb);
    luaL_unref(L, LUA_REGISTRYINDEX, db->commit_hook_udata);
    if (lua_gettop(L) < 2 || lua_isnil(L, 2)) {

        db->commit_hook_cb =
        db->commit_hook_udata = LUA_NOREF;

        /* clear commit_hook handler */
        sqlite3_commit_hook(db->db, NULL, NULL);
    }
    else {
        luaL_checktype(L, 2, LUA_TFUNCTION);

        /* make sure we have an userdata field (even if nil) */
        lua_settop(L, 3);

        db->commit_hook_udata = luaL_ref(L, LUA_REGISTRYINDEX);
        db->commit_hook_cb = luaL_ref(L, LUA_REGISTRYINDEX);

        /* set commit_hook handler */
        sqlite3_commit_hook(db->db, db_commit_hook_callback, db);
    }

    return 0;
}

/*
** rollback hook callback:
** Params: database, callback function, userdata
**
** callback function:
** Params: userdata
*/
static void db_rollback_hook_callback(void *user) {
    sdb *db = (sdb*)user;
    lua_State *L = db->L;
    int top = lua_gettop(L);

    /* setup lua callback call */
    lua_rawgeti(L, LUA_REGISTRYINDEX, db->rollback_hook_cb);    /* get callback */
    lua_rawgeti(L, LUA_REGISTRYINDEX, db->rollback_hook_udata); /* get callback user data */

    /* call lua function */
    lua_pcall(L, 1, 0, 0);
    /* ignore any error generated by this function */

    lua_settop(L, top);
}

static int db_rollback_hook(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);

    luaL_unref(L, LUA_REGISTRYINDEX, db->rollback_hook_cb);
    luaL_unref(L, LUA_REGISTRYINDEX, db->rollback_hook_udata);
    if (lua_gettop(L) < 2 || lua_isnil(L, 2)) {

        db->rollback_hook_cb =
        db->rollback_hook_udata = LUA_NOREF;

        /* clear rollback_hook handler */
        sqlite3_rollback_hook(db->db, NULL, NULL);
    }
    else {
        luaL_checktype(L, 2, LUA_TFUNCTION);

        /* make sure we have an userdata field (even if nil) */
        lua_settop(L, 3);

        db->rollback_hook_udata = luaL_ref(L, LUA_REGISTRYINDEX);
        db->rollback_hook_cb = luaL_ref(L, LUA_REGISTRYINDEX);

        /* set rollback_hook handler */
        sqlite3_rollback_hook(db->db, db_rollback_hook_callback, db);
    }

    return 0;
}

/*
** busy handler:
** Params: database, callback function, userdata
**
** callback function:
** Params: userdata, number of tries
** returns: 0 to return immediately and return SQLITE_BUSY, non-zero to try again
*/
static int db_busy_callback(void *user, int tries) {
    int retry = 0; /* abort by default */
    sdb *db = (sdb*)user;
    lua_State *L = db->L;
    int top = lua_gettop(L);

    lua_rawgeti(L, LUA_REGISTRYINDEX, db->busy_cb);
    lua_rawgeti(L, LUA_REGISTRYINDEX, db->busy_udata);
    lua_pushinteger(L, tries);

    /* call lua function */
    if (!lua_pcall(L, 2, 1, 0))
        retry = lua_toboolean(L, -1);

    lua_settop(L, top);
    return retry;
}

static int db_busy_handler(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);

    luaL_unref(L, LUA_REGISTRYINDEX, db->busy_cb);
    luaL_unref(L, LUA_REGISTRYINDEX, db->busy_udata);
    if (lua_gettop(L) < 2 || lua_isnil(L, 2)) {

        db->busy_cb =
        db->busy_udata = LUA_NOREF;

        /* clear busy handler */
        sqlite3_busy_handler(db->db, NULL, NULL);
    }
    else {
        luaL_checktype(L, 2, LUA_TFUNCTION);
        /* make sure we have an userdata field (even if nil) */
        lua_settop(L, 3);

        db->busy_udata = luaL_ref(L, LUA_REGISTRYINDEX);
        db->busy_cb = luaL_ref(L, LUA_REGISTRYINDEX);

        /* set busy handler */
        sqlite3_busy_handler(db->db, db_busy_callback, db);
    }

    return 0;
}

static int db_busy_timeout(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);
    int timeout = luaL_checkint(L, 2);
    sqlite3_busy_timeout(db->db, timeout);

    /* if there was a timeout callback registered, it is now
    ** invalid/useless. free any references we may have */
    luaL_unref(L, LUA_REGISTRYINDEX, db->busy_cb);
    luaL_unref(L, LUA_REGISTRYINDEX, db->busy_udata);
    db->busy_cb =
    db->busy_udata = LUA_NOREF;

    return 0;
}

/*
** Params: db, sql, callback, user
** returns: code [, errmsg]
**
** Callback:
** Params: user, number of columns, values, names
** Returns: 0 to continue, other value will cause abort
*/
static int db_exec_callback(void* user, int columns, char **data, char **names) {
    int result = SQLITE_ABORT; /* abort by default */
    lua_State *L = (lua_State*)user;
    int n;

    int top = lua_gettop(L);

    lua_pushvalue(L, 3); /* function to call */
    lua_pushvalue(L, 4); /* user data */
    lua_pushinteger(L, columns); /* total number of rows in result */

    /* column values */
    lua_pushvalue(L, 6);
    for (n = 0; n < columns;) {
        lua_pushstring(L, data[n++]);
        lua_rawseti(L, -2, n);
    }

    /* columns names */
    lua_pushvalue(L, 5);
    if (lua_isnil(L, -1)) {
        lua_pop(L, 1);
        lua_createtable(L, columns, 0);
        lua_pushvalue(L, -1);
        lua_replace(L, 5);
        for (n = 0; n < columns;) {
            lua_pushstring(L, names[n++]);
            lua_rawseti(L, -2, n);
        }
    }

    /* call lua function */
    if (!lua_pcall(L, 4, 1, 0)) {

#if LUA_VERSION_NUM > 502
        if (lua_isinteger(L, -1))
            result = lua_tointeger(L, -1);
        else
#endif
        if (lua_isnumber(L, -1))
            result = lua_tonumber(L, -1);
    }

    lua_settop(L, top);
    return result;
}

static int db_exec(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);
    const char *sql = luaL_checkstring(L, 2);
    int result;

    if (!lua_isnoneornil(L, 3)) {
        /* stack:
        **  3: callback function
        **  4: userdata
        **  5: column names
        **  6: reusable column values
        */
        luaL_checktype(L, 3, LUA_TFUNCTION);
        lua_settop(L, 4);   /* 'trap' userdata - nil extra parameters */
        lua_pushnil(L);     /* column names not known at this point */
        lua_newtable(L);    /* column values table */

        result = sqlite3_exec(db->db, sql, db_exec_callback, L, NULL);
    }
    else {
        /* no callbacks */
        result = sqlite3_exec(db->db, sql, NULL, NULL, NULL);
    }

    lua_pushinteger(L, result);
    return 1;
}

/*
** Params: db, sql
** returns: code, compiled length or error message
*/
static int db_prepare(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);
    const char *sql = luaL_checkstring(L, 2);
    int sql_len = lua_rawlen(L, 2);
    const char *sqltail;
    sdb_vm *svm;
    lua_settop(L,2); /* db,sql is on top of stack for call to newvm */
    svm = newvm(L, db);

    if (sqlite3_prepare_v2(db->db, sql, sql_len, &svm->vm, &sqltail) != SQLITE_OK) {
        lua_pushnil(L);
        lua_pushinteger(L, sqlite3_errcode(db->db));
        if (cleanupvm(L, svm) == 1)
            lua_pop(L, 1); /* this should not happen since sqlite3_prepare_v2 will not set ->vm on error */
        return 2;
    }

    /* vm already in the stack */
    lua_pushstring(L, sqltail);
    return 2;
}

static int db_do_next_row(lua_State *L, int packed) {
    int result;
    sdb_vm *svm = lsqlite_checkvm(L, 1);
    sqlite3_stmt *vm;
    int columns;
    int i;

    result = stepvm(L, svm);
    vm = svm->vm; /* stepvm may change svm->vm if re-prepare is needed */
    svm->has_values = result == SQLITE_ROW ? 1 : 0;
    svm->columns = columns = sqlite3_data_count(vm);

    if (result == SQLITE_ROW) {
        if (packed) {
            if (packed == 1) {
                lua_createtable(L, columns, 0);
                for (i = 0; i < columns;) {
                    vm_push_column(L, vm, i);
                    lua_rawseti(L, -2, ++i);
                }
            }
            else {
                lua_createtable(L, 0, columns);
                for (i = 0; i < columns; ++i) {
                    lua_pushstring(L, sqlite3_column_name(vm, i));
                    vm_push_column(L, vm, i);
                    lua_rawset(L, -3);
                }
            }
            return 1;
        }
        else {
            lua_checkstack(L, columns);
            for (i = 0; i < columns; ++i)
                vm_push_column(L, vm, i);
            return svm->columns;
        }
    }

    if (svm->temp) {
        /* finalize and check for errors */
        result = sqlite3_finalize(vm);
        svm->vm = NULL;
        cleanupvm(L, svm);
    }
    else if (result == SQLITE_DONE) {
        result = sqlite3_reset(vm);
    }

    if (result != SQLITE_OK) {
        lua_pushstring(L, sqlite3_errmsg(svm->db->db));
        lua_error(L);
    }
    return 0;
}

static int db_next_row(lua_State *L) {
    return db_do_next_row(L, 0);
}

static int db_next_packed_row(lua_State *L) {
    return db_do_next_row(L, 1);
}

static int db_next_named_row(lua_State *L) {
    return db_do_next_row(L, 2);
}

static int dbvm_do_rows(lua_State *L, int(*f)(lua_State *)) {
    /* sdb_vm *svm =  */
    lsqlite_checkvm(L, 1);
    lua_pushvalue(L,1);
    lua_pushcfunction(L, f);
    lua_insert(L, -2);
    return 2;
}

static int dbvm_rows(lua_State *L) {
    return dbvm_do_rows(L, db_next_packed_row);
}

static int dbvm_nrows(lua_State *L) {
    return dbvm_do_rows(L, db_next_named_row);
}

static int dbvm_urows(lua_State *L) {
    return dbvm_do_rows(L, db_next_row);
}

static int db_do_rows(lua_State *L, int(*f)(lua_State *)) {
    sdb *db = lsqlite_checkdb(L, 1);
    const char *sql = luaL_checkstring(L, 2);
    sdb_vm *svm;
    lua_settop(L,2); /* db,sql is on top of stack for call to newvm */
    svm = newvm(L, db);
    svm->temp = 1;

    if (sqlite3_prepare_v2(db->db, sql, -1, &svm->vm, NULL) != SQLITE_OK) {
        lua_pushstring(L, sqlite3_errmsg(svm->db->db));
        if (cleanupvm(L, svm) == 1)
            lua_pop(L, 1); /* this should not happen since sqlite3_prepare_v2 will not set ->vm on error */
        lua_error(L);
    }

    lua_pushcfunction(L, f);
    lua_insert(L, -2);
    return 2;
}

static int db_rows(lua_State *L) {
    return db_do_rows(L, db_next_packed_row);
}

static int db_nrows(lua_State *L) {
    return db_do_rows(L, db_next_named_row);
}

/* unpacked version of db:rows */
static int db_urows(lua_State *L) {
    return db_do_rows(L, db_next_row);
}

static int db_tostring(lua_State *L) {
    char buff[33];
    sdb *db = lsqlite_getdb(L, 1);
    if (db->db == NULL)
        strcpy(buff, ""closed"");
    else
        sprintf(buff, ""%p"", lua_touserdata(L, 1));
    lua_pushfstring(L, ""sqlite database (%s)"", buff);
    return 1;
}

static int db_close(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);
    lua_pushinteger(L, cleanupdb(L, db));
    return 1;
}

static int db_close_vm(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);
    closevms(L, db, lua_toboolean(L, 2));
    return 0;
}

static int db_gc(lua_State *L) {
    sdb *db = lsqlite_getdb(L, 1);
    if (db->db != NULL)  /* ignore closed databases */
        cleanupdb(L, db);
    return 0;
}

#ifdef SQLITE_ENABLE_DESERIALIZE

static int db_serialize(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);
    sqlite_int64 size = 0;

    char *buffer = (char *)sqlite3_serialize(db->db, ""main"", &size, 0);
    if (buffer == NULL)
        return pusherrstr(L, ""failed to serialize"");

    lua_pushlstring(L, buffer, size);
    free(buffer);
    return 1;
}

static int db_deserialize(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);
    size_t size = 0;

    const char *buffer = luaL_checklstring(L, 2, &size);
    if (buffer == NULL || size == 0)
        return pusherrstr(L, ""failed to deserialize"");

    const char *sqlbuf = memcpy(sqlite3_malloc(size), buffer, size);
    sqlite3_deserialize(db->db, ""main"", (void *)sqlbuf, size, size,
        SQLITE_DESERIALIZE_FREEONCLOSE + SQLITE_DESERIALIZE_RESIZEABLE);
    return 0;
}

#endif

#ifdef SQLITE_ENABLE_SESSION

/*
** =======================================================
** Iterator functions (for session support)
** =======================================================
*/

typedef struct {
    sqlite3_changeset_iter *itr;
    bool collectable;
} liter;

static liter *lsqlite_makeiter(lua_State *L, sqlite3_changeset_iter *piter, bool collectable) {
    liter *litr = (liter*)lua_newuserdata(L, sizeof(liter));
    lua_rawgeti(L, LUA_REGISTRYINDEX, sqlite_itr_meta_ref);
    lua_setmetatable(L, -2);
    litr->itr = piter;
    litr->collectable = collectable;
    return litr;
}

static liter *lsqlite_getiter(lua_State *L, int index) {
    return (liter *)luaL_checkudata(L, index, sqlite_itr_meta);
}

static liter *lsqlite_checkiter(lua_State *L, int index) {
    liter *litr = lsqlite_getiter(L, index);
    if (litr->itr == NULL) luaL_argerror(L, index, ""invalid sqlite iterator"");
    return litr;
}

static int liter_finalize(lua_State *L) {
    liter *litr = lsqlite_getiter(L, 1);
    int rc;
    if (litr->itr) {
        if (!litr->collectable) {
            return pusherr(L, SQLITE_CORRUPT);
        }
        if ((rc = sqlite3changeset_finalize(litr->itr)) != SQLITE_OK) {
            return pusherr(L, rc);
        }
        litr->itr = NULL;
    }
    lua_pushboolean(L, 1);
    return 1;
}

static int liter_gc(lua_State *L) {
    return liter_finalize(L);
}

static int liter_tostring(lua_State *L) {
    char buff[33];
    liter *litr = lsqlite_getiter(L, 1);
    if (litr->itr == NULL)
        strcpy(buff, ""closed"");
    else
        sprintf(buff, ""%p"", litr->itr);
    lua_pushfstring(L, ""sqlite iterator (%s)"", buff);
    return 1;
}

static int liter_table(
        lua_State *L,
        int (*iter_func)(sqlite3_changeset_iter *pIter, int val, sqlite3_value **ppValue)
) {
    const char *zTab;
    int n, rc, nCol, Op, bIndirect;
    sqlite3_value *pVal;
    liter *litr = lsqlite_checkiter(L, 1);
    sqlite3changeset_op(litr->itr, &zTab, &nCol, &Op, &bIndirect);
    lua_createtable(L, nCol, 0);
    for (n = 0; n < nCol; n++) {
        if ((rc = (*iter_func)(litr->itr, n, &pVal)) != LUA_OK) {
            return pusherr(L, rc);
        }
        if (pVal) {
            db_push_value(L, pVal);
        } else {
            // push `false` to indicate that the value wasn't changed
            // and not included in the record and to keep table valid
            lua_pushboolean(L, 0);
        }
        lua_rawseti(L, -2, n+1);
    }
    return 1;
}

static int liter_new(lua_State *L) {
    return liter_table(L, sqlite3changeset_new);
}

static int liter_old(lua_State *L) {
    return liter_table(L, sqlite3changeset_old);
}

static int liter_conflict(lua_State *L) {
    return liter_table(L, sqlite3changeset_conflict);
}

static int liter_op(lua_State *L) {
    const char *zTab;
    int rc, nCol, Op, bIndirect;
    liter *litr = lsqlite_checkiter(L, 1);

    if ((rc = sqlite3changeset_op(litr->itr, &zTab, &nCol, &Op, &bIndirect)) != LUA_OK) {
        return pusherr(L, rc);
    }
    lua_pushstring(L, zTab);
    lua_pushinteger(L, Op);
    lua_pushboolean(L, bIndirect);
    return 3;
}

static int liter_fk_conflicts(lua_State *L) {
    int rc, nOut;
    liter *litr = lsqlite_checkiter(L, 1);
    if ((rc = sqlite3changeset_fk_conflicts(litr->itr, &nOut)) != LUA_OK) {
        return pusherr(L, rc);
    }
    lua_pushinteger(L, nOut);
    return 1;
}

static int liter_next(lua_State *L) {
    liter *litr = lsqlite_checkiter(L, 1);
    if (!litr->collectable) {
        return pusherr(L, SQLITE_CORRUPT);
    }
    lua_pushinteger(L, sqlite3changeset_next(litr->itr));
    return 1;
}

static int liter_pk(lua_State *L) {
    int n, rc, nCol;
    unsigned char *abPK;
    liter *litr = lsqlite_checkiter(L, 1);
    if ((rc = sqlite3changeset_pk(litr->itr, &abPK, &nCol)) != LUA_OK) {
        return pusherr(L, rc);
    }
    lua_createtable(L, nCol, 0);
    for (n = 0; n < nCol; n++) {
        lua_pushboolean(L, abPK[n]);
        lua_rawseti(L, -2, n+1);
    }
    return 1;
}

/*
** =======================================================
** Rebaser functions (for session support)
** =======================================================
*/

typedef struct {
    sqlite3_rebaser *reb;
} lrebaser;

static lrebaser *lsqlite_makerebaser(lua_State *L, sqlite3_rebaser *reb) {
    lrebaser *lreb = (lrebaser*)lua_newuserdata(L, sizeof(lrebaser));
    lua_rawgeti(L, LUA_REGISTRYINDEX, sqlite_reb_meta_ref);
    lua_setmetatable(L, -2);
    lreb->reb = reb;
    return lreb;
}

static lrebaser *lsqlite_getrebaser(lua_State *L, int index) {
    return (lrebaser *)luaL_checkudata(L, index, sqlite_reb_meta);
}

static lrebaser *lsqlite_checkrebaser(lua_State *L, int index) {
    lrebaser *lreb = lsqlite_getrebaser(L, index);
    if (lreb->reb == NULL) luaL_argerror(L, index, ""invalid sqlite rebaser"");
    return lreb;
}

static int lrebaser_delete(lua_State *L) {
    lrebaser *lreb = lsqlite_getrebaser(L, 1);
    if (lreb->reb != NULL) {
      sqlite3rebaser_delete(lreb->reb);
      lreb->reb = NULL;
    }
    return 0;
}

static int lrebaser_gc(lua_State *L) {
    return lrebaser_delete(L);
}

static int lrebaser_tostring(lua_State *L) {
    char buff[32];
    lrebaser *lreb = lsqlite_getrebaser(L, 1);
    if (lreb->reb == NULL)
        strcpy(buff, ""closed"");
    else
        sprintf(buff, ""%p"", lreb->reb);
    lua_pushfstring(L, ""sqlite rebaser (%s)"", buff);
    return 1;
}

static int lrebaser_rebase(lua_State *L) {
    lrebaser *lreb = lsqlite_checkrebaser(L, 1);
    const char *cset = luaL_checkstring(L, 2);
    int nset = lua_rawlen(L, 2);
    int rc;
    int size;
    void *buf;

    if ((rc = sqlite3rebaser_rebase(lreb->reb, nset, cset, &size, &buf)) != SQLITE_OK) {
        return pusherr(L, rc);
    }
    lua_pushlstring(L, buf, size);
    sqlite3_free(buf);
    return 1;
}

static int db_create_rebaser(lua_State *L) {
    sqlite3_rebaser *reb;
    int rc;

    if ((rc = sqlite3rebaser_create(&reb)) != SQLITE_OK) {
        return pusherr(L, rc);
    }
    (void)lsqlite_makerebaser(L, reb);
    return 1;
}

/* session/changeset callbacks */

static int changeset_conflict_cb = LUA_NOREF;
static int changeset_filter_cb = LUA_NOREF;
static int changeset_cb_udata = LUA_NOREF;
static int session_filter_cb = LUA_NOREF;
static int session_cb_udata = LUA_NOREF;

static int db_changeset_conflict_callback(
        void *user,               /* Copy of sixth arg to _apply_v2() */
        int eConflict,            /* DATA, MISSING, CONFLICT, CONSTRAINT */
        sqlite3_changeset_iter *p /* Handle describing change and conflict */
) {
    // return default code if no callback is provided
    if (changeset_conflict_cb == LUA_NOREF) return SQLITE_CHANGESET_OMIT;
    sdb *db = (sdb*)user;
    lua_State *L = db->L;
    int top = lua_gettop(L);
    int result, isint;
    const char *zTab;
    int nCol, Op, bIndirect;

    if (sqlite3changeset_op(p, &zTab, &nCol, &Op, &bIndirect) != LUA_OK) {
        lua_pushliteral(L, ""invalid return from changeset iterator"");
        return lua_error(L);
    }

    lua_rawgeti(L, LUA_REGISTRYINDEX, changeset_conflict_cb); /* get callback */
    lua_rawgeti(L, LUA_REGISTRYINDEX, changeset_cb_udata); /* get callback user data */
    lua_pushinteger(L, eConflict);
    (void)lsqlite_makeiter(L, p, 0);
    lua_pushstring(L, zTab);
    lua_pushinteger(L, Op);
    lua_pushboolean(L, bIndirect);

    if (lua_pcall(L, 6, 1, 0) != LUA_OK) return lua_error(L);

    result = lua_tointegerx(L, -1, &isint); /* use result if there was no error */
    if (!isint) {
        lua_pushliteral(L, ""non-integer returned from conflict callback"");
        return lua_error(L);
    }

    lua_settop(L, top);
    return result;
}

static int db_filter_callback(
        void *user,       /* Context */
        const char *zTab, /* Table name */
        int filter_cb,
        int filter_udata
) {
    // allow the table if no filter callback is provided
    if (filter_cb == LUA_NOREF || filter_cb == LUA_REFNIL) return 1;
    sdb *db = (sdb*)user;
    lua_State *L = db->L;
    int top = lua_gettop(L);
    int result, isint;

    lua_rawgeti(L, LUA_REGISTRYINDEX, filter_cb); /* get callback */
    lua_pushstring(L, zTab);
    lua_rawgeti(L, LUA_REGISTRYINDEX, filter_udata); /* get callback user data */

    if (lua_pcall(L, 2, 1, 0) != LUA_OK) return lua_error(L);

    // allow 0/1 and false/true to be returned
    // returning 0/false skips the table
    result = lua_tointegerx(L, -1, &isint); /* use result if there was no error */
    if (!isint && !lua_isboolean(L, -1)) {
        lua_pushliteral(L, ""non-integer and non-boolean returned from filter callback"");
        return lua_error(L);
    }
    if (!isint) result = lua_toboolean(L, -1);

    lua_settop(L, top);
    return result;
}

static int db_changeset_filter_callback(
        void *user,      /* Copy of sixth arg to _apply_v2() */
        const char *zTab /* Table name */
) {
    return db_filter_callback(user, zTab, changeset_filter_cb, changeset_cb_udata);
}

static int db_session_filter_callback(
        void *user,      /* Copy of third arg to session_attach() */
        const char *zTab /* Table name */
) {
    return db_filter_callback(user, zTab, session_filter_cb, session_cb_udata);
}

/*
** =======================================================
** Session functions
** =======================================================
*/

typedef struct {
    sqlite3_session *ses;
    sdb *db; // keep track of the DB this session is for
} lsession;

static lsession *lsqlite_makesession(lua_State *L, sqlite3_session *ses, sdb *db) {
    lsession *lses = (lsession*)lua_newuserdata(L, sizeof(lsession));
    lua_rawgeti(L, LUA_REGISTRYINDEX, sqlite_ses_meta_ref);
    lua_setmetatable(L, -2);
    lses->ses = ses;
    lses->db = db;
    return lses;
}

static lsession *lsqlite_getsession(lua_State *L, int index) {
    return (lsession *)luaL_checkudata(L, index, sqlite_ses_meta);
}

static lsession *lsqlite_checksession(lua_State *L, int index) {
    lsession *lses = lsqlite_getsession(L, index);
    if (lses->ses == NULL) luaL_argerror(L, index, ""invalid sqlite session"");
    return lses;
}

static int lsession_attach(lua_State *L) {
    lsession *lses = lsqlite_checksession(L, 1);
    int rc;
    // allow either a table or a callback function to filter tables
    const char *zTab = lua_type(L, 2) == LUA_TFUNCTION
        ? NULL
        : luaL_optstring(L, 2, NULL);
    if ((rc = sqlite3session_attach(lses->ses, zTab)) != SQLITE_OK) {
        return pusherr(L, rc);
    }
    // allow to pass a filter callback,
    // but only one shared for all sessions where this callback is used
    if (lua_type(L, 2) == LUA_TFUNCTION) {
        // TBD: does this *also* need to be done in cleanupvm?
        luaL_unref(L, LUA_REGISTRYINDEX, session_filter_cb);
        luaL_unref(L, LUA_REGISTRYINDEX, session_cb_udata);
        lua_settop(L, 3);  // add udata even if it's not provided
        session_cb_udata = luaL_ref(L, LUA_REGISTRYINDEX);
        session_filter_cb = luaL_ref(L, LUA_REGISTRYINDEX);
        sqlite3session_table_filter(lses->ses,
            db_session_filter_callback, lses->db);
    }
    lua_pushboolean(L, 1);
    return 1;
}

static int lsession_isempty(lua_State *L) {
    lsession *lses = lsqlite_checksession(L, 1);
    lua_pushboolean(L, sqlite3session_isempty(lses->ses));
    return 1;
}

static int lsession_diff(lua_State *L) {
    lsession *lses = lsqlite_checksession(L, 1);
    const char *zFromDb = luaL_checkstring(L, 2);
    const char *zTbl = luaL_checkstring(L, 3);
    int rc = sqlite3session_diff(lses->ses, zFromDb, zTbl, NULL);
    if (rc != SQLITE_OK) return pusherr(L, rc);
    lua_pushboolean(L, 1);
    return 1;
}

static int lsession_bool(
        lua_State *L,
        int (*session_func)(sqlite3_session *ses, int val)
) {
    lsession *lses = lsqlite_checksession(L, 1);
    int val = lua_isboolean(L, 2)
        ? lua_toboolean(L, 2)
        : luaL_optinteger(L, 2, -1);
    lua_pushboolean(L, (*session_func)(lses->ses, val));
    return 1;
}

static int lsession_indirect(lua_State *L) {
    return lsession_bool(L, sqlite3session_indirect);
}

static int lsession_enable(lua_State *L) {
    return lsession_bool(L, sqlite3session_enable);
}

static int lsession_getset(
        lua_State *L,
        int (*session_setfunc)(sqlite3_session *ses, int *size, void **buf)
) {
    lsession *lses = lsqlite_checksession(L, 1);
    int rc;
    int size;
    void *buf;

    if ((rc = (*session_setfunc)(lses->ses, &size, &buf)) != SQLITE_OK) {
        return pusherr(L, rc);
    }
    lua_pushlstring(L, buf, size);
    sqlite3_free(buf);
    return 1;
}

static int lsession_changeset(lua_State *L) {
    return lsession_getset(L, sqlite3session_changeset);
}

static int lsession_patchset(lua_State *L) {
    return lsession_getset(L, sqlite3session_patchset);
}

static int lsession_delete(lua_State *L) {
    lsession *lses = lsqlite_getsession(L, 1);
    if (lses->ses != NULL) {
      sqlite3session_delete(lses->ses);
      lses->ses = NULL;
    }
    return 0;
}

static int lsession_tostring(lua_State *L) {
    char buff[32];
    lsession *lses = lsqlite_getsession(L, 1);
    if (lses->ses == NULL)
        strcpy(buff, ""closed"");
    else
        sprintf(buff, ""%p"", lses->ses);
    lua_pushfstring(L, ""sqlite session (%s)"", buff);
    return 1;
}

static int db_create_session(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);
    const char *zDb = luaL_optstring(L, 2, ""main"");
    sqlite3_session *ses;

    if (sqlite3session_create(db->db, zDb, &ses) != SQLITE_OK) {
        return pusherr(L, sqlite3_errcode(db->db));
    }
    (void)lsqlite_makesession(L, ses, db);
    return 1;
}

static int db_iterate_changeset(lua_State *L) {
    sqlite3_changeset_iter *p;
    lsqlite_checkdb(L, 1);
    const char *cset = luaL_checkstring(L, 2);
    int nset = lua_rawlen(L, 2);
    int flags = luaL_optinteger(L, 3, 0);
    int rc;

    if ((rc = sqlite3changeset_start_v2(&p, nset, (void *)cset, flags)) != SQLITE_OK) {
        return pusherr(L, rc);
    }
    (void)lsqlite_makeiter(L, p, 1);
    return 1;
}

static int db_invert_changeset(lua_State *L) {
    lsqlite_checkdb(L, 1);
    const char *cset = luaL_checkstring(L, 2);
    int nset = lua_rawlen(L, 2);
    int rc;
    int size;
    void *buf;

    if ((rc = sqlite3changeset_invert(nset, cset, &size, &buf)) != SQLITE_OK) {
        return pusherr(L, rc);
    }
    lua_pushlstring(L, buf, size);
    sqlite3_free(buf);
    return 1;
}

static int db_concat_changeset(lua_State *L) {
    lsqlite_checkdb(L, 1);
    int size, nset;
    void *buf, *cset;
    sqlite3_changegroup *pGrp;

    luaL_checktype(L, 2, LUA_TTABLE);
    int n = luaL_len(L, 2);
    int rc = sqlite3changegroup_new(&pGrp);
    for (int i = 1; rc == SQLITE_OK && i <= n; i++) {
        lua_rawgeti(L, 2, i);
        cset = (void *)lua_tostring(L, -1);
        nset = lua_rawlen(L, -1);
        rc = sqlite3changegroup_add(pGrp, nset, cset);
        lua_pop(L, 1);  // pop the string
    }
    if (rc == SQLITE_OK) rc = sqlite3changegroup_output(pGrp, &size, &buf);
    sqlite3changegroup_delete(pGrp);

    if (rc != SQLITE_OK) return pusherr(L, rc);
    lua_pushlstring(L, buf, size);
    sqlite3_free(buf);
    return 1;
}

static int db_apply_changeset(lua_State *L) {
    sdb *db = lsqlite_checkdb(L, 1);
    void *cset = (void *)luaL_checkstring(L, 2);
    int nset = lua_rawlen(L, 2);
    int top = lua_gettop(L);
    int rc;
    int flags = 0;
    void *pRebase;
    int nRebase;
    lrebaser *lreb = NULL;

    // parameters: db, changeset[[, filter cb], conflict cb[, udata[, rebaser[, flags]]]]

    // TBD: does this *also* need to be done in cleanupvm?
    if (changeset_cb_udata != LUA_NOREF) {
        luaL_unref(L, LUA_REGISTRYINDEX, changeset_conflict_cb);
        luaL_unref(L, LUA_REGISTRYINDEX, changeset_filter_cb);
        luaL_unref(L, LUA_REGISTRYINDEX, changeset_cb_udata);

        changeset_conflict_cb =
        changeset_filter_cb =
        changeset_cb_udata = LUA_NOREF;
    }

    // check for conflict/filter callback type if provided
    if (top >= 3) {
        luaL_checktype(L, 3, LUA_TFUNCTION);
        // if no filter callback, insert a dummy one to simplify stack handling
        if (lua_type(L, 4) != LUA_TFUNCTION) {
            lua_pushnil(L);
            lua_insert(L, 3);
            top = lua_gettop(L);
        }
    }
    if (top >= 6) lreb = lsqlite_checkrebaser(L, 6);
    if (top >= 7) flags = luaL_checkinteger(L, 7);
    if (top >= 4) {  // two callback are guaranteed to be on the stack in this case
        // shorten stack or extend to set udata to `nil` if not provided
        lua_settop(L, 5);
        changeset_cb_udata = luaL_ref(L, LUA_REGISTRYINDEX);
        changeset_conflict_cb = luaL_ref(L, LUA_REGISTRYINDEX);
        changeset_filter_cb = luaL_ref(L, LUA_REGISTRYINDEX);
    }

    rc = sqlite3changeset_apply_v2(db->db, nset, cset,
                                   db_changeset_filter_callback,
                                   db_changeset_conflict_callback,
                                   db, // context
                                   lreb ? &pRebase : 0,
                                   lreb ? &nRebase : 0,
                                   flags);

    if (rc != SQLITE_OK) return pusherr(L, sqlite3_errcode(db->db));

    if (lreb) { // if rebaser is present
        rc = sqlite3rebaser_configure(lreb->reb, nRebase, pRebase);
        if (rc == SQLITE_OK) lua_pushstring(L, pRebase);
        sqlite3_free(pRebase);
        if (rc == SQLITE_OK) return 1;
        return pusherr(L, rc);
    }

    lua_pushboolean(L, 1);
    return 1;
}

#endif

/*
** =======================================================
** General library functions
** =======================================================
*/

static int lsqlite_version(lua_State *L) {
    lua_pushstring(L, sqlite3_libversion());
    return 1;
}

static int lsqlite_do_open(lua_State *L, const char *filename, int flags) {
    sqlite3_initialize(); /* initialize the engine if hasn't been done yet */
    sdb *db = newdb(L); /* create and leave in stack */

    if (sqlite3_open_v2(filename, &db->db, flags, 0) == SQLITE_OK) {
        /* database handle already in the stack - return it */
        sqlite3_zipfile_init(db->db, 0, 0);
        return 1;
    }

    /* failed to open database */
    lua_pushnil(L);                             /* push nil */
    lua_pushinteger(L, sqlite3_errcode(db->db));
    lua_pushstring(L, sqlite3_errmsg(db->db));  /* push error message */

    /* clean things up */
    cleanupdb(L, db);

    /* return */
    return 3;
}

static int lsqlite_open(lua_State *L) {
    const char *filename = luaL_checkstring(L, 1);
    int flags = luaL_optinteger(L, 2, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE);
    return lsqlite_do_open(L, filename, flags);
}

static int lsqlite_open_memory(lua_State *L) {
    return lsqlite_do_open(L, "":memory:"", SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE);
}

/*
** Log callback:
** Params: user, result code, log message
** Returns: none
*/
static void log_callback(void* user, int rc, const char *msg) {
    if (log_cb != LUA_NOREF) {
        lua_State *L = (lua_State*)user;

        /* setup lua callback call */
        int top = lua_gettop(L);
        lua_rawgeti(L, LUA_REGISTRYINDEX, log_cb);    /* get callback */
        lua_rawgeti(L, LUA_REGISTRYINDEX, log_udata); /* get callback user data */
        lua_pushinteger(L, rc);
        lua_pushstring(L, msg);

        if (lua_pcall(L, 3, 0, 0) != LUA_OK) lua_error(L);

        lua_settop(L, top);
    }
}

static int lsqlite_config(lua_State *L) {
    int rc = SQLITE_MISUSE;
    int option = luaL_checkint(L, 1);

    switch (option) {
        case SQLITE_CONFIG_SINGLETHREAD:
        case SQLITE_CONFIG_MULTITHREAD:
        case SQLITE_CONFIG_SERIALIZED:
            if ((rc = sqlite3_config(option)) == SQLITE_OK) {
                lua_pushinteger(L, rc);
                return 1;
            }
            break;
        case SQLITE_CONFIG_LOG:
            /* make sure we have an userdata field (even if nil) */
            lua_settop(L, 3);

            // prepate to return current (possibly nil) values
            lua_pushinteger(L, SQLITE_OK);
            lua_rawgeti(L, LUA_REGISTRYINDEX, log_cb);    /* get callback */
            lua_rawgeti(L, LUA_REGISTRYINDEX, log_udata); /* get callback user data */

            luaL_unref(L, LUA_REGISTRYINDEX, log_cb);
            luaL_unref(L, LUA_REGISTRYINDEX, log_udata);
            if (lua_isnil(L, 2)) {
                log_cb =
                log_udata = LUA_NOREF;
            }
            else {
                luaL_checktype(L, 2, LUA_TFUNCTION);
                lua_pushvalue(L, 2);
                lua_pushvalue(L, 3);
                log_udata = luaL_ref(L, LUA_REGISTRYINDEX);
                log_cb = luaL_ref(L, LUA_REGISTRYINDEX);
            }
            return 3;  // return OK and previous callback and userdata
    }
    return pusherr(L, rc);
}

static int lsqlite_newindex(lua_State *L) {
    lua_pushliteral(L, ""attempt to change readonly table"");
    lua_error(L);
    return 0;
}

/* Version number of this library
*/
static int lsqlite_lversion(lua_State *L) {
    lua_pushstring(L, LSQLITE_VERSION);
    return 1;
}

/*
** =======================================================
** Register functions
** =======================================================
*/

#define SC(s)   { #s, SQLITE_ ## s },
#define LSC(s)  { #s, LSQLITE_ ## s },

static const struct {
    const char* name;
    int value;
} sqlite_constants[] = {
    /* error codes */
    SC(OK)          SC(ERROR)       SC(INTERNAL)    SC(PERM)
    SC(ABORT)       SC(BUSY)        SC(LOCKED)      SC(NOMEM)
    SC(READONLY)    SC(INTERRUPT)   SC(IOERR)       SC(CORRUPT)
    SC(NOTFOUND)    SC(FULL)        SC(CANTOPEN)    SC(PROTOCOL)
    SC(EMPTY)       SC(SCHEMA)      SC(TOOBIG)      SC(CONSTRAINT)
    SC(MISMATCH)    SC(MISUSE)      SC(NOLFS)
    SC(FORMAT)      SC(NOTADB)

    /* sqlite_step specific return values */
    SC(RANGE)       SC(ROW)         SC(DONE)

    /* column types */
    SC(INTEGER)     SC(FLOAT)       SC(TEXT)        SC(BLOB)
    SC(NULL)

    /* Authorizer Action Codes */
    SC(CREATE_INDEX       )
    SC(CREATE_TABLE       )
    SC(CREATE_TEMP_INDEX  )
    SC(CREATE_TEMP_TABLE  )
    SC(CREATE_TEMP_TRIGGER)
    SC(CREATE_TEMP_VIEW   )
    SC(CREATE_TRIGGER     )
    SC(CREATE_VIEW        )
    SC(DELETE             )
    SC(DROP_INDEX         )
    SC(DROP_TABLE         )
    SC(DROP_TEMP_INDEX    )
    SC(DROP_TEMP_TABLE    )
    SC(DROP_TEMP_TRIGGER  )
    SC(DROP_TEMP_VIEW     )
    SC(DROP_TRIGGER       )
    SC(DROP_VIEW          )
    SC(INSERT             )
    SC(PRAGMA             )
    SC(READ               )
    SC(SELECT             )
    SC(TRANSACTION        )
    SC(UPDATE             )
    SC(ATTACH             )
    SC(DETACH             )
    SC(ALTER_TABLE        )
    SC(REINDEX            )
    SC(ANALYZE            )
    SC(CREATE_VTABLE      )
    SC(DROP_VTABLE        )
    SC(FUNCTION           )
    SC(SAVEPOINT          )

    /* file open flags */
    SC(OPEN_READONLY)
    SC(OPEN_READWRITE)
    SC(OPEN_CREATE)
    SC(OPEN_URI)
    SC(OPEN_MEMORY)
    SC(OPEN_NOMUTEX)
    SC(OPEN_FULLMUTEX)
    SC(OPEN_SHAREDCACHE)
    SC(OPEN_PRIVATECACHE)

    /* config flags */
    SC(CONFIG_SINGLETHREAD)
    SC(CONFIG_MULTITHREAD)
    SC(CONFIG_SERIALIZED)
    SC(CONFIG_LOG)

    /* checkpoint flags */
    SC(CHECKPOINT_PASSIVE)
    SC(CHECKPOINT_FULL)
    SC(CHECKPOINT_RESTART)
    SC(CHECKPOINT_TRUNCATE)

#ifdef SQLITE_ENABLE_SESSION
    /* session constants */
    SC(CHANGESETSTART_INVERT)
    SC(CHANGESETAPPLY_NOSAVEPOINT)
    SC(CHANGESETAPPLY_INVERT)
    SC(CHANGESET_DATA)
    SC(CHANGESET_NOTFOUND)
    SC(CHANGESET_CONFLICT)
    SC(CHANGESET_CONSTRAINT)
    SC(CHANGESET_FOREIGN_KEY)
    SC(CHANGESET_OMIT)
    SC(CHANGESET_REPLACE)
    SC(CHANGESET_ABORT)
#endif

    /* terminator */
    { NULL, 0 }
};

/* ======================================================= */

static const luaL_Reg dblib[] = {
    {""isopen"",              db_isopen               },
    {""readonly"",            db_readonly             },
    {""last_insert_rowid"",   db_last_insert_rowid    },
    {""changes"",             db_changes              },
    {""total_changes"",       db_total_changes        },
    {""errcode"",             db_errcode              },
    {""error_code"",          db_errcode              },
    {""errmsg"",              db_errmsg               },
    {""error_message"",       db_errmsg               },
    {""interrupt"",           db_interrupt            },
    {""db_filename"",         db_db_filename          },
    {""wal_checkpoint"",      db_wal_checkpoint       },

    {""create_function"",     db_create_function      },
    {""create_aggregate"",    db_create_aggregate     },
    {""create_collation"",    db_create_collation     },

    {""busy_timeout"",        db_busy_timeout         },
    {""busy_handler"",        db_busy_handler         },
    {""wal_hook"",            db_wal_hook             },
    {""update_hook"",         db_update_hook          },
    {""commit_hook"",         db_commit_hook          },
    {""rollback_hook"",       db_rollback_hook        },

    {""prepare"",             db_prepare              },
    {""rows"",                db_rows                 },
    {""urows"",               db_urows                },
    {""nrows"",               db_nrows                },

    {""exec"",                db_exec                 },
    {""execute"",             db_exec                 },
    {""close"",               db_close                },
    {""close_vm"",            db_close_vm             },

#ifdef SQLITE_ENABLE_SESSION
    {""create_session"",      db_create_session       },
    {""create_rebaser"",      db_create_rebaser       },
    {""apply_changeset"",     db_apply_changeset      },
    {""invert_changeset"",    db_invert_changeset     },
    {""concat_changeset"",    db_concat_changeset     },
    {""iterate_changeset"",   db_iterate_changeset    },
#endif

#ifdef SQLITE_ENABLE_DESERIALIZE
    {""serialize"",           db_serialize            },
    {""deserialize"",         db_deserialize          },
#endif

    {""__tostring"",          db_tostring             },
    {""__gc"",                db_gc                   },

    {NULL, NULL}
};

static const luaL_Reg vmlib[] = {
    {""isopen"",              dbvm_isopen             },
    {""readonly"",            dbvm_readonly           },

    {""step"",                dbvm_step               },
    {""reset"",               dbvm_reset              },
    {""finalize"",            dbvm_finalize           },

    {""columns"",             dbvm_columns            },

    {""bind"",                dbvm_bind               },
    {""bind_values"",         dbvm_bind_values        },
    {""bind_names"",          dbvm_bind_names         },
    {""bind_blob"",           dbvm_bind_blob          },
    {""bind_parameter_count"",dbvm_bind_parameter_count},
    {""bind_parameter_name"", dbvm_bind_parameter_name},

    {""get_value"",           dbvm_get_value          },
    {""get_values"",          dbvm_get_values         },
    {""get_name"",            dbvm_get_name           },
    {""get_names"",           dbvm_get_names          },
    {""get_type"",            dbvm_get_type           },
    {""get_types"",           dbvm_get_types          },
    {""get_uvalues"",         dbvm_get_uvalues        },
    {""get_unames"",          dbvm_get_unames         },
    {""get_utypes"",          dbvm_get_utypes         },

    {""get_named_values"",    dbvm_get_named_values   },
    {""get_named_types"",     dbvm_get_named_types    },

    {""rows"",                dbvm_rows               },
    {""urows"",               dbvm_urows              },
    {""nrows"",               dbvm_nrows              },

    {""last_insert_rowid"",   dbvm_last_insert_rowid  },

    /* compatibility names (added by request) */
    {""idata"",               dbvm_get_values         },
    {""inames"",              dbvm_get_names          },
    {""itypes"",              dbvm_get_types          },
    {""data"",                dbvm_get_named_values   },
    {""type"",                dbvm_get_named_types    },

    {""__tostring"",          dbvm_tostring           },
    {""__gc"",                dbvm_gc                 },

    { NULL, NULL }
};

static const luaL_Reg ctxlib[] = {
    {""user_data"",               lcontext_user_data              },

    {""get_aggregate_data"",      lcontext_get_aggregate_context  },
    {""set_aggregate_data"",      lcontext_set_aggregate_context  },

    {""result"",                  lcontext_result                 },
    {""result_null"",             lcontext_result_null            },
    {""result_number"",           lcontext_result_double          },
    {""result_double"",           lcontext_result_double          },
    {""result_int"",              lcontext_result_int             },
    {""result_text"",             lcontext_result_text            },
    {""result_blob"",             lcontext_result_blob            },
    {""result_error"",            lcontext_result_error           },

    {""__tostring"",              lcontext_tostring               },
    {NULL, NULL}
};

#ifdef SQLITE_ENABLE_SESSION

static const luaL_Reg seslib[] = {
    {""attach"",          lsession_attach         },
    {""changeset"",       lsession_changeset      },
    {""patchset"",        lsession_patchset       },
    {""isempty"",         lsession_isempty        },
    {""indirect"",        lsession_indirect       },
    {""enable"",          lsession_enable         },
    {""diff"",            lsession_diff           },
    {""delete"",          lsession_delete         },

    {""__tostring"",      lsession_tostring       },
    {NULL, NULL}
};

static const luaL_Reg reblib[] = {
    {""rebase"",          lrebaser_rebase         },
    {""delete"",          lrebaser_delete         },

    {""__tostring"",      lrebaser_tostring       },
    {""__gc"",            lrebaser_gc             },
    {NULL, NULL}
};

static const luaL_Reg itrlib[] = {
    {""op"",              liter_op                },
    {""pk"",              liter_pk                },
    {""new"",             liter_new               },
    {""old"",             liter_old               },
    {""next"",            liter_next              },
    {""conflict"",        liter_conflict          },
    {""finalize"",        liter_finalize          },
    {""fk_conflicts"",    liter_fk_conflicts      },

    {""__tostring"",      liter_tostring          },
    {""__gc"",            liter_gc                },
    {NULL, NULL}
};

#endif

static const luaL_Reg sqlitelib[] = {
    {""lversion"",        lsqlite_lversion        },
    {""version"",         lsqlite_version         },
    {""open"",            lsqlite_open            },
    {""open_memory"",     lsqlite_open_memory     },
    {""config"",          lsqlite_config          },

    {""__newindex"",      lsqlite_newindex        },
    {NULL, NULL}
};

static void create_meta(lua_State *L, const char *name, const luaL_Reg *lib) {
    luaL_newmetatable(L, name);
    lua_pushliteral(L, ""__index"");
    lua_pushvalue(L, -2);               /* push metatable */
    lua_rawset(L, -3);                  /* metatable.__index = metatable */

    /* register metatable functions */
    luaL_openlib(L, NULL, lib, 0);

    /* remove metatable from stack */
    lua_pop(L, 1);
}

LUALIB_API int luaopen_lsqlite3(lua_State *L) {
    /* call config before calling initialize */
    sqlite3_config(SQLITE_CONFIG_LOG, log_callback, L);

    create_meta(L, sqlite_meta, dblib);
    create_meta(L, sqlite_vm_meta, vmlib);
    create_meta(L, sqlite_ctx_meta, ctxlib);

    luaL_getmetatable(L, sqlite_ctx_meta);
    sqlite_ctx_meta_ref = luaL_ref(L, LUA_REGISTRYINDEX);

#ifdef SQLITE_ENABLE_SESSION
    create_meta(L, sqlite_ses_meta, seslib);
    create_meta(L, sqlite_reb_meta, reblib);
    create_meta(L, sqlite_itr_meta, itrlib);

    luaL_getmetatable(L, sqlite_ses_meta);
    sqlite_ses_meta_ref = luaL_ref(L, LUA_REGISTRYINDEX);

    luaL_getmetatable(L, sqlite_reb_meta);
    sqlite_reb_meta_ref = luaL_ref(L, LUA_REGISTRYINDEX);

    luaL_getmetatable(L, sqlite_itr_meta);
    sqlite_itr_meta_ref = luaL_ref(L, LUA_REGISTRYINDEX);
#endif

    /* register (local) sqlite metatable */
    luaL_register(L, ""sqlite3"", sqlitelib);

    {
        int i = 0;
        /* add constants to global table */
        while (sqlite_constants[i].name) {
            lua_pushstring(L, sqlite_constants[i].name);
            lua_pushinteger(L, sqlite_constants[i].value);
            lua_rawset(L, -3);
            ++i;
        }
    }

    /* set sqlite's metatable to itself - set as readonly (__newindex) */
    lua_pushvalue(L, -1);
    lua_setmetatable(L, -2);

    return 1;
}
"
./repos/cosmopolitan/tool/net/redbean-unsecure.c,https://github.com/jart/cosmopolitan.git,"#define UNSECURE
#define REDBEAN ""redbean-unsecure""
#include ""tool/net/redbean.c""
"
./repos/cosmopolitan/tool/net/launch.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2024 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/calls/calls.h""
#include ""libc/calls/struct/sigaction.h""
#include ""libc/calls/struct/sigset.h""
#include ""libc/dce.h""
#include ""libc/errno.h""
#include ""libc/log/log.h""
#include ""libc/proc/posix_spawn.h""
#include ""libc/runtime/runtime.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#include ""libc/sysv/consts/sig.h""

static volatile bool g_timed_out;

static void finish(void) {
  if (!IsWindows()) {
    _exit(0);
  }
}

static void timeout(int sig) {
  g_timed_out = true;
}

static void failure(const char *url, const char *cmd, const char *reason) {
  WARNF(""(srvr) failed to open %s in a browser tab using %s: %s"", url, cmd,
        reason);
}

/**
 * Opens browser tab on host system.
 */
void launch_browser(const char *url) {

  // perform this task from a subprocess so it doesn't block server
  if (!IsWindows()) {
    switch (fork()) {
      case 0:
        break;
      default:
        return;
      case -1:
        perror(""fork"");
        return;
    }
  }

  // determine which command opens browser tab
  const char *cmd;
  if (IsWindows()) {
    cmd = ""/c/windows/explorer.exe"";
  } else if (IsXnu()) {
    cmd = ""open"";
  } else {
    cmd = ""xdg-open"";
  }

  // spawn process
  // set process group so ctrl-c won't kill browser
  int pid, err;
  posix_spawnattr_t sa;
  char *args[] = {(char *)cmd, (char *)url, 0};
  posix_spawnattr_init(&sa);
  posix_spawnattr_setflags(&sa, POSIX_SPAWN_SETPGROUP);
  err = posix_spawnp(&pid, cmd, 0, &sa, args, environ);
  posix_spawnattr_destroy(&sa);
  if (err) {
    failure(url, cmd, strerror(err));
    return finish();
  }

  // kill command if it takes more than three seconds
  // we need it because xdg-open acts weird on headless systems
  struct sigaction hand;
  hand.sa_flags = 0;
  sigemptyset(&hand.sa_mask);
  hand.sa_handler = timeout;
  sigaction(SIGALRM, &hand, 0);
  alarm(3);

  // wait for tab to return finish opening
  // the browser will still be running after this completes
  int ws;
  while (waitpid(pid, &ws, 0) == -1) {
    if (errno != EINTR) {
      failure(url, cmd, strerror(errno));
      kill(pid, SIGKILL);
      return finish();
    }
    if (g_timed_out) {
      failure(url, cmd, ""process timed out"");
      kill(pid, SIGKILL);
      return finish();
    }
  }
  if (ws) {
    failure(url, cmd, ""process exited with non-zero status"");
  }

  // we're done
  return finish();
}
"
./repos/cosmopolitan/tool/net/ljson.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/net/ljson.h""
#include ""libc/serialize.h""
#include ""libc/intrin/likely.h""
#include ""libc/log/check.h""
#include ""libc/log/log.h""
#include ""libc/runtime/runtime.h""
#include ""libc/runtime/stack.h""
#include ""libc/stdckdint.h""
#include ""libc/str/str.h""
#include ""libc/str/tab.internal.h""
#include ""libc/str/utf16.h""
#include ""libc/sysv/consts/auxv.h""
#include ""third_party/double-conversion/wrapper.h""
#include ""third_party/lua/cosmo.h""
#include ""third_party/lua/lauxlib.h""
#include ""third_party/lua/ltests.h""
#include ""third_party/lua/lua.h""

#define KEY    1
#define COMMA  2
#define COLON  4
#define ARRAY  8
#define OBJECT 16
#define DEPTH  64

#define ASCII     0
#define C0        1
#define DQUOTE    2
#define BACKSLASH 3
#define UTF8_2    4
#define UTF8_3    5
#define UTF8_4    6
#define C1        7
#define UTF8_3_E0 8
#define UTF8_3_ED 9
#define UTF8_4_F0 10
#define BADUTF8   11
#define EVILUTF8  12

static const char kJsonStr[256] = {
    1,  1,  1,  1,  1,  1,  1,  1,   // 0000 ascii (0)
    1,  1,  1,  1,  1,  1,  1,  1,   // 0010
    1,  1,  1,  1,  1,  1,  1,  1,   // 0020 c0 (1)
    1,  1,  1,  1,  1,  1,  1,  1,   // 0030
    0,  0,  2,  0,  0,  0,  0,  0,   // 0040 dquote (2)
    0,  0,  0,  0,  0,  0,  0,  0,   // 0050
    0,  0,  0,  0,  0,  0,  0,  0,   // 0060
    0,  0,  0,  0,  0,  0,  0,  0,   // 0070
    0,  0,  0,  0,  0,  0,  0,  0,   // 0100
    0,  0,  0,  0,  0,  0,  0,  0,   // 0110
    0,  0,  0,  0,  0,  0,  0,  0,   // 0120
    0,  0,  0,  0,  3,  0,  0,  0,   // 0130 backslash (3)
    0,  0,  0,  0,  0,  0,  0,  0,   // 0140
    0,  0,  0,  0,  0,  0,  0,  0,   // 0150
    0,  0,  0,  0,  0,  0,  0,  0,   // 0160
    0,  0,  0,  0,  0,  0,  0,  0,   // 0170
    7,  7,  7,  7,  7,  7,  7,  7,   // 0200 c1 (8)
    7,  7,  7,  7,  7,  7,  7,  7,   // 0210
    7,  7,  7,  7,  7,  7,  7,  7,   // 0220
    7,  7,  7,  7,  7,  7,  7,  7,   // 0230
    11, 11, 11, 11, 11, 11, 11, 11,  // 0240 latin1 (4)
    11, 11, 11, 11, 11, 11, 11, 11,  // 0250
    11, 11, 11, 11, 11, 11, 11, 11,  // 0260
    11, 11, 11, 11, 11, 11, 11, 11,  // 0270
    12, 12, 4,  4,  4,  4,  4,  4,   // 0300 utf8-2 (5)
    4,  4,  4,  4,  4,  4,  4,  4,   // 0310
    4,  4,  4,  4,  4,  4,  4,  4,   // 0320 utf8-2
    4,  4,  4,  4,  4,  4,  4,  4,   // 0330
    8,  5,  5,  5,  5,  5,  5,  5,   // 0340 utf8-3 (6)
    5,  5,  5,  5,  5,  9,  5,  5,   // 0350
    10, 6,  6,  6,  6,  11, 11, 11,  // 0360 utf8-4 (7)
    11, 11, 11, 11, 11, 11, 11, 11,  // 0370
};

static struct DecodeJson Parse(struct lua_State *L, const char *p,
                               const char *e, int context, int depth) {
  long x;
  char w[4];
  luaL_Buffer b;
  struct DecodeJson r;
  const char *a, *reason;
  int A, B, C, D, c, d, i, u;
  if (UNLIKELY(!depth)) {
    return (struct DecodeJson){-1, ""maximum depth exceeded""};
  }
  if (UNLIKELY(!HaveStackMemory(getauxval(AT_PAGESZ)))) {
    return (struct DecodeJson){-1, ""out of stack""};
  }
  for (a = p, d = +1; p < e;) {
    switch ((c = *p++ & 255)) {
      case ' ':  // spaces
      case '\n':
      case '\r':
      case '\t':
        a = p;
        break;

      case ',':  // present in list and object
        if (context & COMMA) {
          context = 0;
          a = p;
          break;
        } else {
          return (struct DecodeJson){-1, ""unexpected ','""};
        }

      case ':':  // present only in object after key
        if (context & COLON) {
          context = 0;
          a = p;
          break;
        } else {
          return (struct DecodeJson){-1, ""unexpected ':'""};
        }

      case 'n':  // null
        if (context & (KEY | COLON | COMMA)) goto OnColonCommaKey;
        if (p + 3 <= e && READ32LE(p - 1) == READ32LE(""null"")) {
          lua_pushnil(L);
          return (struct DecodeJson){1, p + 3};
        } else {
          goto IllegalCharacter;
        }

      case 'f':  // false
        if (context & (KEY | COLON | COMMA)) goto OnColonCommaKey;
        if (p + 4 <= e && READ32LE(p) == READ32LE(""alse"")) {
          lua_pushboolean(L, false);
          return (struct DecodeJson){1, p + 4};
        } else {
          goto IllegalCharacter;
        }

      case 't':  // true
        if (context & (KEY | COLON | COMMA)) goto OnColonCommaKey;
        if (p + 3 <= e && READ32LE(p - 1) == READ32LE(""true"")) {
          lua_pushboolean(L, true);
          return (struct DecodeJson){1, p + 3};
        } else {
          goto IllegalCharacter;
        }

      default:
      IllegalCharacter:
        return (struct DecodeJson){-1, ""illegal character""};
      OnColonCommaKey:
        if (context & KEY) goto BadObjectKey;
      OnColonComma:
        if (context & COLON) goto MissingColon;
        return (struct DecodeJson){-1, ""missing ','""};
      MissingColon:
        return (struct DecodeJson){-1, ""missing ':'""};
      BadObjectKey:
        return (struct DecodeJson){-1, ""object key must be string""};

      case '-':  // negative
        if (context & (COLON | COMMA | KEY)) goto OnColonCommaKey;
        if (p < e && isdigit(*p)) {
          d = -1;
          break;
        } else {
          return (struct DecodeJson){-1, ""bad negative""};
        }

      case '0':  // zero or number
        if (context & (COLON | COMMA | KEY)) goto OnColonCommaKey;
        if (p < e) {
          if (*p == '.') {
            if (p + 1 == e || !isdigit(p[1])) {
              return (struct DecodeJson){-1, ""bad double""};
            }
            goto UseDubble;
          } else if (*p == 'e' || *p == 'E') {
            goto UseDubble;
          } else if (isdigit(*p)) {
            return (struct DecodeJson){-1, ""unexpected octal""};
          }
        }
        lua_pushinteger(L, 0);
        return (struct DecodeJson){1, p};

      case '1' ... '9':  // integer
        if (context & (COLON | COMMA | KEY)) goto OnColonCommaKey;
        for (x = (c - '0') * d; p < e; ++p) {
          c = *p & 255;
          if (isdigit(c)) {
            if (ckd_mul(&x, x, 10) || ckd_add(&x, x, (c - '0') * d)) {
              goto UseDubble;
            }
          } else if (c == '.') {
            if (p + 1 == e || !isdigit(p[1])) {
              return (struct DecodeJson){-1, ""bad double""};
            }
            goto UseDubble;
          } else if (c == 'e' || c == 'E') {
            goto UseDubble;
          } else {
            break;
          }
        }
        lua_pushinteger(L, x);
        return (struct DecodeJson){1, p};

      UseDubble:  // number
        lua_pushnumber(L, StringToDouble(a, e - a, &c));
        DCHECK(c > 0, ""paranoid avoiding infinite loop"");
        if (a + c < e && (a[c] == 'e' || a[c] == 'E')) {
          return (struct DecodeJson){-1, ""bad exponent""};
        }
        return (struct DecodeJson){1, a + c};

      case '[':  // Array
        if (context & (COLON | COMMA | KEY)) goto OnColonCommaKey;
        lua_newtable(L);  // +1
        for (context = ARRAY, i = 0;;) {
          r = Parse(L, p, e, context, depth - 1);  // +2
          if (UNLIKELY(r.rc == -1)) {
            lua_pop(L, 1);
            return r;
          }
          p = r.p;
          if (!r.rc) {
            break;
          }
          lua_rawseti(L, -2, i++ + 1);
          context = ARRAY | COMMA;
        }
        if (!i) {
          // we need this kludge so `[]` won't round-trip as `{}`
          lua_pushboolean(L, false);  // +2
          lua_rawseti(L, -2, 0);
        }
        return (struct DecodeJson){1, p};

      case ']':
        if (context & ARRAY) {
          return (struct DecodeJson){0, p};
        } else {
          return (struct DecodeJson){-1, ""unexpected ']'""};
        }

      case '}':
        if (context & OBJECT) {
          return (struct DecodeJson){0, p};
        } else {
          return (struct DecodeJson){-1, ""unexpected '}'""};
        }

      case '{':  // Object
        if (context & (COLON | COMMA | KEY)) goto OnColonCommaKey;
        lua_newtable(L);  // +1
        context = KEY | OBJECT;
        for (;;) {
          r = Parse(L, p, e, context, depth - 1);  // +2
          if (r.rc == -1) {
            lua_pop(L, 1);
            return r;
          }
          p = r.p;
          if (!r.rc) {
            return (struct DecodeJson){1, p};
          }
          r = Parse(L, p, e, COLON, depth - 1);  // +3
          if (r.rc == -1) {
            lua_pop(L, 2);
            return r;
          }
          if (!r.rc) {
            lua_pop(L, 2);
            return (struct DecodeJson){-1, ""unexpected eof in object""};
          }
          p = r.p;
          lua_settable(L, -3);
          context = KEY | COMMA | OBJECT;
        }

      case '""':  // string
        if (context & (COLON | COMMA)) goto OnColonComma;
        luaL_buffinit(L, &b);
        for (;;) {
          if (UNLIKELY(p >= e)) {
          UnexpectedEofString:
            reason = ""unexpected eof in string"";
            goto StringFailureWithReason;
          }
          switch (kJsonStr[(c = *p++ & 255)]) {

            case ASCII:
              luaL_addchar(&b, c);
              break;

            case DQUOTE:
              luaL_pushresult(&b);
              return (struct DecodeJson){1, p};

            case BACKSLASH:
              if (p >= e) {
                goto UnexpectedEofString;
              }
              switch ((c = *p++ & 255)) {
                case '""':
                case '/':
                case '\\':
                  luaL_addchar(&b, c);
                  break;
                case 'b':
                  luaL_addchar(&b, '\b');
                  break;
                case 'f':
                  luaL_addchar(&b, '\f');
                  break;
                case 'n':
                  luaL_addchar(&b, '\n');
                  break;
                case 'r':
                  luaL_addchar(&b, '\r');
                  break;
                case 't':
                  luaL_addchar(&b, '\t');
                  break;
                case 'x':
                  if (p + 2 <= e &&                         //
                      (A = kHexToInt[p[0] & 255]) != -1 &&  // HEX
                      (B = kHexToInt[p[1] & 255]) != -1) {  //
                    c = A << 4 | B;
                    if (!(0x20 <= c && c <= 0x7E)) {
                      reason = ""hex escape not printable"";
                      goto StringFailureWithReason;
                    }
                    p += 2;
                    luaL_addchar(&b, c);
                    break;
                  } else {
                    reason = ""invalid hex escape"";
                    goto StringFailureWithReason;
                  }
                case 'u':
                  if (p + 4 <= e &&                         //
                      (A = kHexToInt[p[0] & 255]) != -1 &&  //
                      (B = kHexToInt[p[1] & 255]) != -1 &&  // UCS-2
                      (C = kHexToInt[p[2] & 255]) != -1 &&  //
                      (D = kHexToInt[p[3] & 255]) != -1) {  //
                    c = A << 12 | B << 8 | C << 4 | D;
                    if (!IsSurrogate(c)) {
                      p += 4;
                    } else if (IsHighSurrogate(c)) {
                      if (p + 4 + 6 <= e &&                     //
                          p[4] == '\\' &&                       //
                          p[5] == 'u' &&                        //
                          (A = kHexToInt[p[6] & 255]) != -1 &&  // UTF-16
                          (B = kHexToInt[p[7] & 255]) != -1 &&  //
                          (C = kHexToInt[p[8] & 255]) != -1 &&  //
                          (D = kHexToInt[p[9] & 255]) != -1) {  //
                        u = A << 12 | B << 8 | C << 4 | D;
                        if (IsLowSurrogate(u)) {
                          p += 4 + 6;
                          c = MergeUtf16(c, u);
                        } else {
                          goto BadUnicode;
                        }
                      } else {
                        goto BadUnicode;
                      }
                    } else {
                      goto BadUnicode;
                    }
                    // UTF-8
                  EncodeUtf8:
                    if (c <= 0x7f) {
                      w[0] = c;
                      i = 1;
                    } else if (c <= 0x7ff) {
                      w[0] = 0300 | (c >> 6);
                      w[1] = 0200 | (c & 077);
                      i = 2;
                    } else if (c <= 0xffff) {
                      if (IsSurrogate(c)) {
                      ReplacementCharacter:
                        c = 0xfffd;
                      }
                      w[0] = 0340 | (c >> 12);
                      w[1] = 0200 | ((c >> 6) & 077);
                      w[2] = 0200 | (c & 077);
                      i = 3;
                    } else if (~(c >> 18) & 007) {
                      w[0] = 0360 | (c >> 18);
                      w[1] = 0200 | ((c >> 12) & 077);
                      w[2] = 0200 | ((c >> 6) & 077);
                      w[3] = 0200 | (c & 077);
                      i = 4;
                    } else {
                      goto ReplacementCharacter;
                    }
                    luaL_addlstring(&b, w, i);
                  } else {
                    reason = ""invalid unicode escape"";
                    goto StringFailureWithReason;
                  BadUnicode:
                    // Echo invalid \uXXXX sequences
                    // Rather than corrupting UTF-8!
                    luaL_addstring(&b, ""\\u"");
                  }
                  break;
                default:
                  reason = ""invalid escape character"";
                  goto StringFailureWithReason;
              }
              break;

            case UTF8_2:
              if (p < e &&                  //
                  (p[0] & 0300) == 0200) {  //
                c = (c & 037) << 6 |        //
                    (p[0] & 077);           //
                p += 1;
                goto EncodeUtf8;
              } else {
                reason = ""malformed utf-8"";
                goto StringFailureWithReason;
              }

            case UTF8_3_E0:
              if (p + 2 <= e &&             //
                  (p[0] & 0377) < 0240 &&   //
                  (p[0] & 0300) == 0200 &&  //
                  (p[1] & 0300) == 0200) {
                reason = ""overlong utf-8 0..0x7ff"";
                goto StringFailureWithReason;
              }
              // fallthrough
            case UTF8_3:
            ThreeUtf8:
              if (p + 2 <= e &&             //
                  (p[0] & 0300) == 0200 &&  //
                  (p[1] & 0300) == 0200) {  //
                c = (c & 017) << 12 |       //
                    (p[0] & 077) << 6 |     //
                    (p[1] & 077);           //
                p += 2;
                goto EncodeUtf8;
              } else {
                reason = ""malformed utf-8"";
                goto StringFailureWithReason;
              }

            case UTF8_3_ED:
              if (p + 2 <= e &&                  //
                  (p[0] & 0377) >= 0240) {       //
                if (p + 5 <= e &&                //
                    (p[0] & 0377) >= 0256 &&     //
                    (p[1] & 0300) == 0200 &&     //
                    (p[2] & 0377) == 0355 &&     //
                    (p[3] & 0377) >= 0260 &&     //
                    (p[4] & 0300) == 0200) {     //
                  A = (0355 & 017) << 12 |       // CESU-8
                      (p[0] & 077) << 6 |        //
                      (p[1] & 077);              //
                  B = (0355 & 017) << 12 |       //
                      (p[3] & 077) << 6 |        //
                      (p[4] & 077);              //
                  c = ((A - 0xDB80) << 10) +     //
                      ((B - 0xDC00) + 0x10000);  //
                  goto EncodeUtf8;
                } else if ((p[0] & 0300) == 0200 &&  //
                           (p[1] & 0300) == 0200) {  //
                  reason = ""utf-16 surrogate in utf-8"";
                  goto StringFailureWithReason;
                } else {
                  reason = ""malformed utf-8"";
                  goto StringFailureWithReason;
                }
              }
              goto ThreeUtf8;

            case UTF8_4_F0:
              if (p + 3 <= e && (p[0] & 0377) < 0220 &&
                  (((uint32_t)(p[+2] & 0377) << 030 |
                    (uint32_t)(p[+1] & 0377) << 020 |
                    (uint32_t)(p[+0] & 0377) << 010 |
                    (uint32_t)(p[-1] & 0377) << 000) &
                   0xC0C0C000) == 0x80808000) {
                reason = ""overlong utf-8 0..0xffff"";
                goto StringFailureWithReason;
              }
              // fallthrough
            case UTF8_4:
              if (p + 3 <= e &&                               //
                  ((A = ((uint32_t)(p[+2] & 0377) << 030 |    //
                         (uint32_t)(p[+1] & 0377) << 020 |    //
                         (uint32_t)(p[+0] & 0377) << 010 |    //
                         (uint32_t)(p[-1] & 0377) << 000)) &  //
                   0xC0C0C000) == 0x80808000) {               //
                A = (A & 7) << 18 |                           //
                    (A & (077 << 010)) << (12 - 010) |        //
                    (A & (077 << 020)) >> -(6 - 020) |        //
                    (A & (077 << 030)) >> 030;                //
                if (A <= 0x10FFFF) {
                  c = A;
                  p += 3;
                  goto EncodeUtf8;
                } else {
                  reason = ""utf-8 exceeds utf-16 range"";
                  goto StringFailureWithReason;
                }
              } else {
                reason = ""malformed utf-8"";
                goto StringFailureWithReason;
              }

            case EVILUTF8:
              if (p < e &&                  //
                  (p[0] & 0300) == 0200) {  //
                reason = ""overlong ascii"";
                goto StringFailureWithReason;
              }
              // fallthrough
            case BADUTF8:
              reason = ""illegal utf-8 character"";
              goto StringFailureWithReason;

            case C0:
              reason = ""non-del c0 control code in string"";
              goto StringFailureWithReason;

            case C1:
              reason = ""c1 control code in string"";
              goto StringFailureWithReason;

            default:
              __builtin_unreachable();
          }
        }
        __builtin_unreachable();
      StringFailureWithReason:
        luaL_pushresultsize(&b, 0);
        lua_pop(L, 1);
        return (struct DecodeJson){-1, reason};
    }
  }
  if (depth == DEPTH) {
    return (struct DecodeJson){0, 0};
  } else {
    return (struct DecodeJson){-1, ""unexpected eof""};
  }
}

/**
 * Parses JSON data structure string into Lua data structure.
 *
 * This function returns the number of items pushed to the Lua stack,
 * which should be 1, unless no parseable JSON content was found, in
 * which case this will return 0. On error -1 is returned. There's
 * currently no error return condition. This function doesn't do JSON
 * validity enforcement.
 *
 * JSON UTF-16 strings are re-encoded as valid UTF-8. 64-bit integers
 * are supported. If an integer overflows during parsing, it'll be
 * converted to a floating-point number instead. Invalid surrogate
 * escape sequences in strings won't be decoded.
 *
 * @param L is Lua interpreter state
 * @param p is input string
 * @param n is byte length of `p` or -1 for automatic strlen()
 * @return r.rc is 1 if value is pushed on lua stack
 * @return r.rc is 0 on eof
 * @return r.rc is -1 on error
 * @return r.p is is advanced `p` pointer if `rc ≥ 0`
 * @return r.p is string describing error if `rc < 0`
 */
struct DecodeJson DecodeJson(struct lua_State *L, const char *p, size_t n) {
  if (n == -1) n = p ? strlen(p) : 0;
  if (lua_checkstack(L, DEPTH * 3 + LUA_MINSTACK)) {
    return Parse(L, p, p + n, 0, DEPTH);
  } else {
    return (struct DecodeJson){-1, ""can't set stack depth""};
  }
}
"
./repos/cosmopolitan/tool/net/lfinger.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""net/finger/finger.h""
#include ""third_party/lua/lauxlib.h""

// finger.DescribeSyn(syn_packet_bytes:str)
//     ├─→ description:str
//     └─→ nil, error:str
static int LuaDescribeSyn(lua_State *L) {
  char *q, *r;
  size_t n, m;
  const char *p;
  luaL_Buffer b;
  if (!lua_isnoneornil(L, 1)) {
    p = luaL_checklstring(L, 1, &n);
    m = 128;
    q = luaL_buffinitsize(L, &b, m);
    if ((r = DescribeSyn(q, m, p, n))) {
      luaL_pushresultsize(&b, r - q);
      return 1;
    } else {
      lua_pushnil(L);
      lua_pushstring(L, ""bad syn packet"");
      return 2;
    }
  } else {
    return lua_gettop(L);
  }
}

// finger.FingerSyn(syn_packet_bytes:str)
//     ├─→ synfinger:uint32
//     └─→ nil, error:str
static int LuaFingerSyn(lua_State *L) {
  size_t n;
  uint32_t x;
  const char *p;
  if (!lua_isnoneornil(L, 1)) {
    p = luaL_checklstring(L, 1, &n);
    if ((x = FingerSyn(p, n))) {
      lua_pushinteger(L, x);
      return 1;
    } else {
      lua_pushnil(L);
      lua_pushstring(L, ""bad syn packet"");
      return 2;
    }
  } else {
    return lua_gettop(L);
  }
}

// finger.GetSynFingerOs(synfinger:uint32)
//     ├─→ osname:str
//     └─→ nil, error:str
static int LuaGetSynFingerOs(lua_State *L) {
  int os;
  if (!lua_isnoneornil(L, 1)) {
    if ((os = GetSynFingerOs(luaL_checkinteger(L, 1)))) {
      lua_pushstring(L, GetOsName(os));
      return 1;
    } else {
      lua_pushnil(L);
      lua_pushstring(L, ""unknown syn os fingerprint"");
      return 2;
    }
  } else {
    return lua_gettop(L);
  }
}

static const luaL_Reg kLuaFinger[] = {
    {""DescribeSyn"", LuaDescribeSyn},        //
    {""FingerSyn"", LuaFingerSyn},            //
    {""GetSynFingerOs"", LuaGetSynFingerOs},  //
    {0},                                    //
};

int LuaFinger(lua_State *L) {
  luaL_newlib(L, kLuaFinger);
  return 1;
}
"
./repos/cosmopolitan/tool/net/lfuncs.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/net/lfuncs.h""
#include ""dsp/scale/cdecimate2xuint8x8.h""
#include ""libc/calls/calls.h""
#include ""libc/calls/struct/rusage.h""
#include ""libc/calls/struct/stat.h""
#include ""libc/calls/struct/timespec.h""
#include ""libc/errno.h""
#include ""libc/fmt/itoa.h""
#include ""libc/fmt/leb128.h""
#include ""libc/intrin/bsf.h""
#include ""libc/intrin/bsr.h""
#include ""libc/intrin/popcnt.h""
#include ""libc/log/check.h""
#include ""libc/log/log.h""
#include ""libc/macros.internal.h""
#include ""libc/math.h""
#include ""libc/mem/gc.h""
#include ""libc/mem/mem.h""
#include ""libc/nexgen32e/bench.h""
#include ""libc/nexgen32e/crc32.h""
#include ""libc/nexgen32e/rdtsc.h""
#include ""libc/nexgen32e/rdtscp.h""
#include ""libc/runtime/runtime.h""
#include ""libc/serialize.h""
#include ""libc/sock/sock.h""
#include ""libc/stdio/rand.h""
#include ""libc/str/highwayhash64.h""
#include ""libc/str/str.h""
#include ""libc/str/strwidth.h""
#include ""libc/str/tab.internal.h""
#include ""libc/sysv/consts/af.h""
#include ""libc/sysv/consts/ipproto.h""
#include ""libc/sysv/consts/o.h""
#include ""libc/sysv/consts/rusage.h""
#include ""libc/sysv/consts/sock.h""
#include ""libc/thread/thread.h""
#include ""libc/time/time.h""
#include ""libc/x/x.h""
#include ""net/http/escape.h""
#include ""net/http/http.h""
#include ""net/http/ip.h""
#include ""net/http/url.h""
#include ""third_party/lua/cosmo.h""
#include ""third_party/lua/lauxlib.h""
#include ""third_party/lua/lua.h""
#include ""third_party/lua/luaconf.h""
#include ""third_party/lua/lunix.h""
#include ""third_party/mbedtls/everest.h""
#include ""third_party/mbedtls/md.h""
#include ""third_party/mbedtls/md5.h""
#include ""third_party/mbedtls/platform.h""
#include ""third_party/mbedtls/sha1.h""
#include ""third_party/mbedtls/sha256.h""
#include ""third_party/mbedtls/sha512.h""
#include ""third_party/musl/netdb.h""
#include ""third_party/zlib/zlib.h""

static int Rdpid(void) {
#ifdef __x86_64__
  return rdpid();
#else
  return -1;
#endif
}

int LuaHex(lua_State *L) {
  char b[19];
  uint64_t x;
  x = luaL_checkinteger(L, 1);
  FormatHex64(b, x, true);
  lua_pushstring(L, b);
  return 1;
}

int LuaOct(lua_State *L) {
  char b[24];
  uint64_t x;
  x = luaL_checkinteger(L, 1);
  FormatOctal64(b, x, true);
  lua_pushstring(L, b);
  return 1;
}

int LuaBin(lua_State *L) {
  char b[67];
  uint64_t x;
  x = luaL_checkinteger(L, 1);
  FormatBinary64(b, x, 2);
  lua_pushstring(L, b);
  return 1;
}

int LuaGetTime(lua_State *L) {
  struct timespec now = timespec_real();
  lua_pushnumber(L, now.tv_sec + now.tv_nsec * 1e-9);
  return 1;
}

int LuaSleep(lua_State *L) {
  usleep(1e6 * luaL_checknumber(L, 1));
  return 0;
}

int LuaRdtsc(lua_State *L) {
  lua_pushinteger(L, rdtsc());
  return 1;
}

int LuaGetCpuNode(lua_State *L) {
  lua_pushinteger(L, TSC_AUX_NODE(Rdpid()));
  return 1;
}

int LuaGetCpuCore(lua_State *L) {
  lua_pushinteger(L, TSC_AUX_CORE(Rdpid()));
  return 1;
}

int LuaGetCpuCount(lua_State *L) {
  lua_pushinteger(L, __get_cpu_count());
  return 1;
}

int LuaGetLogLevel(lua_State *L) {
  lua_pushinteger(L, __log_level);
  return 1;
}

int LuaSetLogLevel(lua_State *L) {
  __log_level = luaL_checkinteger(L, 1);
  return 0;
}

static int LuaRand(lua_State *L, uint64_t impl(void)) {
  lua_pushinteger(L, impl());
  return 1;
}

int LuaLemur64(lua_State *L) {
  return LuaRand(L, lemur64);
}

int LuaRand64(lua_State *L) {
  return LuaRand(L, _rand64);
}

int LuaRdrand(lua_State *L) {
  return LuaRand(L, rdrand);
}

int LuaRdseed(lua_State *L) {
  return LuaRand(L, rdseed);
}

int LuaDecimate(lua_State *L) {
  char *p;
  size_t n, m;
  const char *s;
  luaL_Buffer buf;
  s = luaL_checklstring(L, 1, &n);
  m = ROUNDUP(n, 16);
  p = luaL_buffinitsize(L, &buf, m);
  memcpy(p, s, n);
  bzero(p + n, m - n);
  cDecimate2xUint8x8(m, (unsigned char *)p,
                     (signed char[8]){-1, -3, 3, 17, 17, 3, -3, -1});
  luaL_pushresultsize(&buf, (n + 1) >> 1);
  return 1;
}

int LuaMeasureEntropy(lua_State *L) {
  size_t n;
  const char *s;
  s = luaL_checklstring(L, 1, &n);
  lua_pushnumber(L, MeasureEntropy(s, n));
  return 1;
}

int LuaGetHostOs(lua_State *L) {
  const char *s = NULL;
  if (IsLinux()) {
    s = ""LINUX"";
  } else if (IsMetal()) {
    s = ""METAL"";
  } else if (IsWindows()) {
    s = ""WINDOWS"";
  } else if (IsXnu()) {
    s = ""XNU"";
  } else if (IsOpenbsd()) {
    s = ""OPENBSD"";
  } else if (IsFreebsd()) {
    s = ""FREEBSD"";
  } else if (IsNetbsd()) {
    s = ""NETBSD"";
  }
  if (s) {
    lua_pushstring(L, s);
  } else {
    lua_pushnil(L);
  }
  return 1;
}

int LuaGetHostIsa(lua_State *L) {
  const char *s;
#ifdef __x86_64__
  s = ""X86_64"";
#elif defined(__aarch64__)
  s = ""AARCH64"";
#elif defined(__powerpc64__)
  s = ""POWERPC64"";
#elif defined(__s390x__)
  s = ""S390X"";
#else
#error ""unsupported architecture""
#endif
  lua_pushstring(L, s);
  return 1;
}

int LuaFormatIp(lua_State *L) {
  char b[16];
  uint32_t ip;
  ip = htonl(luaL_checkinteger(L, 1));
  inet_ntop(AF_INET, &ip, b, sizeof(b));
  lua_pushstring(L, b);
  return 1;
}

int LuaParseIp(lua_State *L) {
  size_t n;
  const char *s;
  s = luaL_checklstring(L, 1, &n);
  lua_pushinteger(L, ParseIp(s, n));
  return 1;
}

static int LuaIsIp(lua_State *L, bool IsIp(uint32_t)) {
  lua_pushboolean(L, IsIp(luaL_checkinteger(L, 1)));
  return 1;
}

int LuaIsPublicIp(lua_State *L) {
  return LuaIsIp(L, IsPublicIp);
}

int LuaIsPrivateIp(lua_State *L) {
  return LuaIsIp(L, IsPrivateIp);
}

int LuaIsLoopbackIp(lua_State *L) {
  return LuaIsIp(L, IsLoopbackIp);
}

int LuaCategorizeIp(lua_State *L) {
  lua_pushstring(L, GetIpCategoryName(CategorizeIp(luaL_checkinteger(L, 1))));
  return 1;
}

int LuaFormatHttpDateTime(lua_State *L) {
  char buf[30];
  lua_pushstring(L, FormatUnixHttpDateTime(buf, luaL_checkinteger(L, 1)));
  return 1;
}

int LuaParseHttpDateTime(lua_State *L) {
  size_t n;
  const char *s;
  s = luaL_checklstring(L, 1, &n);
  lua_pushinteger(L, ParseHttpDateTime(s, n));
  return 1;
}

int LuaParseParams(lua_State *L) {
  void *m;
  size_t size;
  const char *data;
  struct UrlParams h;
  if (!lua_isnoneornil(L, 1)) {
    data = luaL_checklstring(L, 1, &size);
    bzero(&h, sizeof(h));
    if ((m = ParseParams(data, size, &h))) {
      LuaPushUrlParams(L, &h);
      free(h.p);
      free(m);
      return 1;
    } else {
      luaL_error(L, ""out of memory"");
      __builtin_unreachable();
    }
  } else {
    return lua_gettop(L);
  }
}

int LuaParseHost(lua_State *L) {
  void *m;
  size_t n;
  struct Url h;
  const char *p;
  if (!lua_isnoneornil(L, 1)) {
    bzero(&h, sizeof(h));
    p = luaL_checklstring(L, 1, &n);
    if ((m = ParseHost(p, n, &h))) {
      lua_newtable(L);
      LuaPushUrlView(L, &h.host);
      LuaPushUrlView(L, &h.port);
      free(m);
      return 1;
    } else {
      luaL_error(L, ""out of memory"");
      __builtin_unreachable();
    }
  } else {
    return lua_gettop(L);
  }
}

int LuaPopcnt(lua_State *L) {
  lua_pushinteger(L, popcnt(luaL_checkinteger(L, 1)));
  return 1;
}

int LuaBsr(lua_State *L) {
  long x;
  if ((x = luaL_checkinteger(L, 1))) {
    lua_pushinteger(L, bsrl(x));
    return 1;
  } else {
    luaL_argerror(L, 1, ""zero"");
    __builtin_unreachable();
  }
}

int LuaBsf(lua_State *L) {
  long x;
  if ((x = luaL_checkinteger(L, 1))) {
    lua_pushinteger(L, bsfl(x));
    return 1;
  } else {
    luaL_argerror(L, 1, ""zero"");
    __builtin_unreachable();
  }
}

int LuaHighwayHash64(lua_State *L) {
  size_t n;
  uint64_t k[4];
  const char *p;
  p = luaL_checklstring(L, 1, &n);
  k[0] = luaL_optinteger(L, 2, 0);
  k[1] = luaL_optinteger(L, 3, 0);
  k[2] = luaL_optinteger(L, 4, 0);
  k[3] = luaL_optinteger(L, 5, 0);
  lua_pushinteger(L, HighwayHash64(p, n, k));
  return 1;
}

static int LuaHash(lua_State *L, uint32_t H(uint32_t, const void *, size_t)) {
  long i;
  size_t n;
  const char *p;
  i = luaL_checkinteger(L, 1);
  p = luaL_checklstring(L, 2, &n);
  lua_pushinteger(L, H(i, p, n));
  return 1;
}

int LuaCrc32(lua_State *L) {
  return LuaHash(L, crc32_z);
}

int LuaCrc32c(lua_State *L) {
  return LuaHash(L, crc32c);
}

int LuaIndentLines(lua_State *L) {
  size_t n, j;
  const void *p;
  if (!lua_isnoneornil(L, 1)) {
    p = luaL_checklstring(L, 1, &n);
    j = luaL_optinteger(L, 2, 1);
    if (!(0 <= j && j <= 65535)) {
      luaL_argerror(L, 2, ""not in range 0..65535"");
      __builtin_unreachable();
    }
    char *q = IndentLines(p, n, &n, j);
    lua_pushlstring(L, q, n);
    free(q);
    return 1;
  } else {
    return lua_gettop(L);
  }
}

int LuaGetMonospaceWidth(lua_State *L) {
  int w;
  if (lua_isnumber(L, 1)) {
    w = wcwidth(lua_tointeger(L, 1));
  } else if (lua_isstring(L, 1)) {
    w = strwidth(luaL_checkstring(L, 1), luaL_optinteger(L, 2, 0) & 7);
  } else {
    luaL_argerror(L, 1, ""not integer or string"");
    __builtin_unreachable();
  }
  lua_pushinteger(L, w);
  return 1;
}

// Slurp(path:str[, i:int[, j:int]])
//     ├─→ data:str
//     └─→ nil, unix.Errno
int LuaSlurp(lua_State *L) {
  ssize_t rc;
  char tb[2048];
  luaL_Buffer b;
  struct stat st;
  int fd, olderr;
  bool shouldpread;
  lua_Integer i, j, got;
  olderr = errno;
  if (lua_isnoneornil(L, 2)) {
    i = 1;
  } else {
    i = luaL_checkinteger(L, 2);
  }
  if (lua_isnoneornil(L, 3)) {
    j = LUA_MAXINTEGER;
  } else {
    j = luaL_checkinteger(L, 3);
  }
  luaL_buffinit(L, &b);
  if ((fd = open(luaL_checkstring(L, 1), O_RDONLY | O_SEQUENTIAL)) == -1) {
    return LuaUnixSysretErrno(L, ""open"", olderr);
  }
  if (i < 0 || j < 0) {
    if (fstat(fd, &st) == -1) {
      close(fd);
      return LuaUnixSysretErrno(L, ""fstat"", olderr);
    }
    if (i < 0) {
      i = st.st_size + (i + 1);
    }
    if (j < 0) {
      j = st.st_size + (j + 1);
    }
  }
  if (i < 1) {
    i = 1;
  }
  shouldpread = i > 1;
  for (; i <= j; i += got) {
    if (shouldpread) {
      rc = pread(fd, tb, MIN(j - i + 1, sizeof(tb)), i - 1);
    } else {
      rc = read(fd, tb, MIN(j - i + 1, sizeof(tb)));
    }
    if (rc != -1) {
      got = rc;
      if (!got) break;
      luaL_addlstring(&b, tb, got);
    } else if (errno == EINTR) {
      errno = olderr;
      got = 0;
    } else {
      close(fd);
      return LuaUnixSysretErrno(L, ""read"", olderr);
    }
  }
  if (close(fd) == -1) {
    return LuaUnixSysretErrno(L, ""close"", olderr);
  }
  luaL_pushresult(&b);
  return 1;
}

// Barf(path:str, data:str[, mode:int[, flags:int[, offset:int]]])
//     ├─→ true
//     └─→ nil, unix.Errno
int LuaBarf(lua_State *L) {
  ssize_t rc;
  const char *data;
  lua_Number offset;
  size_t i, n, wrote;
  int fd, mode, flags, olderr;
  olderr = errno;
  data = luaL_checklstring(L, 2, &n);
  if (lua_isnoneornil(L, 5)) {
    offset = 0;
  } else {
    offset = luaL_checkinteger(L, 5);
    if (offset < 1) {
      luaL_error(L, ""offset must be >= 1"");
      __builtin_unreachable();
    }
    --offset;
  }
  mode = luaL_optinteger(L, 3, 0644);
  flags = O_WRONLY | O_SEQUENTIAL | luaL_optinteger(L, 4, O_TRUNC | O_CREAT);
  if (flags & O_NONBLOCK) {
    luaL_error(L, ""O_NONBLOCK not allowed"");
    __builtin_unreachable();
  }
  if ((flags & O_APPEND) && offset) {
    luaL_error(L, ""O_APPEND with offset not possible"");
    __builtin_unreachable();
  }
  if ((fd = open(luaL_checkstring(L, 1), flags, mode)) == -1) {
    return LuaUnixSysretErrno(L, ""open"", olderr);
  }
  for (i = 0; i < n; i += wrote) {
    if (offset) {
      rc = pwrite(fd, data + i, n - i, offset + i);
    } else {
      rc = write(fd, data + i, n - i);
    }
    if (rc != -1) {
      wrote = rc;
    } else if (errno == EINTR) {
      errno = olderr;
      wrote = 0;
    } else {
      close(fd);
      return LuaUnixSysretErrno(L, ""write"", olderr);
    }
  }
  if (close(fd) == -1) {
    return LuaUnixSysretErrno(L, ""close"", olderr);
  }
  lua_pushboolean(L, true);
  return 1;
}

int LuaResolveIp(lua_State *L) {
  ssize_t rc;
  int64_t ip;
  const char *host;
  struct addrinfo *ai = NULL;
  struct addrinfo hint = {AI_NUMERICSERV, AF_INET, SOCK_STREAM, IPPROTO_TCP};
  host = luaL_checkstring(L, 1);
  if ((ip = ParseIp(host, -1)) != -1) {
    lua_pushinteger(L, ip);
    return 1;
  } else if ((rc = getaddrinfo(host, ""0"", &hint, &ai)) == 0) {
    lua_pushinteger(
        L, ntohl(((struct sockaddr_in *)ai->ai_addr)->sin_addr.s_addr));
    freeaddrinfo(ai);
    return 1;
  } else {
    lua_pushnil(L);
    lua_pushfstring(L, ""%s: DNS lookup failed: EAI_%s"", host, gai_strerror(rc));
    return 2;
  }
}

static int LuaCheckControlFlags(lua_State *L, int idx) {
  int f = luaL_optinteger(L, idx, 0);
  if (f & ~(kControlWs | kControlC0 | kControlC1)) {
    luaL_argerror(L, idx, ""invalid control flags"");
    __builtin_unreachable();
  }
  return f;
}

int LuaHasControlCodes(lua_State *L) {
  int f;
  size_t n;
  const char *p;
  p = luaL_checklstring(L, 1, &n);
  f = LuaCheckControlFlags(L, 2);
  lua_pushboolean(L, HasControlCodes(p, n, f) != -1);
  return 1;
}

int LuaEncodeLatin1(lua_State *L) {
  int f;
  char *q;
  size_t n;
  const char *p;
  p = luaL_checklstring(L, 1, &n);
  f = LuaCheckControlFlags(L, 2);
  if ((q = EncodeLatin1(p, n, &n, f))) {
    lua_pushlstring(L, q, n);
    free(q);
    return 1;
  } else {
    luaL_error(L, ""out of memory"");
    __builtin_unreachable();
  }
}

dontinline int LuaBase32Impl(lua_State *L,
                             char *B32(const char *, size_t, const char *,
                                       size_t, size_t *)) {
  char *p;
  size_t sl, al;  // source/output and alphabet lengths
  const char *s = luaL_checklstring(L, 1, &sl);
  // use an empty string, as EncodeBase32 provides a default value
  const char *a = luaL_optlstring(L, 2, """", &al);
  if (!IS2POW(al) || al > 128 || al == 1)
    return luaL_error(L, ""alphabet length is not a power of 2 in range 2..128"");
  if (!(p = B32(s, sl, a, al, &sl))) return luaL_error(L, ""out of memory"");
  lua_pushlstring(L, p, sl);
  free(p);
  return 1;
}

int LuaEncodeBase32(lua_State *L) {
  return LuaBase32Impl(L, EncodeBase32);
}

int LuaDecodeBase32(lua_State *L) {
  return LuaBase32Impl(L, DecodeBase32);
}

int LuaEncodeHex(lua_State *L) {
  char *p;
  size_t n;
  const char *s;
  luaL_Buffer buf;
  s = luaL_checklstring(L, 1, &n);
  p = luaL_buffinitsize(L, &buf, n * 2 + 1);
  hexpcpy(p, s, n);
  luaL_pushresultsize(&buf, n * 2);
  return 1;
}

int LuaDecodeHex(lua_State *L) {
  char *p;
  int x, y;
  size_t i, n;
  const char *s;
  luaL_Buffer buf;
  s = luaL_checklstring(L, 1, &n);
  if (n & 1) {
    luaL_argerror(L, 1, ""hex string length uneven"");
    __builtin_unreachable();
  }
  p = luaL_buffinitsize(L, &buf, n >> 1);
  for (i = 0; i < n; i += 2) {
    if ((x = kHexToInt[s[i + 0] & 255]) == -1 ||
        (y = kHexToInt[s[i + 1] & 255]) == -1) {
      luaL_argerror(L, 1, ""hex string has non-hex character"");
      __builtin_unreachable();
    }
    p[i >> 1] = x << 4 | y;
  }
  luaL_pushresultsize(&buf, n >> 1);
  return 1;
}

int LuaGetRandomBytes(lua_State *L) {
  size_t n;
  luaL_Buffer buf;
  n = luaL_optinteger(L, 1, 16);
  if (!(n > 0 && n <= 256)) {
    luaL_argerror(L, 1, ""not in range 1..256"");
    __builtin_unreachable();
  }
  CHECK_EQ(n, getrandom(luaL_buffinitsize(L, &buf, n), n, 0));
  luaL_pushresultsize(&buf, n);
  return 1;
}

int LuaGetHttpReason(lua_State *L) {
  lua_pushstring(L, GetHttpReason(luaL_checkinteger(L, 1)));
  return 1;
}

int LuaGetCryptoHash(lua_State *L) {
  size_t hl, pl, kl;
  uint8_t d[64];
  // get hash name, payload, and key
  const void *h = luaL_checklstring(L, 1, &hl);
  const void *p = luaL_checklstring(L, 2, &pl);
  const void *k = luaL_optlstring(L, 3, """", &kl);
  const mbedtls_md_info_t *digest = mbedtls_md_info_from_string(h);
  if (!digest) return luaL_argerror(L, 1, ""unknown hash type"");
  if (kl == 0) {
    // no key provided, run generic hash function
    if ((digest->f_md)(p, pl, d)) return luaL_error(L, ""bad input data"");
  } else if (mbedtls_md_hmac(digest, k, kl, p, pl, d)) {
    return luaL_error(L, ""bad input data"");
  }
  lua_pushlstring(L, (void *)d, digest->size);
  mbedtls_platform_zeroize(d, sizeof(d));
  return 1;
}

static dontinline int LuaIsValid(lua_State *L, bool V(const char *, size_t)) {
  size_t size;
  const char *data;
  data = luaL_checklstring(L, 1, &size);
  lua_pushboolean(L, V(data, size));
  return 1;
}

int LuaIsValidHttpToken(lua_State *L) {
  return LuaIsValid(L, IsValidHttpToken);
}

int LuaIsAcceptablePath(lua_State *L) {
  return LuaIsValid(L, IsAcceptablePath);
}

int LuaIsReasonablePath(lua_State *L) {
  return LuaIsValid(L, IsReasonablePath);
}

int LuaIsAcceptableHost(lua_State *L) {
  return LuaIsValid(L, IsAcceptableHost);
}

int LuaIsAcceptablePort(lua_State *L) {
  return LuaIsValid(L, IsAcceptablePort);
}

static dontinline int LuaCoderImpl(lua_State *L,
                                   char *C(const char *, size_t, size_t *)) {
  void *q;
  size_t n;
  const void *p;
  if (!lua_isnoneornil(L, 1)) {
    p = luaL_checklstring(L, 1, &n);
    if ((q = C(p, n, &n))) {
      lua_pushlstring(L, q, n);
      free(q);
    } else {
      luaL_error(L, ""out of memory"");
      __builtin_unreachable();
    }
    return 1;
  } else {
    return lua_gettop(L);
  }
}

static dontinline int LuaCoder(lua_State *L,
                               char *C(const char *, size_t, size_t *)) {
  return LuaCoderImpl(L, C);
}

int LuaUnderlong(lua_State *L) {
  return LuaCoder(L, Underlong);
}

int LuaEncodeBase64(lua_State *L) {
  return LuaCoder(L, EncodeBase64);
}

int LuaDecodeBase64(lua_State *L) {
  return LuaCoder(L, DecodeBase64);
}

int LuaDecodeLatin1(lua_State *L) {
  return LuaCoder(L, DecodeLatin1);
}

int LuaEscapeHtml(lua_State *L) {
  return LuaCoder(L, EscapeHtml);
}

int LuaEscapeParam(lua_State *L) {
  return LuaCoder(L, EscapeParam);
}

int LuaEscapePath(lua_State *L) {
  return LuaCoder(L, EscapePath);
}

int LuaEscapeHost(lua_State *L) {
  return LuaCoder(L, EscapeHost);
}

int LuaEscapeIp(lua_State *L) {
  return LuaCoder(L, EscapeIp);
}

int LuaEscapeUser(lua_State *L) {
  return LuaCoder(L, EscapeUser);
}

int LuaEscapePass(lua_State *L) {
  return LuaCoder(L, EscapePass);
}

int LuaEscapeSegment(lua_State *L) {
  return LuaCoder(L, EscapeSegment);
}

int LuaEscapeFragment(lua_State *L) {
  return LuaCoder(L, EscapeFragment);
}

int LuaEscapeLiteral(lua_State *L) {
  const char *p;
  char *z, *q = 0;
  size_t n, y = 0;
  p = luaL_checklstring(L, 1, &n);
  if ((z = EscapeJsStringLiteral(&q, &y, p, n, &n))) {
    lua_pushlstring(L, z, n);
    free(z);
    return 1;
  } else {
    luaL_error(L, ""out of memory"");
    __builtin_unreachable();
  }
}

int LuaVisualizeControlCodes(lua_State *L) {
  return LuaCoder(L, VisualizeControlCodes);
}

static dontinline int LuaHasherImpl(lua_State *L, size_t k,
                                    int H(const void *, size_t, uint8_t *)) {
  size_t n;
  uint8_t d[64];
  const void *p;
  if (!lua_isnoneornil(L, 1)) {
    p = luaL_checklstring(L, 1, &n);
    H(p, n, d);
    lua_pushlstring(L, (void *)d, k);
    mbedtls_platform_zeroize(d, sizeof(d));
    return 1;
  } else {
    return lua_gettop(L);
  }
}

static dontinline int LuaHasher(lua_State *L, size_t k,
                                int H(const void *, size_t, uint8_t *)) {
  return LuaHasherImpl(L, k, H);
}

int LuaMd5(lua_State *L) {
  return LuaHasher(L, 16, mbedtls_md5_ret);
}

int LuaSha1(lua_State *L) {
  return LuaHasher(L, 20, mbedtls_sha1_ret);
}

int LuaSha224(lua_State *L) {
  return LuaHasher(L, 28, mbedtls_sha256_ret_224);
}

int LuaSha256(lua_State *L) {
  return LuaHasher(L, 32, mbedtls_sha256_ret_256);
}

int LuaSha384(lua_State *L) {
  return LuaHasher(L, 48, mbedtls_sha512_ret_384);
}

int LuaSha512(lua_State *L) {
  return LuaHasher(L, 64, mbedtls_sha512_ret_512);
}

int LuaIsHeaderRepeatable(lua_State *L) {
  int h;
  bool r;
  size_t n;
  const char *s;
  s = luaL_checklstring(L, 1, &n);
  if ((h = GetHttpHeader(s, n)) != -1) {
    r = kHttpRepeatable[h];
  } else {
    r = false;
  }
  lua_pushboolean(L, r);
  return 1;
}

void LuaPushUrlView(lua_State *L, struct UrlView *v) {
  if (v->p) {
    lua_pushlstring(L, v->p, v->n);
  } else {
    lua_pushnil(L);
  }
}

static int64_t GetInterrupts(void) {
  struct rusage ru;
  if (!getrusage(RUSAGE_SELF, &ru)) {
    return ru.ru_nivcsw;
  } else {
    return 0;
  }
}

static int DoNothing(lua_State *L) {
  return 0;
}

int LuaBenchmark(lua_State *L) {
  uint64_t t1, t2;
  int64_t interrupts;
  double avgticks, overhead;
  int core, iter, count, attempts, maxattempts;
  luaL_checktype(L, 1, LUA_TFUNCTION);
  count = luaL_optinteger(L, 2, 100);
  maxattempts = luaL_optinteger(L, 3, 10);
  __warn_if_powersave();
  lua_gc(L, LUA_GCSTOP);

  for (attempts = 0;;) {
    lua_gc(L, LUA_GCCOLLECT);
    pthread_yield();
    core = TSC_AUX_CORE(Rdpid());
    interrupts = GetInterrupts();
    for (avgticks = iter = 1; iter < count; ++iter) {
      lua_pushcfunction(L, DoNothing);
      t1 = __startbench_m();
      lua_call(L, 0, 0);
      t2 = __endbench_m();
      avgticks += 1. / iter * ((int)(t2 - t1) - avgticks);
    }
    ++attempts;
    if (TSC_AUX_CORE(Rdpid()) == core && GetInterrupts() == interrupts) {
      break;
    } else if (attempts >= maxattempts) {
      luaL_error(L, ""system is under too much load to run benchmark"");
      __builtin_unreachable();
    }
  }
  overhead = avgticks;

  for (attempts = 0;;) {
    lua_gc(L, LUA_GCCOLLECT);
    pthread_yield();
    core = TSC_AUX_CORE(Rdpid());
    interrupts = GetInterrupts();
    for (avgticks = iter = 1; iter < count; ++iter) {
      lua_pushvalue(L, 1);
      t1 = __startbench_m();
      lua_call(L, 0, 0);
      t2 = __endbench_m();
      avgticks += 1. / iter * ((int)(t2 - t1) - avgticks);
    }
    ++attempts;
    if (TSC_AUX_CORE(Rdpid()) == core && GetInterrupts() == interrupts) {
      break;
    } else if (attempts >= maxattempts) {
      luaL_error(L, ""system is under too much load to run benchmark"");
      __builtin_unreachable();
    }
  }
  avgticks = MAX(avgticks - overhead, 0);

  lua_gc(L, LUA_GCRESTART);
  lua_pushinteger(L, avgticks / 3);
  lua_pushinteger(L, round(avgticks));
  lua_pushinteger(L, round(overhead));
  lua_pushinteger(L, attempts);
  return 4;
}

static void LuaCompress2(lua_State *L, void *dest, size_t *destLen,
                         const void *source, size_t sourceLen, int level) {
  switch (compress2(dest, destLen, source, sourceLen, level)) {
    case Z_OK:
      break;
    case Z_BUF_ERROR:
      luaL_error(L, ""out of memory"");
      __builtin_unreachable();
    case Z_STREAM_ERROR:
      luaL_error(L, ""invalid level"");
      __builtin_unreachable();
    default:
      __builtin_unreachable();
  }
}

// VERY DEPRECATED - PLEASE DO NOT USE
int LuaCompress(lua_State *L) {
  size_t n, m;
  char *q, *e;
  uint32_t crc;
  const char *p;
  luaL_Buffer buf;
  int level, hdrlen;
  p = luaL_checklstring(L, 1, &n);
  level = luaL_optinteger(L, 2, Z_DEFAULT_COMPRESSION);
  m = compressBound(n);
  if (lua_toboolean(L, 3)) {
    // raw mode
    q = luaL_buffinitsize(L, &buf, m);
    LuaCompress2(L, q, &m, p, n, level);
  } else {
    // easy mode
    q = luaL_buffinitsize(L, &buf, 10 + 4 + m);
    crc = crc32_z(0, p, n);
    e = uleb64(q, n);
    e = WRITE32LE(e, crc);
    hdrlen = e - q;
    LuaCompress2(L, q + hdrlen, &m, p, n, level);
    m += hdrlen;
  }
  luaL_pushresultsize(&buf, m);
  return 1;
}

// VERY DEPRECATED - PLEASE DO NOT USE
int LuaUncompress(lua_State *L) {
  int rc;
  char *q;
  uint32_t crc;
  const char *p;
  luaL_Buffer buf;
  size_t n, m, len;
  p = luaL_checklstring(L, 1, &n);
  if (lua_isnoneornil(L, 2)) {
    if ((rc = unuleb64(p, n, &m)) == -1 || n < rc + 4) {
      luaL_error(L, ""compressed value too short to be valid"");
      __builtin_unreachable();
    }
    len = m;
    crc = READ32LE(p + rc);
    q = luaL_buffinitsize(L, &buf, m);
    if (uncompress((void *)q, &m, (unsigned char *)p + rc + 4, n) != Z_OK ||
        m != len || crc32_z(0, q, m) != crc) {
      luaL_error(L, ""compressed value is corrupted"");
      __builtin_unreachable();
    }
  } else {
    len = m = luaL_checkinteger(L, 2);
    q = luaL_buffinitsize(L, &buf, m);
    if (uncompress((void *)q, &m, (void *)p, n) != Z_OK || m != len) {
      luaL_error(L, ""compressed value is corrupted"");
      __builtin_unreachable();
    }
  }
  luaL_pushresultsize(&buf, m);
  return 1;
}

// unix.deflate(uncompressed:str[, level:int])
//     ├─→ compressed:str
//     └─→ nil, error:str
int LuaDeflate(lua_State *L) {
  char *out;
  z_stream zs;
  int rc, level;
  const char *in;
  luaL_Buffer buf;
  size_t insize, outsize, actualoutsize;
  in = luaL_checklstring(L, 1, &insize);
  level = luaL_optinteger(L, 2, Z_DEFAULT_COMPRESSION);
  outsize = compressBound(insize);
  out = luaL_buffinitsize(L, &buf, outsize);

  zs.next_in = (const uint8_t *)in;
  zs.avail_in = insize;
  zs.next_out = (uint8_t *)out;
  zs.avail_out = outsize;
  zs.zalloc = Z_NULL;
  zs.zfree = Z_NULL;

  if ((rc = deflateInit2(&zs, level, Z_DEFLATED, -MAX_WBITS, MAX_MEM_LEVEL,
                         Z_DEFAULT_STRATEGY)) != Z_OK) {
    lua_pushnil(L);
    lua_pushfstring(L, ""%s() failed: %d"", ""deflateInit2"", rc);
    return 2;
  }

  rc = deflate(&zs, Z_FINISH);
  actualoutsize = outsize - zs.avail_out;
  deflateEnd(&zs);

  if (rc != Z_STREAM_END) {
    lua_pushnil(L);
    lua_pushfstring(L, ""%s() failed: %d"", ""deflate"", rc);
    return 2;
  }

  luaL_pushresultsize(&buf, actualoutsize);
  return 1;
}

// unix.inflate(compressed:str, maxoutsize:int)
//     ├─→ uncompressed:str
//     └─→ nil, error:str
int LuaInflate(lua_State *L) {
  int rc;
  char *out;
  z_stream zs;
  const char *in;
  luaL_Buffer buf;
  size_t insize, outsize, actualoutsize;
  in = luaL_checklstring(L, 1, &insize);
  outsize = luaL_checkinteger(L, 2);
  out = luaL_buffinitsize(L, &buf, outsize);

  zs.next_in = (const uint8_t *)in;
  zs.avail_in = insize;
  zs.total_in = insize;
  zs.next_out = (uint8_t *)out;
  zs.avail_out = outsize;
  zs.total_out = outsize;
  zs.zalloc = Z_NULL;
  zs.zfree = Z_NULL;

  if ((rc = inflateInit2(&zs, -MAX_WBITS)) != Z_OK) {
    lua_pushnil(L);
    lua_pushfstring(L, ""%s() failed: %d"", ""inflateInit2"", rc);
    return 2;
  }

  rc = inflate(&zs, Z_FINISH);
  actualoutsize = outsize - zs.avail_out;
  inflateEnd(&zs);

  if (rc != Z_STREAM_END) {
    lua_pushnil(L);
    lua_pushfstring(L, ""%s() failed: %d"", ""inflate"", rc);
    return 2;
  }

  luaL_pushresultsize(&buf, actualoutsize);
  return 1;
}

static void GetCurve25519Arg(lua_State *L, int arg, uint8_t buf[static 32]) {
  size_t len;
  const char *val;
  val = luaL_checklstring(L, arg, &len);
  bzero(buf, 32);
  if (len) {
    if (len > 32) {
      len = 32;
    }
    memcpy(buf, val, len);
  }
}

/*
 * Example usage:
 *
 *     >: secret1 = ""\1""
 *     >: secret2 = ""\2""
 *     >: public1 = Curve25519(secret1, ""\9"")
 *     >: public2 = Curve25519(secret2, ""\9"")
 *     >: Curve25519(secret1, public2)
 *     ""\x93\xfe\xa2\xa7\xc1\xae\xb6,\xfddR\xff...
 *     >: Curve25519(secret2, public1)
 *     ""\x93\xfe\xa2\xa7\xc1\xae\xb6,\xfddR\xff...
 *
 */
int LuaCurve25519(lua_State *L) {
  uint8_t mypublic[32], secret[32], basepoint[32];
  GetCurve25519Arg(L, 1, secret);
  GetCurve25519Arg(L, 2, basepoint);
  curve25519(mypublic, secret, basepoint);
  lua_pushlstring(L, (const char *)mypublic, 32);
  return 1;
}
"
./repos/cosmopolitan/tool/net/echo.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/calls/calls.h""
#include ""libc/fmt/conv.h""
#include ""libc/intrin/kprintf.h""
#include ""libc/log/check.h""
#include ""libc/runtime/runtime.h""
#include ""libc/sock/sock.h""
#include ""libc/sock/struct/sockaddr.h""
#include ""libc/stdio/rand.h""
#include ""libc/str/str.h""
#include ""libc/sysv/consts/af.h""
#include ""libc/sysv/consts/ipproto.h""
#include ""libc/sysv/consts/sock.h""
#include ""net/http/http.h""
#include ""net/http/ip.h""

/**
 * @fileoverview tcp/udp echo servers/clients
 * use it to fill your network with junk data
 */

int sock;
char buf[1000];
struct sockaddr_in addr = {0};
uint32_t addrsize = sizeof(struct sockaddr_in);

void PrintUsage(char **argv) {
  kprintf(""usage: %s udp server [ip port]%n"", argv[0]);
  kprintf(""       %s tcp server [ip port]%n"", argv[0]);
  kprintf(""       %s udp client [ip port]%n"", argv[0]);
  kprintf(""       %s tcp client [ip port]%n"", argv[0]);
  exit(1);
}

void UdpServer(void) {
  int ip;
  ssize_t rc;
  struct sockaddr_in addr2;
  uint32_t addrsize2 = sizeof(struct sockaddr_in);
  CHECK_NE(-1, (sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)));
  CHECK_NE(-1, bind(sock, (struct sockaddr *)&addr, addrsize));
  CHECK_NE(-1, getsockname(sock, (struct sockaddr *)&addr2, &addrsize2));
  ip = ntohl(addr2.sin_addr.s_addr);
  kprintf(""udp server %hhu.%hhu.%hhu.%hhu %hu%n"", ip >> 24, ip >> 16, ip >> 8,
          ip, ntohs(addr2.sin_port));
  for (;;) {
    CHECK_NE(-1, (rc = recvfrom(sock, buf, sizeof(buf), 0,
                                (struct sockaddr *)&addr2, &addrsize2)));
    CHECK_NE(-1,
             sendto(sock, buf, rc, 0, (struct sockaddr *)&addr2, addrsize2));
  }
}

void UdpClient(void) {
  CHECK_NE(-1, (sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)));
  CHECK_NE(-1, connect(sock, (struct sockaddr *)&addr, addrsize));
  for (;;) {
    rngset(buf, sizeof(buf), _rand64, -1);
    CHECK_NE(-1, write(sock, &addr, addrsize));
  }
}

void TcpServer(void) {
  ssize_t rc;
  int ip, client;
  struct sockaddr_in addr2;
  uint32_t addrsize2 = sizeof(struct sockaddr_in);
  CHECK_NE(-1, (sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)));
  CHECK_NE(-1, bind(sock, (struct sockaddr *)&addr, addrsize));
  CHECK_NE(-1, listen(sock, 10));
  CHECK_NE(-1, getsockname(sock, (struct sockaddr *)&addr2, &addrsize2));
  ip = ntohl(addr2.sin_addr.s_addr);
  kprintf(""tcp server %hhu.%hhu.%hhu.%hhu %hu%n"", ip >> 24, ip >> 16, ip >> 8,
          ip, ntohs(addr2.sin_port));
  for (;;) {
    addrsize2 = sizeof(struct sockaddr_in);
    CHECK_NE(-1,
             (client = accept(sock, (struct sockaddr *)&addr2, &addrsize2)));
    ip = ntohl(addr2.sin_addr.s_addr);
    kprintf(""got client %hhu.%hhu.%hhu.%hhu %hu%n"", ip >> 24, ip >> 16, ip >> 8,
            ip, ntohs(addr2.sin_port));
    for (;;) {
      CHECK_NE(-1, (rc = read(client, buf, sizeof(buf))));
      if (!rc) break;
      CHECK_NE(-1, write(client, buf, rc));
    }
  }
}

void TcpClient(void) {
  CHECK_NE(-1, (sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)));
  CHECK_NE(-1, connect(sock, (struct sockaddr *)&addr, addrsize));
  for (;;) {
    rngset(buf, sizeof(buf), _rand64, -1);
    CHECK_NE(-1, write(sock, buf, sizeof(buf)));
    CHECK_NE(-1, read(sock, buf, sizeof(buf)));
  }
}

int main(int argc, char *argv[]) {
  int port = 0;
  int64_t ip = 0;
  if (argc < 3) PrintUsage(argv);
  if (argc >= 4) {
    if ((ip = ParseIp(argv[3], -1)) == -1) {
      PrintUsage(argv);
    }
  }
  if (argc >= 5) {
    port = atoi(argv[4]);
    if (port & 0xffff0000) {
      PrintUsage(argv);
    }
  }
  addr.sin_family = AF_INET;
  addr.sin_port = htons(port);
  addr.sin_addr.s_addr = htonl(ip);
  if (!strcmp(argv[1], ""udp"")) {
    if (!strcmp(argv[2], ""server"")) {
      UdpServer();
    } else if (!strcmp(argv[2], ""client"")) {
      UdpClient();
    } else {
      PrintUsage(argv);
    }
  } else if (!strcmp(argv[1], ""tcp"")) {
    if (!strcmp(argv[2], ""server"")) {
      TcpServer();
    } else if (!strcmp(argv[2], ""client"")) {
      TcpClient();
    } else {
      PrintUsage(argv);
    }
  } else {
    PrintUsage(argv);
  }
  return 0;
}
"
./repos/cosmopolitan/tool/net/lmaxmind.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2021 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/mem/mem.h""
#include ""libc/x/x.h""
#include ""third_party/lua/lauxlib.h""
#include ""third_party/lua/lua.h""
#include ""third_party/lua/luaconf.h""
#include ""third_party/maxmind/maxminddb.h""

struct MaxmindDb {
  int refs;
  MMDB_s mmdb;
};

struct MaxmindResult {
  uint32_t ip;
  struct MaxmindDb *db;
  MMDB_lookup_result_s mmlr;
};

static const char *GetMmdbError(int err) {
  switch (err) {
    case MMDB_FILE_OPEN_ERROR:
      return ""FILE_OPEN_ERROR"";
    case MMDB_CORRUPT_SEARCH_TREE_ERROR:
      return ""CORRUPT_SEARCH_TREE_ERROR"";
    case MMDB_INVALID_METADATA_ERROR:
      return ""INVALID_METADATA_ERROR"";
    case MMDB_IO_ERROR:
      return ""IO_ERROR"";
    case MMDB_OUT_OF_MEMORY_ERROR:
      return ""OUT_OF_MEMORY_ERROR"";
    case MMDB_UNKNOWN_DATABASE_FORMAT_ERROR:
      return ""UNKNOWN_DATABASE_FORMAT_ERROR"";
    case MMDB_INVALID_DATA_ERROR:
      return ""INVALID_DATA_ERROR"";
    case MMDB_INVALID_LOOKUP_PATH_ERROR:
      return ""INVALID_LOOKUP_PATH_ERROR"";
    case MMDB_LOOKUP_PATH_DOES_NOT_MATCH_DATA_ERROR:
      return ""LOOKUP_PATH_DOES_NOT_MATCH_DATA_ERROR"";
    case MMDB_INVALID_NODE_NUMBER_ERROR:
      return ""INVALID_NODE_NUMBER_ERROR"";
    case MMDB_IPV6_LOOKUP_IN_IPV4_DATABASE_ERROR:
      return ""IPV6_LOOKUP_IN_IPV4_DATABASE_ERROR"";
    default:
      return ""UNKNOWN"";
  }
};

static int LuaMaxmindOpen(lua_State *L) {
  int err;
  const char *p;
  struct MaxmindDb **udb, *db;
  p = luaL_checklstring(L, 1, 0);
  db = xmalloc(sizeof(struct MaxmindDb));
  if ((err = MMDB_open(p, 0, &db->mmdb)) != MMDB_SUCCESS) {
    free(db);
    luaL_error(L, ""MMDB_open(%s) → MMDB_%s"", p, GetMmdbError(err));
    __builtin_unreachable();
  }
  db->refs = 1;
  udb = lua_newuserdatauv(L, sizeof(db), 1);
  luaL_setmetatable(L, ""MaxmindDb*"");
  *udb = db;
  return 1;
}

static wontreturn void LuaThrowMaxmindIpError(lua_State *L,
                                              const char *function_name,
                                              uint32_t ip, int err) {
  luaL_error(L, ""%s(%d.%d.%d.%d) → MMDB_%s"", function_name,
             (ip & 0xff000000) >> 030, (ip & 0x00ff0000) >> 020,
             (ip & 0x0000ff00) >> 010, (ip & 0x000000ff) >> 000,
             GetMmdbError(err));
  __builtin_unreachable();
}

static int LuaMaxmindDbLookup(lua_State *L) {
  int err;
  lua_Integer ip;
  struct MaxmindDb **udb, *db;
  struct MaxmindResult **ur, *r;
  udb = luaL_checkudata(L, 1, ""MaxmindDb*"");
  ip = luaL_checkinteger(L, 2);
  if (ip < 0 || ip > 0xffffffff) {
    lua_pushnil(L);
    return 1;
  }
  db = *udb;
  r = xmalloc(sizeof(struct MaxmindResult));
  r->mmlr = MMDB_lookup(&db->mmdb, ip, &err);
  if (err) {
    free(r);
    LuaThrowMaxmindIpError(L, ""MMDB_lookup"", ip, err);
  }
  if (!r->mmlr.found_entry) {
    free(r);
    lua_pushnil(L);
    return 1;
  }
  r->ip = ip;
  r->db = db;
  r->db->refs++;
  ur = lua_newuserdatauv(L, sizeof(r), 1);
  luaL_setmetatable(L, ""MaxmindResult*"");
  *ur = r;
  return 1;
}

static int LuaMaxmindResultNetmask(lua_State *L) {
  struct MaxmindResult **ur;
  ur = luaL_checkudata(L, 1, ""MaxmindResult*"");
  lua_pushinteger(L, (*ur)->mmlr.netmask - (128 - 32));
  return 1;
}

static MMDB_entry_data_list_s *LuaMaxmindDump(lua_State *L,
                                              MMDB_entry_data_list_s *dl) {
  size_t i, n;
  char ibuf[64];
  switch (dl->entry_data.type) {
    case MMDB_DATA_TYPE_UTF8_STRING:
      lua_pushlstring(L, dl->entry_data.utf8_string, dl->entry_data.data_size);
      return dl->next;
    case MMDB_DATA_TYPE_BYTES:
      lua_pushlstring(L, (void *)dl->entry_data.bytes,
                      dl->entry_data.data_size);
      return dl->next;
    case MMDB_DATA_TYPE_INT32:
      lua_pushinteger(L, dl->entry_data.int32);
      return dl->next;
    case MMDB_DATA_TYPE_UINT16:
      lua_pushinteger(L, dl->entry_data.uint16);
      return dl->next;
    case MMDB_DATA_TYPE_UINT32:
      lua_pushinteger(L, dl->entry_data.uint32);
      return dl->next;
    case MMDB_DATA_TYPE_BOOLEAN:
      lua_pushboolean(L, dl->entry_data.boolean);
      return dl->next;
    case MMDB_DATA_TYPE_UINT64:
      lua_pushinteger(L, dl->entry_data.uint64);
      return dl->next;
    case MMDB_DATA_TYPE_UINT128:
      sprintf(ibuf, ""%#jjx"", dl->entry_data.uint128);
      lua_pushstring(L, ibuf);
      return dl->next;
    case MMDB_DATA_TYPE_DOUBLE:
      lua_pushnumber(L, dl->entry_data.double_value);
      return dl->next;
    case MMDB_DATA_TYPE_FLOAT:
      lua_pushnumber(L, dl->entry_data.float_value);
      return dl->next;
    case MMDB_DATA_TYPE_ARRAY:
      lua_newtable(L);
      n = dl->entry_data.data_size;
      for (dl = dl->next, i = 0; dl && i < n; ++i) {
        dl = LuaMaxmindDump(L, dl);
        lua_seti(L, -2, i + 1);
      }
      return dl;
    case MMDB_DATA_TYPE_MAP:
      lua_newtable(L);
      n = dl->entry_data.data_size;
      for (dl = dl->next; dl && n; n--) {
        dl = LuaMaxmindDump(L, dl);
        dl = LuaMaxmindDump(L, dl);
        lua_settable(L, -3);
      }
      return dl;
    default:
      lua_pushnil(L);
      return dl->next;
  }
}

static int LuaMaxmindResultGet(lua_State *L) {
  int i, n, err;
  const char **path;
  MMDB_entry_s entry, *ep;
  MMDB_entry_data_s edata;
  struct MaxmindResult **ur;
  MMDB_entry_data_list_s *dl;
  n = lua_gettop(L) - 1;
  ur = luaL_checkudata(L, 1, ""MaxmindResult*"");
  if (n <= 0) {
    ep = &(*ur)->mmlr.entry;
  } else {
    path = xcalloc(n + 1, sizeof(const char *));
    for (i = 0; i < n; ++i) path[i] = lua_tostring(L, 2 + i);
    err = MMDB_aget_value(&(*ur)->mmlr.entry, &edata, path);
    free(path);
    if (err) {
      if (err == MMDB_LOOKUP_PATH_DOES_NOT_MATCH_DATA_ERROR) {
        lua_pushnil(L);
        return 1;
      } else {
        LuaThrowMaxmindIpError(L, ""getpath"", (*ur)->ip, err);
      }
    }
    if (!edata.offset) {
      lua_pushnil(L);
      return 1;
    }
    entry.mmdb = (*ur)->mmlr.entry.mmdb;
    entry.offset = edata.offset;
    ep = &entry;
  }
  err = MMDB_get_entry_data_list(ep, &dl);
  if (err) LuaThrowMaxmindIpError(L, ""getlist"", (*ur)->ip, err);
  LuaMaxmindDump(L, dl);
  MMDB_free_entry_data_list(dl);
  return 1;
}

static void FreeMaxmindDb(struct MaxmindDb *db) {
  if (!--db->refs) {
    MMDB_close(&db->mmdb);
    free(db);
  }
}

static int LuaMaxmindDbGc(lua_State *L) {
  struct MaxmindDb **udb;
  udb = luaL_checkudata(L, 1, ""MaxmindDb*"");
  if (*udb) {
    FreeMaxmindDb(*udb);
    *udb = 0;
  }
  return 0;
}

static int LuaMaxmindResultGc(lua_State *L) {
  struct MaxmindResult **ur;
  ur = luaL_checkudata(L, 1, ""MaxmindResult*"");
  if (*ur) {
    FreeMaxmindDb((*ur)->db);
    free(*ur);
    *ur = 0;
  }
  return 0;
}

static const luaL_Reg kLuaMaxmind[] = {
    {""open"", LuaMaxmindOpen},  //
    {0},                       //
};

static const luaL_Reg kLuaMaxmindDbMeth[] = {
    {""lookup"", LuaMaxmindDbLookup},  //
    {0},                             //
};

static const luaL_Reg kLuaMaxmindDbMeta[] = {
    {""__gc"", LuaMaxmindDbGc},  //
    {0},                       //
};

static const luaL_Reg kLuaMaxmindResultMeth[] = {
    {""get"", LuaMaxmindResultGet},          //
    {""netmask"", LuaMaxmindResultNetmask},  //
    {0},                                   //
};

static const luaL_Reg kLuaMaxmindResultMeta[] = {
    {""__gc"", LuaMaxmindResultGc},  //
    {0},                           //
};

static void LuaMaxmindDb(lua_State *L) {
  luaL_newmetatable(L, ""MaxmindDb*"");
  luaL_setfuncs(L, kLuaMaxmindDbMeta, 0);
  luaL_newlibtable(L, kLuaMaxmindDbMeth);
  luaL_setfuncs(L, kLuaMaxmindDbMeth, 0);
  lua_setfield(L, -2, ""__index"");
  lua_pop(L, 1);
}

static void LuaMaxmindResult(lua_State *L) {
  luaL_newmetatable(L, ""MaxmindResult*"");
  luaL_setfuncs(L, kLuaMaxmindResultMeta, 0);
  luaL_newlibtable(L, kLuaMaxmindResultMeth);
  luaL_setfuncs(L, kLuaMaxmindResultMeth, 0);
  lua_setfield(L, -2, ""__index"");
  lua_pop(L, 1);
}

int LuaMaxmind(lua_State *L) {
  luaL_newlib(L, kLuaMaxmind);
  LuaMaxmindResult(L);
  LuaMaxmindDb(L);
  return 1;
}
"
./repos/cosmopolitan/tool/net/lpath.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/calls/struct/stat.h""
#include ""libc/errno.h""
#include ""libc/sysv/consts/at.h""
#include ""libc/sysv/consts/s.h""
#include ""third_party/lua/lauxlib.h""

/**
 * @fileoverview redbean unix path manipulation module
 */

// path.basename(str)
//     └─→ str
static int LuaPathBasename(lua_State *L) {
  size_t i, n;
  const char *p;
  if ((p = luaL_optlstring(L, 1, 0, &n)) && n) {
    while (n > 1 && p[n - 1] == '/') --n;
    i = n - 1;
    while (i && p[i - 1] != '/') --i;
    lua_pushlstring(L, p + i, n - i);
  } else {
    lua_pushlstring(L, ""."", 1);
  }
  return 1;
}

// path.dirname(str)
//     └─→ str
static int LuaPathDirname(lua_State *L) {
  size_t n;
  const char *p;
  if ((p = luaL_optlstring(L, 1, 0, &n)) && n--) {
    for (; p[n] == '/'; n--) {
      if (!n) goto ReturnSlash;
    }
    for (; p[n] != '/'; n--) {
      if (!n) goto ReturnDot;
    }
    for (; p[n] == '/'; n--) {
      if (!n) goto ReturnSlash;
    }
    lua_pushlstring(L, p, n + 1);
    return 1;
  }
ReturnDot:
  lua_pushlstring(L, ""."", 1);
  return 1;
ReturnSlash:
  lua_pushlstring(L, ""/"", 1);
  return 1;
}

// path.join(str, ...)
//     └─→ str
static int LuaPathJoin(lua_State *L) {
  int i, n;
  size_t z;
  bool gotstr;
  const char *c;
  luaL_Buffer b;
  bool needslash;
  if ((n = lua_gettop(L))) {
    luaL_buffinit(L, &b);
    gotstr = false;
    needslash = false;
    for (i = 1; i <= n; ++i) {
      if (lua_isnoneornil(L, i)) continue;
      gotstr = true;
      c = luaL_checklstring(L, i, &z);
      if (z) {
        if (c[0] == '/') {
          luaL_buffsub(&b, luaL_bufflen(&b));
        } else if (needslash) {
          luaL_addchar(&b, '/');
        }
        luaL_addlstring(&b, c, z);
        needslash = c[z - 1] != '/';
      } else if (needslash) {
        luaL_addchar(&b, '/');
        needslash = false;
      }
    }
    if (gotstr) {
      luaL_pushresult(&b);
    } else {
      lua_pushnil(L);
    }
    return 1;
  } else {
    luaL_error(L, ""missing argument"");
    __builtin_unreachable();
  }
}

static int CheckPath(lua_State *L, int type, int flags) {
  int olderr;
  struct stat st;
  const char *path;
  path = luaL_checkstring(L, 1);
  olderr = errno;
  if (fstatat(AT_FDCWD, path, &st, flags) != -1) {
    lua_pushboolean(L, !type || (st.st_mode & S_IFMT) == type);
  } else {
    errno = olderr;
    lua_pushboolean(L, false);
  }
  return 1;
}

// path.exists(str)
//     └─→ bool
static int LuaPathExists(lua_State *L) {
  return CheckPath(L, 0, 0);
}

// path.isfile(str)
//     └─→ bool
static int LuaPathIsfile(lua_State *L) {
  return CheckPath(L, S_IFREG, AT_SYMLINK_NOFOLLOW);
}

// path.islink(str)
//     └─→ bool
static int LuaPathIslink(lua_State *L) {
  return CheckPath(L, S_IFLNK, AT_SYMLINK_NOFOLLOW);
}

// path.isdir(str)
//     └─→ bool
static int LuaPathIsdir(lua_State *L) {
  return CheckPath(L, S_IFDIR, AT_SYMLINK_NOFOLLOW);
}

static const luaL_Reg kLuaPath[] = {
    {""basename"", LuaPathBasename},  //
    {""dirname"", LuaPathDirname},    //
    {""exists"", LuaPathExists},      //
    {""isdir"", LuaPathIsdir},        //
    {""isfile"", LuaPathIsfile},      //
    {""islink"", LuaPathIslink},      //
    {""join"", LuaPathJoin},          //
    {0},                            //
};

int LuaPath(lua_State *L) {
  luaL_newlib(L, kLuaPath);
  return 1;
}
"
./repos/cosmopolitan/tool/viz/fixconsole.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/calls/calls.h""
#include ""libc/dce.h""
#include ""libc/intrin/describeflags.internal.h""
#include ""libc/nt/console.h""
#include ""libc/nt/enum/consolemodeflags.h""
#include ""libc/nt/runtime.h""
#if defined(__x86_64__) && SupportsWindows()

int main(int argc, char *argv[]) {

  if (!IsWindows()) {
    tinyprint(2, argv[0], "" is intended for windows\n"", NULL);
    return 1;
  }

  // clear console and print old config
  uint32_t cm;
  tinyprint(1, ""\e[H\e[J"", NULL);
  tinyprint(1, ""broken console settings were\r\n"", NULL);
  GetConsoleMode(GetStdHandle(kNtStdInputHandle), &cm);
  tinyprint(1, ""stdin: "", DescribeNtConsoleInFlags(cm), ""\r\n"", NULL);
  GetConsoleMode(GetStdHandle(kNtStdOutputHandle), &cm);
  tinyprint(1, ""stdout: "", DescribeNtConsoleOutFlags(cm), ""\r\n"", NULL);
  GetConsoleMode(GetStdHandle(kNtStdErrorHandle), &cm);
  tinyprint(1, ""stderr: "", DescribeNtConsoleOutFlags(cm), ""\r\n"", NULL);

  // fix console settings
  SetConsoleMode(GetStdHandle(kNtStdInputHandle),
                 kNtEnableProcessedInput | kNtEnableLineInput |
                     kNtEnableEchoInput | kNtEnableMouseInput |
                     kNtEnableInsertMode | kNtEnableQuickEditMode |
                     kNtEnableExtendedFlags | kNtEnableAutoPosition);
  SetConsoleMode(GetStdHandle(kNtStdOutputHandle),
                 kNtEnableProcessedOutput | kNtEnableWrapAtEolOutput);
  SetConsoleMode(GetStdHandle(kNtStdErrorHandle),
                 kNtEnableProcessedOutput | kNtEnableWrapAtEolOutput |
                     kNtEnableVirtualTerminalProcessing);

  return 0;
}

#else
int main(int argc, char *argv[]) {
  tinyprint(2, ""fixconsole not supported on this cpu arch or build config\n"",
            NULL);
  return 1;
}
#endif /* __x86_64__ && SupportsWindows() */
"
./repos/cosmopolitan/tool/viz/setitimer_accuracy.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2023 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/calls/calls.h""
#include ""libc/calls/struct/itimerval.h""
#include ""libc/calls/struct/sigaction.h""
#include ""libc/calls/struct/timespec.h""
#include ""libc/calls/struct/timeval.h""
#include ""libc/fmt/itoa.h""
#include ""libc/sysv/consts/itimer.h""
#include ""libc/sysv/consts/sig.h""

#define HZ 120

struct timeval start;
struct timeval expect;
struct timeval interval = {0, 1e6 / HZ};

void OnTick(int sig) {
  char ibuf[27];
  struct timeval now = timeval_real();
  switch (timeval_cmp(now, expect)) {
    case 0:
      tinyprint(1, ""100% precise\n"", NULL);
      break;
    case -1:
      FormatInt64Thousands(ibuf, timeval_tomicros(timeval_sub(expect, now)));
      tinyprint(1, ibuf, "" µs early\n"", NULL);
      break;
    case +1:
      FormatInt64Thousands(ibuf, timeval_tomicros(timeval_sub(now, expect)));
      tinyprint(1, ibuf, "" µs late\n"", NULL);
      break;
    default:
      __builtin_unreachable();
  }
  expect = timeval_add(expect, interval);
}

int main(int argc, char *argv[]) {
  start = timeval_real();
  expect = timeval_add(start, interval);
  signal(SIGALRM, OnTick);
  setitimer(ITIMER_REAL, &(struct itimerval){interval, interval}, 0);
  for (;;) pause();
}
"
./repos/cosmopolitan/tool/viz/tailf.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/calls/calls.h""
#include ""libc/calls/struct/stat.h""
#include ""libc/intrin/safemacros.internal.h""
#include ""libc/macros.internal.h""
#include ""libc/runtime/runtime.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#include ""libc/sysv/consts/o.h""
#include ""libc/sysv/consts/sig.h""
#include ""libc/time/time.h""
#include ""libc/x/xsigaction.h""

/**
 * @fileoverview tail -f with lower poll rate
 * @see busybox not having interval flag
 */

int fd;
bool exited;
struct stat st;
char buf[FRAMESIZE];

int WriteString(const char *s) {
  return write(1, s, strlen(s));
}

void HideCursor(void) {
  WriteString(""\e[?25l"");
}

void ShowCursor(void) {
  WriteString(""\e[?25h"");
}

void OnInt(void) {
  exited = true;
}

void OnExit(void) {
  ShowCursor();
}

int main(int argc, char *argv[]) {
  char *p;
  ssize_t n;
  size_t i, j;
  bool chopped;
  if (argc < 2) return 1;
  if ((fd = open(argv[1], O_RDONLY)) == -1) return 2;
  if (fstat(fd, &st) == -1) return 3;
  n = st.st_size - MIN(st.st_size, sizeof(buf));
  if ((n = pread(fd, buf, sizeof(buf), n)) == -1) return 4;
  for (p = buf + n, i = 0; i < 10; ++i) {
    p = firstnonnull(memrchr(buf, '\n', p - buf), buf);
  }
  chopped = false;
  if (buf + n - p) ++p;
  i = st.st_size - (buf + n - p);
  atexit(OnExit);
  HideCursor();
  xsigaction(SIGINT, OnInt, 0, 0, 0);
  xsigaction(SIGTERM, OnInt, 0, 0, 0);
  while (!exited) {
    if (fstat(fd, &st) == -1) return 5;
    if (i > st.st_size) i = 0;
    for (; i < st.st_size; i += n) {
      if ((n = pread(fd, buf, sizeof(buf), i)) == -1) return 6;
      j = n;
      while (j && (buf[j - 1] == '\n' || buf[j - 1] == '\r')) --j;
      if (j) {
        if (chopped) {
          WriteString(""\r\n"");
        }
        write(1, buf, j);
      }
      chopped = j != n;
    }
    usleep(10000);
  }
  close(fd);
  WriteString(""\r\n"");
  return 0;
}
"
./repos/cosmopolitan/tool/viz/printvideo.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""dsp/core/core.h""
#include ""dsp/core/half.h""
#include ""dsp/core/illumination.h""
#include ""dsp/mpeg/mpeg.h""
#include ""dsp/scale/scale.h""
#include ""dsp/tty/quant.h""
#include ""dsp/tty/tty.h""
#include ""libc/assert.h""
#include ""libc/calls/calls.h""
#include ""libc/calls/internal.h""
#include ""libc/calls/struct/framebufferfixedscreeninfo.h""
#include ""libc/calls/struct/framebuffervirtualscreeninfo.h""
#include ""libc/calls/struct/iovec.h""
#include ""libc/calls/struct/itimerval.h""
#include ""libc/calls/struct/sigaction.h""
#include ""libc/calls/struct/siginfo.h""
#include ""libc/calls/struct/sigset.h""
#include ""libc/calls/struct/timespec.h""
#include ""libc/calls/struct/winsize.h""
#include ""libc/calls/termios.h""
#include ""libc/calls/ucontext.h""
#include ""libc/cxxabi.h""
#include ""libc/errno.h""
#include ""libc/fmt/conv.h""
#include ""libc/fmt/itoa.h""
#include ""libc/intrin/kprintf.h""
#include ""libc/intrin/safemacros.internal.h""
#include ""libc/intrin/xchg.internal.h""
#include ""libc/log/check.h""
#include ""libc/log/log.h""
#include ""libc/macros.internal.h""
#include ""libc/math.h""
#include ""libc/mem/alg.h""
#include ""libc/mem/arraylist.internal.h""
#include ""libc/mem/mem.h""
#include ""libc/nexgen32e/bench.h""
#include ""libc/nexgen32e/x86feature.h""
#include ""libc/nt/console.h""
#include ""libc/nt/runtime.h""
#include ""libc/runtime/runtime.h""
#include ""libc/sock/sock.h""
#include ""libc/sock/struct/pollfd.h""
#include ""libc/stdio/internal.h""
#include ""libc/stdio/rand.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#include ""libc/str/strwidth.h""
#include ""libc/str/unicode.h""
#include ""libc/sysv/consts/af.h""
#include ""libc/sysv/consts/auxv.h""
#include ""libc/sysv/consts/clock.h""
#include ""libc/sysv/consts/ex.h""
#include ""libc/sysv/consts/exit.h""
#include ""libc/sysv/consts/f.h""
#include ""libc/sysv/consts/fd.h""
#include ""libc/sysv/consts/fileno.h""
#include ""libc/sysv/consts/ipproto.h""
#include ""libc/sysv/consts/itimer.h""
#include ""libc/sysv/consts/map.h""
#include ""libc/sysv/consts/mlock.h""
#include ""libc/sysv/consts/o.h""
#include ""libc/sysv/consts/ok.h""
#include ""libc/sysv/consts/poll.h""
#include ""libc/sysv/consts/prio.h""
#include ""libc/sysv/consts/prot.h""
#include ""libc/sysv/consts/sa.h""
#include ""libc/sysv/consts/shut.h""
#include ""libc/sysv/consts/sig.h""
#include ""libc/sysv/consts/splice.h""
#include ""libc/sysv/consts/termios.h""
#include ""libc/sysv/consts/w.h""
#include ""libc/sysv/errfuns.h""
#include ""libc/thread/thread.h""
#include ""libc/time/time.h""
#include ""libc/x/xsigaction.h""
#include ""third_party/getopt/getopt.internal.h""
#include ""third_party/stb/stb_image_resize.h""
#include ""tool/viz/lib/graphic.h""
#include ""tool/viz/lib/knobs.h""
#include ""tool/viz/lib/ycbcr.h""

/**
 * @fileoverview MPEG Video Player for Terminal.
 */

#define GAMMADELTA    0.1
#define NETBUFSIZ     (2 * 1024 * 1024)
#define MAX_FRAMERATE (1 / 60.)

#define USAGE \
  "" [FLAGS] MPG\n\
Renders motion picture to teletypewriters.\n\
\n\
Flags & Keyboard Shortcuts:\n\
  -s         stats\n\
  -t         true color\n\
  -d         dithering\n\
  -3         ibm cp437 rendering\n\
  -4         unicode rendering\n\
  -a         ansi quantization\n\
  -x         xterm256 quantization\n\
  -A         assume ansi ansi palette\n\
  -T         assume tango ansi palette\n\
  -v         increases verbosity        [flag]\n\
  -L PATH    redirects stderr to path   [flag]\n\
  -y         yes to interactive prompts [flag]\n\
  -h or -?   shows this information     [flag]\n\
  UP/DOWN    adjust volume              [keyboard]\n\
  CTRL+L     redraw                     [keyboard]\n\
  CTRL+Z     suspend                    [keyboard]\n\
  CTRL+C     exit                       [keyboard]\n\
  q          quit                       [keyboard]\n\
\n\
Effects Shortcuts:\n\
\n\
  S          Toggle Swing (TV, PC)\n\
  Y          Toggle Black/White Mode\n\
  p          Toggle Primaries (BT.601, BT.709)\n\
  g          +Gamma           G          -Gamma\n\
  l          +Illumination    L          -Illumination\n\
  k          +LumaKernel      K          -LumaKernel\n\
  j          +ChromaKernel    J          -ChromaKernel\n\
  CTRL-G     {Unsharp,Sharp}\n\
\n\
Environment Variables:\n\
  SOX        overrides location of SoX executable\n\
  FFPLAY     overrides location of FFmpeg ffplay executable\n\
  ROWS=𝑦     sets height [inarticulate mode]\n\
  COLUMNS=𝑥  sets width  [inarticulate mode]\n\
  TERM=dumb  inarticulate mode\n\
\n\
Notes:\n\
\n\
Your video printer natively supports .mpg files. If your videos are\n\
in a different format, then it's fast and easy to convert them:\n\
\n\
    ffmpeg -i movie.mkv movie.mpg\n\
\n\
The terminal fonts we recommend are PragmataPro, Bitstream Vera Sans\n\
Mono (known as DejaVu Sans Mono in the open source community), Menlo,\n\
and Lucida Console.\n\
\n\
On Linux, playing audio requires either `sox` or `ffplay` being on\n\
the $PATH. Kitty is the fastest terminal. Alacritty also has a fast\n\
display. GNOME Terminal and xterm both work well in 256-color or ANSI\n\
mode.\n\
\n""

#define CTRL(C)   ((C) ^ 0100)
#define ALT(C)    ((033 << 010) | (C))
#define ARGZ(...) ((char *const[]){__VA_ARGS__, NULL})
#define MOD(X, Y) ((X) - (ABS(Y)) * ((X) / ABS(Y)))

#define BALLOC(B, A, N, NAME)               \
  ({                                        \
    INFOF(""balloc/%s %,zu bytes"", NAME, N); \
    *(B) = pvalloc(N);                      \
  })

#define TIMEIT(OUT_NANOS, FORM)                                           \
  do {                                                                    \
    struct timespec Start = timespec_real();                              \
    FORM;                                                                 \
    (OUT_NANOS) = timespec_tonanos(timespec_sub(timespec_real(), Start)); \
  } while (0)

typedef bool (*openspeaker_f)(void);

enum Sharp {
  kSharpNone,
  kSharpUnsharp,
  kSharpSharp,
  kSharpMAX,
};

enum Blur {
  kBlurNone,
  kBlurBox,
  kBlurGaussian,
  kBlurMAX,
};

struct NamedVector {
  char name[8];
  const double (*vector)[3];
};

struct VtFrame {
  size_t i, n;
  union {
    void *b;
    char *bytes;
  };
};

struct FrameCountRing {
  size_t i, n;
  float p[64]; /* seconds relative to starttime_ */
};

struct FrameBuffer {
  void *map;
  size_t size;
  char *path;
  int fd;
  struct FrameBufferFixedScreenInfo fscreen;
  struct FrameBufferVirtualScreenInfo vscreen;
};

static const struct itimerval kTimerDisarm = {
    {0, 0},
    {0, 0},
};

static const struct itimerval kTimerHalfSecondSingleShot = {
    {0, 0},
    {0, 500000},
};

static const struct NamedVector kPrimaries[] = {
    {""BT.601"", &kBt601Primaries},
    {""BT.709"", &kBt709Primaries},
};

static const struct NamedVector kLightings[] = {
    {""A"", &kIlluminantA},           {""C"", &kIlluminantC},
    {""D50"", &kIlluminantD50},       {""D55"", &kIlluminantD55},
    {""D65"", &kIlluminantD65},       {""D75"", &kIlluminantD75},
    {""F2"", &kIlluminantF2},         {""F7"", &kIlluminantF7},
    {""F11"", &kIlluminantF11},       {""A-10"", &kIlluminantAD10},
    {""C-10"", &kIlluminantCD10},     {""D50-10"", &kIlluminantD50D10},
    {""D55-10"", &kIlluminantD55D10}, {""D65-10"", &kIlluminantD65D10},
    {""D75-10"", &kIlluminantD75D10}, {""F2-10"", &kIlluminantF2D10},
    {""F7-10"", &kIlluminantF7D10},   {""F11-10"", &kIlluminantF11D10},
};

static plm_t *plm_;
static float gamma_;
static int volscale_;
static enum Blur blur_;
static enum Sharp sharp_;
static jmp_buf jb_, jbi_;
static double pary_, parx_;
static struct TtyIdent ti_;
static struct YCbCr *ycbcr_;
static bool emboss_, sobel_;
static volatile int playpid_;
static struct winsize wsize_;
static float hue_, sat_, lit_;
static void *xtcodes_, *audio_;
static struct FrameBuffer fb0_;
static unsigned chans_, srate_;
static volatile bool ignoresigs_;
static size_t dh_, dw_, framecount_;
static struct FrameCountRing fcring_;
static volatile bool resized_, piped_;
static int lumakernel_, chromakernel_;
static openspeaker_f tryspeakerfns_[4];
static int primaries_, lighting_, swing_;
static uint64_t t1, t2, t3, t4, t5, t6, t8;
static const char *sox_, *ffplay_, *patharg_;
static struct VtFrame vtframe_[2], *f1_, *f2_;
static struct Graphic graphic_[2], *g1_, *g2_;
static struct timespec deadline_, dura_, starttime_;
static bool yes_, stats_, dither_, ttymode_, istango_;
static struct timespec decode_start_, f1_start_, f2_start_;
static int16_t pcm_[PLM_AUDIO_SAMPLES_PER_FRAME * 2 / 8][8];
static int16_t pcmscale_[PLM_AUDIO_SAMPLES_PER_FRAME * 2 / 8][8];
static bool fullclear_, historyclear_, tuned_, yonly_, gotvideo_;
static int homerow_, lastrow_, playfd_, infd_, outfd_, speakerfails_;
static char status_[7][200], logpath_[PATH_MAX], fifopath_[PATH_MAX],
    chansstr_[32], sratestr_[32];

static void OnCtrlC(void) {
  longjmp(jb_, 1);
}

static void OnResize(void) {
  resized_ = true;
}

static void OnSigPipe(void) {
  piped_ = true;
}

static void OnSigChld(void) {
  playpid_ = 0, piped_ = true;
}

static void StrikeDownCrapware(int sig) {
  kill(playpid_, SIGKILL);
}

static struct timespec GetGraceTime(void) {
  return timespec_sub(deadline_, timespec_real());
}

static char *strntoupper(char *s, size_t n) {
  size_t i;
  for (i = 0; s[i] && i < n; ++i) {
    if ('a' <= s[i] && s[i] <= 'z') {
      s[i] -= 'a' - 'A';
    }
  }
  return s;
}

static int GetNamedVector(const struct NamedVector *choices, size_t n,
                          const char *s) {
  int i;
  char name[sizeof(choices->name)];
#pragma GCC push_options
#pragma GCC diagnostic ignored ""-Wstringop-truncation""
  strncpy(name, s, sizeof(name));
#pragma GCC pop_options
  strntoupper(name, sizeof(name));
  for (i = 0; i < n; ++i) {
    if (memcmp(choices[i].name, name, sizeof(name)) == 0) {
      return i;
    }
  }
  return -1;
}

static int GetPrimaries(const char *s) {
  return GetNamedVector(kPrimaries, ARRAYLEN(kPrimaries), s);
}

static int GetLighting(const char *s) {
  return GetNamedVector(kLightings, ARRAYLEN(kLightings), s);
}

static bool CloseSpeaker(void) {
  int rc, wstatus;
  rc = 0;
  pthread_yield();
  if (playfd_) {
    rc |= close(playfd_);
    playfd_ = -1;
  }
  if (playpid_) {
    kill(playpid_, SIGTERM);
    xsigaction(SIGALRM, StrikeDownCrapware, SA_RESETHAND, 0, 0);
    setitimer(ITIMER_REAL, &kTimerHalfSecondSingleShot, NULL);
    while (playpid_) {
      if (waitpid(playpid_, &wstatus, 0) != -1) {
        rc |= WEXITSTATUS(wstatus);
      } else if (errno == EINTR) {
        continue;
      } else {
        rc = -1;
      }
      break;
    }
    playpid_ = 0;
    setitimer(ITIMER_REAL, &kTimerDisarm, NULL);
  }
  return !!rc;
}

static void ResizeVtFrame(struct VtFrame *f, size_t yn, size_t xn) {
  BALLOC(&f->b, 4096, 64 + yn * (xn * 32 + 8), __FUNCTION__);
  f->i = f->n = 0;
}

static float timespec_tofloat(struct timespec ts) {
  return ts.tv_sec + ts.tv_nsec * 1e-9;
}

static void RecordFactThatFrameWasFullyRendered(void) {
  fcring_.p[fcring_.i] =
      timespec_tofloat(timespec_sub(timespec_real(), starttime_));
  fcring_.n += 1;
  fcring_.i += 1;
  fcring_.i &= ARRAYLEN(fcring_.p) - 1;
}

static double MeasureFrameRate(void) {
  int i, j, n, m;
  if (fcring_.n) {
    m = ARRAYLEN(fcring_.p);
    n = MIN(fcring_.n, m);
    i = (fcring_.i - 1) & (m - 1);
    j = (fcring_.i - n) & (m - 1);
    return n / (fcring_.p[i] - fcring_.p[j]);
  } else {
    return 0;
  }
}

static bool ShouldUseFrameBuffer(void) {
  return fb0_.fd != -1;
}

static bool IsHighDefinition(long yn, long xn) {
  return yn * xn >= 1280 * 720;
}

static void ComputeColoringSolution(void) {
  YCbCrInit(&ycbcr_, yonly_, swing_, gamma_, *kPrimaries[primaries_].vector,
            *kLightings[lighting_].vector);
}

static void DimensionDisplay(void) {
  size_t yn, xn;
  double ratio, height, width;
  do {
    resized_ = false;
    if (ShouldUseFrameBuffer()) {
      pary_ = 1;
      parx_ = 1;
      dh_ = fb0_.vscreen.yres;
      dw_ = fb0_.vscreen.xres;
      wsize_.ws_row = fb0_.vscreen.yres_virtual;
      wsize_.ws_col = fb0_.vscreen.xres_virtual;
    } else {
      pary_ = 1;
      parx_ = 1;
      wsize_.ws_row = 25;
      wsize_.ws_col = 80;
      wsize_ = (struct winsize){.ws_row = 40, .ws_col = 80};
      if (tcgetwinsize(outfd_, &wsize_) == -1) {
        tcgetwinsize(0, &wsize_);
      }
      dh_ = wsize_.ws_row * 2;
      dw_ = wsize_.ws_col * 2;
    }
    ratio = g1_->xn;
    ratio /= g1_->yn;
    height = dh_;
    width = dw_;
    height = MIN(height, height * ratio);
    width = MIN(width, width * ratio);
    yn = height;
    xn = width;
    yn = ROUNDDOWN(yn, 2);
    xn = ROUNDDOWN(xn, 2);
    g2_ = resizegraphic(&graphic_[1], yn, xn);
    INFOF(""%s 𝑑(%hu×%hu)×(%d,%d): 𝑔₁(%zu×%zu,r=%f) → 𝑔₂(%zu×%zu)"",
          ""DimensionDisplay"", wsize_.ws_row, wsize_.ws_col, g1_->yn, g1_->xn,
          ratio, yn, xn);
    BALLOC(&xtcodes_, 64, ((g2_->yn) * g2_->xn + 8) * sizeof(struct TtyRgb),
           ""xtcodes_"");
    ResizeVtFrame(&vtframe_[0], (g2_->yn), g2_->xn);
    ResizeVtFrame(&vtframe_[1], (g2_->yn), g2_->xn);
    f1_ = &vtframe_[0];
    f2_ = &vtframe_[1];
    if (ttymode_) {
      homerow_ = MIN(wsize_.ws_row - HALF(g2_->yn),
                     HALF(wsize_.ws_row - HALF(g2_->yn)));
    }
    lastrow_ = homerow_ + HALF(g2_->yn);
    ComputeColoringSolution();
  } while (resized_);
}

static int WriteAudio(int fd, const void *data, size_t size, int deadlinems) {
  ssize_t rc;
  const char *p;
  size_t wrote, n;
  p = data;
  n = size;
  do {
  TryAgain:
    if ((rc = write(fd, p, n)) != -1) {
      wrote = rc;
      p += wrote;
      n -= wrote;
    } else if (errno == EINTR) {
      goto TryAgain;
    } else if (errno == EAGAIN) {
      if (poll((struct pollfd[]){{fd, POLLOUT}}, 1, deadlinems) == 0) {
        return etimedout();
      }
    } else {
      return -1;
    }
  } while (n);
  return 0;
}

static bool TrySpeaker(const char *prog, char *const *args) {
  int pipefds[2];
  CHECK_NE(-1, pipe2(pipefds, O_CLOEXEC));
  if (!(playpid_ = fork())) {
    dup2(pipefds[0], 0);
    dup2(fileno(__log_file), 1);
    dup2(fileno(__log_file), 2);
    close(fileno(__log_file));
    execv(prog, args);
    abort();
  }
  playfd_ = pipefds[1];
  return true;
}

static bool TrySox(void) {
  return TrySpeaker(sox_, ARGZ(""play"", ""-q"", ""-c"", chansstr_, ""-traw"",
                               ""-esigned"", ""-b16"", ""-r"", sratestr_, ""-""));
}

static bool TryFfplay(void) {
  return TrySpeaker(ffplay_, ARGZ(""ffplay"", ""-nodisp"", ""-loglevel"", ""quiet"",
                                  ""-fflags"", ""nobuffer"", ""-ac"", chansstr_,
                                  ""-ar"", sratestr_, ""-f"", ""s16le"", ""pipe:""));
}

static bool OpenSpeaker(void) {
  size_t i;
  static bool once, count;
  if (!once) {
    once = true;
    i = 0;
    if (ffplay_) tryspeakerfns_[i++] = TryFfplay;
    if (sox_) tryspeakerfns_[i++] = TrySox;
  }
  snprintf(fifopath_, sizeof(fifopath_), ""%s%s.%d.%d.wav"", __get_tmpdir(),
           firstnonnull(program_invocation_short_name, ""unknown""), getpid(),
           count);
  for (i = 0; i < ARRAYLEN(tryspeakerfns_); ++i) {
    if (tryspeakerfns_[i]) {
      if (++speakerfails_ <= 2 && tryspeakerfns_[i]()) {
        return true;
      } else {
        speakerfails_ = 0;
        tryspeakerfns_[i] = NULL;
      }
    }
  }
  return false;
}

static void OnAudio(plm_t *mpeg, plm_samples_t *samples, void *user) {
  if (playfd_ != -1) {
    DEBUGF(""OnAudio() [grace=%,ldns]"", timespec_tonanos(GetGraceTime()));
    CHECK_EQ(2, chans_);
    CHECK_EQ(ARRAYLEN(pcm_) * 8, samples->count * chans_);
    float2short(ARRAYLEN(pcm_), pcm_, (void *)samples->interleaved);
    scalevolume(ARRAYLEN(pcm_), pcm_, volscale_);
    sad16x8n(ARRAYLEN(pcm_), pcm_, pcmscale_);
    DEBUGF(""transcoded audio"");
  TryAgain:
    if (WriteAudio(playfd_, pcm_, sizeof(pcm_), 1000) != -1) {
      DEBUGF(""WriteAudio(%d, %zu) ok [grace=%,ldns]"", playfd_,
             samples->count * 2, timespec_tonanos(GetGraceTime()));
    } else {
      WARNF(""WriteAudio(%d, %zu) failed: %s"", playfd_, samples->count * 2,
            strerror(errno));
      CloseSpeaker();
      if (OpenSpeaker()) {
        goto TryAgain;
      }
    }
  }
}

static void DescribeAlgorithms(char *p) {
  if (dither_ && TTYQUANT()->alg != kTtyQuantTrue) {
    p = stpcpy(p, "" ℍithered"");
  }
  if (yonly_) {
    p = stpcpy(p, "" grayscaled"");
  }
  p += sprintf(p, "" magikarp:%d:%d"", lumakernel_, chromakernel_);
  switch (TTYQUANT()->alg) {
    case kTtyQuantTrue:
      p = stpcpy(p, "" true-color"");
      break;
    case kTtyQuantXterm256:
      p = stpcpy(p, "" xterm256"");
      break;
    case kTtyQuantAnsi:
      p = stpcpy(p, "" aixterm ansi"");
      if (istango_) p = stpcpy(p, "" tango"");
      break;
    default:
      break;
  }
  switch (TTYQUANT()->blocks) {
    case kTtyBlocksCp437:
      p = stpcpy(p, "" ibm cp437"");
      break;
    case kTtyBlocksUnicode:
      p = stpcpy(p, "" unicode"");
      break;
    default:
      break;
  }
  *p++ = ' ';
  *p = '\0';
}

static char *StartRender(char *vt) {
  if (!ttymode_) vt += sprintf(vt, ""\r\n\r\n"");
  if (fullclear_) {
    vt += sprintf(vt, ""\e[0m\e[H\e[J"");
    fullclear_ = false;
  } else if (historyclear_) {
    vt += sprintf(vt, ""\e[0m\e[H\e[J\e[3J"");
    historyclear_ = false;
  }
  vt += sprintf(vt, ""\e[%hhuH"", homerow_ + 1);
  return vt;
}

static void EndRender(char *vt) {
  vt += sprintf(vt, ""\e[0m"");
  f2_->n = (intptr_t)vt - (intptr_t)f2_->b;
  f2_->i = 0;
}

static bool IsNonZeroFloat(float f) {
  return fabsf(f) > 0.001f;
}

static bool HasAdjustments(void) {
  return (IsNonZeroFloat(hue_) || IsNonZeroFloat(sat_) ||
          IsNonZeroFloat(lit_)) ||
         (emboss_ || sharp_ || blur_ || sobel_ || pf1_ || pf2_ || pf3_ ||
          pf4_ || pf5_ || pf6_ || pf7_ || pf8_ || pf9_ || pf10_ || pf11_ ||
          pf12_);
}

static char *DescribeAdjustments(char *p) {
  if (emboss_) p = stpcpy(p, "" emboss"");
  if (sobel_) p = stpcpy(p, "" sobel"");
  switch (sharp_) {
    case kSharpSharp:
      p = stpcpy(p, "" sharp"");
      break;
    case kSharpUnsharp:
      p = stpcpy(p, "" unsharp"");
      break;
    default:
      break;
  }
  switch (blur_) {
    case kBlurBox:
      p = stpcpy(p, "" boxblur"");
      break;
    case kBlurGaussian:
      p = stpcpy(p, "" gaussian"");
      break;
    default:
      break;
  }
  if (IsNonZeroFloat(hue_)) p += sprintf(p, "" hue%+.2f"", hue_);
  if (IsNonZeroFloat(sat_)) p += sprintf(p, "" sat%+.2f"", sat_);
  if (IsNonZeroFloat(lit_)) p += sprintf(p, "" lit%+.2f"", lit_);
  if (pf1_) p = stpcpy(p, "" PF1"");
  if (pf2_) p = stpcpy(p, "" PF2"");
  if (pf3_) p = stpcpy(p, "" PF3"");
  if (pf4_) p = stpcpy(p, "" PF4"");
  if (pf5_) p = stpcpy(p, "" PF5"");
  if (pf6_) p = stpcpy(p, "" PF6"");
  if (pf7_) p = stpcpy(p, "" PF7"");
  if (pf8_) p = stpcpy(p, "" PF8"");
  if (pf9_) p = stpcpy(p, "" PF9"");
  if (pf10_) p = stpcpy(p, "" PF10"");
  if (pf11_) p = stpcpy(p, "" PF11"");
  if (pf12_) p = stpcpy(p, "" PF12"");
  *p++ = ' ';
  *p++ = '\0';
  return p;
}

static const char *DescribeSwing(int swing) {
  switch (swing) {
    case 219:
      return ""TV"";
    case 255:
      return ""PC"";
    default:
      return ""??"";
  }
}

static void RenderIt(void) {
  long bpf;
  double bpc;
  char *vt, *p;
  unsigned yn, xn;
  struct TtyRgb bg, fg;
  yn = g2_->yn;
  xn = g2_->xn;
  vt = f2_->b;
  p = StartRender(vt);
  if (TTYQUANT()->alg == kTtyQuantTrue) {
    bg = (struct TtyRgb){0, 0, 0, 0};
    fg = (struct TtyRgb){0xee, 0xff, 0xff, 0};
    p = stpcpy(p, ""\e[48;2;0;0;0;38;2;255;255;255m"");
  } else if (TTYQUANT()->alg == kTtyQuantAnsi) {
    bg = g_ansi2rgb_[0];
    fg = g_ansi2rgb_[7];
    p +=
        sprintf(p, ""\e[%d;%dm"", 30 + g_ansi2rgb_[0].xt, 40 + g_ansi2rgb_[7].xt);
  } else {
    bg = (struct TtyRgb){0, 0, 0, 16};
    fg = (struct TtyRgb){0xff, 0xff, 0xff, 231};
    p = stpcpy(p, ""\e[48;5;16;38;5;231m"");
  }
  p = ttyraster(p, xtcodes_, yn, xn, bg, fg);
  if (ttymode_ && stats_) {
    bpc = bpf = p - vt;
    bpc /= wsize_.ws_row * wsize_.ws_col;
    sprintf(status_[4], "" %s/%s/%s %d×%d → %u×%u pixels "",
            kPrimaries[primaries_].name, DescribeSwing(swing_),
            kLightings[lighting_].name, plm_get_width(plm_),
            plm_get_height(plm_), g2_->xn, g2_->yn);
    sprintf(status_[5], "" decode:%,8luµs | magikarp:%,8luµs "",
            plmpegdecode_latency_, magikarp_latency_);
    sprintf(status_[1], "" ycbcr2rgb:%,8luµs | gyarados:%,8luµs "",
            ycbcr2rgb_latency_, gyarados_latency_);
    sprintf(status_[0], "" fx:%,ldµs %.6fbpc %,ldbpf %.6ffps "",
            lroundl(t6 / 1e3L), bpc, bpf, (size_t)(p - vt), MeasureFrameRate());
    sprintf(status_[2], "" gamma:%.1f %hu columns × %hu lines of text "", gamma_,
            wsize_.ws_col, wsize_.ws_row);
    DescribeAlgorithms(status_[3]);
    p += sprintf(p, ""\e[0m"");
    if (HasAdjustments()) {
      DescribeAdjustments(status_[6]);
      p += sprintf(p, ""\e[%d;%dH%s"", lastrow_ - 7,
                   HALF(xn) - strwidth(status_[6], 0), status_[6]);
    }
    p += sprintf(p, ""\e[%d;%dH%s"", lastrow_ - 6,
                 HALF(xn) - strwidth(status_[4], 0), status_[4]);
    p += sprintf(p, ""\e[%d;%dH%s"", lastrow_ - 5,
                 HALF(xn) - strwidth(status_[5], 0), status_[5]);
    p += sprintf(p, ""\e[%d;%dH%s"", lastrow_ - 4,
                 HALF(xn) - strwidth(status_[1], 0), status_[1]);
    p += sprintf(p, ""\e[%d;%dH%s"", lastrow_ - 3,
                 HALF(xn) - strwidth(status_[0], 0), status_[0]);
    p += sprintf(p, ""\e[%d;%dH%30s"", lastrow_ - 2,
                 HALF(xn) - strwidth(status_[2], 0), status_[2]);
    p += sprintf(p, ""\e[%d;%dH%s"", lastrow_ - 1,
                 HALF(xn) - strwidth(status_[3], 0), status_[3]);
    p += sprintf(p, ""\e[%d;%dH %s %s "", lastrow_ - 2, 2,
                 program_invocation_name, """");
    p += sprintf(p, ""\e[%d;%dH %s "", lastrow_ - 1, 2,
                 ""by justine tunney <jtunney@gmail.com>"");
  }
  EndRender(p);
}

static void RasterIt(void) {
  static bool once;
  static void *buf;
  if (!once) {
    buf = _mapanon(ROUNDUP(fb0_.size, FRAMESIZE));
    once = true;
  }
  WriteToFrameBuffer(fb0_.vscreen.yres_virtual, fb0_.vscreen.xres_virtual, buf,
                     g2_->yn, g2_->xn, g2_->b, fb0_.vscreen.yres,
                     fb0_.vscreen.xres);
  memcpy(fb0_.map, buf, fb0_.size);
}

static void TranscodeVideo(plm_frame_t *pf) {
  CHECK_EQ(pf->cb.width, pf->cr.width);
  CHECK_EQ(pf->cb.height, pf->cr.height);
  DEBUGF(""TranscodeVideo() [grace=%,ldns]"", timespec_tonanos(GetGraceTime()));
  g2_ = &graphic_[1];
  t5 = 0;

  TIMEIT(t1, {
    pary_ = 2;
    if (pf1_) pary_ = 1.;
    if (pf2_) pary_ = (266 / 64.) * (900 / 1600.);
    pary_ *= plm_get_pixel_aspect_ratio(plm_);
    YCbCr2RgbScale(g2_->yn, g2_->xn, g2_->b, pf->y.height, pf->y.width,
                   (void *)pf->y.data, pf->cr.height, pf->cr.width,
                   (void *)pf->cb.data, (void *)pf->cr.data, pf->y.height,
                   pf->y.width, pf->cr.height, pf->cr.width, pf->height,
                   pf->width, pary_, parx_, &ycbcr_);
  });
  t2 = 0;
  t8 = 0;

  TIMEIT(t6, {
    switch (blur_) {
      case kBlurBox:
        boxblur(g2_);
        break;
      case kBlurGaussian:
        gaussian(g2_->yn, g2_->xn, g2_->b);
        break;
      default:
        break;
    }
    if (sobel_) sobel(g2_);
    if (emboss_) emboss(g2_);
    switch (sharp_) {
      case kSharpSharp:
        sharpen(3, g2_->yn, g2_->xn, g2_->b, g2_->yn, g2_->xn);
        break;
      case kSharpUnsharp:
        unsharp(3, g2_->yn, g2_->xn, g2_->b, g2_->yn, g2_->xn);
        break;
      default:
        break;
    }
    if (dither_ && TTYQUANT()->alg != kTtyQuantTrue) {
      dither(g2_->yn, g2_->xn, g2_->b, g2_->yn, g2_->xn);
    }
  });

  if (ShouldUseFrameBuffer()) {
    t3 = 0;
    TIMEIT(t4, RasterIt());
  } else {
    TIMEIT(t3, getxtermcodes(xtcodes_, g2_));
    TIMEIT(t4, RenderIt());
  }

  INFOF(""𝑓%zu(%u×%u) %,zub (%f BPP) ""
        ""ycbcr=%,zuns ""
        ""scale=%,zuns ""
        ""lace=%,zuns ""
        ""fx=%,zuns ""
        ""quantize=%,zuns ""
        ""render=%,zuns"",
        framecount_++, g2_->yn, g2_->xn, f2_->n,
        (f1_->n / (double)(g2_->yn * g2_->xn)), t1, t2, t8, t6, t3, t4);
}

static void OnVideo(plm_t *mpeg, plm_frame_t *pf, void *user) {
  gotvideo_ = true;
  if (f2_->n) {
    WARNF(""video frame dropped"");
  } else {
    TranscodeVideo(pf);
    if (!f1_->n) {
      struct VtFrame *t = f1_;
      f1_ = f2_, f2_ = t;
      f1_start_ = decode_start_;
    } else {
      f2_start_ = decode_start_;
    }
  }
}

static void OpenVideo(void) {
  size_t yn, xn;
  playfd_ = -1;
  INFOF(""%s(%`'s)"", ""OpenVideo"", patharg_);
  CHECK_NOTNULL((plm_ = plm_create_with_filename(patharg_)));
  swing_ = 219;
  xn = plm_get_width(plm_);
  yn = plm_get_height(plm_);
  lighting_ = GetLighting(""D65"");
  primaries_ = IsHighDefinition(yn, xn) ? GetPrimaries(""BT.709"")
                                        : GetPrimaries(""BT.601"");
  plm_set_video_decode_callback(plm_, OnVideo, NULL);
  plm_set_audio_decode_callback(plm_, OnAudio, NULL);
  plm_set_loop(plm_, false);
  FormatInt64(chansstr_, (chans_ = 2));
  FormatInt64(sratestr_, (srate_ = plm_get_samplerate(plm_)));
  if (plm_get_num_audio_streams(plm_) && OpenSpeaker()) {
    plm_set_audio_enabled(plm_, true, 0);
  } else {
    plm_set_audio_enabled(plm_, false, 0);
  }
  g2_ = g1_ = resizegraphic(&graphic_[0], yn, xn);
}

static ssize_t WriteVideoCall(void) {
  size_t amt;
  ssize_t rc;
  amt = min(4096 * 4, f1_->n - f1_->i);
  if ((rc = write(outfd_, f1_->bytes + f1_->i, amt)) != -1) {
    if ((f1_->i += rc) == f1_->n) {
      if (plm_get_audio_enabled(plm_)) {
        plm_set_audio_lead_time(
            plm_,
            max(0,
                min(timespec_tofloat(timespec_sub(timespec_real(), f1_start_)),
                    plm_get_samplerate(plm_) / PLM_AUDIO_SAMPLES_PER_FRAME)));
      }
      f1_start_ = f2_start_;
      f1_->i = f1_->n = 0;
      struct VtFrame *t = f1_;
      f1_ = f2_, f2_ = t;
      RecordFactThatFrameWasFullyRendered();
    }
  }
  return rc;
}

static void DrainVideo(void) {
  if (f1_ && f1_->n) {
    ttywrite(outfd_, f1_->bytes + f1_->i, f1_->n - f1_->i);
    f1_->i = f1_->n = 0;
  }
  if (f2_ && f2_->n) {
    f2_->i = f2_->n = 0;
  }
}

static void WriteVideo(void) {
  ssize_t rc;
  DEBUGF(""write(tty) grace=%,ldns"", timespec_tonanos(GetGraceTime()));
  if ((rc = WriteVideoCall()) != -1) {
    DEBUGF(""write(tty) → %zd [grace=%,ldns]"", rc,
           timespec_tonanos(GetGraceTime()));
  } else if (errno == EAGAIN || errno == EINTR) {
    DEBUGF(""write(tty) → EINTR"");
    longjmp(jbi_, 1);
  } else if (errno == EPIPE) {
    DEBUGF(""write(tty) → EPIPE"");
    longjmp(jb_, 1);
  } else {
    FATALF(""write(tty) → %s"", strerror(errno));
  }
}

static void RefreshDisplay(void) {
  if (f1_ && f1_->n) f1_->i = 0;
  DimensionDisplay();
  resized_ = false;
  historyclear_ = true;
  ttysend(outfd_, ""\e[0m\e[H\e[3J"");
}

static void SetQuant(enum TtyQuantizationAlgorithm alg,
                     enum TtyQuantizationChannels chans,
                     enum TtyBlocksSelection blocks) {
  tuned_ = true;
  ttyquantsetup(alg, chans, blocks);
}

static void SetQuantizationAlgorithm(enum TtyQuantizationAlgorithm alg) {
  SetQuant(alg, TTYQUANT()->chans, TTYQUANT()->blocks);
  /* TODO(jart): autotune */
}

static void SetDithering(bool dither) {
  tuned_ = true;
  dither_ = dither;
}

static optimizesize bool ProcessOptKey(int opt) {
  switch (opt) {
    case 's':
      stats_ = !stats_;
      return true;
    case '3':
      TTYQUANT()->blocks = kTtyBlocksCp437;
      return true;
    case '4':
      TTYQUANT()->blocks = kTtyBlocksUnicode;
      return true;
    case 'd':
      SetDithering(!dither_);
      return true;
    case 't':
      SetQuantizationAlgorithm(kTtyQuantTrue);
      return true;
    case 'a':
      SetQuantizationAlgorithm(kTtyQuantAnsi);
      return true;
    case 'x':
      SetQuantizationAlgorithm(kTtyQuantXterm256);
      return true;
    case 'A':
      istango_ = false;
      memcpy(g_ansi2rgb_, &kCgaPalette, sizeof(kCgaPalette));
      return true;
    case 'T':
      istango_ = true;
      memcpy(g_ansi2rgb_, &kTangoPalette, sizeof(kTangoPalette));
      return true;
    default:
      return false;
  }
}

static optimizesize void ReadKeyboard(void) {
  char b[64];
  int c, i, n, sgn;
  memset(b, -1, sizeof(b));
  b[0] = CTRL('B'); /* for eof case */
  if ((n = read(infd_, &b, sizeof(b))) != -1) {
    for (;;) {
      i = 0;
      c = b[i++];
      if (!ProcessOptKey(c)) {
        sgn = isupper(c) ? -1 : 1;
        switch (c) {
          case 'Y':
            yonly_ = !yonly_;
            ComputeColoringSolution();
            break;
          case 'S':
            swing_ = swing_ == 219 ? 255 : 219;
            ComputeColoringSolution();
            break;
          case 'p':
          case 'P':
            primaries_ = MOD(sgn + primaries_, ARRAYLEN(kPrimaries));
            ComputeColoringSolution();
            break;
          case 'l':
          case 'L':
            lighting_ = MOD(sgn + lighting_, ARRAYLEN(kLightings));
            ComputeColoringSolution();
            break;
          case 'g':
          case 'G':
            gamma_ += sgn * GAMMADELTA;
            g_xterm256_gamma += sgn * GAMMADELTA;
            ComputeColoringSolution();
            break;
          case 'k':
          case 'K':
            lumakernel_ = MOD(sgn + lumakernel_, ARRAYLEN(kMagikarp));
            memcpy(g_magikarp, kMagikarp[lumakernel_], sizeof(kMagikarp[0]));
            break;
          case 'j':
          case 'J':
            chromakernel_ = MOD(sgn + chromakernel_, ARRAYLEN(kMagkern));
            memcpy(g_magkern, kMagkern[chromakernel_], sizeof(kMagkern[0]));
            break;
          case 'q':
          case CTRL('C'):
            longjmp(jb_, 1);
            break;
          case CTRL('Z'):
            ttyshowcursor(outfd_);
            raise(SIGSTOP);
            break;
          case CTRL('G'):
            sharp_ = (sharp_ + 1) % kSharpMAX;
            break;
          case CTRL('\\'):
            raise(SIGQUIT);
            break;
          case CTRL('L'):
            RefreshDisplay();
            break;
          case '\e':
            if (n == 1) {
              longjmp(jb_, 1); /* \e <𝟷𝟶𝟶ms*VTIME> is ESC */
            }
            switch (b[i++]) {
              case '[':
                switch (b[i++]) {
                  case 'A': /* ""\e[A"" is up arrow */
                    ++volscale_;
                    break;
                  case 'B': /* ""\e[B"" is down arrow */
                    --volscale_;
                    break;
                  case 'C': /* ""\e[C"" is right arrow */
                    break;
                  case 'D': /* ""\e[D"" is left arrow */
                    break;
                  case '1':
                    switch (b[i++]) {
                      case '1':
                        switch (b[i++]) {
                          case '~': /* \e[11~ is F1 */
                            pf1_ = !pf1_;
                            break;
                          default:
                            break;
                        }
                        break;
                      case '2':
                        switch (b[i++]) {
                          case '~': /* \e[12~ is F2 */
                            pf2_ = !pf2_;
                            break;
                          default:
                            break;
                        }
                        break;
                      case '3':
                        switch (b[i++]) {
                          case '~': /* \e[13~ is F3 */
                            pf3_ = !pf3_;
                            break;
                          default:
                            break;
                        }
                        break;
                      case '4':
                        switch (b[i++]) {
                          case '~': /* \e[14~ is F4 */
                            pf4_ = !pf4_;
                            break;
                          default:
                            break;
                        }
                        break;
                      case '5':
                        switch (b[i++]) {
                          case '~': /* \e[15~ is F5 */
                            pf5_ = !pf5_;
                            break;
                          default:
                            break;
                        }
                        break;
                      case '7':
                        switch (b[i++]) {
                          case '~': /* \e[17~ is F6 */
                            pf6_ = !pf6_;
                            break;
                          default:
                            break;
                        }
                        break;
                      case '8':
                        switch (b[i++]) {
                          case '~': /* \e[18~ is F7 */
                            pf7_ = !pf7_;
                            break;
                          default:
                            break;
                        }
                        break;
                      case '9':
                        switch (b[i++]) {
                          case '~': /* \e[19~ is F8 */
                            pf8_ = !pf8_;
                            break;
                          default:
                            break;
                        }
                        break;
                      default:
                        break;
                    }
                    break;
                  case '2':
                    switch (b[i++]) {
                      case '0':
                        switch (b[i++]) {
                          case '~': /* \e[20~ is F9 */
                            pf9_ = !pf9_;
                            break;
                          default:
                            break;
                        }
                        break;
                      case '1':
                        switch (b[i++]) {
                          case '~': /* \e[21~ is F10 */
                            pf10_ = !pf10_;
                            break;
                          default:
                            break;
                        }
                        break;
                      case '3':
                        switch (b[i++]) {
                          case '~': /* \e[23~ is F11 */
                            pf11_ = !pf11_;
                            break;
                          default:
                            break;
                        }
                        break;
                      case '4':
                        switch (b[i++]) {
                          case '~': /* \e[24~ is F12 */
                            pf12_ = !pf12_;
                            break;
                          default:
                            break;
                        }
                        break;
                      default:
                        break;
                    }
                    break;
                  case '[':
                    switch (b[i++]) {
                      case 'A': /* \e[[A is F1 */
                        pf1_ = !pf1_;
                        break;
                      case 'B': /* \e[[B is F2 */
                        pf2_ = !pf2_;
                        break;
                      case 'C': /* \e[[C is F3 */
                        pf3_ = !pf3_;
                        break;
                      case 'D': /* \e[[D is F4 */
                        pf4_ = !pf4_;
                        break;
                      case 'E': /* \e[[E is F5 */
                        pf5_ = !pf5_;
                        break;
                      default:
                        break;
                    }
                    break;
                  default:
                    break;
                }
                break;
              case 'O':
                switch (b[i++]) {
                  case 'P': /* \eOP is F1 */
                    pf1_ = !pf1_;
                    break;
                  case 'Q': /* \eOQ is F2 */
                    pf2_ = !pf2_;
                    break;
                  case 'R': /* \eOR is F3 */
                    pf3_ = !pf3_;
                    break;
                  case 'S': /* \eOS is F4 */
                    pf4_ = !pf4_;
                    break;
                  case 'T': /* \eOT is F5 */
                    pf5_ = !pf5_;
                    break;
                  case 'U': /* \eOU is F6 */
                    pf6_ = !pf6_;
                    break;
                  case 'V': /* \eOV is F7 */
                    pf7_ = !pf7_;
                    break;
                  case 'W': /* \eOW is F8 */
                    pf8_ = !pf8_;
                    break;
                  case 'Y': /* \eOY is F10 */
                    pf10_ = !pf10_;
                    break;
                  case 'Z': /* \eOZ is F11 */
                    pf11_ = !pf11_;
                    break;
                  case '[': /* \eO[ is F12 */
                    pf12_ = !pf12_;
                    break;
                  default:
                    break;
                }
                break;
              default:
                break;
            }
            break;
          default:
            break;
        }
      }
      if ((n -= i) <= 0) {
        break;
      } else {
        memmove(b, b + i, sizeof(b) - i);
      }
    }
  } else if (errno == EINTR) {
    longjmp(jbi_, 1);
  }
}

static void PerformBestEffortIo(void) {
  int toto, pollms;
  struct pollfd fds[] = {
      {infd_, POLLIN},
      {outfd_, f1_ && f1_->n ? POLLOUT : 0},
  };
  pollms = MAX(0, timespec_tomillis(GetGraceTime()));
  DEBUGF(""poll() ms=%,d"", pollms);
  if ((toto = poll(fds, ARRAYLEN(fds), pollms)) != -1) {
    DEBUGF(""poll() toto=%d [grace=%,ldns]"", toto,
           timespec_tonanos(GetGraceTime()));
    if (toto) {
      if (fds[0].revents & (POLLIN | POLLERR)) ReadKeyboard();
      if (fds[1].revents & (POLLOUT | POLLERR)) WriteVideo();
    }
  } else if (errno == EINTR) {
    DEBUGF(""poll() → EINTR"");
    return;
  } else {
    FATALF(""poll() → %s"", strerror(errno));
  }
}

static void RestoreTty(void) {
  DrainVideo();
  if (ttymode_) ttysend(outfd_, ""\r\n\e[J"");
  ttymode_ = false;
  ttyraw(-1);
}

static void HandleSignals(void) {
  if (piped_) {
    WARNF(""SIGPIPE"");
    CloseSpeaker();
    piped_ = false;
  }
  if (resized_) {
    RefreshDisplay();
  }
}

static void PrintVideo(void) {
  struct timespec decode_last, decode_end, next_tick, lag;
  dura_ = timespec_frommicros(min(MAX_FRAMERATE, 1 / plm_get_framerate(plm_)) *
                              1e6);
  INFOF(""framerate=%f dura=%f"", plm_get_framerate(plm_), dura_);
  next_tick = deadline_ = decode_last = timespec_real();
  next_tick = timespec_add(next_tick, dura_);
  deadline_ = timespec_add(deadline_, dura_);
  do {
    DEBUGF(""plm_decode [grace=%,ldns]"", timespec_tonanos(GetGraceTime()));
    decode_start_ = timespec_real();
    plm_decode(plm_,
               timespec_tofloat(timespec_sub(decode_start_, decode_last)));
    decode_last = decode_start_;
    decode_end = timespec_real();
    lag = timespec_sub(decode_end, decode_start_);
    while (timespec_cmp(timespec_add(decode_end, lag), next_tick) > 0) {
      next_tick = timespec_add(next_tick, dura_);
    }
    deadline_ = timespec_sub(next_tick, lag);
    if (gotvideo_ || !plm_get_video_enabled(plm_)) {
      gotvideo_ = false;
      INFOF(""entering printvideo event loop (lag=%,ldns, grace=%,ldns)"",
            timespec_tonanos(lag), timespec_tonanos(GetGraceTime()));
    }
    do {
      if (!setjmp(jbi_)) {
        PerformBestEffortIo();
      }
      HandleSignals();
    } while (timespec_tomillis(GetGraceTime()) > 0);
  } while (plm_ && !plm_has_ended(plm_));
}

static bool AskUserYesOrNoQuestion(const char *prompt) {
  char c;
  if (yes_ || !ttymode_) return true;
  ttysend(outfd_, ""\r\e[K"");
  ttysend(outfd_, prompt);
  ttysend(outfd_, "" [yn] "");
  poll((struct pollfd[]){{infd_, POLLIN}}, 1, -1);
  c = 0, read(infd_, &c, 1);
  ttysend(infd_, ""\r\e[K"");
  return c == 'y' || c == 'Y';
}

static bool CanPlayAudio(void) {
  if (ffplay_ || sox_) {
    return true;
  } else if (AskUserYesOrNoQuestion(
                 ""ffplay not found; continue without audio?"")) {
    return false;
  } else {
    longjmp(jb_, 1);
  }
}

static void PrintUsage(int rc, int fd) {
  tinyprint(fd, ""Usage: "", program_invocation_name, USAGE, NULL);
  exit(rc);
}

static void GetOpts(int argc, char *argv[]) {
  int opt;
  snprintf(logpath_, sizeof(logpath_), ""%s%s.log"", __get_tmpdir(),
           firstnonnull(program_invocation_short_name, ""unknown""));
  while ((opt = getopt(argc, argv, ""?34AGSTVYabdfhnpstxyzvL:"")) != -1) {
    switch (opt) {
      case 'y':
        yes_ = true;
        break;
      case 'v':
        ++__log_level;
        break;
      case 'L':
        snprintf(logpath_, sizeof(logpath_), ""%s"", optarg);
        break;
      case 'Y':
        yonly_ = true;
        break;
      case 'h':
      case '?':
      default:
        if (!ProcessOptKey(opt)) {
          if (opt == optopt) {
            PrintUsage(EXIT_SUCCESS, STDOUT_FILENO);
          } else {
            PrintUsage(EX_USAGE, STDERR_FILENO);
          }
        }
    }
  }
}

static void OnExit(void) {
  if (playpid_) kill(playpid_, SIGTERM), sched_yield();
  if (plm_) plm_destroy(plm_), plm_ = NULL;
  YCbCrFree(&ycbcr_);
  RestoreTty();
  ttyidentclear(&ti_);
  close(infd_), infd_ = -1;
  close(outfd_), outfd_ = -1;
  free(graphic_[0].b);
  free(graphic_[1].b);
  free(vtframe_[0].b);
  free(vtframe_[1].b);
  free(xtcodes_);
  free(audio_);
  CloseSpeaker();
}

static void MakeLatencyLittleLessBad(void) {
  LOGIFNEG1(sys_mlockall(MCL_CURRENT));
  LOGIFNEG1(nice(-5));
}

static void PickDefaults(void) {
  /*
   * Direct color ain't true color -- it just means xterm does the
   * xterm256 rgb quantization for you. we're better at xterm256
   * than xterm is, so we don't need the training wheels.
   *
   * strcmp(nulltoempty(getenv(""TERM"")), ""xterm-direct"") == 0
   */
  if (strcmp(nulltoempty(getenv(""TERM"")), ""xterm-kitty"") == 0) {
    ttyquantsetup(kTtyQuantTrue, TTYQUANT()->chans, kTtyBlocksUnicode);
  }
}

static void RenounceSpecialPrivileges(void) {
  if (issetugid()) {
    setegid(getgid());
    seteuid(getuid());
  }
}

#define FBIOGET_VSCREENINFO 0x4600
#define FBIOGET_FSCREENINFO 0x4602

static void TryToOpenFrameBuffer(void) {
  /*
   * Linux (i.e. without some X or Wayland thing running on top of it)
   * is barely able to display any non-ascii characters, so things look
   * much better if we can access the framebuffer.
   */
  int rc;
  fb0_.fd = -1;
  fb0_.path = NULL;
  if (!isempty(getenv(""FRAMEBUFFER""))) {
    fb0_.path = strdup(getenv(""FRAMEBUFFER""));
  } else if (strcmp(nulltoempty(getenv(""TERM"")), ""linux"") == 0) {
    fb0_.path = strdup(""/dev/fb0"");
  }
  if ((fb0_.fd = open(fb0_.path, O_RDWR)) != -1) {
    CHECK_NE(-1, (rc = ioctl(fb0_.fd, FBIOGET_FSCREENINFO, &fb0_.fscreen)));
    INFOF(""ioctl(%s) → %d"", ""FBIOGET_FSCREENINFO"", rc);
    INFOF(""%s.%s=%.*s"", ""fb0_.fscreen"", ""id"", sizeof(fb0_.fscreen.id),
          fb0_.fscreen.id);
    INFOF(""%s.%s=%p"", ""fb0_.fscreen"", ""smem_start"", fb0_.fscreen.smem_start);
    INFOF(""%s.%s=%u"", ""fb0_.fscreen"", ""smem_len"", fb0_.fscreen.smem_len);
    INFOF(""%s.%s=%u"", ""fb0_.fscreen"", ""type"", fb0_.fscreen.type);
    INFOF(""%s.%s=%u"", ""fb0_.fscreen"", ""type_aux"", fb0_.fscreen.type_aux);
    INFOF(""%s.%s=%u"", ""fb0_.fscreen"", ""visual"", fb0_.fscreen.visual);
    INFOF(""%s.%s=%hu"", ""fb0_.fscreen"", ""xpanstep"", fb0_.fscreen.xpanstep);
    INFOF(""%s.%s=%hu"", ""fb0_.fscreen"", ""ypanstep"", fb0_.fscreen.ypanstep);
    INFOF(""%s.%s=%hu"", ""fb0_.fscreen"", ""ywrapstep"", fb0_.fscreen.ywrapstep);
    INFOF(""%s.%s=%u"", ""fb0_.fscreen"", ""line_length"", fb0_.fscreen.line_length);
    INFOF(""%s.%s=%p"", ""fb0_.fscreen"", ""mmio_start"", fb0_.fscreen.mmio_start);
    INFOF(""%s.%s=%u"", ""fb0_.fscreen"", ""mmio_len"", fb0_.fscreen.mmio_len);
    INFOF(""%s.%s=%u"", ""fb0_.fscreen"", ""accel"", fb0_.fscreen.accel);
    INFOF(""%s.%s=%#b"", ""fb0_.fscreen"", ""capabilities"",
          fb0_.fscreen.capabilities);
    CHECK_NE(-1, (rc = ioctl(fb0_.fd, FBIOGET_VSCREENINFO, &fb0_.vscreen)));
    INFOF(""ioctl(%s) → %d"", ""FBIOGET_VSCREENINFO"", rc);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""xres"", fb0_.vscreen.xres);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""yres"", fb0_.vscreen.yres);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""xres_virtual"",
          fb0_.vscreen.xres_virtual);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""yres_virtual"",
          fb0_.vscreen.yres_virtual);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""xoffset"", fb0_.vscreen.xoffset);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""yoffset"", fb0_.vscreen.yoffset);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""bits_per_pixel"",
          fb0_.vscreen.bits_per_pixel);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""grayscale"", fb0_.vscreen.grayscale);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen.red"", ""offset"", fb0_.vscreen.red.offset);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen.red"", ""length"", fb0_.vscreen.red.length);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen.red"", ""msb_right"",
          fb0_.vscreen.red.msb_right);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen.green"", ""offset"",
          fb0_.vscreen.green.offset);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen.green"", ""length"",
          fb0_.vscreen.green.length);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen.green"", ""msb_right"",
          fb0_.vscreen.green.msb_right);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen.blue"", ""offset"", fb0_.vscreen.blue.offset);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen.blue"", ""length"", fb0_.vscreen.blue.length);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen.blue"", ""msb_right"",
          fb0_.vscreen.blue.msb_right);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen.transp"", ""offset"",
          fb0_.vscreen.transp.offset);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen.transp"", ""length"",
          fb0_.vscreen.transp.length);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen.transp"", ""msb_right"",
          fb0_.vscreen.transp.msb_right);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""nonstd"", fb0_.vscreen.nonstd);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""activate"", fb0_.vscreen.activate);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""height"", fb0_.vscreen.height);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""width"", fb0_.vscreen.width);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""accel_flags"", fb0_.vscreen.accel_flags);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""pixclock"", fb0_.vscreen.pixclock);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""left_margin"", fb0_.vscreen.left_margin);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""right_margin"",
          fb0_.vscreen.right_margin);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""upper_margin"",
          fb0_.vscreen.upper_margin);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""lower_margin"",
          fb0_.vscreen.lower_margin);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""hsync_len"", fb0_.vscreen.hsync_len);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""vsync_len"", fb0_.vscreen.vsync_len);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""sync"", fb0_.vscreen.sync);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""vmode"", fb0_.vscreen.vmode);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""rotate"", fb0_.vscreen.rotate);
    INFOF(""%s.%s=%u"", ""fb0_.vscreen"", ""colorspace"", fb0_.vscreen.colorspace);
    fb0_.size = fb0_.fscreen.smem_len;
    CHECK_NE(MAP_FAILED,
             (fb0_.map = mmap(NULL, fb0_.size, PROT_READ | PROT_WRITE,
                              MAP_SHARED, fb0_.fd, 0)));
  }
}

int main(int argc, char *argv[]) {
  sigset_t wut;
  const char *s;
  ShowCrashReports();
  gamma_ = 2.4;
  volscale_ -= 2;
  dither_ = true;
  sigemptyset(&wut);
  sigaddset(&wut, SIGCHLD);
  sigaddset(&wut, SIGPIPE);
  sigprocmask(SIG_SETMASK, &wut, NULL);
  ShowCrashReports();
  fullclear_ = true;
  GetOpts(argc, argv);
  if (!tuned_) PickDefaults();
  if (optind == argc) PrintUsage(EX_USAGE, STDERR_FILENO);
  patharg_ = argv[optind];
  s = commandvenv(""SOX"", ""sox"");
  sox_ = s ? strdup(s) : 0;
  s = commandvenv(""FFPLAY"", ""ffplay"");
  ffplay_ = s ? strdup(s) : 0;
  if (!sox_ && !ffplay_) {
    fprintf(stderr, ""please install either the ""
                    ""`play` (sox) or ""
                    ""`ffplay` (ffmpeg) ""
                    ""commands, so printvideo can play audio\n"");
    usleep(10000);
  }
  infd_ = STDIN_FILENO;
  outfd_ = STDOUT_FILENO;
  if (!setjmp(jb_)) {
    xsigaction(SIGINT, OnCtrlC, 0, 0, NULL);
    xsigaction(SIGHUP, OnCtrlC, 0, 0, NULL);
    xsigaction(SIGTERM, OnCtrlC, 0, 0, NULL);
    xsigaction(SIGWINCH, OnResize, 0, 0, NULL);
    xsigaction(SIGCHLD, OnSigChld, 0, 0, NULL);
    xsigaction(SIGPIPE, OnSigPipe, 0, 0, NULL);
    if (ttyraw(kTtyLfToCrLf) != -1) ttymode_ = true;
    __cxa_atexit((void *)OnExit, NULL, NULL);
    __log_file = fopen(logpath_, ""a"");
    if (ischardev(infd_) && ischardev(outfd_)) {
      /* CHECK_NE(-1, fcntl(infd_, F_SETFL, O_NONBLOCK)); */
    } else if (infd_ != outfd_) {
      infd_ = -1;
    }
    /* CHECK_NE(-1, fcntl(outfd_, F_SETFL, O_NONBLOCK)); */
    if (CanPlayAudio()) MakeLatencyLittleLessBad();
    TryToOpenFrameBuffer();
    RenounceSpecialPrivileges();
    if (t2 > t1) longjmp(jb_, 1);
    OpenVideo();
    DimensionDisplay();
    starttime_ = timespec_real();
    PrintVideo();
  }
  INFOF(""jb_ triggered"");
  return 0;
}
"
./repos/cosmopolitan/tool/viz/ascii2utf8.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/errno.h""
#include ""libc/stdio/stdio.h""

/**
  @fileoverview Converts ASCII combining marks to UNICODE.

  Getting started:

    nroff -mandoc -rLL=72n -rLT=78n -Tutf8 <manpage.1 |
      o/tool/viz/ascii2utf8

  ASCII Bold:

    - CHAR BACKSPACE CHAR                      c ++ ""\b"" ++ c
      e.g. AABBCCDD                    410841 420842 430843 440844

  ASCII Underlines:

    - CHAR BACKSPACE LOW LINE                  c ++ ""\b_""
      e.g. A_B_C_D_                    41085F 42085F 43085F 44085F

  UNICODE Underlines:

    - COMBINING LOW LINE                       U+0332 (\xCC\xB1)
      e.g. A̲B̲C̲D̲ (ugly notches)                 41CCB2 42CCB2 43CCB2 44CCB2

    - COMBINING MACRON BELOW                   U+0331 (\xCC\xB1)
      e.g. A̱ḆC̱Ḏ (too short)                    41CCB1 42CCB1 43CCB1 44CCB1

    - COMBINING DOUBLE MACRON BELOW            U+035F (\xCD\x9F)
      e.g. A͟B͟C͟D͟ (too long)                     41CD9F 42CD9F 43CD9F 44CD9F

    - DOUBLE PLUS COMBINING MACRON BELOW       3×U+035F + 1×U+0331
      e.g. A͟B͟C͟Ḏ (too narrow)                   41CCB1 42CCB1 43CCB1 44CD9F

    - DOUBLE PLUS COMBINING MACRON LOW LINE    [it's complicated]
      e.g. A͟B͟C͟D̲ (𝑓𝑙𝑎𝑤𝑙𝑒𝑠𝑠)                     41CD9F 42CD9F 43CD9F 44CCB2

*/

const wint_t kBackspace = '\b';
const wint_t kCombiningLowLine = L'\u0332';
const wint_t kCombiningDoubleMacronBelow = L'\u035f';

forceinline int PutChar(wint_t (*buf)[3], size_t *i, wint_t *cc, FILE *out) {
  if (fputwc((*buf)[0], out) == -1) return -1;
  if (*cc != -1) {
    if (fputwc(*cc, out) == -1) return -1;
    *cc = -1;
  }
  (*buf)[0] = (*buf)[1];
  (*buf)[1] = (*buf)[2];
  --*i;
  return 0;
}

int CombineAsciiMarks(FILE *in, FILE *out) {
  wint_t buf[3], wc = 0, cc = -1;
  size_t i = 0;
  for (;;) {
    while (i < 3) {
      if ((wc = fgetwc(in)) == -1) goto InputBreak;
      buf[i++] = wc;
    }
    if (buf[1] == '\b' && cc == -1) {
      if (buf[0] == buf[2]) { /* bold */
        if (L'0' <= buf[0] && buf[0] <= L'9') {
          buf[0] = L'𝟬' + (buf[0] - L'0');
          i = 1;
        } else if (L'A' <= buf[0] && buf[0] <= L'Z') {
          buf[0] = L'𝐀' + (buf[0] - L'A');
          i = 1;
        } else if ('a' <= buf[0] && buf[0] <= L'z') {
          buf[0] = L'𝗮' + (buf[0] - L'a');
          i = 1;
        } else {
          i = 1;
        }
      } else if (buf[2] == '_') { /* underline */
        cc = kCombiningLowLine;
        i = 1;
      } else if (buf[0] == '_') {
        cc = kCombiningLowLine;
        buf[0] = buf[2];
        i = 1;
      }
    }
    if (i == 3) {
      if (PutChar(&buf, &i, &cc, out) == -1) goto OutputBreak;
    }
  }
InputBreak:
  while (i) {
    if (PutChar(&buf, &i, &cc, out) == -1) goto OutputBreak;
  }
OutputBreak:
  return (fclose(in) | fclose(out)) != -1 ? 0 : -1;
}

int main(int argc, char *argv[]) {
  return CombineAsciiMarks(stdin, stdout) != -1 ? 0 : errno;
}
"
./repos/cosmopolitan/tool/viz/bin2asm.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#include ""libc/str/tab.internal.h""

#define COLS 8

int main(int argc, char *argv[]) {
  int c, col = 0;
  int need_newline = 0;
  char16_t glyphs[COLS + 1];
  while ((c = getchar()) != -1) {
    if (!col) {
      need_newline = 1;
      printf(""\t.byte\t"");
      bzero(glyphs, sizeof(glyphs));
    }
    glyphs[col] = kCp437[c];
    if (col) putchar(',');
    printf(""0x%02x"", c);
    if (++col == COLS) {
      col = 0;
      printf(""\t//%hs\n"", glyphs);
      need_newline = 0;
    }
  }
  if (need_newline) {
    printf(""\n"");
  }
  return 0;
}
"
./repos/cosmopolitan/tool/viz/datauri.c,https://github.com/jart/cosmopolitan.git,"#if 0
/*─────────────────────────────────────────────────────────────────╗
│ To the extent possible under law, Justine Tunney has waived      │
│ all copyright and related or neighboring rights to this file,    │
│ as it is written in the following disclaimers:                   │
│   • http://unlicense.org/                                        │
│   • http://creativecommons.org/publicdomain/zero/1.0/            │
╚─────────────────────────────────────────────────────────────────*/
#endif
#include ""libc/errno.h""
#include ""libc/log/log.h""
#include ""libc/mem/gc.h""
#include ""libc/runtime/runtime.h""
#include ""libc/stdio/stdio.h""
#include ""libc/x/x.h""
#include ""net/http/escape.h""
#include ""net/http/http.h""
#include ""third_party/getopt/getopt.internal.h""
#include ""third_party/stb/stb_image.h""

#define USAGE \
  "" [FLAGS] FILE...\n\
Utility for printing data:base64 URIs.\n\
\n\
FLAGS\n\
\n\
  -h      Help\n""

void PrintUsage(int rc, FILE *f) {
  fputs(""Usage: "", f);
  fputs(program_invocation_name, f);
  fputs(USAGE, f);
  exit(rc);
}

void PrintUri(const char *path) {
  size_t n;
  void *img;
  if (!(img = gc(xslurp(path, &n)))) exit(2);
  fputs(""data:"", stdout);
  fputs(FindContentType(path, -1), stdout);
  fputs("";base64,"", stdout);
  fputs(gc(EncodeBase64(img, n, 0)), stdout);
}

int main(int argc, char *argv[]) {
  int i;
  while ((i = getopt(argc, argv, ""?h"")) != -1) {
    switch (i) {
      case '?':
      case 'h':
        PrintUsage(0, stdout);
      default:
        PrintUsage(1, stderr);
    }
  }
  if (optind == argc) {
    PrintUsage(1, stderr);
  }
  for (i = optind; i < argc; ++i) {
    PrintUri(argv[i]);
  }
}
"
./repos/cosmopolitan/tool/viz/life.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""dsp/scale/scale.h""
#include ""libc/calls/calls.h""
#include ""libc/calls/struct/sigaction.h""
#include ""libc/calls/struct/termios.h""
#include ""libc/calls/struct/winsize.h""
#include ""libc/calls/termios.h""
#include ""libc/errno.h""
#include ""libc/fmt/conv.h""
#include ""libc/fmt/itoa.h""
#include ""libc/intrin/popcnt.h""
#include ""libc/intrin/safemacros.internal.h""
#include ""libc/intrin/xchg.internal.h""
#include ""libc/limits.h""
#include ""libc/log/check.h""
#include ""libc/log/log.h""
#include ""libc/macros.internal.h""
#include ""libc/mem/mem.h""
#include ""libc/nexgen32e/nt2sysv.h""
#include ""libc/nt/comdlg.h""
#include ""libc/nt/dll.h""
#include ""libc/nt/enum/bitblt.h""
#include ""libc/nt/enum/color.h""
#include ""libc/nt/enum/cw.h""
#include ""libc/nt/enum/idc.h""
#include ""libc/nt/enum/mb.h""
#include ""libc/nt/enum/mf.h""
#include ""libc/nt/enum/mk.h""
#include ""libc/nt/enum/ofn.h""
#include ""libc/nt/enum/rdw.h""
#include ""libc/nt/enum/sc.h""
#include ""libc/nt/enum/sw.h""
#include ""libc/nt/enum/wm.h""
#include ""libc/nt/enum/ws.h""
#include ""libc/nt/events.h""
#include ""libc/nt/messagebox.h""
#include ""libc/nt/paint.h""
#include ""libc/nt/struct/openfilename.h""
#include ""libc/nt/windows.h""
#include ""libc/runtime/runtime.h""
#include ""libc/runtime/sysconf.h""
#include ""libc/sock/struct/pollfd.h""
#include ""libc/stdio/rand.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#include ""libc/str/strwidth.h""
#include ""libc/sysv/consts/auxv.h""
#include ""libc/sysv/consts/ex.h""
#include ""libc/sysv/consts/exit.h""
#include ""libc/sysv/consts/poll.h""
#include ""libc/sysv/consts/sig.h""
#include ""libc/sysv/consts/termios.h""
#include ""libc/time/time.h""
#include ""third_party/getopt/getopt.internal.h""

/**
 * @fileoverview Conway's Game of Life
 *
 * The Game of Life, also known simply as Life, is a cellular automaton
 * devised by the British mathematician John Horton Conway in 1970. It
 * is Turing complete and can simulate a universal constructor or any
 * other Turing machine.
 *
 * There's about 20 million Software Engineers in the world, which means
 * Game of Life has likely been implemented 20 million times before. Why
 * do we need this one?
 *
 *   - It's a tutorial on how to build an Actually Portable Executable
 *     that'll run as a GUI on Windows, and as a TUI on Linux/Mac/BSDs
 *     using roughly one thousand lines of code. For a much better GUI
 *     that's not as hackable, try Golly: http://golly.sourceforge.net
 *
 *   - It's a tutorial on how to implement XTERM mouse cursor dragging
 *     where zooming in/out can be performed too using ctrl+mousewheel
 *     which is an underused (but easily implemented) terminal feature
 *     that even the Windows10 Command Prompt supports these days.
 *
 *   - It uses bitboards. That's almost as simple as the naive approach
 *     but goes significantly faster, needing 150 picoseconds per board
 *     position. See ""Bitboard Methods for Games"" by Cameron Browne for
 *     further details on how it works. More advanced algorithms exist,
 *     such as Hashlife: quadtree memoization to make humongous numbers
 *     of generations tractable.
 *
 * Here's how you can compile this program on Linux:
 *
 *     git clone https://github.com/jart/cosmopolitan && cd cosmopolitan
 *     make -j12 o//tool/viz/life
 *
 * The output binary works on Linux, Windows, Mac, and FreeBSD:
 *
 *     o//tool/viz/life
 *
 * @see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life
 * @see https://www.conwaylife.com/wiki/Run_Length_Encoded
 * @see http://golly.sourceforge.net/
 */

#define USAGE \
  "" [-zNW] [-w WIDTH] [-h HEIGHT] [PATH]\n\
\n\
DESCRIPTION\n\
\n\
  Conway's Game of Life\n\
\n\
FLAGS\n\
\n\
  -?         help\n\
  -z         zoom\n\
  -w INT     board width\n\
  -h INT     board height\n\
  -N         natural scrolling\n\
  -W         white terminal background\n\
\n\
SHORTCUTS\n\
\n\
  space      step\n\
  left+drag  draw\n\
  right+drag move\n\
  ctrl+wheel zoom\n\
  ctrl+t     turbo\n\
  alt+t      slowmo\n\
  R          reset\n\
  q          quit\n\
\n""

#define MAXZOOM   14
#define VOIDSPACE "".""
#define ALT       (1 << 29)

#define INTERRUPTED 1
#define RESIZED     2

#define IDM_ABOUT 0x10
#define IDM_OPEN  0x20

#define MOUSE_LEFT_DOWN       0
#define MOUSE_MIDDLE_DOWN     1
#define MOUSE_RIGHT_DOWN      2
#define MOUSE_LEFT_UP         4
#define MOUSE_MIDDLE_UP       5
#define MOUSE_RIGHT_UP        6
#define MOUSE_LEFT_DRAG       32
#define MOUSE_MIDDLE_DRAG     33
#define MOUSE_RIGHT_DRAG      34
#define MOUSE_WHEEL_UP        64
#define MOUSE_WHEEL_DOWN      65
#define MOUSE_CTRL_WHEEL_UP   80
#define MOUSE_CTRL_WHEEL_DOWN 81

struct Buffer {
  unsigned i, n;
  char *p;
};

static bool erase;
static bool white;
static bool natural;
static bool mousemode;
static bool isdragging;
static bool dimensioned;

static int out;
static int line;
static int column;
static int action;
static int color[2];

static long top;
static long bottom;
static long left;
static long right;
static long tyn;
static long txn;
static long byn;
static long bxn;
static long zoom;
static long speed;
static long save_y;
static long save_x;
static long save_top;
static long save_left;
static long generation;

static uint64_t *board;
static uint64_t *board2;
static size_t boardsize;
static int64_t oldcursor;

static struct Buffer buffer;
static struct termios oldterm;

static char name[64];
static char statusline[256];
static char16_t statusline16[256];

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § game of life » algorithm                                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define LEFT   0x0101010101010101ul
#define RIGHT  0x8080808080808080ul
#define TOP    0x00000000000000FFul
#define BOTTOM 0xFF00000000000000ul

#define CTRL(C)      ((C) ^ 0100)
#define GOUP(x)      ((x) >> 8)
#define GODOWN(x)    ((x) << 8)
#define GORIGHT(x)   (((x) & ~RIGHT) << 1)
#define GOLEFT(x)    (((x) & ~LEFT) >> 1)
#define LEFTMOST(x)  ((x) & LEFT)
#define RIGHTMOST(x) ((x) & RIGHT)
#define TOPMOST(x)   ((x) & TOP)
#define BOTMOST(x)   ((x) & BOTTOM)

#define ADD(X)       \
  do {               \
    uint64_t c1, c2; \
    c1 = r0 & (X);   \
    c2 = r1 & c1;    \
    r0 ^= (X);       \
    r1 ^= c1;        \
    r2 |= c2;        \
  } while (0)

#define STEP(RES, B00, B01, B02, B10, B11, B12, B20, B21, B22)             \
  do {                                                                     \
    uint64_t r0 = 0, r1 = 0, r2 = 0;                                       \
    ADD(GORIGHT(GODOWN(B11)) | GORIGHT(BOTMOST(B01) >> 56) |               \
        GODOWN(RIGHTMOST(B10) >> 7) | BOTMOST(RIGHTMOST(B00)) >> 7 >> 56); \
    ADD(GORIGHT(B11) | RIGHTMOST(B10) >> 7);                               \
    ADD(GORIGHT(GOUP(B11)) | GORIGHT(TOPMOST(B21) << 56) |                 \
        GOUP(RIGHTMOST(B10) >> 7) | TOPMOST(RIGHTMOST(B20)) >> 7 << 56);   \
    ADD(GODOWN(B11) | BOTMOST(B01) >> 56);                                 \
    ADD(GOUP(B11) | TOPMOST(B21) << 56);                                   \
    ADD(GOLEFT(GODOWN(B11)) | GOLEFT(BOTMOST(B01) >> 56) |                 \
        GODOWN(LEFTMOST(B12) << 7) | BOTMOST(LEFTMOST(B02)) << 7 >> 56);   \
    ADD(GOLEFT(B11) | LEFTMOST(B12) << 7);                                 \
    ADD(GOLEFT(GOUP(B11)) | GOLEFT(TOPMOST(B21) << 56) |                   \
        GOUP(LEFTMOST(B12) << 7) | TOPMOST(LEFTMOST(B22)) << 7 << 56);     \
    RES = (B11 | r0) & r1 & ~r2;                                           \
  } while (0)

static void SwapBoards(void) {
  uint64_t *t = board;
  board = board2;
  board2 = t;
}

static void Step(void) {
  long y, x, yn, xn;
  yn = byn >> 3;
  xn = bxn >> 3;
  for (y = 0; y < yn; ++y) {
    for (x = 0; x < xn; ++x) {
      STEP(board2[y * xn + x],
           board[(y ? y - 1 : yn - 1) * xn + (x ? x - 1 : xn - 1)],
           board[(y ? y - 1 : yn - 1) * xn + x],
           board[(y ? y - 1 : yn - 1) * xn + (x + 1 < xn ? x + 1 : 0)],
           board[y * xn + (x ? x - 1 : xn - 1)], board[y * xn + x],
           board[y * xn + (x + 1 < xn ? x + 1 : 0)],
           board[(y + 1 < yn ? y + 1 : 0) * xn + (x ? x - 1 : xn - 1)],
           board[(y + 1 < yn ? y + 1 : 0) * xn + x],
           board[(y + 1 < yn ? y + 1 : 0) * xn + (x + 1 < xn ? x + 1 : 0)]);
    }
  }
  SwapBoards();
  ++generation;
}

static bool Test(long y, long x) {
  return (board[(bxn >> 3) * (y >> 3) + (x >> 3)] >>
          (((y & 7) << 3) + (x & 7))) &
         1;
}

static void Set(long y, long x) {
  board[(bxn >> 3) * (y >> 3) + (x >> 3)] |= 1ul << (((y & 7) << 3) + (x & 7));
}

static void Unset(long y, long x) {
  board[(bxn >> 3) * (y >> 3) + (x >> 3)] &=
      ~(1ul << (((y & 7) << 3) + (x & 7)));
}

static long Population(void) {
  return _countbits(board, byn * bxn / 64 * 8);
}

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § game of life » buffer                                     ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

static void AppendData(char *data, unsigned len) {
  char *p;
  unsigned n;
  if (buffer.i + len + 1 > buffer.n) {
    n = MAX(buffer.i + len + 1, MAX(16, buffer.n + (buffer.n >> 1)));
    if (!(p = realloc(buffer.p, n))) return;
    buffer.p = p;
    buffer.n = n;
  }
  memcpy(buffer.p + buffer.i, data, len);
  buffer.p[buffer.i += len] = 0;
}

static void AppendChar(char c) {
  AppendData(&c, 1);
}

#define AppendStr(s) AppendData(s, strlen(s))

static void AppendInt(long x) {
  char ibuf[21];
  AppendData(ibuf, FormatInt64(ibuf, x) - ibuf);
}

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § game of life » board control                              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

static void Generation(void) {
  long i;
  for (i = 0; i < speed; ++i) {
    Step();
  }
}

static void Dimension(void) {
  if (!dimensioned) {
    top = byn / 2 - tyn / 2;
    left = bxn / 2 - txn / 2;
    dimensioned = true;
  }
  right = left + txn;
  bottom = top + tyn;
}

static void Move(long dy, long dx) {
  long yn, xn;
  yn = zoom ? tyn * 2 : tyn;
  xn = txn;
  top = top + (dy << zoom);
  left = left + (dx << zoom);
  bottom = top + (yn << zoom);
  right = left + (xn << zoom);
}

static void OnUp(void) {
  Move(-1, 0);
}

static void OnDown(void) {
  Move(+1, 0);
}

static void OnLeft(void) {
  Move(0, -1);
}

static void OnRight(void) {
  Move(0, +1);
}

static void OnPageUp(void) {
  Move(-(tyn - 2), 0);
}

static void OnPageDown(void) {
  Move(+(tyn - 2), 0);
}

static void OnTurbo(void) {
  ++speed;
}

static void OnSlowmo(void) {
  --speed;
  if (speed < 1) speed = 1;
}

static void SetZoom(long y, long x, int d) {
  long a, b;
  if ((0 <= y && y < tyn) && (0 <= x && x < txn)) {
    a = zoom;
    b = MIN(MAXZOOM, MAX(0, a + d));
    zoom = b;
    Move(((y << (a + !!a)) - (y << (b + !!b))) >> b,
         ((x << a) - (x << b)) >> b);
  }
}

static void OnZoom(long y, long x) {
  SetZoom(y, x, +1);
}

static void OnUnzoom(long y, long x) {
  SetZoom(y, x, -1);
}

static void OnMouseLeftDrag(long y, long x) {
  int i;
  if (y == save_y && x == save_x) return;
  save_y = y;
  save_x = x;
  y = top + (y << (zoom + !!zoom));
  x = left + (x << zoom);
  y += _rand64() & ((1ul << (zoom + !!zoom)) - 1);
  x += _rand64() & ((1ul << zoom) - 1);
  if (y < 0 || y >= byn) return;
  if (x < 0 || x >= bxn) return;
  if (erase) {
    Unset(y, x);
  } else {
    for (i = 0; i < (2 << zoom); ++i) {
      Set(y + (rand() % (zoom + 1)) - (rand() % (zoom + 1)),
          x + (rand() % (zoom + 1)) - (rand() % (zoom + 1)));
    }
  }
}

static void OnMouseLeftUp(long y, long x) {
  isdragging = false;
}

static void OnMouseLeftDown(long y, long x) {
  isdragging = true;
  save_y = y;
  save_x = x;
  y = top + (y << (zoom + !!zoom));
  x = left + (x << zoom);
  erase = false;
  if (y < 0 || y >= byn) return;
  if (x < 0 || x >= bxn) return;
  if ((erase = Test(y, x))) {
    Unset(y, x);
  } else {
    Set(y, x);
  }
}

static void OnMouseRightUp(long y, long x) {
  isdragging = false;
}

static void OnMouseRightDown(long y, long x) {
  isdragging = true;
  save_y = y;
  save_x = x;
  save_top = top;
  save_left = left;
}

static void OnMouseRightDrag(long y, long x) {
  long dy, dx, h, w;
  dy = (save_y - y) << zoom;
  dx = (save_x - x) << zoom;
  if (zoom) dy <<= 1;
  if (natural) {
    dy = -dy;
    dx = -dx;
  }
  h = bottom - top;
  w = right - left;
  top = save_top + dy;
  left = save_left + dx;
  bottom = top + h;
  right = left + w;
}

static void *NewBoard(size_t *out_size) {
  char *p;
  size_t s, n, k;
  s = (byn * bxn) >> 3;
  k = getauxval(AT_PAGESZ) + ROUNDUP(s, getauxval(AT_PAGESZ));
  n = ROUNDUP(k + getauxval(AT_PAGESZ), sysconf(_SC_PAGESIZE));
  p = _mapanon(n);
  mprotect(p, getauxval(AT_PAGESZ), 0);
  mprotect(p + k, n - k, 0);
  if (out_size) *out_size = n;
  return p + getauxval(AT_PAGESZ);
}

static void FreeBoard(void *p, size_t n) {
  munmap((char *)p - getauxval(AT_PAGESZ), n);
}

static void AllocateBoardsWithHardwareAcceleratedMemorySafety(void) {
  if (board) {
    FreeBoard(board2, boardsize);
    FreeBoard(board, boardsize);
  }
  board = NewBoard(&boardsize);
  board2 = NewBoard(NULL);
}

static void GenerateStatusLine(void) {
  snprintf(statusline, sizeof(statusline),
           ""%s :: %,ldg %,ldp %lds %ldx %ld×%ld (%ld,%ld,%ld,%ld)"", name,
           generation, Population(), speed, zoom, byn, bxn, left, top, right,
           bottom);
}

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § game of life » files                                      ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

static void OnHeader(void) {
  size_t n;
  if (!buffer.i) return;
  switch (buffer.p[0]) {
    case 'N':
      if (buffer.i > 2) {
        n = MIN(buffer.i - 2, sizeof(name) - 1);
        memcpy(name, buffer.p + 2, n);
        name[n] = 0;
      }
      break;
    default:
      break;
  }
}

static int ReadChar(FILE *f) {
  int c;
  ++column;
  if ((c = fgetc(f)) == -1) return -1;
  if (c == '\n') {
    ++line;
    column = 0;
  }
  return c;
}

static int GetChar(FILE *f) {
  int c;
  for (;;) {
    if ((c = ReadChar(f)) == -1) return -1;
    if (c == '#' && column == 1) {
      for (;;) {
        if ((c = ReadChar(f)) == -1) return -1;
        if (c == '\r') {
          continue;
        } else if (c == '\n') {
          OnHeader();
          break;
        }
        AppendChar(c);
      }
      continue;
    }
    return c;
  }
}

static int LoadFile(const char *path) {
  FILE *f;
  long c, y, x, i, n, yn, xn, yo, xo;
  line = 0;
  f = fopen(path, ""r"");
  if (GetChar(f) != 'x') goto ReadError;
  if (GetChar(f) != ' ') goto ReadError;
  if (GetChar(f) != '=') goto ReadError;
  if (GetChar(f) != ' ') goto ReadError;
  xn = 0;
  for (;;) {
    if ((c = GetChar(f)) == -1) goto ReadError;
    if (!isdigit(c)) break;
    xn *= 10;
    xn += c - '0';
  }
  do {
    if ((c = GetChar(f)) == -1) goto ReadError;
  } while (!isdigit(c));
  yn = 0;
  do {
    yn *= 10;
    yn += c - '0';
    if ((c = GetChar(f)) == -1) goto ReadError;
  } while (isdigit(c));
  while (c != '\n') {
    if ((c = ReadChar(f)) == -1) goto ReadError;
  }
  if (yn > byn || xn > bxn) goto ReadError;
  SwapBoards();
  bzero(board, (byn * bxn) >> 3);
  yo = byn / 2 - yn / 2;
  xo = bxn / 2 - xn / 2;
  y = 0;
  x = 0;
  for (;;) {
    if ((c = GetChar(f)) == -1) goto ReadError;
    if (c == '!') {
      break;
    } else if (isspace(c)) {
      continue;
    }
    if (isdigit(c)) {
      n = c - '0';
      for (;;) {
        if ((c = GetChar(f)) == -1) goto ReadError;
        if (!isdigit(c)) break;
        n *= 10;
        n += c - '0';
      }
    } else {
      n = 1;
    }
    if (c == '$') {
      if (++y == yn) y = 0;
      x = 0;
    } else if (c == 'b' || c == 'o') {
      for (i = 0; i < n; ++i) {
        if (x >= xn) {
          if (++y == yn) y = 0;
          x = 0;
        }
        if (c == 'o') {
          Set(yo + y, xo + x);
        }
        ++x;
      }
    } else {
      goto ReadError;
    }
  }
  fclose(f);
  dimensioned = false;
  return 0;
ReadError:
  fclose(f);
  SwapBoards();
  return -1;
}

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § game of life » terminal user interface                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

static int Write(const char *s) {
  return write(out, s, strlen(s));
}

static wontreturn void PrintUsage(int rc) {
  Write(""SYNOPSIS\n\n  "");
  Write(program_invocation_name);
  Write(USAGE);
  exit(rc);
}

static void GetOpts(int argc, char *argv[]) {
  int opt;
  while ((opt = getopt(argc, argv, ""?hNWzw:h:"")) != -1) {
    switch (opt) {
      case 'w':
        bxn = strtol(optarg, NULL, 0);
        bxn = ROUNDUP(MAX(8, bxn), 8);
        break;
      case 'h':
        byn = strtol(optarg, NULL, 0);
        byn = ROUNDUP(MAX(8, byn), 8);
        break;
      case 'z':
        ++zoom;
        break;
      case 'N':
        natural = true;
        break;
      case 'W':
        white = true;
        break;
      case '?':
        PrintUsage(EXIT_SUCCESS);
      default:
        PrintUsage(EX_USAGE);
    }
  }
}

static void HideTtyCursor(void) {
  Write(""\e[?25l"");
}

static void ShowTtyCursor(void) {
  Write(""\e[?25h"");
}

static void EnableMouse(void) {
  mousemode = true;
  Write(""\e[?1000;1002;1015;1006h"");
}

static void DisableMouse(void) {
  mousemode = false;
  Write(""\e[?1000;1002;1015;1006l"");
}

static void LeaveScreen(void) {
  Write(""\e[H\e[0m\e[J"");
}

static void GetTtySize(void) {
  struct winsize wsize;
  wsize.ws_row = tyn + 1;
  wsize.ws_col = txn;
  tcgetwinsize(out, &wsize);
  tyn = wsize.ws_row - 1;
  txn = wsize.ws_col;
  right = left + txn;
  bottom = top + tyn;
}

static void EnableRaw(void) {
  struct termios term;
  memcpy(&term, &oldterm, sizeof(term));
  term.c_cc[VMIN] = 1;
  term.c_cc[VTIME] = 1;
  term.c_iflag &= ~(INPCK | ISTRIP | PARMRK | INLCR | IGNCR | ICRNL | IXON);
  term.c_lflag &= ~(IEXTEN | ICANON | ECHO | ECHONL);
  term.c_cflag &= ~(CSIZE | PARENB);
  term.c_cflag |= CS8;
  term.c_iflag |= IUTF8;
  tcsetattr(out, TCSANOW, &term);
}

static void OnExit(void) {
  LeaveScreen();
  ShowTtyCursor();
  DisableMouse();
  tcsetattr(out, TCSANOW, &oldterm);
}

static void OnSigInt(int sig) {
  action |= INTERRUPTED;
}

static void OnSigWinch(int sig) {
  action |= RESIZED;
}

static void OnMouse(char *p) {
  int e, x, y;
  e = strtol(p, &p, 10);
  if (*p == ';') ++p;
  x = min(txn, max(1, strtol(p, &p, 10))) - 1;
  if (*p == ';') ++p;
  y = min(tyn, max(1, strtol(p, &p, 10))) - 1;
  e |= (*p == 'm') << 2;
  switch (e) {
    case MOUSE_WHEEL_UP:
      if (natural) {
        OnDown();
        OnDown();
        OnDown();
      } else {
        OnUp();
        OnUp();
        OnUp();
      }
      break;
    case MOUSE_WHEEL_DOWN:
      if (natural) {
        OnUp();
        OnUp();
        OnUp();
      } else {
        OnDown();
        OnDown();
        OnDown();
      }
      break;
    case MOUSE_CTRL_WHEEL_UP:
      if (natural) {
        OnZoom(y, x);
      } else {
        OnUnzoom(y, x);
      }
      break;
    case MOUSE_CTRL_WHEEL_DOWN:
      if (natural) {
        OnUnzoom(y, x);
      } else {
        OnZoom(y, x);
      }
      break;
    case MOUSE_RIGHT_DOWN:
      OnMouseRightDown(y, x);
      break;
    case MOUSE_RIGHT_DRAG:
      OnMouseRightDrag(y, x);
      break;
    case MOUSE_RIGHT_UP:
      OnMouseRightUp(y, x);
      break;
    case MOUSE_LEFT_DOWN:
      OnMouseLeftDown(y, x);
      break;
    case MOUSE_LEFT_DRAG:
      OnMouseLeftDrag(y, x);
      break;
    case MOUSE_LEFT_UP:
      OnMouseLeftUp(y, x);
      break;
    default:
      break;
  }
}

static void Rando1(void) {
  long i, n;
  n = (byn * bxn) >> 6;
  for (i = 0; i < n; ++i) {
    board[i] = _rand64();
  }
}

static void Rando2(void) {
  long i, n;
  n = (byn * bxn) >> 6;
  for (i = 0; i < n; ++i) {
    board[i] = rand();
    board[i] <<= 31;
    board[i] |= rand();
    board[i] <<= 2;
    board[i] |= rand() & 0b11;
  }
}

static void ReadKeyboard(void) {
  char buf[32], *p = buf;
  bzero(buf, sizeof(buf));
  if (readansi(0, buf, sizeof(buf)) == -1) {
    if (errno == EINTR) return;
    exit(errno);
  }
  switch (*p++) {
    case 'q':
      exit(0);
    case ' ':
    case 's':
    case '\t':
      Generation();
      break;
    case 'k':
    case CTRL('P'):
      OnUp();
      break;
    case 'j':
    case CTRL('N'):
      OnDown();
      break;
    case CTRL('V'):
      OnPageDown();
      break;
    case CTRL('R'):
      Rando1();
      break;
    case CTRL('G'):
      Rando2();
      break;
    case 'M':
      if (mousemode) {
        DisableMouse();
      } else {
        EnableMouse();
      }
      break;
    case 'R':
      bzero(board, (byn * bxn) >> 3);
      break;
    case CTRL('T'):
      OnTurbo();
      break;
    case '\e':
      switch (*p++) {
        case 'v':
          OnPageUp();
          break;
        case 't':
          OnSlowmo();
          break;
        case '[':
          switch (*p++) {
            case '<':
              OnMouse(p);
              break;
            case 'A':
              OnUp();
              break;
            case 'B':
              OnDown();
              break;
            case 'D':
              OnLeft();
              break;
            case 'C':
              OnRight();
              break;
            case '5':
              switch (*p++) {
                case '~':
                  OnPageUp();
                  break;
                default:
                  break;
              }
              break;
            case '6':
              switch (*p++) {
                case '~':
                  OnPageDown();
                  break;
                default:
                  break;
              }
              break;
            default:
              break;
          }
          break;
        default:
          break;
      }
      break;
    default:
      break;
  }
}

static int InvertXtermGreyscale(int x) {
  return -(x - 232) + 255;
}

static int ByteToColor(int x) {
  uint8_t c;
  c = x / 256. * 24 + 232;
  if (white) c = InvertXtermGreyscale(c);
  return c;
}

static void SetColor(int x, bool isbg) {
  if (x != color[isbg]) {
    AppendStr(""\e["");
    AppendInt(38 + 10 * isbg);
    AppendStr("";5;"");
    AppendInt(x);
    AppendStr(""m"");
    color[isbg] = x;
  }
}

static void SetFg(int x) {
  SetColor(x, false);
}

static void SetBg(int x) {
  SetColor(x, true);
}

static void BitsToBytes(uint8_t a[8], uint64_t x) {
  a[0] = -((x >> 0) & 1);
  a[1] = -((x >> 1) & 1);
  a[2] = -((x >> 2) & 1);
  a[3] = -((x >> 3) & 1);
  a[4] = -((x >> 4) & 1);
  a[5] = -((x >> 5) & 1);
  a[6] = -((x >> 6) & 1);
  a[7] = -((x >> 7) & 1);
}

static void Raster(void) {
  long y, x;
  SetBg(ByteToColor(0));
  SetFg(ByteToColor(255));
  for (y = top; y < bottom; ++y) {
    for (x = left; x < right; ++x) {
      if ((0 <= y && y < byn) && (0 <= x && x < bxn)) {
        if (Test(y, x)) {
          AppendStr(""█"");
        } else {
          AppendStr("" "");
        }
      } else {
        AppendStr(VOIDSPACE);
      }
    }
  }
}

static void RasterZoomed(long t, long l, long b, long r,
                         uint8_t p[b - t][r - l]) {
  uint64_t c;
  uint8_t b1, b2;
  long i, y, x, yn, xn;
  for (y = MAX(0, t); y < MIN(b, byn); y += 8) {
    for (x = MAX(0, l); x < MIN(r, bxn); x += 8) {
      c = board[(bxn >> 3) * (y >> 3) + (x >> 3)];
      for (i = 0; i < 8; ++i) {
        BitsToBytes(&p[y - t + i][x - l], c);
        c >>= 8;
      }
    }
  }
  yn = b - t;
  xn = r - l;
  for (i = 0; i < zoom; ++i) {
    Magikarp2xX(b - t, r - l, p, yn, xn);
    Magikarp2xY(b - t, r - l, p, yn, xn);
    yn >>= 1;
    xn >>= 1;
  }
  for (y = top; y < bottom; y += 2ul << zoom) {
    for (x = left; x < right; x += 1ul << zoom) {
      if ((0 <= y && y < byn) && (0 <= x && x < bxn)) {
        b1 = p[((top - t) + ((y + 0) - top)) >> zoom]
              [((left - l) + (x - left)) >> zoom];
        b2 = y + (1ul << zoom) < bottom
                 ? p[((top - t) + ((y + 1) - top)) >> zoom]
                    [((left - l) + (x - left)) >> zoom]
                 : 0;
        if (b1 || b2) {
          SetBg(ByteToColor(b1));
          SetFg(ByteToColor(b2));
          AppendStr(""▄"");
        } else {
          SetBg(ByteToColor(0));
          SetFg(ByteToColor(255));
          AppendStr("" "");
        }
      } else {
        SetBg(ByteToColor(0));
        SetFg(ByteToColor(255));
        AppendStr(VOIDSPACE);
      }
    }
  }
}

static void Draw(void) {
  void *m;
  long t, l, b, r, i, n;
  buffer.i = 0;
  color[0] = -1;
  color[1] = -1;
  AppendStr(""\e[H"");
  if (!zoom) {
    Raster();
  } else {
    t = ROUNDDOWN(top, 16);
    l = ROUNDDOWN(left, 16);
    b = ROUNDUP(bottom, 16);
    r = ROUNDUP(right, 16);
    if ((m = calloc((b - t) * (r - l), 1))) {
      RasterZoomed(t, l, b, r, m);
      free(m);
    }
  }
  AppendStr(""\e[0;7m"");
  GenerateStatusLine();
  AppendStr(statusline);
  n = txn - strwidth(statusline, 0);
  for (i = 0; i < n; ++i) {
    AppendStr("" "");
  }
  AppendStr(""\e[0m"");
  write(out, buffer.p, buffer.i);
}

static bool HasPendingInput(void) {
  struct pollfd fds[1];
  fds[0].fd = 0;
  fds[0].events = POLLIN;
  fds[0].revents = 0;
  poll(fds, ARRAYLEN(fds), 0);
  return fds[0].revents & (POLLIN | POLLERR);
}

static bool ShouldDraw(void) {
  struct timespec now;
  static struct timespec next;
  if (!isdragging) return true;
  now = timespec_real();
  if (timespec_cmp(now, next) > 0 && !HasPendingInput()) {
    next = timespec_add(now, timespec_frommicros(1. / 24 * 1e6));
    return true;
  } else {
    return false;
  }
}

static void Tui(void) {
  GetTtySize();
  Dimension();
  tcgetattr(out, &oldterm);
  HideTtyCursor();
  EnableRaw();
  EnableMouse();
  atexit(OnExit);
  sigaction(SIGINT, &(struct sigaction){.sa_handler = OnSigInt}, 0);
  sigaction(SIGWINCH, &(struct sigaction){.sa_handler = OnSigWinch}, 0);
  do {
    if (action & RESIZED) {
      GetTtySize();
      action &= ~RESIZED;
      Draw();
    } else if (ShouldDraw()) {
      Draw();
    }
    ReadKeyboard();
  } while (!(action & INTERRUPTED));
}

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § game of life » graphical user interface                   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

static const char16_t kClassName[] = u""apelife"";

static void OnMenuAbout(int64_t hwnd) {
  MessageBox(hwnd, u""\
Apelife\r\n\
Cosmopolitan C Library\r\n\
αcτµαlly pδrταblε εxεcµταblε\r\n\
By Justine Tunney <jtunney@gmail.com>\r\n\
In memory of John Horton Conway, 1937-2020\r\n\
https://github.com/jart/cosmopolitan\r\n\
\r\n\
- Hold space to animate\r\n\
- Hold left mouse to draw cells\r\n\
- Hold right mouse to move view\r\n\
- Press t or alt+t to adjust speed"",
             u""Conway's Game of Life"", kNtMbOk | kNtMbIconinformation);
}

static void OnMenuOpen(int64_t hwnd) {
  char buf8[PATH_MAX];
  char16_t buf16[PATH_MAX];
  struct NtOpenFilename ofn;
  bzero(&ofn, sizeof(ofn));
  ofn.lStructSize = sizeof(ofn);
  ofn.hwndOwner = hwnd;
  ofn.lpstrFile = buf16;
  ofn.nMaxFile = ARRAYLEN(buf16);
  ofn.lpstrFilter = u""RLE Format (*.RLE;*.LIF;*.LIFE)\0""
                    u""*.RLE;*.LIF;*.LIFE\0""
                    u""All (*.*)\0""
                    u""*.*\0"";
  ofn.Flags = kNtOfnPathmustexist | kNtOfnFilemustexist | kNtOfnExplorer;
  if (GetOpenFileName(&ofn)) {
    tprecode16to8(buf8, sizeof(buf8), ofn.lpstrFile);
    if (LoadFile(buf8) == -1) {
      MessageBox(hwnd, u""Failed to open run-length encoded game file"",
                 u""Open Failed"", kNtMbOk | kNtMbIconerror);
    }
    RedrawWindow(hwnd, 0, 0, kNtRdwInvalidate);
  }
}

static bool IsMaximized(int64_t hwnd) {
  struct NtWindowPlacement wp;
  wp.length = sizeof(wp);
  return GetWindowPlacement(hwnd, &wp) && wp.showCmd == kNtSwMaximize;
}

static void OnWindowPaint(int64_t hwnd) {
  int y, x;
  int64_t mdc, mbm;
  struct NtRect r, w;
  struct NtPaintStruct ps;
  BeginPaint(hwnd, &ps);
  r.top = 0;
  r.left = 0;
  r.right = ps.rcPaint.right - ps.rcPaint.left;
  r.bottom = ps.rcPaint.bottom - ps.rcPaint.top;
  w.top = MAX(r.top, -(top + ps.rcPaint.top));
  w.left = MAX(r.left, -(left + ps.rcPaint.left));
  w.right = MIN(r.right, bxn - (left + ps.rcPaint.left));
  w.bottom = MIN(r.bottom, byn - (top + ps.rcPaint.top));
  mdc = CreateCompatibleDC(ps.hdc);
  mbm = CreateCompatibleBitmap(ps.hdc, r.right, r.bottom);
  SelectObject(mdc, mbm);
  FillRect(mdc, &r, kNtColorInactiveborder);
  FillRect(mdc, &w, kNtColorAppworkspace);
  for (y = w.top; y < w.bottom; ++y) {
    for (x = w.left; x < w.right; ++x) {
      if (Test(top + ps.rcPaint.top + y, left + ps.rcPaint.left + x)) {
        SetPixel(mdc, x, y, 0);
      }
    }
  }
  BitBlt(ps.hdc, ps.rcPaint.left, ps.rcPaint.top, r.right, r.bottom, mdc, 0, 0,
         kNtSrccopy);
  DeleteObject(mbm);
  DeleteDC(mdc);
  GenerateStatusLine();
  tprecode8to16(statusline16, ARRAYLEN(statusline16), statusline);
  SetWindowText(hwnd, statusline16);
  EndPaint(hwnd, &ps);
}

static void OnWindowCharStep(int64_t hwnd, int64_t wParam, int64_t lParam) {
  int i, repeats;
  repeats = lParam & 0xFFFF;
  for (i = 0; i < repeats; ++i) {
    Generation();
  }
  RedrawWindow(hwnd, 0, 0, kNtRdwInvalidate);
}

static void OnWindowChar(int64_t hwnd, int64_t wParam, int64_t lParam) {
  switch (wParam) {
    case ' ':
    case 's':
    case '\t':
      OnWindowCharStep(hwnd, wParam, lParam);
      break;
    case 't':
      if (lParam & ALT) {
        OnSlowmo();
      } else {
        OnTurbo();
      }
      break;
    case '\r':
      if (IsMaximized(hwnd)) {
        SendMessage(hwnd, kNtWmSyscommand, kNtScRestore, 0);
      } else {
        SendMessage(hwnd, kNtWmSyscommand, kNtScMaximize, 0);
      }
      break;
    default:
      break;
  }
}

static void OnWindowSize(int64_t lParam) {
  txn = (lParam & 0x0000FFFF) >> 000;
  tyn = (lParam & 0xFFFF0000) >> 020;
  Dimension();
}

static void OnWindowLbuttondown(int64_t hwnd, int64_t wParam, int64_t lParam) {
  int y, x;
  y = (lParam & 0xFFFF0000) >> 020;
  x = (lParam & 0x0000FFFF) >> 000;
  SetCapture(hwnd);
  OnMouseLeftDown(y, x);
  RedrawWindow(hwnd, &(struct NtRect){x, y, x + 1, y + 1}, 0, kNtRdwInvalidate);
}

static void OnWindowLbuttonup(int64_t hwnd, int64_t wParam, int64_t lParam) {
  int y, x;
  y = (lParam & 0xFFFF0000) >> 020;
  x = (lParam & 0x0000FFFF) >> 000;
  OnMouseLeftUp(y, x);
  ReleaseCapture();
}

static void OnWindowRbuttondown(int64_t hwnd, int64_t wParam, int64_t lParam) {
  int y, x;
  y = (lParam & 0xFFFF0000) >> 020;
  x = (lParam & 0x0000FFFF) >> 000;
  oldcursor = GetCursor();
  SetCapture(hwnd);
  SetCursor(LoadCursor(0, kNtIdcSizeall));
  OnMouseRightDown(y, x);
  RedrawWindow(hwnd, NULL, 0, kNtRdwInvalidate);
}

static void OnWindowRbuttonup(int64_t hwnd, int64_t wParam, int64_t lParam) {
  int y, x;
  y = (lParam & 0xFFFF0000) >> 020;
  x = (lParam & 0x0000FFFF) >> 000;
  OnMouseRightUp(y, x);
  SetCursor(oldcursor);
  ReleaseCapture();
}

static void OnWindowMousemove(int64_t hwnd, int64_t wParam, int64_t lParam) {
  int y, x;
  y = (lParam & 0xFFFF0000) >> 020;
  x = (lParam & 0x0000FFFF) >> 000;
  if (wParam & kNtMkLbutton) {
    OnMouseLeftDrag(y, x);
    RedrawWindow(hwnd, &(struct NtRect){x, y, x + 1, y + 1}, 0,
                 kNtRdwInvalidate);
  } else if (wParam & kNtMkRbutton) {
    OnMouseRightDrag(y, x);
    RedrawWindow(hwnd, NULL, 0, kNtRdwInvalidate);
  }
}

static int64_t WindowProc(int64_t hwnd, uint32_t uMsg, uint64_t wParam,
                          int64_t lParam) {
  switch (uMsg) {
    case kNtWmDestroy:
      PostQuitMessage(0);
      return 0;
    case kNtWmSize:
      OnWindowSize(lParam);
      return 0;
    case kNtWmPaint:
      OnWindowPaint(hwnd);
      return 0;
    case kNtWmChar:
      OnWindowChar(hwnd, wParam, lParam);
      return 0;
    case kNtWmLbuttondown:
      OnWindowLbuttondown(hwnd, wParam, lParam);
      return 0;
    case kNtWmLbuttonup:
      OnWindowLbuttonup(hwnd, wParam, lParam);
      return 0;
    case kNtWmRbuttondown:
      OnWindowRbuttondown(hwnd, wParam, lParam);
      return 0;
    case kNtWmRbuttonup:
      OnWindowRbuttonup(hwnd, wParam, lParam);
      return 0;
    case kNtWmMousemove:
      OnWindowMousemove(hwnd, wParam, lParam);
      return 0;
    case kNtWmCommand:
    case kNtWmSyscommand:
      switch (wParam & ~0xF) {
        case IDM_ABOUT:
          OnMenuAbout(hwnd);
          return 0;
        case IDM_OPEN:
          OnMenuOpen(hwnd);
          return 0;
      }
      /* fallthrough */
    default:
      return DefWindowProc(hwnd, uMsg, wParam, lParam);
  }
}

static void Gui(void) {
  int64_t hwnd, mh;
  struct NtMsg msg;
  struct NtWndClass wc;
  bzero(&wc, sizeof(wc));
  wc.lpfnWndProc = NT2SYSV(WindowProc);
  wc.hInstance = GetModuleHandle(NULL);
  wc.hCursor = LoadCursor(0, kNtIdcCross);
  wc.lpszClassName = kClassName;
  wc.hbrBackground = kNtColorInactiveborder;
  CHECK(RegisterClass(&wc));
  CHECK((hwnd = CreateWindowEx(0, kClassName, u""Conway's Game of Life"",
                               kNtWsOverlappedwindow, kNtCwUsedefault,
                               kNtCwUsedefault, kNtCwUsedefault,
                               kNtCwUsedefault, 0, 0, wc.hInstance, 0)));
  mh = GetSystemMenu(hwnd, false);
  AppendMenu(mh, kNtMfSeparator, 0, 0);
  AppendMenu(mh, kNtMfEnabled, IDM_OPEN, u""&Open File..."");
  AppendMenu(mh, kNtMfEnabled, IDM_ABOUT, u""&About..."");
  ShowWindow(hwnd, kNtSwNormal);
  while (GetMessage(&msg, 0, 0, 0)) {
    TranslateMessage(&msg);
    DispatchMessage(&msg);
  }
}

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § game of life » program                                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

int main(int argc, char *argv[]) {
  if (!NoDebug()) ShowCrashReports();
  out = 1;
  speed = 1;
  tyn = right = 80;
  txn = bottom = 24;
  byn = 64 * 64;
  bxn = 64 * 64;
  strcpy(name, ""apelife"");
  GetOpts(argc, argv);
  AllocateBoardsWithHardwareAcceleratedMemorySafety();
  if (optind < argc) {
    if (LoadFile(argv[optind]) == -1) {
      fprintf(
          stderr, ""%s:%d:%d: %s\n"", argv[optind], line + 1, column,
          ""error: failed to load game of life run length encoded (rle) file"");
      return 1;
    }
  }
  if (0 && IsWindows()) {
    Gui();
  } else {
    Tui();
  }
  return 0;
}
"
./repos/cosmopolitan/tool/viz/clock_accuracy.c,https://github.com/jart/cosmopolitan.git,"#if 0
/*─────────────────────────────────────────────────────────────────╗
│ To the extent possible under law, Justine Tunney has waived      │
│ all copyright and related or neighboring rights to this file,    │
│ as it is written in the following disclaimers:                   │
│   • http://unlicense.org/                                        │
│   • http://creativecommons.org/publicdomain/zero/1.0/            │
╚─────────────────────────────────────────────────────────────────*/
#endif
#include ""libc/calls/calls.h""
#include ""libc/calls/struct/timespec.h""
#include ""libc/runtime/runtime.h""
#include ""libc/stdio/stdio.h""

/**
 * @fileoverview clock() function demo
 */

int main(int argc, char *argv[]) {
  ShowCrashReports();
  unsigned long i;
  volatile unsigned long x;
  struct timespec now, start, next, interval;
  printf(""hammering the cpu...\n"");
  next = start = timespec_mono();
  interval = timespec_frommillis(500);
  next = timespec_add(next, interval);
  for (;;) {
    for (i = 0;; ++i) {
      x *= 7;
      if (!(i % 256)) {
        now = timespec_mono();
        if (timespec_cmp(now, next) >= 0) {
          break;
        }
      }
    }
    next = timespec_add(next, interval);
    printf(""consumed %10g seconds monotonic time and %10g seconds cpu time\n"",
           timespec_tonanos(timespec_sub(now, start)) / 1000000000.,
           (double)clock() / CLOCKS_PER_SEC);
  }
}
"
./repos/cosmopolitan/tool/viz/img.c,https://github.com/jart/cosmopolitan.git,"#if 0
/*─────────────────────────────────────────────────────────────────╗
│ To the extent possible under law, Justine Tunney has waived      │
│ all copyright and related or neighboring rights to this file,    │
│ as it is written in the following disclaimers:                   │
│   • http://unlicense.org/                                        │
│   • http://creativecommons.org/publicdomain/zero/1.0/            │
╚─────────────────────────────────────────────────────────────────*/
#endif
#include ""libc/dce.h""
#include ""libc/errno.h""
#include ""libc/log/log.h""
#include ""libc/mem/gc.h""
#include ""libc/runtime/runtime.h""
#include ""libc/stdio/stdio.h""
#include ""libc/x/x.h""
#include ""libc/x/xasprintf.h""
#include ""net/http/escape.h""
#include ""net/http/http.h""
#include ""third_party/getopt/getopt.internal.h""
#include ""third_party/stb/stb_image.h""

#define USAGE \
  "" [FLAGS] IMG...\n\
Utility for printing HTML <img> tags.\n\
\n\
FLAGS\n\
\n\
  -h      Help\n\
  -a      Wrap with <a> tag\n\
  -u      Embed data:base64 URI\n""

int scale;
bool linktag;
bool datauri;
bool sizeonly;

void PrintUsage(int rc, FILE *f) {
  fputs(""Usage: "", f);
  fputs(program_invocation_name, f);
  fputs(USAGE, f);
  exit(rc);
}

void PrintImg(const char *path) {
  size_t n;
  int yn, xn, cn, w, h;
  void *img, *pix, *src;
  if (!(img = gc(xslurp(path, &n)))) exit(2);
  if (!(pix = gc(stbi_load_from_memory(img, n, &xn, &yn, &cn, 0)))) exit(3);
  if (linktag) {
    printf(""<a href=\""%s\""\n  >"", path);
  }
  src = (void *)path;
  if (datauri) {
    src = xasprintf(""data:%s;base64,%s"", FindContentType(path, -1),
                    gc(EncodeBase64(img, n, &n)));
  }
  w = (xn + (1 << scale) / 2) >> scale;
  h = (yn + (1 << scale) / 2) >> scale;
  if (sizeonly) {
    printf(""width=\""%d\"" height=\""%d\"""", w, h);
  } else {
    printf(""<img width=\""%d\"" height=\""%d\"" alt=\""[%s]\""\n     src=\""%s\"">"", w,
           h, path, src);
  }
  if (linktag) {
    printf(""</a>"");
  }
  printf(""\n"");
}

int main(int argc, char *argv[]) {
  if (!NoDebug()) ShowCrashReports();
  int i;
  while ((i = getopt(argc, argv, ""?huas01234"")) != -1) {
    switch (i) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
        scale = i - '0';
        break;
      case 's':
        sizeonly = true;
        break;
      case 'a':
        linktag = true;
        break;
      case 'u':
        datauri = true;
        break;
      case '?':
      case 'h':
        PrintUsage(0, stdout);
      default:
        PrintUsage(1, stderr);
    }
  }
  if (optind == argc) {
    PrintUsage(1, stderr);
  }
  for (i = optind; i < argc; ++i) {
    PrintImg(argv[i]);
  }
}
"
./repos/cosmopolitan/tool/viz/generatetortureimage.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/mem/gc.h""
#include ""libc/str/str.h""
#include ""libc/x/x.h""
#include ""libc/x/xasprintf.h""
#include ""third_party/stb/stb_image_write.h""

#define YN (1080 / YM)
#define XN (1920 / XM)
#define YM 2
#define XM 2

void *GenerateTortureImage(unsigned char RGB[YN][YM][XN][XM][3]) {
  long y, x, i, j, b, r, g;
  for (y = 0; y < YN; ++y) {
    for (x = 0; x < XN; ++x) {
      if ((y & 1) ^ (x & 1)) {
        r = 255;
        g = 255;
        b = 0;
      } else {
        r = 0;
        g = 0;
        b = 255;
      }
      for (i = 0; i < YM; ++i) {
        for (j = 0; j < XM; ++j) {
          RGB[y][i][x][j][0] = r;
          RGB[y][i][x][j][1] = g;
          RGB[y][i][x][j][2] = b;
        }
      }
    }
  }
  return RGB;
}

int main(int argc, char *argv[]) {
  stbi_write_png(
      gc(xasprintf(""maxwell_%dx%d_%dx%d.png"", XN * XM, YN * YM, XM, YM)),
      XN * XM, YN * YM, 3,
      GenerateTortureImage(
          gc(xmemalign(32, sizeof(unsigned char) * XN * XM * YN * YM * 3))),
      XN * XM * 3);
  return 0;
}
"
./repos/cosmopolitan/tool/viz/basicidea.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""dsp/scale/scale.h""
#include ""libc/calls/calls.h""
#include ""libc/calls/struct/stat.h""
#include ""libc/calls/struct/winsize.h""
#include ""libc/calls/termios.h""
#include ""libc/log/log.h""
#include ""libc/macros.internal.h""
#include ""libc/mem/mem.h""
#include ""libc/runtime/runtime.h""
#include ""libc/str/locale.h""
#include ""libc/str/str.h""
#include ""libc/sysv/consts/exit.h""
#include ""libc/sysv/consts/fileno.h""
#include ""libc/sysv/consts/map.h""
#include ""libc/sysv/consts/o.h""
#include ""libc/sysv/consts/prot.h""
#include ""libc/sysv/consts/termios.h""
#include ""third_party/stb/stb_image.h""

#define SQR(X)    ((X) * (X))
#define UNCUBE(x) x < 48 ? 0 : x < 115 ? 1 : (x - 35) / 40
#define ORDIE(X)                   \
  do {                             \
    if (!(X)) perror(#X), exit(1); \
  } while (0)

int want24bit_;
int wantfullsize_;

/**
 * Quantizes 24-bit RGB to xterm256 code range [16,256).
 */
int rgb2xterm256(int r, int g, int b) {
  unsigned char cube[] = {0, 0137, 0207, 0257, 0327, 0377};
  int av, ir, ig, ib, il, qr, qg, qb, ql;
  av = r * .299 + g * .587 + b * .114 + .5;
  ql = (il = av > 238 ? 23 : (av - 3) / 10) * 10 + 8;
  qr = cube[(ir = UNCUBE(r))];
  qg = cube[(ig = UNCUBE(g))];
  qb = cube[(ib = UNCUBE(b))];
  if (SQR(qr - r) + SQR(qg - g) + SQR(qb - b) <=
      SQR(ql - r) + SQR(ql - g) + SQR(ql - b)) {
    return ir * 36 + ig * 6 + ib + 020;
  } else {
    return il + 0350;
  }
}

/**
 * Prints raw packed 8-bit RGB data from memory.
 */
void PrintImage(int yn, int xn, unsigned char rgb[yn][xn][3]) {
  unsigned y, x;
  for (y = 0; y < yn; y += 2) {
    for (x = 0; x < xn; ++x) {
      if (want24bit_) {
        printf(""\033[48;2;%hhu;%hhu;%hhu;38;2;%hhu;%hhu;%hhum▄"",
               rgb[y + 0][x][0], rgb[y + 0][x][1], rgb[y + 0][x][2],
               rgb[MIN(y + 1, yn - 1)][x][0], rgb[MIN(y + 1, yn - 1)][x][1],
               rgb[MIN(y + 1, yn - 1)][x][2]);
      } else {
        printf(
            ""\033[48;5;%hhu;38;5;%hhum▄"",
            rgb2xterm256(rgb[y + 0][x][0], rgb[y + 0][x][1], rgb[y + 0][x][2]),
            rgb2xterm256(rgb[MIN(y + 1, yn - 1)][x][0],
                         rgb[MIN(y + 1, yn - 1)][x][1],
                         rgb[MIN(y + 1, yn - 1)][x][2]));
      }
    }
    printf(""\e[0m\n"");
  }
}

/**
 * Determines dimensions of teletypewriter.
 */
void GetTermSize(int *out_rows, int *out_cols) {
  struct winsize ws;
  ws.ws_row = 20;
  ws.ws_col = 80;
  tcgetwinsize(STDOUT_FILENO, &ws);
  tcgetwinsize(STDIN_FILENO, &ws);
  *out_rows = ws.ws_row;
  *out_cols = ws.ws_col;
}

void ReadAll(int fd, char *p, size_t n) {
  ssize_t rc;
  size_t got;
  do {
    ORDIE((rc = read(fd, p, n)) != -1);
    got = rc;
    if (!got && n) {
      fprintf(stderr, ""error: expected eof\n"");
      exit(EXIT_FAILURE);
    }
    p += got;
    n -= got;
  } while (n);
}

static void Deblinterlace(long zn, long yn, long xn,
                          unsigned char dst[zn][yn][xn],
                          const unsigned char src[yn][xn][zn]) {
  long y, x, z;
  for (y = 0; y < yn; ++y) {
    for (x = 0; x < xn; ++x) {
      for (z = 0; z < zn; ++z) {
        dst[z][y][x] = src[y][x][z];
      }
    }
  }
}

static void Reblinterlace(long zn, long yn, long xn,
                          unsigned char dst[yn][xn][zn],
                          const unsigned char src[zn][yn][xn]) {
  long y, x, z;
  for (y = 0; y < yn; ++y) {
    for (x = 0; x < xn; ++x) {
      for (z = 0; z < zn; ++z) {
        dst[y][x][z] = src[z][y][x];
      }
    }
  }
}

int main(int argc, char *argv[]) {
  struct stat st;
  void *map, *data, *data2;
  int i, fd, tyn, txn, yn, xn, cn;
  setlocale(LC_ALL, ""C.UTF-8"");
  for (i = 1; i < argc; ++i) {
    if (strcmp(argv[i], ""-t"") == 0) {
      want24bit_ = 1;
    } else if (strcmp(argv[i], ""-f"") == 0) {
      wantfullsize_ = 1;
    } else {
      fd = open(argv[i], O_RDONLY);
      if (fd == -1) {
        perror(argv[i]);
        exit(1);
      }
      fstat(fd, &st);
      map = mmap(0, st.st_size, PROT_READ, MAP_SHARED, fd, 0);
      data = stbi_load_from_memory(map, st.st_size, &xn, &yn, &cn, 3);
      munmap(map, st.st_size);
      close(fd);
      if (!wantfullsize_) {
        GetTermSize(&tyn, &txn);
        --tyn;
        tyn *= 2;
        data2 = memalign(32, 3 * yn * xn);
        Deblinterlace(3, yn, xn, data2, data);
        free(data);
        data = memalign(32, 3 * tyn * txn);
        EzGyarados(3, tyn, txn, data, 3, yn, xn, data2, 0, 3, tyn, txn, yn, xn,
                   0, 0, 0, 0);
        free(data2);
        data2 = memalign(32, 3 * yn * xn);
        Reblinterlace(3, tyn, txn, data2, data);
        free(data);
        data = data2;
        yn = tyn;
        xn = txn;
      }
      PrintImage(yn, xn, data);
      free(data);
    }
  }
  return 0;
}
"
./repos/cosmopolitan/tool/viz/printimage.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""dsp/core/half.h""
#include ""dsp/core/twixt8.h""
#include ""dsp/scale/scale.h""
#include ""dsp/tty/quant.h""
#include ""dsp/tty/tty.h""
#include ""libc/calls/calls.h""
#include ""libc/calls/struct/stat.h""
#include ""libc/calls/struct/winsize.h""
#include ""libc/calls/termios.h""
#include ""libc/dce.h""
#include ""libc/errno.h""
#include ""libc/fmt/conv.h""
#include ""libc/log/check.h""
#include ""libc/log/log.h""
#include ""libc/mem/gc.h""
#include ""libc/mem/mem.h""
#include ""libc/runtime/runtime.h""
#include ""libc/stdio/stdio.h""
#include ""libc/sysv/consts/ex.h""
#include ""libc/sysv/consts/exit.h""
#include ""libc/sysv/consts/fileno.h""
#include ""libc/sysv/consts/madv.h""
#include ""libc/sysv/consts/map.h""
#include ""libc/sysv/consts/o.h""
#include ""libc/sysv/consts/prot.h""
#include ""libc/sysv/consts/termios.h""
#include ""third_party/getopt/getopt.internal.h""
#include ""third_party/stb/stb_image.h""
#include ""tool/viz/lib/graphic.h""

__static_yoink(""__zipos_get"");

static struct Flags {
  const char *out;
  bool subpixel;
  bool unsharp;
  bool dither;
  bool ruler;
  bool magikarp;
  long half;
  bool full;
  bool ignoreaspect;
  long width;
  long height;
  enum TtyBlocksSelection blocks;
  enum TtyQuantizationAlgorithm quant;
} g_flags;

struct winsize g_winsize;

static wontreturn void PrintUsage(int rc, int fd) {
  tinyprint(fd, ""Usage: "", program_invocation_name, ""\
 [FLAGS] [PATH]\n\
\n\
FLAGS\n\
\n\
  -o PATH    output path\n\
  -w INT     manual width\n\
  -h INT     manual height\n\
  -f         display full size\n\
  -i         ignore aspect ratio\n\
  -4         unicode blocks\n\
  -a         ansi color mode\n\
  -t         true color mode\n\
  -2         use half blocks\n\
  -3         ibm cp437 blocks\n\
  -s         unsharp sharpening\n\
  -x         xterm256 color mode\n\
  -m         use magikarp scaling\n\
  -d         hilbert curve dithering\n\
  -r         display pixel ruler on sides\n\
  -p         convert to subpixel layout\n\
  -v         increases verbosity\n\
  -?         shows this information\n\
\n\
EXAMPLES\n\
\n\
  printimage -sxd lemurs.jpg  # 256-color dither unsharp\n\
\n"",
            NULL);
  exit(rc);
}

static int ParseNumberOption(const char *arg) {
  long x;
  x = strtol(arg, NULL, 0);
  if (!(1 <= x && x <= INT_MAX)) {
    fprintf(stderr, ""invalid flexidecimal: %s\n\n"", arg);
    exit(EXIT_FAILURE);
  }
  return x;
}

static void GetOpts(int *argc, char *argv[]) {
  int opt;
  g_flags.quant = kTtyQuantTrue;
  g_flags.blocks = IsWindows() ? kTtyBlocksCp437 : kTtyBlocksUnicode;
  if (*argc == 2 &&
      (strcmp(argv[1], ""--help"") == 0 || strcmp(argv[1], ""-help"") == 0)) {
    PrintUsage(EXIT_SUCCESS, STDOUT_FILENO);
  }
  while ((opt = getopt(*argc, argv, ""?vpmfirtxads234o:w:h:"")) != -1) {
    switch (opt) {
      case 'o':
        g_flags.out = optarg;
        break;
      case 'd':
        g_flags.dither = true;
        break;
      case 's':
        g_flags.unsharp = true;
        break;
      case 'w':
        g_flags.width = ParseNumberOption(optarg);
        break;
      case 'h':
        g_flags.height = ParseNumberOption(optarg);
        break;
      case 'f':
        g_flags.full = true;
        break;
      case 'i':
        g_flags.ignoreaspect = true;
        break;
      case '2':
        g_flags.half = true;
        break;
      case 'r':
        g_flags.ruler = true;
        break;
      case 'm':
        g_flags.magikarp = true;
        break;
      case 'p':
        g_flags.subpixel = true;
        break;
      case 'a':
        g_flags.quant = kTtyQuantAnsi;
        break;
      case 'x':
        g_flags.quant = kTtyQuantXterm256;
        break;
      case 't':
        g_flags.quant = kTtyQuantTrue;
        break;
      case '3':
        g_flags.blocks = kTtyBlocksCp437;
        break;
      case '4':
        g_flags.blocks = kTtyBlocksUnicode;
        break;
      case 'v':
        ++__log_level;
        break;
      case '?':
      default:
        if (opt == optopt) {
          PrintUsage(EXIT_SUCCESS, STDOUT_FILENO);
        } else {
          PrintUsage(EX_USAGE, STDERR_FILENO);
        }
    }
  }
  g_winsize.ws_col = 80;
  g_winsize.ws_row = 24;
  if (!g_flags.full && (!g_flags.width || !g_flags.height)) {
    (void)(tcgetwinsize(STDIN_FILENO, &g_winsize) != -1 ||
           tcgetwinsize(STDOUT_FILENO, &g_winsize));
  }
  ttyquantsetup(g_flags.quant, kTtyQuantRgb, g_flags.blocks);
}

static unsigned char ChessBoard(unsigned y, unsigned x, unsigned char a,
                                unsigned char b) {
  return !((y ^ x) & (1u << 2)) ? a : b;
}

static unsigned char AlphaBackground(unsigned y, unsigned x) {
  return ChessBoard(y, x, 255, 200);
}

static unsigned char OutOfBoundsBackground(unsigned y, unsigned x) {
  return ChessBoard(y, x, 40, 80);
}

static void PrintRulerRight(long yn, long xn, long y, long x,
                            bool *inout_didhalfy) {
  if (y == 0) {
    printf(""‾0"");
  } else if (yn / 2 <= y && y <= yn / 2 + 1 && !*inout_didhalfy) {
    printf(""‾%s%s"", ""yn/2"", y % 2 ? ""+1"" : """");
    *inout_didhalfy = true;
  } else if (y + 1 == yn / 2 && !*inout_didhalfy) {
    printf(""⎯yn/2"");
    *inout_didhalfy = true;
  } else if (y + 1 == yn) {
    printf(""⎯yn"");
  } else if (y + 2 == yn) {
    printf(""_yn"");
  } else if (!(y % 10)) {
    printf(""‾%,u"", y);
  }
}

static void PrintImageImpl(long syn, long sxn, unsigned char RGB[3][syn][sxn],
                           long y0, long yn, long x0, long xn, long dy,
                           long dx) {
  long y, x;
  bool didhalfy;
  unsigned char a[3], b[3];
  didhalfy = false;
  for (y = y0; y < yn; y += dy) {
    if (y) printf(""\e[0m\n"");
    for (x = x0; x < xn; x += dx) {
      a[0] = RGB[0][y][x];
      a[1] = RGB[1][y][x];
      a[2] = RGB[2][y][x];
      if (y + dy < yn && x + dx < xn) {
        b[0] = RGB[0][y + dy][x + dx];
        b[1] = RGB[1][y + dy][x + dx];
        b[2] = RGB[2][y + dy][x + dx];
      } else {
        b[2] = b[1] = b[0] = OutOfBoundsBackground(y + dy, x + dx);
      }
      printf(""\e[48;2;%d;%d;%d;38;2;%d;%d;%dm%lc"", a[0], a[1], a[2], b[0], b[1],
             b[2], dy > 1 ? u'▄' : u'▐');
    }
    printf(""\e[0m"");
    if (g_flags.ruler) {
      PrintRulerRight(yn, xn, y, x, &didhalfy);
    }
  }
  printf(""\n"");
}

static void PrintImage(long syn, long sxn, unsigned char RGB[3][syn][sxn],
                       long y0, long yn, long x0, long xn) {
  PrintImageImpl(syn, sxn, RGB, y0, yn, x0, xn, 2, 1);
}

static void PrintImageLR(long syn, long sxn, unsigned char RGB[3][syn][sxn],
                         long y0, long yn, long x0, long xn) {
  PrintImageImpl(syn, sxn, RGB, y0, yn, x0, xn, 1, 2);
}

static void *Deblinterlace(long dyn, long dxn, unsigned char dst[3][dyn][dxn],
                           long syn, long sxn, long scn,
                           const unsigned char src[syn][sxn][scn], long y0,
                           long yn, long x0, long xn) {
  long y, x;
  unsigned char c;
  for (y = y0; y < yn; ++y) {
    for (x = x0; x < xn; ++x) {
      switch (scn) {
        case 1:
          c = src[y][x][0];
          dst[0][y][x] = c;
          dst[1][y][x] = c;
          dst[2][y][x] = c;
          break;
        case 2:
          c = twixt8(AlphaBackground(y, x), src[y][x][0], src[y][x][1]);
          dst[0][y][x] = c;
          dst[1][y][x] = c;
          dst[2][y][x] = c;
          break;
        case 3:
          dst[0][y][x] = src[y][x][0];
          dst[1][y][x] = src[y][x][1];
          dst[2][y][x] = src[y][x][2];
          break;
        case 4:
          c = AlphaBackground(y, x);
          dst[0][y][x] = twixt8(c, src[y][x][0], src[y][x][3]);
          dst[1][y][x] = twixt8(c, src[y][x][1], src[y][x][3]);
          dst[2][y][x] = twixt8(c, src[y][x][2], src[y][x][3]);
          break;
      }
    }
  }
  return dst;
}

static void *DeblinterlaceSubpixelBgr(long dyn, long dxn,
                                      unsigned char dst[3][dyn][dxn][3],
                                      long syn, long sxn,
                                      const unsigned char src[syn][sxn][4],
                                      long y0, long yn, long x0, long xn) {
  long y, x;
  for (y = y0; y < yn; ++y) {
    for (x = x0; x < xn; ++x) {
      dst[0][y][x][0] = 0;
      dst[1][y][x][0] = 0;
      dst[2][y][x][0] = src[y][x][2];
      dst[0][y][x][1] = 0;
      dst[1][y][x][1] = src[y][x][1];
      dst[2][y][x][1] = 0;
      dst[0][y][x][2] = src[y][x][0];
      dst[1][y][x][2] = 0;
      dst[2][y][x][2] = 0;
    }
  }
  return dst;
}

static void PrintImageSerious(long yn, long xn, unsigned char RGB[3][yn][xn],
                              long tyn, long txn, struct TtyRgb TTY[tyn][txn],
                              char *vt) {
  char *p;
  long y, x;
  struct TtyRgb bg = {0x12, 0x34, 0x56, 0};
  struct TtyRgb fg = {0x12, 0x34, 0x56, 0};
  if (g_flags.unsharp) unsharp(3, yn, xn, RGB, yn, xn);
  if (g_flags.dither) dither(yn, xn, RGB, yn, xn);
  if (yn && xn) {
    for (y = 0; y < tyn; ++y) {
      for (x = 0; x < txn; ++x) {
        TTY[y][x] = rgb2tty(RGB[0][MIN(y, yn - 1)][MIN(x, xn - 1)],
                            RGB[1][MIN(y, yn - 1)][MIN(x, xn - 1)],
                            RGB[2][MIN(y, yn - 1)][MIN(x, xn - 1)]);
      }
    }
  }
  p = ttyraster(vt, (void *)TTY, tyn, txn, bg, fg);
  p = stpcpy(p, ""\e[0m\r\n"");
  ttywrite(STDOUT_FILENO, vt, p - vt);
}

static void ProcessImage(long yn, long xn, unsigned char RGB[3][yn][xn]) {
  long tyn, txn;
  if (g_flags.half) {
    if (g_flags.subpixel) {
      PrintImageLR(yn, xn * 3, RGB, 0, yn, 0, xn * 3);
    } else {
      PrintImage(yn, xn, RGB, 0, yn, 0, xn);
    }
  } else {
    tyn = ROUNDUP(yn, 2);
    txn = ROUNDUP(xn, 2);
    PrintImageSerious(
        yn, xn, RGB, tyn, txn, gc(calloc(sizeof(struct TtyRgb), tyn * txn)),
        gc(calloc(1, ((yn * xn * strlen(""\e[48;2;255;48;2;255m▄"")) +
                      (yn * strlen(""\e[0m\r\n"")) + 128))));
  }
}

void WithImageFile(const char *path,
                   void fn(long yn, long xn, unsigned char RGB[3][yn][xn])) {
  struct stat st;
  void *map, *data;
  int fd, yn, xn, cn, dyn, dxn, syn, sxn, wyn, wxn;
  CHECK_NE(-1, (fd = open(path, O_RDONLY)), ""%s"", path);
  CHECK_NE(-1, fstat(fd, &st));
  CHECK_GT(st.st_size, 0);
  CHECK_LE(st.st_size, INT_MAX);
  fadvise(fd, 0, st.st_size, MADV_WILLNEED | MADV_SEQUENTIAL);
  CHECK_NE(MAP_FAILED,
           (map = mmap(NULL, st.st_size, PROT_READ, MAP_SHARED, fd, 0)));
  CHECK_NOTNULL(
      (data = gc(stbi_load_from_memory(map, st.st_size, &xn, &yn, &cn, 0))),
      ""%s"", path);
  CHECK_NE(-1, munmap(map, st.st_size));
  CHECK_NE(-1, close(fd));
  if (g_flags.subpixel) {
    data = DeblinterlaceSubpixelBgr(yn, xn, gc(memalign(32, yn * xn * 4 * 3)),
                                    yn, xn, data, 0, yn, 0, xn);
    xn *= 3;
  } else {
    data = Deblinterlace(yn, xn, gc(memalign(32, yn * xn * 4)), yn, xn, cn,
                         data, 0, yn, 0, xn);
    cn = 3;
  }
  if (!g_flags.full) {
    syn = yn;
    sxn = xn;
    dyn = g_flags.height;
    dxn = g_flags.width;
    wyn = g_winsize.ws_row * 2;
    wxn = g_winsize.ws_col;
    if (g_flags.ignoreaspect) {
      if (!dyn) dyn = wyn;
      if (!dxn) dxn = wxn * (1 + !g_flags.half);
    }
    if (!dyn && !dxn) {
      if (sxn * wyn > syn * wxn) {
        dxn = wxn * (1 + !g_flags.half);
      } else {
        dyn = wyn;
      }
    }
    if (dyn && !dxn) {
      dxn = dyn * sxn * (1 + !g_flags.half) / syn;
    } else if (dxn && !dyn) {
      dyn = dxn * syn / (sxn * (1 + !g_flags.half));
    }
    if (g_flags.magikarp) {
      while (HALF(syn) > dyn || HALF(sxn) > dxn) {
        if (HALF(sxn) > dxn) {
          Magikarp2xX(yn, xn, data, syn, sxn);
          Magikarp2xX(yn, xn, (char *)data + yn * xn, syn, sxn);
          Magikarp2xX(yn, xn, (char *)data + yn * xn * 2, syn, sxn);
          sxn = HALF(sxn);
        }
        if (HALF(syn) > dyn) {
          Magikarp2xY(yn, xn, data, syn, sxn);
          Magikarp2xY(yn, xn, (char *)data + yn * xn, syn, sxn);
          Magikarp2xY(yn, xn, (char *)data + yn * xn * 2, syn, sxn);
          syn = HALF(syn);
        }
      }
    }
    data = EzGyarados(3, dyn, dxn, gc(memalign(32, dyn * dxn * 3)), cn, yn, xn,
                      data, 0, cn, dyn, dxn, syn, sxn, 0, 0, 0, 0);
    yn = dyn;
    xn = dxn;
  }
  fn(yn, xn, data);
}

int main(int argc, char *argv[]) {
  int i;
  ShowCrashReports();
  GetOpts(&argc, argv);
  if (optind == argc) PrintUsage(EXIT_SUCCESS, STDOUT_FILENO);
  stbi_set_unpremultiply_on_load(true);
  for (i = optind; i < argc; ++i) {
    WithImageFile(argv[i], ProcessImage);
  }
  return 0;
}
"
./repos/cosmopolitan/tool/viz/fliphex.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2021 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/fmt/conv.h""
#include ""libc/stdio/stdio.h""

int main(int argc, char *argv[]) {
  int i, x;
  for (i = 1; i < argc; ++i) {
    x = strtoul(argv[i], 0, 0);
    printf(""%#x\n"", -x);
  }
  return 0;
}
"
./repos/cosmopolitan/tool/viz/cpuid.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/intrin/kprintf.h""
#include ""libc/log/color.internal.h""
#include ""libc/mem/gc.h""
#include ""libc/nexgen32e/cpuid4.internal.h""
#include ""libc/nexgen32e/nexgen32e.h""
#include ""libc/nexgen32e/rdtscp.h""
#include ""libc/nexgen32e/x86feature.h""
#include ""libc/nexgen32e/x86info.h""
#include ""libc/runtime/runtime.h""
#include ""libc/stdio/stdio.h""
#include ""libc/time/time.h""
#include ""libc/x/xasprintf.h""
#include ""tool/decode/lib/idname.h""
#include ""tool/decode/lib/x86idnames.h""
#ifdef __x86_64__

#define CANIUSE(FEATURE) caniuse(#FEATURE, X86_HAVE(FEATURE))
#define SHOW(CONSTANT)   show(#CONSTANT, CONSTANT)

static void caniuse(const char *feature, bool present) {
  printf(""%-20s%s%s%s\n"", feature, present ? GREEN : RED,
         present ? ""present"" : ""unavailable"", RESET);
}

static void show(const char *constant, long value) {
  printf(""%-20s%#lx\n"", constant, value);
}

static void decimal(const char *a, long b, const char *c) {
  printf(""%-20s%ld%s\n"", a, b, c);
}

static void showvendor(void) {
  printf(""%.*s%.*s%.*s"", 4, &KCPUIDS(0H, EBX), 4, &KCPUIDS(0H, EDX), 4,
         &KCPUIDS(0H, ECX));
}

static void showmodel(void) {
  if (getx86processormodel(kX86ProcessorModelKey)) {
    printf("" %s"",
           findnamebyid(kX86MarchNames,
                        getx86processormodel(kX86ProcessorModelKey)->march));
  }
}

static void showstrata(void) {
  if (getx86processormodel(kX86ProcessorModelKey)) {
    printf("" (%s %s)"",
           findnamebyid(kX86GradeNames,
                        getx86processormodel(kX86ProcessorModelKey)->grade),
           ""Grade"");
  }
}

void showcachesizes(void) {
  unsigned i;
  CPUID4_ITERATE(i, {
    printf(""%-19s%s%s %2u-way %,9u byte cache w/%s %,6u sets of %u byte lines ""
           ""shared across %u threads\n"",
           gc(xasprintf(""Level %u%s"", CPUID4_CACHE_LEVEL,
                        CPUID4_CACHE_TYPE == 1   ? "" data""
                        : CPUID4_CACHE_TYPE == 2 ? "" code""
                                                 : """")),
           CPUID4_IS_FULLY_ASSOCIATIVE ? "" fully-associative"" : """",
           CPUID4_COMPLEX_INDEXING ? "" complexly-indexed"" : """",
           CPUID4_WAYS_OF_ASSOCIATIVITY, CPUID4_CACHE_SIZE_IN_BYTES,
           CPUID4_PHYSICAL_LINE_PARTITIONS > 1
               ? gc(xasprintf("" %u physically partitioned""))
               : """",
           CPUID4_NUMBER_OF_SETS, CPUID4_SYSTEM_COHERENCY_LINE_SIZE,
           CPUID4_MAX_THREADS_SHARING_CACHE);
  });
}

int main(int argc, char *argv[]) {
  int x;
  long tsc_aux;
  ShowCrashReports();

  showvendor();
  showmodel();
  showstrata();
  printf(""\n"");

  if (KCPUIDS(16H, EAX)) {
    printf(""\n"");
    if ((x = KCPUIDS(16H, EAX) & 0x7fff)) decimal(""frequency"", x, ""mhz"");
    if ((x = KCPUIDS(16H, EBX) & 0x7fff)) decimal(""turbo"", x, ""mhz"");
    if ((x = KCPUIDS(16H, ECX) & 0x7fff)) decimal(""bus"", x, ""mhz"");
  }

  if (X86_HAVE(HYPERVISOR)) {
    int ax, cx;
    char s[4 * 3 + 1];
    asm(""push\t%%rbx\r\n""
        ""cpuid\r\n""
        ""mov\t%%ebx,0+%2\r\n""
        ""mov\t%%ecx,4+%2\r\n""
        ""mov\t%%edx,8+%2\r\n""
        ""movb\t$0,12+%2\r\n""
        ""pop\t%%rbx""
        : ""=a""(ax), ""=c""(cx), ""=o""(s)
        : ""0""(0x40000000), ""1""(0)
        : ""rdx"");
    kprintf(""Running inside %s (eax=%#x)\n"", s, ax);
  }

  printf(""\n"");
  SHOW(kX86CpuFamily);
  SHOW(kX86CpuModel);
  printf(""\n"");
  SHOW(kX86CpuStepping);
  SHOW(kX86CpuType);
  SHOW(kX86CpuModelid);
  SHOW(kX86CpuExtmodelid);
  SHOW(kX86CpuFamilyid);
  SHOW(kX86CpuExtfamilyid);

  printf(""\n"");
  tsc_aux = rdpid();
  show(""TSC_AUX"", tsc_aux);
  show("" → core"", TSC_AUX_CORE(tsc_aux));
  show("" → node"", TSC_AUX_NODE(tsc_aux));

  printf(""\n"");
  printf(""Caches\n"");
  printf(""──────\n"");
  showcachesizes();

  printf(""\n"");
  printf(""Features\n"");
  printf(""────────\n"");
  CANIUSE(ACC);
  CANIUSE(ACPI);
  CANIUSE(ADX);
  CANIUSE(AES);
  CANIUSE(APIC);
  CANIUSE(ARCH_CAPABILITIES);
  CANIUSE(AVX);

  printf(""%-20s%s%s%s%s\n"", ""AVX2"", X86_HAVE(AVX2) ? GREEN : RED,
         X86_HAVE(AVX2) ? ""present"" : ""unavailable"", RESET,
         (!X86_HAVE(AVX2) && ({
           unsigned eax, ebx, ecx, edx;
           asm(""push\t%%rbx\n\t""
               ""cpuid\n\t""
               ""mov\t%%ebx,%1\n\t""
               ""pop\t%%rbx""
               : ""=a""(eax), ""=rm""(ebx), ""=c""(ecx), ""=d""(edx)
               : ""0""(7), ""2""(0));
           (void)eax;
           (void)ecx;
           (void)edx;
           !!(ebx & (1u << 5));
         }))
             ? "" (disabled by operating system)""
             : """");

  CANIUSE(AVXVNNI);
  CANIUSE(AVXVNNIINT8);
  CANIUSE(AVXVNNIINT16);
  CANIUSE(AVX512BW);
  CANIUSE(AVX512CD);
  CANIUSE(AVX512DQ);
  CANIUSE(AVX512ER);
  CANIUSE(AVX512F);
  CANIUSE(AVX512IFMA);
  CANIUSE(AVX512PF);
  CANIUSE(AVX512VBMI);
  CANIUSE(AVX512VL);
  CANIUSE(AVX512_4FMAPS);
  CANIUSE(AVX512_4VNNIW);
  CANIUSE(AVX512_FP16);
  CANIUSE(AVX512_BF16);
  CANIUSE(AVX512_BITALG);
  CANIUSE(AVX512_VBMI2);
  CANIUSE(AVX512_VNNI);
  CANIUSE(AVX512_VP2INTERSECT);
  CANIUSE(AVX512_VPOPCNTDQ);
  CANIUSE(BMI);
  CANIUSE(BMI2);
  CANIUSE(CID);
  CANIUSE(CLDEMOTE);
  CANIUSE(CLFLUSH);
  CANIUSE(CLFLUSHOPT);
  CANIUSE(CLWB);
  CANIUSE(CMOV);
  CANIUSE(CQM);
  CANIUSE(CX16);
  CANIUSE(CX8);
  CANIUSE(DCA);
  CANIUSE(DE);
  CANIUSE(DS);
  CANIUSE(DSCPL);
  CANIUSE(DTES64);
  CANIUSE(ERMS);
  CANIUSE(EST);
  CANIUSE(F16C);
  CANIUSE(FDP_EXCPTN_ONLY);
  CANIUSE(FLUSH_L1D);
  CANIUSE(FMA);
  CANIUSE(FPU);
  CANIUSE(FSGSBASE);
  CANIUSE(FXSR);
  CANIUSE(GBPAGES);
  CANIUSE(GFNI);
  CANIUSE(HLE);
  CANIUSE(HT);
  CANIUSE(HYPERVISOR);
  CANIUSE(IA64);
  CANIUSE(INTEL_PT);
  CANIUSE(INTEL_STIBP);
  CANIUSE(INVPCID);
  CANIUSE(LA57);
  CANIUSE(LM);
  CANIUSE(MCA);
  CANIUSE(MCE);
  CANIUSE(MD_CLEAR);
  CANIUSE(MMX);
  CANIUSE(MOVBE);
  CANIUSE(MOVDIR64B);
  CANIUSE(MOVDIRI);
  CANIUSE(MP);
  CANIUSE(MPX);
  CANIUSE(MSR);
  CANIUSE(MTRR);
  CANIUSE(MWAIT);
  CANIUSE(NX);
  CANIUSE(OSPKE);
  CANIUSE(OSXSAVE);
  CANIUSE(PAE);
  CANIUSE(PAT);
  CANIUSE(PBE);
  CANIUSE(PCID);
  CANIUSE(PCLMUL);
  CANIUSE(PCONFIG);
  CANIUSE(PDCM);
  CANIUSE(PGE);
  CANIUSE(PKU);
  CANIUSE(PN);
  CANIUSE(POPCNT);
  CANIUSE(PSE);
  CANIUSE(PSE36);
  CANIUSE(RDPID);
  CANIUSE(RDRND);
  CANIUSE(RDSEED);
  CANIUSE(RDTSCP);
  CANIUSE(RDT_A);
  CANIUSE(RTM);
  CANIUSE(SDBG);
  CANIUSE(SELFSNOOP);
  CANIUSE(SEP);
  CANIUSE(SHA);
  CANIUSE(SMAP);
  CANIUSE(SMEP);
  CANIUSE(SMX);
  CANIUSE(SPEC_CTRL);
  CANIUSE(SPEC_CTRL_SSBD);
  CANIUSE(SSE);
  CANIUSE(SSE2);
  CANIUSE(SSE3);
  CANIUSE(SSE4_1);
  CANIUSE(SSE4_2);
  CANIUSE(SSSE3);
  CANIUSE(SYSCALL);
  CANIUSE(TM2);
  CANIUSE(TME);
  CANIUSE(TSC);
  CANIUSE(TSC_ADJUST);
  CANIUSE(TSC_DEADLINE_TIMER);
  CANIUSE(TSX_FORCE_ABORT);
  CANIUSE(UMIP);
  CANIUSE(VAES);
  CANIUSE(VME);
  CANIUSE(VMX);
  CANIUSE(VPCLMULQDQ);
  CANIUSE(WAITPKG);
  CANIUSE(X2APIC);
  CANIUSE(XSAVE);
  CANIUSE(XTPR);
  CANIUSE(ZERO_FCS_FDS);

  printf(""\n"");
  printf(""AMD Stuff\n"");
  printf(""─────────\n"");
  CANIUSE(3DNOW);
  CANIUSE(3DNOWEXT);
  CANIUSE(3DNOWPREFETCH);
  CANIUSE(ABM);
  CANIUSE(BPEXT);
  CANIUSE(CMP_LEGACY);
  CANIUSE(CR8_LEGACY);
  CANIUSE(EXTAPIC);
  CANIUSE(FMA4);
  CANIUSE(FXSR_OPT);
  CANIUSE(IBS);
  CANIUSE(LAHF_LM);
  CANIUSE(LWP);
  CANIUSE(MISALIGNSSE);
  CANIUSE(MMXEXT);
  CANIUSE(MWAITX);
  CANIUSE(NODEID_MSR);
  CANIUSE(OSVW);
  CANIUSE(OVERFLOW_RECOV);
  CANIUSE(PERFCTR_CORE);
  CANIUSE(PERFCTR_LLC);
  CANIUSE(PERFCTR_NB);
  CANIUSE(PTSC);
  CANIUSE(SKINIT);
  CANIUSE(SMCA);
  CANIUSE(SSE4A);
  CANIUSE(SUCCOR);
  CANIUSE(SVM);
  CANIUSE(TBM);
  CANIUSE(TCE);
  CANIUSE(TOPOEXT);
  CANIUSE(WDT);
  CANIUSE(XOP);

  return 0;
}

#else

int main(int argc, char *argv[]) {
}

#endif /* __x86_64__ */
"
./repos/cosmopolitan/tool/viz/maxmind.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2021 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/calls/calls.h""
#include ""libc/serialize.h""
#include ""libc/log/check.h""
#include ""libc/log/log.h""
#include ""libc/mem/gc.h""
#include ""libc/mem/mem.h""
#include ""libc/stdio/stdio.h""
#include ""net/http/http.h""
#include ""net/http/ip.h""
#include ""third_party/maxmind/maxminddb.h""

#define PATH(...) \
  (const char *const[]) { __VA_ARGS__, 0 }

MMDB_s *ipdb, *asdb;

int PrintIpInfo(const char *ipstr) {
  int error;
  bool uhoh;
  int64_t ip;
  uint16_t cc;
  MMDB_entry_data_s e, f;
  MMDB_lookup_result_s r;
  if ((ip = ParseIp(ipstr, -1)) == -1) {
    fprintf(stderr, ""BAD IP: %s\n"", ipstr);
    return -1;
  }
  r = MMDB_lookup(ipdb, ip, &error);
  CHECK_EQ(MMDB_SUCCESS, error);
  if (!r.found_entry) {
    fprintf(stderr, ""NOT FOUND: %s\n"", ipstr);
    return -1;
  }
  printf(""%hhu.%hhu.%hhu.%hhu\n"", ip >> 24, ip >> 16, ip >> 8, ip);
  if (!MMDB_aget_value(&r.entry, &e, PATH(""location"", ""metro_code""))) {
    printf(""%s: %s\n"", ""metro"", GetMetroName(e.uint16));
  }
  if (!MMDB_aget_value(&r.entry, &e, PATH(""postal"", ""code""))) {
    printf(""%s: %.*s\n"", ""postal"", e.data_size, e.utf8_string);
  }
  if (!MMDB_aget_value(&r.entry, &e, PATH(""city"", ""names"", ""en""))) {
    printf(""%s: %.*s\n"", ""city"", e.data_size, e.utf8_string);
  }
  if (!MMDB_aget_value(&r.entry, &e, PATH(""subdivisions"", ""0"", ""iso_code"")) &&
      !MMDB_aget_value(&r.entry, &f,
                       PATH(""subdivisions"", ""0"", ""names"", ""en""))) {
    printf(""%s: %.*s (%.*s)\n"", ""region"", e.data_size, e.utf8_string,
           f.data_size, f.utf8_string);
  }
  if (!MMDB_aget_value(&r.entry, &e, PATH(""country"", ""iso_code"")) &&
      !MMDB_aget_value(&r.entry, &f, PATH(""country"", ""names"", ""en""))) {
    printf(""%s: %.*s (%.*s)\n"", ""country"", e.data_size, e.utf8_string,
           f.data_size, f.utf8_string);
    cc = READ16LE(e.utf8_string);
  } else {
    cc = 0;
  }
  if (!MMDB_aget_value(&r.entry, &e, PATH(""registered_country"", ""iso_code"")) &&
      !MMDB_aget_value(&r.entry, &f,
                       PATH(""registered_country"", ""names"", ""en""))) {
    uhoh = cc && cc != READ16LE(e.utf8_string);
    printf(""%s%s: %.*s (%.*s)%s\n"", uhoh ? ""\e[1m"" : """", ""registered"",
           e.data_size, e.utf8_string, f.data_size, f.utf8_string,
           uhoh ? ""\e[0m"" : """");
  }
  if ((!MMDB_aget_value(&r.entry, &e,
                        PATH(""country"", ""is_in_european_union"")) &&
       e.boolean) ||
      (!MMDB_aget_value(&r.entry, &e,
                        PATH(""registered_country"", ""is_in_european_union"")) &&
       e.boolean)) {
    printf(""%s: %s\n"", ""is_in_european_union"", ""true"");
  }
  if (!MMDB_aget_value(&r.entry, &e, PATH(""continent"", ""code"")) &&
      !MMDB_aget_value(&r.entry, &f, PATH(""continent"", ""names"", ""en""))) {
    printf(""%s: %.*s (%.*s)\n"", ""continent"", e.data_size, e.utf8_string,
           f.data_size, f.utf8_string);
  }
  if (!MMDB_aget_value(&r.entry, &e, PATH(""location"", ""time_zone""))) {
    printf(""%s: %.*s\n"", ""timezone"", e.data_size, e.utf8_string);
  }
  if (!MMDB_aget_value(&r.entry, &e, PATH(""location"", ""latitude"")) &&
      !MMDB_aget_value(&r.entry, &f, PATH(""location"", ""longitude""))) {
    printf(""%s: %g %g\n"", ""location"", e.double_value, f.double_value);
  }
  if (!MMDB_aget_value(&r.entry, &e, PATH(""location"", ""accuracy_radius""))) {
    printf(""%s: %dkm\n"", ""accuracy"", e.uint16);
  }
  printf(""%s: %s\n"", ""category"", GetIpCategoryName(CategorizeIp(ip)));
  if ((r = MMDB_lookup(asdb, ip, &error)).found_entry &&
      !MMDB_aget_value(&r.entry, &e, PATH(""autonomous_system_number"")) &&
      !MMDB_aget_value(&r.entry, &f, PATH(""autonomous_system_organization""))) {
    printf(""%s: AS%u (%.*s)\n"", ""asn"", e.uint32, f.data_size, f.utf8_string);
  }
  return 0;
}

int main(int argc, char *argv[]) {
  int i, rc;
  ipdb = gc(calloc(1, sizeof(MMDB_s)));
  CHECK_EQ(MMDB_SUCCESS,
           MMDB_open(""/usr/local/share/maxmind/GeoLite2-City.mmdb"", 0, ipdb));
  asdb = gc(calloc(1, sizeof(MMDB_s)));
  CHECK_EQ(MMDB_SUCCESS,
           MMDB_open(""/usr/local/share/maxmind/GeoLite2-ASN.mmdb"", 0, asdb));
  for (rc = 0, i = 1; i < argc; ++i) {
    if (PrintIpInfo(argv[i]) != -1) {
      if (i + 1 < argc) printf(""\n"");
    } else {
      fprintf(stderr, ""NOT FOUND: %s\n"", argv[i]);
      rc = 1;
    }
  }
  MMDB_close(asdb);
  MMDB_close(ipdb);
  return rc;
}
"
./repos/cosmopolitan/tool/viz/od16.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/calls/calls.h""
#include ""libc/errno.h""
#include ""libc/fmt/conv.h""
#include ""libc/log/check.h""
#include ""libc/mem/mem.h""
#include ""libc/runtime/runtime.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#include ""libc/sysv/consts/ex.h""
#include ""libc/sysv/consts/exit.h""
#include ""libc/sysv/consts/fileno.h""
#include ""third_party/getopt/getopt.internal.h""

#define USAGE \
  "" [FLAGS] [PATH...]\n\
this program prints binary as signed 16-bit decimal numbers\n\
\n\
Flags:\n\
  -n INT\n\
  -c INT\n\
  -w INT     width (aka cols) [default 8]\n\
  -o PATH    output path [default -]\n\
  -h or -?   shows this information\n\
\n""

static long width_;
static FILE *in_, *out_;
static char *inpath_, *outpath_;

void PrintUsage(int rc, int fd) {
  tinyprint(fd, ""Usage: "", program_invocation_name, USAGE, NULL);
  exit(rc);
}

void GetOpts(int *argc, char *argv[]) {
  int opt;
  outpath_ = ""-"";
  while ((opt = getopt(*argc, argv, ""?ho:w:c:n:"")) != -1) {
    switch (opt) {
      case 'o':
        outpath_ = optarg;
        break;
      case 'n':
      case 'c':
      case 'w':
        width_ = strtol(optarg, NULL, 0);
        break;
      case 'h':
      case '?':
      default:
        if (opt == optopt) {
          PrintUsage(EXIT_SUCCESS, STDOUT_FILENO);
        } else {
          PrintUsage(EX_USAGE, STDERR_FILENO);
        }
    }
  }
  if (optind == *argc) {
    argv[(*argc)++] = ""-"";
  }
}

void ProcessFile(void) {
  int a, b;
  unsigned n;
  n = 0;
  while ((a = fgetc(in_)) != -1 && (b = fgetc(in_)) != -1) {
    if (n) {
      fputc(',', out_);
      fputc(' ', out_);
    }
    fprintf(out_, ""%7hd"", b << 010 | a);
    if (++n == width_) {
      n = 0;
      fputc('\n', out_);
    }
  }
  if (n) {
    fputc('\n', out_);
  }
}

int main(int argc, char *argv[]) {
  size_t i;
  GetOpts(&argc, argv);
  CHECK_NOTNULL((out_ = fopen(outpath_, ""w"")));
  for (i = optind; i < argc; ++i) {
    CHECK_NOTNULL((in_ = fopen((inpath_ = argv[i]), ""r"")));
    ProcessFile();
    CHECK_NE(-1, fclose(in_));
    in_ = 0;
  }
  CHECK_NE(-1, fclose(out_));
  out_ = 0;
  return 0;
}
"
./repos/cosmopolitan/tool/viz/derasterize.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""dsp/tty/itoa8.h""
#include ""libc/assert.h""
#include ""libc/calls/calls.h""
#include ""libc/calls/struct/stat.h""
#include ""libc/calls/termios.h""
#include ""libc/fmt/conv.h""
#include ""libc/limits.h""
#include ""libc/log/check.h""
#include ""libc/log/log.h""
#include ""libc/macros.internal.h""
#include ""libc/math.h""
#include ""libc/mem/gc.h""
#include ""libc/mem/mem.h""
#include ""libc/nexgen32e/x86feature.h""
#include ""libc/runtime/runtime.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#include ""libc/sysv/consts/ex.h""
#include ""libc/sysv/consts/exit.h""
#include ""libc/sysv/consts/fileno.h""
#include ""libc/sysv/consts/madv.h""
#include ""libc/sysv/consts/map.h""
#include ""libc/sysv/consts/o.h""
#include ""libc/sysv/consts/prot.h""
#include ""libc/x/x.h""
#include ""third_party/getopt/getopt.internal.h""
#include ""third_party/stb/stb_image.h""
#include ""third_party/stb/stb_image_resize.h""
#ifdef __x86_64__

#define HELPTEXT \
  ""\n\
NAME\n\
\n\
  derasterize - convert pictures to text using unicode ANSI art\n\
\n\
SYNOPSIS\n\
\n\
  derasterize [FLAGS] [PNG|JPG|ETC]...\n\
\n\
DESCRIPTION\n\
\n\
  This program converts pictures into unicode text and ANSI colors so\n\
  that images can be displayed within a terminal. It performs lots of\n\
  AVX2 optimized math to deliver the best quality on modern terminals\n\
  with 24-bit color support, e.g. Kitty, Gnome Terminal, CMD.EXE, etc\n\
\n\
  The default output if fullscreen but can be changed:\n\
  -w X\n\
  -x X\n\
          If X is positive, hardcode the width in tty cells to X\n\
          If X is negative, remove as much from the fullscreen width\n\
          X may be specified as base 10 decimal, octal, binary, or hex\n\
  -h Y\n\
  -y Y\n\
          If Y is positive, hardcode the height in tty cells to Y\n\
          If Y is negative, remove as much from the fullscreen height\n\
          May be specified as base 10 decimal, octal, binary, or hex\n\
  -m\n\
          Use ImageMagick `convert` command to load/scale graphics\n\
  -?\n\
  -H\n\
          Show this help information\n\
\n\
EXAMPLES\n\
\n\
  $ ./derasterize samples/wave.png > wave.uaart\n\
  $ cat wave.uaart\n\
\n\
AUTHORS\n\
\n\
  Csdvrx <csdvrx@outlook.com>\n\
  Justine Tunney <jtunney@gmail.com>\n\
""

int m_; /* -m        [use imagemagick] */
int x_; /* -x WIDTH  [in flexidecimal] */
int y_; /* -y HEIGHT [in flexidecimal] */

#define BEST   0
#define FAST   1
#define FASTER 2

#define Mode BEST

#if Mode == BEST
#define MC 9u  /* log2(#) of color combos to consider */
#define GN 35u /* # of glyphs to consider */
#elif Mode == FAST
#define MC 6u
#define GN 35u
#elif Mode == FASTER
#define MC 4u
#define GN 25u
#endif

#define CN 3u        /* # channels (rgb) */
#define YS 8u        /* row stride -or- block height */
#define XS 4u        /* column stride -or- block width */
#define GT 44u       /* total glyphs */
#define BN (YS * XS) /* # scalars in block/glyph plane */

#define PHIPRIME 0x9E3779B1u

extern const uint32_t kGlyphs[];
extern const char16_t kRunes[];

/*───────────────────────────────────────────────────────────────────────────│─╗
│ derasterize § encoding                                                   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

/**
 * Formats Thompson-Pike variable length integer to array.
 *
 * @param p needs at least 8 bytes
 * @return p + number of bytes written, cf. mempcpy
 * @note no NUL-terminator is added
 */
static char *tptoa(char *p, wchar_t x) {
  unsigned long w;
  for (w = tpenc(x); w; w >>= 010) *p++ = w & 0xff;
  return p;
}

/*───────────────────────────────────────────────────────────────────────────│─╗
│ derasterize § colors                                                     ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

static float frgb2lin(float x) {
  float r1, r2;
  r1 = x / 12.92f;
  r2 = pow((x + 0.055) / (1 + 0.055), 2.4);
  return x < 0.04045f ? r1 : r2;
}

static float frgb2std(float x) {
  float r1, r2;
  r1 = x * 12.92f;
  r2 = 1.055 * pow(x, 1 / 2.4) - 0.055;
  return x < 0.0031308f ? r1 : r2;
}

/**
 * Converts 8-bit RGB samples to floating point.
 */
static void rgb2float(unsigned n, float *f, const unsigned char *u) {
  unsigned i;
  for (i = 0; i < n; ++i) f[i] = u[i];
  for (i = 0; i < n; ++i) f[i] /= 255;
}

/**
 * Converts floating point RGB samples to 8-bit.
 */
static void float2rgb(unsigned n, unsigned char *u, float *f) {
  unsigned i;
  for (i = 0; i < n; ++i) f[i] *= 256;
  for (i = 0; i < n; ++i) f[i] = roundf(f[i]);
  for (i = 0; i < n; ++i) u[i] = MAX(0, MIN(255, f[i]));
}

/**
 * Converts standard RGB to linear RGB.
 *
 * This makes subtraction look good by flattening out the bias curve
 * that PC display manufacturers like to use.
 */
static dontinline void rgb2lin(unsigned n, float *f, const unsigned char *u) {
  unsigned i;
  rgb2float(n, f, u);
  for (i = 0; i < n; ++i) f[i] = frgb2lin(f[i]);
}

/**
 * Converts linear RGB to standard RGB.
 */
static dontinline void rgb2std(unsigned n, unsigned char *u, float *f) {
  unsigned i;
  for (i = 0; i < n; ++i) f[i] = frgb2std(f[i]);
  float2rgb(n, u, f);
}

/*───────────────────────────────────────────────────────────────────────────│─╗
│ derasterize § blocks                                                     ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

struct Cell {
  char16_t rune;
  unsigned char bg[CN], fg[CN];
};

/**
 * Serializes ANSI background, foreground, and UNICODE glyph to wire.
 */
static char *celltoa(char *p, struct Cell cell) {
  *p++ = 033;
  *p++ = '[';
  *p++ = '4';
  *p++ = '8';
  *p++ = ';';
  *p++ = '2';
  *p++ = ';';
  p = itoa8(p, cell.bg[0]);
  *p++ = ';';
  p = itoa8(p, cell.bg[1]);
  *p++ = ';';
  p = itoa8(p, cell.bg[2]);
  *p++ = ';';
  *p++ = '3';
  *p++ = '8';
  *p++ = ';';
  *p++ = '2';
  *p++ = ';';
  p = itoa8(p, cell.fg[0]);
  *p++ = ';';
  p = itoa8(p, cell.fg[1]);
  *p++ = ';';
  p = itoa8(p, cell.fg[2]);
  *p++ = 'm';
  p = tptoa(p, cell.rune);
  return p;
}

/**
 * Picks ≤2**MC unique (bg,fg) pairs from product of lb.
 */
static unsigned combinecolors(unsigned char bf[1u << MC][2],
                              const unsigned char bl[CN][YS * XS]) {
  uint64_t hv, ht[(1u << MC) * 2];
  unsigned i, j, n, b, f, h, hi, bu, fu;
  bzero(ht, sizeof(ht));
  for (n = b = 0; b < BN && n < (1u << MC); ++b) {
    bu = bl[2][b] << 020 | bl[1][b] << 010 | bl[0][b];
    hi = 0;
    hi = (((bu >> 000) & 0xff) + hi) * PHIPRIME;
    hi = (((bu >> 010) & 0xff) + hi) * PHIPRIME;
    hi = (((bu >> 020) & 0xff) + hi) * PHIPRIME;
    for (f = b + 1; f < BN && n < (1u << MC); ++f) {
      fu = bl[2][f] << 020 | bl[1][f] << 010 | bl[0][f];
      h = hi;
      h = (((fu >> 000) & 0xff) + h) * PHIPRIME;
      h = (((fu >> 010) & 0xff) + h) * PHIPRIME;
      h = (((fu >> 020) & 0xff) + h) * PHIPRIME;
      h = h & 0xffff;
      h = MAX(1, h);
      hv = 0;
      hv <<= 030;
      hv |= fu;
      hv <<= 030;
      hv |= bu;
      hv <<= 020;
      hv |= h;
      for (i = 0;; ++i) {
        j = (h + i * (i + 1) / 2) & (ARRAYLEN(ht) - 1);
        if (!ht[j]) {
          ht[j] = hv;
          bf[n][0] = b;
          bf[n][1] = f;
          n++;
          break;
        } else if (ht[j] == hv) {
          break;
        }
      }
    }
  }
  return n;
}

/**
 * Computes distance between synthetic block and actual.
 */
#define ADJUDICATE(SYMBOL, ARCH)                                  \
  ARCH static float SYMBOL(unsigned b, unsigned f, unsigned g,    \
                           const float lb[CN][YS * XS]) {         \
    unsigned i, k, gu;                                            \
    float p[BN], q[BN], fu, bu, r;                                \
    bzero(q, sizeof(q));                                          \
    for (k = 0; k < CN; ++k) {                                    \
      gu = kGlyphs[g];                                            \
      bu = lb[k][b];                                              \
      fu = lb[k][f];                                              \
      for (i = 0; i < BN; ++i) p[i] = (gu & (1u << i)) ? fu : bu; \
      for (i = 0; i < BN; ++i) p[i] -= lb[k][i];                  \
      for (i = 0; i < BN; ++i) p[i] *= p[i];                      \
      for (i = 0; i < BN; ++i) q[i] += p[i];                      \
    }                                                             \
    r = 0;                                                        \
    for (i = 0; i < BN; ++i) q[i] = sqrtf(q[i]);                  \
    for (i = 0; i < BN; ++i) r += q[i];                           \
    return r;                                                     \
  }

ADJUDICATE(adjudicate_avx2, _Microarchitecture(""avx2,fma""))
ADJUDICATE(adjudicate_avx, _Microarchitecture(""avx""))
ADJUDICATE(adjudicate_default, )

static float (*adjudicate_hook)(unsigned, unsigned, unsigned,
                                const float[CN][YS * XS]);

static float adjudicate2(unsigned b, unsigned f, unsigned g,
                         const float lb[CN][YS * XS]) {
  if (!adjudicate_hook) {
    if (X86_HAVE(AVX2) && X86_HAVE(FMA)) {
      adjudicate_hook = adjudicate_avx2;
    } else if (X86_HAVE(AVX)) {
      adjudicate_hook = adjudicate_avx;
    } else {
      adjudicate_hook = adjudicate_default;
    }
  }
  return adjudicate_hook(b, f, g, lb);
}

static float adjudicate(unsigned b, unsigned f, unsigned g,
                        const float lb[CN][YS * XS]) {
  unsigned i, k, gu;
  float p[BN], q[BN], fu, bu, r;
  bzero(q, sizeof(q));
  for (k = 0; k < CN; ++k) {
    gu = kGlyphs[g];
    bu = lb[k][b];
    fu = lb[k][f];
    for (i = 0; i < BN; ++i) p[i] = (gu & (1u << i)) ? fu : bu;
    for (i = 0; i < BN; ++i) p[i] -= lb[k][i];
    for (i = 0; i < BN; ++i) p[i] *= p[i];
    for (i = 0; i < BN; ++i) q[i] += p[i];
  }
  r = 0;
  for (i = 0; i < BN; ++i) q[i] = sqrtf(q[i]);
  for (i = 0; i < BN; ++i) r += q[i];
  return r;
}

/**
 * Converts tiny bitmap graphic into unicode glyph.
 */
static struct Cell derasterize(unsigned char block[CN][YS * XS]) {
  struct Cell cell;
  unsigned i, n, b, f, g;
  float r, best, lb[CN][YS * XS];
  unsigned char bf[1u << MC][2];
  rgb2lin(CN * YS * XS, lb[0], block[0]);
  n = combinecolors(bf, block);
  best = FLT_MAX;
  cell.rune = 0;
  for (i = 0; i < n; ++i) {
    b = bf[i][0];
    f = bf[i][1];
    for (g = 0; g < GN; ++g) {
      r = adjudicate(b, f, g, lb);
      if (r < best) {
        best = r;
        cell.rune = kRunes[g];
        cell.bg[0] = block[0][b];
        cell.bg[1] = block[1][b];
        cell.bg[2] = block[2][b];
        cell.fg[0] = block[0][f];
        cell.fg[1] = block[1][f];
        cell.fg[2] = block[2][f];
        if (!r) return cell;
      }
    }
  }
  return cell;
}

/*───────────────────────────────────────────────────────────────────────────│─╗
│ derasterize § graphics                                                   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

/**
 * Turns packed 8-bit RGB graphic into ANSI UNICODE text.
 */
static char *RenderImage(char *v, unsigned yn, unsigned xn,
                         const unsigned char srgb[yn][YS][xn][XS][CN]) {
  unsigned y, x, i, j, k;
  unsigned char copy[YS][XS][CN] forcealign(32);
  unsigned char block[CN][YS * XS] forcealign(32);
  DCHECK_ALIGNED(32, v);
  DCHECK_ALIGNED(32, srgb);
  for (y = 0; y < yn; ++y) {
    if (y) {
      *v++ = 033;
      *v++ = '[';
      *v++ = '0';
      *v++ = 'm';
      *v++ = '\n';
    }
    for (x = 0; x < xn; ++x) {
      for (i = 0; i < YS; ++i) {
        memcpy(copy[i], srgb[y][i][x], XS * CN);
      }
      for (i = 0; i < YS; ++i) {
        for (j = 0; j < XS; ++j) {
          for (k = 0; k < CN; ++k) {
            block[k][i * XS + j] = copy[i][j][k];
          }
        }
      }
      v = celltoa(v, derasterize(block));
    }
  }
  return v;
}

/*───────────────────────────────────────────────────────────────────────────│─╗
│ derasterize § systems                                                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

static void PrintImage(unsigned yn, unsigned xn,
                       const unsigned char rgb[yn][YS][xn][XS][CN]) {
  size_t size;
  char *v, *vt;
  size = yn * (xn * (32 + (2 + (1 + 3) * 3) * 2 + 1 + 3)) * 1 + 5 + 1;
  size = ROUNDUP(size, FRAMESIZE);
  CHECK_NOTNULL((vt = _mapanon(size)));
  v = RenderImage(vt, yn, xn, rgb);
  *v++ = '\r';
  *v++ = 033;
  *v++ = '[';
  *v++ = '0';
  *v++ = 'm';
  CHECK_NE(-1, xwrite(1, vt, v - vt));
  CHECK_NE(-1, munmap(vt, size));
}

/**
 * Determines dimensions of teletypewriter.
 */
static void GetTermSize(unsigned out_rows[1], unsigned out_cols[1]) {
  struct winsize ws;
  ws.ws_row = 24;
  ws.ws_col = 80;
  if (tcgetwinsize(STDIN_FILENO, &ws) == -1) {
    tcgetwinsize(STDOUT_FILENO, &ws);
  }
  out_rows[0] = ws.ws_row;
  out_cols[0] = ws.ws_col;
}

static int ReadAll(int fd, void *data, size_t size) {
  char *p;
  ssize_t rc;
  size_t got, n;
  p = data;
  n = size;
  do {
    if ((rc = read(fd, p, n)) == -1) return -1;
    got = rc;
    assert(got || !n);
    p += got;
    n -= got;
  } while (n);
  return 0;
}

/**
 * Loads and scales image via ImageMagick `convert` command.
 *
 * @param path is filename of graphic
 * @param yn is desired height
 * @param xn is desired width
 * @param rgb is memory allocated by caller for image
 */
static void LoadFileViaImageMagick(const char *path, unsigned yn, unsigned xn,
                                   unsigned char rgb[yn][YS][xn][XS][CN]) {
  const char *convert;
  int pid, ws, pipefds[2];
  char pathbuf[PATH_MAX], dim[32];
  if (!(convert = commandv(""convert"", pathbuf, sizeof(pathbuf)))) {
    fputs(""error: `convert` command not found\n""
          ""try: apt-get install imagemagick\n"",
          stderr);
    exit(EXIT_FAILURE);
  }
  sprintf(dim, ""%ux%u!"", xn * XS, yn * YS);
  CHECK_NE(-1, pipe2(pipefds, O_CLOEXEC));
  if (!(pid = vfork())) {
    dup2(pipefds[1], 1);
    execv(convert,
          (char *const[]){""convert"", (char *)path, ""-resize"", dim, ""-depth"",
                          ""8"", ""-colorspace"", ""sRGB"", ""rgb:-"", NULL});
    abort();
  }
  CHECK_NE(-1, close(pipefds[1]));
  CHECK_NE(-1, ReadAll(pipefds[0], rgb, yn * YS * xn * XS * CN));
  CHECK_NE(-1, close(pipefds[0]));
  CHECK_NE(-1, waitpid(pid, &ws, 0));
  CHECK_EQ(0, WEXITSTATUS(ws));
}

static void LoadFile(const char *path, size_t yn, size_t xn, void *rgb) {
  struct stat st;
  void *map, *data;
  int fd, gotx, goty, channels_in_file;
  CHECK_NE(-1, (fd = open(path, O_RDONLY)), ""%s"", path);
  CHECK_NE(-1, fstat(fd, &st));
  CHECK_GT(st.st_size, 0);
  CHECK_LE(st.st_size, INT_MAX);
  /* LOGIFNEG1(fadvise(fd, 0, 0, MADV_WILLNEED | MADV_SEQUENTIAL)); */
  CHECK_NE(MAP_FAILED,
           (map = mmap(NULL, st.st_size, PROT_READ, MAP_SHARED, fd, 0)));
  CHECK_NOTNULL((data = stbi_load_from_memory(map, st.st_size, &gotx, &goty,
                                              &channels_in_file, CN)),
                ""%s"", path);
  CHECK_NE(-1, munmap(map, st.st_size));
  CHECK_NE(-1, close(fd));
#if 1
  stbir_resize_uint8(data, gotx, goty, 0, rgb, xn * XS, yn * YS, 0, CN);
#else
  CHECK_EQ(CN, 3);
  data2size = ROUNDUP(sizeof(float) * goty * gotx * CN, FRAMESIZE);
  data3size = ROUNDUP(sizeof(float) * yn * YS * xn * XS * CN, FRAMESIZE);
  CHECK_NOTNULL((data2 = _mapanon(data2size)));
  CHECK_NOTNULL((data3 = _mapanon(data3size)));
  rgb2lin(goty * gotx * CN, data2, data);
  lanczos3(yn * YS, xn * XS, data3, goty, gotx, data2, gotx * 3);
  rgb2std(yn * YS * xn * XS * CN, rgb, data3);
  CHECK_NE(-1, munmap(data2, data2size));
  CHECK_NE(-1, munmap(data3, data3size));
#endif
  free(data);
}

static int ParseNumberOption(const char *arg) {
  long x;
  x = strtol(arg, NULL, 0);
  if (!(1 <= x && x <= INT_MAX)) {
    fprintf(stderr, ""invalid flexidecimal: %s\n\n"", arg);
    exit(EXIT_FAILURE);
  }
  return x;
}

static void PrintUsage(int rc, int fd) {
  tinyprint(fd, HELPTEXT, NULL);
  exit(rc);
}

static void GetOpts(int argc, char *argv[]) {
  int opt;
  while ((opt = getopt(argc, argv, ""?Hmx:y:w:h:"")) != -1) {
    switch (opt) {
      case 'w':
      case 'x':
        x_ = ParseNumberOption(optarg);
        break;
      case 'h':
      case 'y':
        y_ = ParseNumberOption(optarg);
        break;
      case 'm':
        m_ = 1;
        break;
      case '?':
      case 'H':
      default:
        if (opt == optopt) {
          PrintUsage(EXIT_SUCCESS, STDOUT_FILENO);
        } else {
          PrintUsage(EX_USAGE, STDERR_FILENO);
        }
    }
  }
}

int main(int argc, char *argv[]) {
  int i;
  void *rgb;
  size_t size;
  unsigned yd, xd;
  ShowCrashReports();
  GetOpts(argc, argv);
  // if sizes are given, 2 cases:
  //  - positive values: use that as the target size
  //  - negative values: add, for ex to offset the command prompt size
  GetTermSize(&yd, &xd);
  if (y_ <= 0) {
    y_ += yd;
  }
  if (x_ <= 0) {
    x_ += xd;
  }
  // FIXME: on the conversion stage should do 2Y because of halfblocks
  // printf( ""filename >%s<\tx >%d<\ty >%d<\n\n"", filename, x_, y_);
  size = y_ * YS * x_ * XS * CN;
  CHECK_NOTNULL((rgb = _mapanon(ROUNDUP(size, FRAMESIZE))));
  for (i = optind; i < argc; ++i) {
    if (!argv[i]) continue;
    if (m_) {
      LoadFileViaImageMagick(argv[i], y_, x_, rgb);
    } else {
      LoadFile(argv[i], y_, x_, rgb);
    }
    PrintImage(y_, x_, rgb);
  }
  munmap(rgb, ROUNDUP(size, FRAMESIZE));
  return 0;
}

#else

int main(int argc, char *argv[]) {
}

#endif /* __x86_64__ */
"
./repos/cosmopolitan/tool/viz/fold.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/errno.h""
#include ""libc/fmt/conv.h""
#include ""libc/intrin/safemacros.internal.h""
#include ""libc/runtime/runtime.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#include ""libc/sysv/consts/ex.h""
#include ""libc/sysv/consts/exit.h""
#include ""third_party/getopt/getopt.internal.h""

int column_;

wontreturn void usage(int rc, FILE *f) {
  fputs(""Usage: "", f);
  fputs(program_invocation_name, f);
  fputs("" [-w COLS] [FILE...]\n"", f);
  exit(rc);
}

void getopts(int argc, char *argv[]) {
  int opt;
  while ((opt = getopt(argc, argv, ""?hw:"")) != -1) {
    switch (opt) {
      case 'w':
        column_ = strtol(optarg, NULL, 0);
        break;
      case '?':
      case 'h':
        usage(EXIT_SUCCESS, stdout);
      default:
        usage(EX_USAGE, stderr);
    }
  }
  if (column_ <= 0) {
    column_ = 64;
  }
}

void fold(FILE *fin, FILE *fout) {
  unsigned column = 0;
  for (;;) {
    wint_t wc = fgetwc(fin);
    if (wc != -1) {
      fputwc(wc, fout);
      if (wc == '\n') {
        column = 0;
      } else if (++column == column_) {
        fputc('\n', fout);
        column = 0;
      }
    } else {
      if (feof(fin)) {
        return;
      } else {
        fprintf(stderr, ""%s: %d\n"", ""fgetwc"", errno);
        exit(1);
      }
    }
  }
}

int main(int argc, char *argv[]) {
  getopts(argc, argv);
  fold(stdin, stdout);
  return 0;
}
"
./repos/cosmopolitan/tool/viz/printansi.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""dsp/core/half.h""
#include ""dsp/core/twixt8.h""
#include ""dsp/scale/scale.h""
#include ""dsp/tty/quant.h""
#include ""dsp/tty/tty.h""
#include ""libc/assert.h""
#include ""libc/calls/calls.h""
#include ""libc/calls/struct/stat.h""
#include ""libc/calls/struct/winsize.h""
#include ""libc/calls/termios.h""
#include ""libc/dce.h""
#include ""libc/errno.h""
#include ""libc/fmt/conv.h""
#include ""libc/intrin/safemacros.internal.h""
#include ""libc/limits.h""
#include ""libc/log/check.h""
#include ""libc/log/log.h""
#include ""libc/macros.internal.h""
#include ""libc/math.h""
#include ""libc/mem/gc.h""
#include ""libc/mem/mem.h""
#include ""libc/stdio/rand.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#include ""libc/sysv/consts/ex.h""
#include ""libc/sysv/consts/exit.h""
#include ""libc/sysv/consts/fileno.h""
#include ""libc/sysv/consts/madv.h""
#include ""libc/sysv/consts/map.h""
#include ""libc/sysv/consts/o.h""
#include ""libc/sysv/consts/prot.h""
#include ""libc/sysv/consts/termios.h""
#include ""libc/x/x.h""
#include ""third_party/getopt/getopt.internal.h""
#include ""third_party/stb/stb_image.h""
#include ""tool/viz/lib/graphic.h""

#define SQR(x) ((x) * (x))

static struct Flags {
  const char *out;
  bool invert;
  bool subpixel;
  bool unsharp;
  bool dither;
  bool ruler;
  bool trailingnewline;
  long half;
  bool full;
  long width;
  long height;
  enum TtyBlocksSelection blocks;
  enum TtyQuantizationAlgorithm quant;
} g_flags;

static wontreturn void PrintUsage(int rc, int fd) {
  tinyprint(fd, ""Usage: "", program_invocation_name, ""\
 [FLAGS] [PATH]\n\
\n\
FLAGS\n\
\n\
  -w INT     width\n\
  -h INT     height\n\
  -i         invert\n\
  -?         shows this information\n\
\n\
EXAMPLES\n\
\n\
  printansi -w80 -h40 logo.png\n\
\n\
\n"",
            NULL);
  exit(rc);
}

static int ParseNumberOption(const char *arg) {
  long x;
  x = strtol(arg, NULL, 0);
  if (!(1 <= x && x <= INT_MAX)) {
    fprintf(stderr, ""invalid flexidecimal: %s\n\n"", arg);
    exit(EXIT_FAILURE);
  }
  return x;
}

static void GetOpts(int *argc, char *argv[]) {
  int opt;
  struct winsize ws;
  g_flags.quant = kTtyQuantTrue;
  g_flags.blocks = IsWindows() ? kTtyBlocksCp437 : kTtyBlocksUnicode;
  if (*argc == 2 &&
      (strcmp(argv[1], ""--help"") == 0 || strcmp(argv[1], ""-help"") == 0)) {
    PrintUsage(EXIT_SUCCESS, STDOUT_FILENO);
  }
  while ((opt = getopt(*argc, argv, ""?ivpfrtxads234o:w:h:"")) != -1) {
    switch (opt) {
      case 'o':
        g_flags.out = optarg;
        break;
      case 'd':
        g_flags.dither = true;
        break;
      case 's':
        g_flags.unsharp = true;
        break;
      case 'w':
        g_flags.trailingnewline = true;
        g_flags.width = ParseNumberOption(optarg);
        break;
      case 'h':
        g_flags.trailingnewline = true;
        g_flags.height = ParseNumberOption(optarg);
        break;
      case 'f':
        g_flags.full = true;
        break;
      case 'i':
        g_flags.invert = true;
        break;
      case '2':
        g_flags.half = true;
        break;
      case 'r':
        g_flags.ruler = true;
        break;
      case 'p':
        g_flags.subpixel = true;
        break;
      case 'a':
        g_flags.quant = kTtyQuantAnsi;
        break;
      case 'x':
        g_flags.quant = kTtyQuantXterm256;
        break;
      case 't':
        g_flags.quant = kTtyQuantTrue;
        break;
      case '3':
        g_flags.blocks = kTtyBlocksCp437;
        break;
      case '4':
        g_flags.blocks = kTtyBlocksUnicode;
        break;
      case 'v':
        ++__log_level;
        break;
      case '?':
      default:
        if (opt == optopt) {
          PrintUsage(EXIT_SUCCESS, STDOUT_FILENO);
        } else {
          PrintUsage(EX_USAGE, STDERR_FILENO);
        }
    }
  }
  if (optind == *argc) {
    if (!g_flags.out) g_flags.out = ""-"";
    argv[(*argc)++] = ""-"";
  }
  if (!g_flags.full && (!g_flags.width || !g_flags.width)) {
    ws.ws_col = 80;
    ws.ws_row = 24;
    if (tcgetwinsize(STDIN_FILENO, &ws) != -1 ||
        tcgetwinsize(STDOUT_FILENO, &ws) != -1) {
      g_flags.width = ws.ws_col * (1 + !g_flags.half);
      g_flags.height = ws.ws_row * 2;
    }
  }
  ttyquantsetup(g_flags.quant, kTtyQuantRgb, g_flags.blocks);
}

static unsigned char AlphaBackground(unsigned y, unsigned x) {
  return 255;
}

static void *Deblinterlace(long dyn, long dxn, unsigned char dst[3][dyn][dxn],
                           long syn, long sxn, long scn,
                           const unsigned char src[syn][sxn][scn], long y0,
                           long yn, long x0, long xn) {
  long y, x;
  unsigned char c;
  for (y = y0; y < yn; ++y) {
    for (x = x0; x < xn; ++x) {
      switch (scn) {
        case 1:
          c = src[y][x][0];
          dst[0][y][x] = c;
          dst[1][y][x] = c;
          dst[2][y][x] = c;
          break;
        case 2:
          c = twixt8(AlphaBackground(y, x), src[y][x][0], src[y][x][1]);
          dst[0][y][x] = c;
          dst[1][y][x] = c;
          dst[2][y][x] = c;
          break;
        case 3:
          dst[0][y][x] = src[y][x][0];
          dst[1][y][x] = src[y][x][1];
          dst[2][y][x] = src[y][x][2];
          break;
        case 4:
          c = AlphaBackground(y, x);
          dst[0][y][x] = twixt8(c, src[y][x][0], src[y][x][3]);
          dst[1][y][x] = twixt8(c, src[y][x][1], src[y][x][3]);
          dst[2][y][x] = twixt8(c, src[y][x][2], src[y][x][3]);
          break;
      }
    }
  }
  return dst;
}

static void *DeblinterlaceSubpixelBgr(long dyn, long dxn,
                                      unsigned char dst[3][dyn][dxn][3],
                                      long syn, long sxn,
                                      const unsigned char src[syn][sxn][4],
                                      long y0, long yn, long x0, long xn) {
  long y, x;
  for (y = y0; y < yn; ++y) {
    for (x = x0; x < xn; ++x) {
      dst[0][y][x][0] = 0;
      dst[1][y][x][0] = 0;
      dst[2][y][x][0] = src[y][x][2];
      dst[0][y][x][1] = 0;
      dst[1][y][x][1] = src[y][x][1];
      dst[2][y][x][1] = 0;
      dst[0][y][x][2] = src[y][x][0];
      dst[1][y][x][2] = 0;
      dst[2][y][x][2] = 0;
    }
  }
  return dst;
}

struct Block {
  char16_t c;
  unsigned char b[4][2];
} kBlocks[] = {
    {u' ', {{0000, 0000}, {0000, 0000}, {0000, 0000}, {0000, 0000}}},  //
    {u'░', {{0060, 0060}, {0060, 0060}, {0060, 0060}, {0060, 0060}}},  //
    {u'▒', {{0140, 0140}, {0140, 0140}, {0140, 0140}, {0140, 0140}}},  //
    {u'▓', {{0300, 0300}, {0300, 0300}, {0300, 0300}, {0300, 0300}}},  //
    {u'█', {{0377, 0377}, {0377, 0377}, {0377, 0377}, {0377, 0377}}},  //
    {u'▄', {{0000, 0000}, {0000, 0000}, {0377, 0377}, {0377, 0377}}},  //
    {u'▌', {{0377, 0000}, {0377, 0000}, {0377, 0000}, {0377, 0000}}},  //
    {u'▐', {{0000, 0377}, {0000, 0377}, {0000, 0377}, {0000, 0377}}},  //
    {u'▀', {{0377, 0377}, {0377, 0377}, {0000, 0000}, {0000, 0000}}},  //
};

static void *Raster(long yn, long xn, unsigned char Y[yn][xn]) {
  long y, x, i, j, k, s, bi, bs;
  for (y = 0; y + 4 <= yn; y += 4) {
    if (y) fputc('\n', stdout);
    for (x = 0; x + 2 <= xn; x += 2) {
      bi = 0;
      bs = LONG_MAX;
      for (k = 0; k < ARRAYLEN(kBlocks); ++k) {
        s = 0;
        for (i = 0; i < 4; ++i) {
          for (j = 0; j < 2; ++j) {
            s += SQR(Y[y + i][x + j] - kBlocks[k].b[i][j]);
          }
        }
        if (s < bs) {
          bi = k;
          bs = s;
        }
      }
      fputwc(kBlocks[bi].c, stdout);
    }
  }
  fputc('\n', stdout);
  return Y;
}

static void *Invert(long yn, long xn, unsigned char Y[yn][xn]) {
  long y, x;
  if (!g_flags.invert) {
    for (y = 0; y < yn; ++y) {
      for (x = 0; x < xn; ++x) {
        Y[y][x] = 255 - Y[y][x];
      }
    }
  }
  return Y;
}

static void *Grayify(long yn, long xn, unsigned char Y[yn][xn],
                     const unsigned char RGB[3][yn][xn]) {
  long y, x;
  for (y = 0; y < yn; ++y) {
    for (x = 0; x < xn; ++x) {
      Y[y][x] = RGB[0][y][x] * .299 + RGB[1][y][x] * .587 + RGB[2][y][x] * .114;
    }
  }
  return Y;
}

static void ProcessImage(long yn, long xn, unsigned char RGB[3][yn][xn]) {
  Raster(yn, xn,
         Invert(yn, xn, Grayify(yn, xn, gc(memalign(32, yn * xn)), RGB)));
}

void WithImageFile(const char *path,
                   void fn(long yn, long xn, unsigned char RGB[3][yn][xn])) {
  struct stat st;
  void *map, *data;
  int fd, yn, xn, cn, dyn, dxn, syn, sxn;
  CHECK_NE(-1, (fd = open(path, O_RDONLY)), ""%s"", path);
  CHECK_NE(-1, fstat(fd, &st));
  CHECK_GT(st.st_size, 0);
  CHECK_LE(st.st_size, INT_MAX);
  fadvise(fd, 0, 0, MADV_WILLNEED | MADV_SEQUENTIAL);
  CHECK_NE(MAP_FAILED,
           (map = mmap(NULL, st.st_size, PROT_READ, MAP_SHARED, fd, 0)));
  CHECK_NOTNULL(
      (data = gc(stbi_load_from_memory(map, st.st_size, &xn, &yn, &cn, 0))),
      ""%s"", path);
  CHECK_NE(-1, munmap(map, st.st_size));
  CHECK_NE(-1, close(fd));
  if (g_flags.subpixel) {
    data = DeblinterlaceSubpixelBgr(yn, xn, gc(memalign(32, yn * xn * 4 * 3)),
                                    yn, xn, data, 0, yn, 0, xn);
    xn *= 3;
  } else {
    data = Deblinterlace(yn, xn, gc(memalign(32, yn * xn * 4)), yn, xn, cn,
                         data, 0, yn, 0, xn);
    cn = 3;
  }
  if (g_flags.height && g_flags.width) {
    syn = yn;
    sxn = xn;
    dyn = g_flags.height * 4;
    dxn = g_flags.width * 2;
    while (HALF(syn) > dyn || HALF(sxn) > dxn) {
      if (HALF(sxn) > dxn) {
        Magikarp2xX(yn, xn, data, syn, sxn);
        Magikarp2xX(yn, xn, (char *)data + yn * xn, syn, sxn);
        Magikarp2xX(yn, xn, (char *)data + yn * xn * 2, syn, sxn);
        sxn = HALF(sxn);
      }
      if (HALF(syn) > dyn) {
        Magikarp2xY(yn, xn, data, syn, sxn);
        Magikarp2xY(yn, xn, (char *)data + yn * xn, syn, sxn);
        Magikarp2xY(yn, xn, (char *)data + yn * xn * 2, syn, sxn);
        syn = HALF(syn);
      }
    }
    data = EzGyarados(3, dyn, dxn, gc(memalign(32, dyn * dxn * 3)), cn, yn, xn,
                      data, 0, cn, dyn, dxn, syn, sxn, 0, 0, 0, 0);
    yn = dyn;
    xn = dxn;
  }
  fn(yn, xn, data);
}

int main(int argc, char *argv[]) {
  int i;
  GetOpts(&argc, argv);
  stbi_set_unpremultiply_on_load(true);
  for (i = optind; i < argc; ++i) {
    WithImageFile(argv[i], ProcessImage);
  }
  return 0;
}
"
./repos/cosmopolitan/tool/viz/hwcap.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2024 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/sysv/consts/hwcap.h""
#include ""libc/runtime/runtime.h""
#include ""libc/stdio/stdio.h""
#include ""libc/sysv/consts/auxv.h""

int main(int argc, char *argv[]) {
#ifdef __aarch64__

  long x = getauxval(AT_HWCAP);

  if (x & HWCAP_FP) puts(""HWCAP_FP"");
  if (x & HWCAP_ASIMD) puts(""HWCAP_ASIMD"");
  if (x & HWCAP_EVTSTRM) puts(""HWCAP_EVTSTRM"");
  if (x & HWCAP_AES) puts(""HWCAP_AES"");
  if (x & HWCAP_PMULL) puts(""HWCAP_PMULL"");
  if (x & HWCAP_SHA1) puts(""HWCAP_SHA1"");
  if (x & HWCAP_SHA2) puts(""HWCAP_SHA2"");
  if (x & HWCAP_CRC32) puts(""HWCAP_CRC32"");
  if (x & HWCAP_ATOMICS) puts(""HWCAP_ATOMICS"");
  if (x & HWCAP_FPHP) puts(""HWCAP_FPHP"");
  if (x & HWCAP_ASIMDHP) puts(""HWCAP_ASIMDHP"");
  if (x & HWCAP_CPUID) puts(""HWCAP_CPUID"");
  if (x & HWCAP_ASIMDRDM) puts(""HWCAP_ASIMDRDM"");
  if (x & HWCAP_JSCVT) puts(""HWCAP_JSCVT"");
  if (x & HWCAP_FCMA) puts(""HWCAP_FCMA"");
  if (x & HWCAP_LRCPC) puts(""HWCAP_LRCPC"");
  if (x & HWCAP_DCPOP) puts(""HWCAP_DCPOP"");
  if (x & HWCAP_SHA3) puts(""HWCAP_SHA3"");
  if (x & HWCAP_SM3) puts(""HWCAP_SM3"");
  if (x & HWCAP_SM4) puts(""HWCAP_SM4"");
  if (x & HWCAP_ASIMDDP) puts(""HWCAP_ASIMDDP"");
  if (x & HWCAP_SHA512) puts(""HWCAP_SHA512"");
  if (x & HWCAP_SVE) puts(""HWCAP_SVE"");
  if (x & HWCAP_ASIMDFHM) puts(""HWCAP_ASIMDFHM"");
  if (x & HWCAP_DIT) puts(""HWCAP_DIT"");
  if (x & HWCAP_USCAT) puts(""HWCAP_USCAT"");
  if (x & HWCAP_ILRCPC) puts(""HWCAP_ILRCPC"");
  if (x & HWCAP_FLAGM) puts(""HWCAP_FLAGM"");
  if (x & HWCAP_SSBS) puts(""HWCAP_SSBS"");
  if (x & HWCAP_SB) puts(""HWCAP_SB"");
  if (x & HWCAP_PACA) puts(""HWCAP_PACA"");
  if (x & HWCAP_PACG) puts(""HWCAP_PACG"");

  x = getauxval(AT_HWCAP2);

  if (x & HWCAP2_DCPODP) puts(""HWCAP2_DCPODP"");
  if (x & HWCAP2_SVE2) puts(""HWCAP2_SVE2"");
  if (x & HWCAP2_SVEAES) puts(""HWCAP2_SVEAES"");
  if (x & HWCAP2_SVEPMULL) puts(""HWCAP2_SVEPMULL"");
  if (x & HWCAP2_SVEBITPERM) puts(""HWCAP2_SVEBITPERM"");
  if (x & HWCAP2_SVESHA3) puts(""HWCAP2_SVESHA3"");
  if (x & HWCAP2_SVESM4) puts(""HWCAP2_SVESM4"");
  if (x & HWCAP2_FLAGM2) puts(""HWCAP2_FLAGM2"");
  if (x & HWCAP2_FRINT) puts(""HWCAP2_FRINT"");
  if (x & HWCAP2_SVEI8MM) puts(""HWCAP2_SVEI8MM"");
  if (x & HWCAP2_SVEF32MM) puts(""HWCAP2_SVEF32MM"");
  if (x & HWCAP2_SVEF64MM) puts(""HWCAP2_SVEF64MM"");
  if (x & HWCAP2_SVEBF16) puts(""HWCAP2_SVEBF16"");
  if (x & HWCAP2_I8MM) puts(""HWCAP2_I8MM"");
  if (x & HWCAP2_BF16) puts(""HWCAP2_BF16"");
  if (x & HWCAP2_DGH) puts(""HWCAP2_DGH"");
  if (x & HWCAP2_RNG) puts(""HWCAP2_RNG"");
  if (x & HWCAP2_BTI) puts(""HWCAP2_BTI"");
  if (x & HWCAP2_MTE) puts(""HWCAP2_MTE"");

#endif /* __aarch64__ */
}
"
./repos/cosmopolitan/tool/viz/rlimit.c,https://github.com/jart/cosmopolitan.git,"#if 0
/*─────────────────────────────────────────────────────────────────╗
│ To the extent possible under law, Justine Tunney has waived      │
│ all copyright and related or neighboring rights to this file,    │
│ as it is written in the following disclaimers:                   │
│   • http://unlicense.org/                                        │
│   • http://creativecommons.org/publicdomain/zero/1.0/            │
╚─────────────────────────────────────────────────────────────────*/
#endif
#include ""libc/calls/struct/rlimit.h""
#include ""libc/calls/calls.h""
#include ""libc/errno.h""
#include ""libc/intrin/describeflags.internal.h""
#include ""libc/intrin/strace.internal.h""
#include ""libc/log/color.internal.h""
#include ""libc/macros.internal.h""
#include ""libc/runtime/runtime.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#include ""libc/sysv/consts/rlim.h""
#include ""libc/sysv/consts/rlimit.h""

/**
 * @fileoverview tool for printing and changing system resource limits
 *
 * This is what you do if you want to not accidentally bomb your system
 * with runaway code. If you haven't accidentally bombed your UNIX
 * system before then you're not pushing it hard enough.
 */

static void SetLimit(int resource, uint64_t soft, uint64_t hard) {
  struct rlimit old;
  struct rlimit lim = {soft, hard};
  if (resource == 127) return;
  if (setrlimit(resource, &lim) == -1) {
    if (!getrlimit(resource, &old)) {
      lim.rlim_max = MIN(hard, old.rlim_max);
      lim.rlim_cur = MIN(soft, old.rlim_max);
      if (!setrlimit(resource, &lim)) {
        fprintf(stderr, ""%sNOTE: SETRLIMIT(%s) DOWNGRADED TO {%,ld, %,ld}\n"",
                DescribeRlimitName(resource), lim.rlim_cur, lim.rlim_max);
        return;
      }
    }
    fprintf(stderr, ""ERROR: SETRLIMIT(%s, %,ld, %,ld) FAILED %m%n"",
            DescribeRlimitName(resource), soft, hard);
    exit(1);
  }
}

int main(int argc, char *argv[]) {
  int i, rc;
  char rlnbuf[20];
  struct rlimit rlim;

  // // example of how you might change the limits
  // SetLimit(RLIMIT_CPU, 3, 33);
  // SetLimit(RLIMIT_NPROC, 4, 128);
  // SetLimit(RLIMIT_NOFILE, 32, 128);
  // SetLimit(RLIMIT_SIGPENDING, 16, 1024);
  // SetLimit(RLIMIT_AS, 8 * 1024 * 1024, 1l * 1024 * 1024 * 1024);
  // SetLimit(RLIMIT_RSS, 8 * 1024 * 1024, 1l * 1024 * 1024 * 1024);
  // SetLimit(RLIMIT_DATA, 8 * 1024 * 1024, 1l * 1024 * 1024 * 1024);
  // SetLimit(RLIMIT_FSIZE, 8 * 1000 * 1000, 1l * 1000 * 1000 * 1000);

  for (i = 0; i < RLIM_NLIMITS; ++i) {
    rc = getrlimit(i, &rlim);
    printf(""SETRLIMIT(%-20s, %,16ld, %,16ld) → %d %s\n"",
           (DescribeRlimitName)(rlnbuf, i), rlim.rlim_cur, rlim.rlim_max, rc,
           !rc ? """" : strerror(errno));
  }

  return 0;
}
"
./repos/cosmopolitan/tool/viz/getglyph.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2021 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/calls/struct/sigaction.h""
#include ""libc/fmt/conv.h""
#include ""libc/limits.h""
#include ""libc/log/log.h""
#include ""libc/macros.internal.h""
#include ""libc/mem/gc.h""
#include ""libc/mem/mem.h""
#include ""libc/stdio/append.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#include ""libc/sysv/consts/sig.h""
#include ""libc/x/x.h""
#include ""third_party/getopt/getopt.internal.h""
#include ""third_party/stb/stb_truetype.h""

#define SQR(x) ((x) * (x))

int end;
int start;
int verbose;
int difference;

struct Block {
  char16_t c;
  unsigned char b[4][2];
} kBlocks[] = {
    {u' ', {{0000, 0000}, {0000, 0000}, {0000, 0000}, {0000, 0000}}},  //
    {u'░', {{0060, 0060}, {0060, 0060}, {0060, 0060}, {0060, 0060}}},  //
    {u'▒', {{0140, 0140}, {0140, 0140}, {0140, 0140}, {0140, 0140}}},  //
    {u'▓', {{0300, 0300}, {0300, 0300}, {0300, 0300}, {0300, 0300}}},  //
    {u'█', {{0377, 0377}, {0377, 0377}, {0377, 0377}, {0377, 0377}}},  //
    {u'▄', {{0000, 0000}, {0000, 0000}, {0377, 0377}, {0377, 0377}}},  //
    {u'▌', {{0377, 0000}, {0377, 0000}, {0377, 0000}, {0377, 0000}}},  //
    {u'▐', {{0000, 0377}, {0000, 0377}, {0000, 0377}, {0000, 0377}}},  //
    {u'▀', {{0377, 0377}, {0377, 0377}, {0000, 0000}, {0000, 0000}}},  //
};

static char *Raster(int yn, int xn, unsigned char Y[yn][xn], int *dw) {
  char *r = 0;
  unsigned char B[4][4];
  int y, x, i, j, k, s, w, bi, bs;
  *dw = 0;
  for (y = 0; y < yn; y += 4) {
    if (y) appendw(&r, '\n');
    for (w = x = 0; x < xn; x += 4) {
      for (i = 0; i < 4; ++i) {
        for (j = 0; j < 4; ++j) {
          if (y + i < yn && x + j < xn) {
            B[i][j] = Y[y + i][x + j];
          } else {
            B[i][j] = 0;
          }
        }
      }
      bi = 0;
      bs = INT_MAX;
      for (k = 0; k < ARRAYLEN(kBlocks); ++k) {
        s = 0;
        for (i = 0; i < 4; ++i) {
          for (j = 0; j < 4; ++j) {
            s += SQR(B[i][j] - kBlocks[k].b[i][j / 2]);
          }
        }
        if (s < bs) {
          bi = k;
          bs = s;
        }
      }
      appendw(&r, tpenc(kBlocks[bi].c));
      ++w;
    }
    if (w > *dw) *dw = w;
  }
  return r;
}

void OnSig(int sig) {
  exit(128 + sig);
}

int main(int argc, char *argv[]) {
  char *p;
  void *bmap;
  float scale;
  bool gotsome;
  char **rasters;
  char **fasters;
  size_t ttfsize;
  bool isdifferent;
  unsigned char **ttf;
  stbtt_fontinfo *font;
  int c, i, j, m, o, dw, maxw, *w, *h, s = 40 * 4;
  ShowCrashReports();
  signal(SIGPIPE, OnSig);
  start = 0;
  end = 0x10FFFD;
  while ((o = getopt(argc, argv, ""vdc:s:e:S:"")) != -1) {
    switch (o) {
      case 'v':
        ++verbose;
        break;
      case 'd':
        difference = 1;
        break;
      case 'c':
        start = end = strtol(optarg, 0, 16);
        break;
      case 's':
        start = strtol(optarg, 0, 16);
        break;
      case 'e':
        end = strtol(optarg, 0, 16);
        break;
      case 'S':
        s = strtol(optarg, 0, 0);
        break;
      default:
        return 1;
    }
  }
  m = argc - optind;
  w = gc(calloc(m, sizeof(*w)));
  h = gc(calloc(m, sizeof(*h)));
  ttf = gc(calloc(m, sizeof(*ttf)));
  font = gc(calloc(m, sizeof(*font)));
  rasters = gc(calloc(m, sizeof(*rasters)));
  fasters = gc(calloc(m, sizeof(*fasters)));
  for (j = 0; j < m; ++j) {
    ttf[j] = gc(xslurp(argv[optind + j], &ttfsize));
    if (!ttf[j]) {
      fprintf(stderr, ""%s: not found\n"", argv[optind + j]);
      exit(1);
    }
    stbtt_InitFont(font + j, ttf[j], stbtt_GetFontOffsetForIndex(ttf[j], 0));
    printf(""%s\n"", argv[optind + j]);
  }
  for (c = start; c <= end; ++c) {
    maxw = 0;
    gotsome = false;
    isdifferent = false;
    for (j = 0; j < m; ++j) {
      rasters[j] = 0;
      if ((i = stbtt_FindGlyphIndex(font + j, c)) > 0) {
        w[j] = 0;
        h[j] = 0;
        scale = stbtt_ScaleForPixelHeight(font + j, s);
        bmap = stbtt_GetGlyphBitmap(font + j, 0, scale, i, w + j, h + j, 0, 0);
        if (w[j] && h[j]) {
          gotsome = true;
          if (verbose) {
            rasters[j] = Raster(h[j], w[j], bmap, &dw);
            if (!isdifferent && j && rasters[j - 1] &&
                strcmp(rasters[j], rasters[j - 1])) {
              isdifferent = true;
            }
            if (dw > maxw) maxw = dw;
          }
        }
        free(bmap);
      }
    }
    if (gotsome) {
      memcpy(fasters, rasters, m * sizeof(*rasters));
      printf(""%04X\n"", c);
      if (verbose && (!difference || isdifferent)) {
        do {
          gotsome = false;
          for (j = 0; j < m; ++j) {
            if (!rasters[j]) {
              printf(""%-*s    "", maxw, """");
              continue;
            }
            p = strchrnul(rasters[j], '\n');
            if (p - rasters[j]) gotsome = true;
            printf(""%-*.*s    "", maxw, p - rasters[j], rasters[j]);
            rasters[j] = *p ? p + 1 : p;
          }
          printf(""\n"");
        } while (gotsome);
        printf(""\n"");
      }
      for (j = 0; j < m; ++j) {
        free(fasters[j]);
      }
    }
  }
  return 0;
}
"
./repos/cosmopolitan/tool/viz/printdos2errno.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/fmt/magnumstrs.internal.h""
#include ""libc/intrin/dos2errno.internal.h""
#include ""libc/intrin/kprintf.h""
#include ""libc/str/str.h""

// note: these are supplementary errno magnum mappings
//       don't include the ones in libc/sysv/consts.sh

int main(int argc, char *argv[]) {
  int i;
  for (i = 0; kDos2Errno[i].doscode; ++i) {
    kprintf(""dos error %10hu maps to rva %10d errno %10d which is %s%n"",
            kDos2Errno[i].doscode, kDos2Errno[i].systemv,
            *(const int *)((intptr_t)kDos2Errno + kDos2Errno[i].systemv),
            _strerrno(
                *(const int *)((intptr_t)kDos2Errno + kDos2Errno[i].systemv)));
  }
  return 0;
}
"
./repos/cosmopolitan/tool/viz/bing.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/calls/calls.h""
#include ""libc/errno.h""
#include ""libc/log/log.h""
#include ""libc/runtime/runtime.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#include ""libc/str/tab.internal.h""
#include ""libc/sysv/consts/ex.h""
#include ""libc/sysv/consts/exit.h""
#include ""libc/sysv/consts/fileno.h""
#include ""third_party/getopt/getopt.internal.h""

/**
 * @fileoverview Bing: Binary → Glyphs.
 * Intended for oldskool data science.
 */

int ispipe_;
int newlines_;

wontreturn void ShowUsage(FILE *f, int rc) {
  fputs(program_invocation_name, f);
  fputs("": [-p] [-n] [FILE...]\n"", f);
  exit(rc);
}

void GetOpts(int argc, char *argv[]) {
  int opt;
  while ((opt = getopt(argc, argv, ""hpn"")) != -1) {
    switch (opt) {
      case 'p':
        ispipe_ = true;
        break;
      case 'n':
        newlines_ = true;
        break;
      case 'h':
        ShowUsage(stdout, EXIT_SUCCESS);
      default:
        ShowUsage(stderr, EX_USAGE);
    }
  }
}

void bing(FILE *f) {
  int c, c2;
  while ((c = fgetc(f)) != -1) {
    c2 = c == '\n' && newlines_ ? '\n' : kCp437[c & 0xff];
    if (ispipe_) {
      fputc(c, stdout);
      fputwc(c2, stderr);
    } else {
      fputwc(c2, stdout);
    }
  }
  fputc('\n', ispipe_ ? stderr : stdout);
}

int main(int argc, char *argv[]) {
  FILE *f;
  size_t i;
  GetOpts(argc, argv);
  if (optind < argc) {
    for (i = optind; i < argc; ++i) {
      if (!(f = fopen(argv[i], ""rb""))) {
        perror(argv[i]);
        exit(EXIT_FAILURE);
      }
      bing(f);
      fclose(f);
    }
  } else {
    bing(stdin);
  }
  return 0;
}
"
./repos/cosmopolitan/tool/viz/fontspace.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2021 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""dsp/scale/cdecimate2xuint8x8.h""
#include ""libc/calls/struct/winsize.h""
#include ""libc/calls/termios.h""
#include ""libc/fmt/conv.h""
#include ""libc/fmt/libgen.h""
#include ""libc/intrin/bsr.h""
#include ""libc/log/libfatal.internal.h""
#include ""libc/log/log.h""
#include ""libc/macros.internal.h""
#include ""libc/mem/gc.h""
#include ""libc/mem/mem.h""
#include ""libc/runtime/runtime.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#include ""libc/sysv/consts/termios.h""
#include ""libc/x/x.h""
#include ""third_party/getopt/getopt.internal.h""
#include ""third_party/stb/stb_truetype.h""

#define MAXCODE

int start;
int end = 0x03134A /* 0x10FFFD */;
int verbose;

struct winsize ws = {24, 80};
signed char kThePerfectKernel[8] = {-1, -1, 3, 15, 15, 3, -1, -1};

void PrintBar(unsigned char *p, size_t n) {
  size_t i, j;
  for (j = n; j > ws.ws_col - 32; j = (j + 1) >> 1) {
    cDecimate2xUint8x8(j, p, kThePerfectKernel);
  }
  for (i = 0; i < j; ++i) {
    if (p[i]) {
      fputwc(u""░░▒▒▓▓██""[bsr(p[i])], stdout);
    } else {
      fputc(' ', stdout);
    }
  }
}

int main(int argc, char *argv[]) {
  size_t n, m;
  float scale;
  void *bitmap;
  size_t ttfsize;
  unsigned char *ttf;
  stbtt_fontinfo font;
  unsigned char *present;
  unsigned char *intotal;
  int w, h, i, c, arg, opt, errs, line, s = 40 * 4, rc = 0;
  ShowCrashReports();
  tcgetwinsize(0, &ws);
  while ((opt = getopt(argc, argv, ""vs:e:"")) != -1) {
    switch (opt) {
      case 'v':
        ++verbose;
        break;
      case 's':
        start = strtol(optarg, 0, 16);
        break;
      case 'e':
        end = strtol(optarg, 0, 16);
        break;
      default:
        return 1;
    }
  }
  n = end + 1 - start;
  m = ROUNDUP(n, 16);
  present = gc(malloc(m));
  intotal = gc(calloc(1, m));
  if (optind < argc) {
    for (arg = optind; arg < argc; ++arg) {
      ttf = xslurp(argv[arg], &ttfsize);
      if (!(line = setjmp(stbtt_jmpbuf))) {
        stbtt_InitFont(&font, ttf, stbtt_GetFontOffsetForIndex(ttf, 0));
      } else {
        rc = 1;
        fprintf(stderr, ""%s: error loading font (assert @ stb_truetype.c:%d\n"",
                argv[arg], line);
        free(ttf);
        continue;
      }
      bzero(present, m);
      for (errs = 0, c = start; c <= end; ++c) {
        if (!(line = setjmp(stbtt_jmpbuf))) {
          if ((i = stbtt_FindGlyphIndex(&font, c)) > 0) {
            w = h = 0;
            scale = stbtt_ScaleForPixelHeight(&font, s);
            bitmap = stbtt_GetGlyphBitmap(&font, 0, scale, i, &w, &h, 0, 0);
            if (w && h) {
              intotal[c - start] = present[c - start] = 255;
            }
            free(bitmap);
          }
        } else {
          ++errs;
        }
      }
      PrintBar(present, m);
      if (errs) {
        printf("" %s (%d errors)\n"", basename(argv[arg]), errs);
      } else {
        printf("" %s (%,d kb)\n"", basename(argv[arg]), ttfsize / 1024);
      }
      free(ttf);
    }
    PrintBar(intotal, m);
    fputc('\n', stdout);
  }
  return rc;
}
"
./repos/cosmopolitan/tool/viz/virtualquery.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/dce.h""
#include ""libc/errno.h""
#include ""libc/fmt/conv.h""
#include ""libc/intrin/describeflags.internal.h""
#include ""libc/macros.internal.h""
#include ""libc/nt/enum/memflags.h""
#include ""libc/nt/memory.h""
#include ""libc/nt/struct/memorybasicinformation.h""
#include ""libc/runtime/runtime.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#if defined(__x86_64__) && SupportsWindows()

/**
 * @fileoverview WIN32 Virtual Memory Layout Dump Utility
 */

static const struct DescribeFlags kNtMemState[] = {
    {kNtMemCommit, ""Commit""},    //
    {kNtMemFree, ""Free""},        //
    {kNtMemReserve, ""Reserve""},  //
};

const char *DescribeNtMemState(char buf[64], uint32_t x) {
  return DescribeFlags(buf, 64, kNtMemState, ARRAYLEN(kNtMemState), ""kNtMem"",
                       x);
}

static const struct DescribeFlags kNtMemType[] = {
    {kNtMemImage, ""Image""},      //
    {kNtMemMapped, ""Mapped""},    //
    {kNtMemPrivate, ""Private""},  //
};

const char *DescribeNtMemType(char buf[64], uint32_t x) {
  return DescribeFlags(buf, 64, kNtMemType, ARRAYLEN(kNtMemType), ""kNtMem"", x);
}

int main(int argc, char *argv[]) {
  char *p, b[5][64];
  struct NtMemoryBasicInformation mi;
  if (!IsWindows()) {
    fprintf(stderr, ""error: %s is intended for windows\n"",
            program_invocation_short_name);
    exit(1);
  }
  printf(""%-12s %-12s %10s %16s %16s %32s %32s\n"", ""Allocation"", ""BaseAddress"",
         ""RegionSize"", ""State"", ""Type"", ""AllocationProtect"", ""Protect"");
  for (p = 0;; p = (char *)mi.BaseAddress + mi.RegionSize) {
    bzero(&mi, sizeof(mi));
    if (!VirtualQuery(p, &mi, sizeof(mi))) break;
    sizefmt(b[0], mi.RegionSize, 1024);
    printf(""%.12lx %.12lx %10s %16s %16s %32s %32s\n"", mi.AllocationBase,
           mi.BaseAddress, b[0], DescribeNtMemState(b[1], mi.State),
           DescribeNtMemType(b[2], mi.Type),
           (DescribeNtPageFlags)(b[3], mi.AllocationProtect),
           (DescribeNtPageFlags)(b[4], mi.Protect));
  }
}

#else
int main(int argc, char *argv[]) {
  fprintf(stderr,
          ""virtualquery not supported on this cpu arch or build config\n"");
  return 1;
}
#endif /* __x86_64__ && SupportsWindows() */
"
./repos/cosmopolitan/tool/viz/dumphexc.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2021 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/macros.internal.h""
#include ""libc/mem/mem.h""
#include ""libc/stdio/append.h""
#include ""libc/stdio/hex.internal.h""
#include ""libc/stdio/stdio.h""

/**
 * @fileoverview Hex String Literal Converter, e.g.
 *
 *     $ echo hello | o/tool/viz/dumphexc
 *     ""\
 *     \x68\x65\x6c\x6c\x6f\x0a""
 */

int main(int argc, char *argv[]) {
  char *p;
  size_t n, g;
  char *b = 0;
  char buf[512];
  while ((g = fread(buf, 1, sizeof(buf), stdin))) {
    appendd(&b, buf, g);
  }
  if (!ferror(stdin)) {
    p = DumpHexc(b, appendz(b).i, &n);
    fwrite(p, 1, n, stdout);
    free(p);
  }
  printf(""\n"");
  return ferror(stdin) || ferror(stdout) ? 1 : 0;
}
"
./repos/cosmopolitan/tool/viz/deathstar.c,https://github.com/jart/cosmopolitan.git,"#include ""libc/calls/calls.h""
#include ""libc/calls/struct/sigaction.h""
#include ""libc/calls/struct/termios.h""
#include ""libc/intrin/safemacros.internal.h""
#include ""libc/math.h""
#include ""libc/runtime/runtime.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#include ""libc/sysv/consts/sig.h""

/**
 * @fileoverview demo code borrowed from Rosetta Code.
 */

#define FRAMERATE 23.976
#define WRITE(s)  write(1, s, strlen(s))

#ifdef __x86_64__
__static_yoink(""vga_console"");
__static_yoink(""EfiMain"");
#endif

struct Sphere {
  double cx, cy, cz, r;
};

static const char *kShades[] = {
    ""\e[48;5;232m "", ""\e[48;5;233m "", ""\e[48;5;234m "", ""\e[48;5;235m "",
    ""\e[48;5;236m "", ""\e[48;5;237m "", ""\e[48;5;238m "", ""\e[48;5;239m "",
    ""\e[48;5;240m "", ""\e[48;5;241m "", ""\e[48;5;242m "", ""\e[48;5;243m "",
    ""\e[48;5;244m "", ""\e[48;5;245m "", ""\e[48;5;246m "", ""\e[48;5;247m "",
    ""\e[48;5;248m "", ""\e[48;5;249m "", ""\e[48;5;250m "", ""\e[48;5;251m "",
    ""\e[48;5;252m "", ""\e[48;5;253m "", ""\e[48;5;254m "", ""\e[48;5;255m "",
};

static jmp_buf jb_;
static double light_[3] = {-50, 0, 50};
static struct Sphere pos_ = {11, 11, 11, 11};
static struct Sphere neg_ = {1, 1, -4, 11};

static void OnCtrlC(int sig) {
  longjmp(jb_, 1);
}

static void Normalize(double v[3]) {
  double len;
  len = 1 / sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
  v[0] *= len;
  v[1] *= len;
  v[2] *= len;
}

static double Dot(const double x[3], const double y[3]) {
  return fabs(x[0] * y[0] + x[1] * y[1] + x[2] * y[2]);
}

/* check if a ray (x,y, -inf)->(x, y, inf) hits a sphere; if so, return
   the intersecting z values.  z1 is closer to the eye */
static int HitSphere(struct Sphere *s, double x, double y, double z[2]) {
  double zsq;
  x -= s->cx;
  y -= s->cy;
  zsq = s->r * s->r - (x * x + y * y);
  if (zsq < 0) {
    return 0;
  } else {
    zsq = sqrt(zsq);
    z[0] = s->cz - zsq;
    z[1] = s->cz + zsq;
    return 1;
  }
}

static void DrawSphere(double k, double ambient) {
  int i, j, hit_result;
  double x, y, vec[3], zb[2], zs[2];
  for (i = floor(pos_.cy - pos_.r); i <= ceil(pos_.cy + pos_.r); i++) {
    y = i + .5L;
    for (j = floor(pos_.cx - 2 * pos_.r); j <= ceil(pos_.cx + 2 * pos_.r);
         j++) {
      x = .5L * (j - pos_.cx) + .5L + pos_.cx;
      if (!HitSphere(&pos_, x, y, zb)) {
        /* ray lands in blank space, draw bg */
        hit_result = 0;
      } else if (!HitSphere(&neg_, x, y, zs)) {
        /* ray hits pos_ sphere but not neg_, draw pos_ sphere surface */
        hit_result = 1;
      } else if (zs[0] > zb[0]) {
        /* ray hits both, but pos_ front surface is closer */
        hit_result = 1;
      } else if (zs[1] > zb[1]) {
        /* pos_ sphere surface is inside neg_ sphere, show bg */
        hit_result = 0;
      } else if (zs[1] > zb[0]) {
        /* back surface on neg_ sphere is inside pos_ sphere,
           the only place where neg_ sphere surface will be shown */
        hit_result = 2;
      } else {
        hit_result = 1;
      }
      switch (hit_result) {
        case 0:
          WRITE(""\e[0m "");
          continue;
        case 1:
          vec[0] = x - pos_.cx;
          vec[1] = y - pos_.cy;
          vec[2] = zb[0] - pos_.cz;
          break;
        default:
          vec[0] = neg_.cx - x;
          vec[1] = neg_.cy - y;
          vec[2] = neg_.cz - zs[1];
          break;
      }
      Normalize(vec);
      WRITE(
          kShades[min(ARRAYLEN(kShades) - 1,
                      max(0, lround((1 - (pow(Dot(light_, vec), k) + ambient)) *
                                    (ARRAYLEN(kShades) - 1))))]);
    }
    WRITE(""\e[0m\n"");
  }
  fflush(stdout);
}

int main() {
  double ang;
  WRITE(""\e[?25l"");
  if (!setjmp(jb_)) {
    signal(SIGINT, OnCtrlC);
    ang = 0;
    for (;;) {
      WRITE(""\e[H"");
      light_[1] = cosl(ang * 2);
      sincos(ang, &light_[0], &light_[2]);
      Normalize(light_);
      ang += .05L;
      DrawSphere(1.5L, .01L);
      usleep(1.L / FRAMERATE * 1e6);
    }
  }
  WRITE(""\e[0m\e[H\e[J\e[?25h"");
  return 0;
}
"
./repos/cosmopolitan/tool/viz/clock_nanosleep_accuracy.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2023 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/assert.h""
#include ""libc/calls/struct/timespec.h""
#include ""libc/intrin/kprintf.h""
#include ""libc/runtime/runtime.h""
#include ""libc/stdio/stdio.h""
#include ""libc/sysv/consts/clock.h""

#define MAXIMUM    1e9
#define ITERATIONS 10

void TestSleepRealRelative(void) {
  printf(""\n"");
  printf(""testing: clock_nanosleep(CLOCK_REALTIME) with relative ""
         ""timeout\n"");
  for (long nanos = 1; nanos < (long)MAXIMUM; nanos *= 2) {
    struct timespec t1, t2, wf;
    wf = timespec_fromnanos(nanos);
    clock_gettime(CLOCK_REALTIME, &t1);
    for (int i = 0; i < ITERATIONS; ++i) {
      npassert(!clock_nanosleep(CLOCK_REALTIME, 0, &wf, 0));
    }
    clock_gettime(CLOCK_REALTIME, &t2);
    long took = timespec_tonanos(timespec_sub(t2, t1)) / ITERATIONS;
    printf(""%,12ld ns sleep took %,12ld ns delta %,12ld ns\n"", nanos, took,
           took - nanos);
  }
}

void TestSleepMonoRelative(void) {
  printf(""\n"");
  printf(""testing: clock_nanosleep(CLOCK_MONOTONIC) with relative ""
         ""timeout\n"");
  for (long nanos = 1; nanos < (long)MAXIMUM; nanos *= 2) {
    struct timespec t1, t2, wf;
    wf = timespec_fromnanos(nanos);
    clock_gettime(CLOCK_REALTIME, &t1);
    for (int i = 0; i < ITERATIONS; ++i) {
      npassert(!clock_nanosleep(CLOCK_MONOTONIC, 0, &wf, 0));
    }
    clock_gettime(CLOCK_REALTIME, &t2);
    long took = timespec_tonanos(timespec_sub(t2, t1)) / ITERATIONS;
    printf(""%,12ld ns sleep took %,12ld ns delta %,12ld ns\n"", nanos, took,
           took - nanos);
  }
}

int main(int argc, char *argv[]) {
  TestSleepRealRelative();
  TestSleepMonoRelative();
}
"
./repos/cosmopolitan/tool/viz/unbing.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/calls/calls.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#include ""libc/str/tab.internal.h""

/**
 * @fileoverview UnBing: Glyphs → Binary.
 *
 * Intended for reassembling modified binaries. Characters that aren't
 * IBM CodePage 437 glyphs are ignored. That includes line feeds, so
 * it's safe to use the fold command on the bing program output, to have
 * something almost representing a source code file. A hack also exists
 * for comments in such files: 𝘶𝘴𝘦 𝑛𝑜𝑛-𝑎𝑠𝑐𝑖𝑖 𝗹𝗲𝘁𝘁𝗲𝗿𝗶𝗻𝗴 𝔞𝔩𝔱𝔢𝔯𝔫𝔞𝔱𝔦𝔳𝔢𝔰.
 *
 *   bash$ o/tool/viz/bing </bin/sh | o/tool/viz/fold >sh.txt
 *   bash$ emacs sh.txt
 *   bash$ o/tool/viz/unbing <sh.txt >sh
 *   bash$ chmod +x sh
 *   bash$ ./sh
 *
 * That's how it works.
 */

uint16_t g_map[0x10000];

int main(int argc, char *argv[argc]) {
  size_t i;
  wint_t c;
  for (i = 0; i < 256; ++i) {
    g_map[kCp437[i]] = i + 1;
  }
  while ((c = fgetwc(stdin)) != WEOF) {
    if (c == (c & 0xffff) && g_map[c]) {
      fputc(g_map[c] - 1, stdout);
    }
  }
  return 0;
}
"
./repos/cosmopolitan/tool/viz/getifaddrs.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2023 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/calls/calls.h""
#include ""libc/fmt/itoa.h""
#include ""libc/runtime/runtime.h""
#include ""libc/sock/ifaddrs.h""
#include ""libc/sock/sock.h""
#include ""libc/sock/struct/sockaddr.h""
#include ""libc/sock/struct/sockaddr6.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#include ""libc/sysv/consts/af.h""
#include ""libc/sysv/consts/iff.h""

/* example output:

   eth0
   addr: 10.10.10.237
   netmask: 255.255.255.0
   broadcast: 255.255.255.0
   flags: IFF_UP IFF_BROADCAST IFF_MULTICAST IFF_RUNNING

   lo
   addr: 127.0.0.1
   netmask: 255.0.0.0
   flags: IFF_UP IFF_LOOPBACK IFF_RUNNING */

const char *sockaddr2str(const struct sockaddr *sa, char *buf, size_t size) {
  if (sa->sa_family == AF_INET) {
    return inet_ntop(AF_INET, &(((const struct sockaddr_in *)sa)->sin_addr),
                     buf, size);
  } else if (sa->sa_family == AF_INET6) {
    return inet_ntop(AF_INET6, &(((const struct sockaddr_in6 *)sa)->sin6_addr),
                     buf, size);
  } else {
    return 0;
  }
}

int main(int argc, char *argv[]) {

  // get network interface list
  struct ifaddrs *ifaddrs;
  if (getifaddrs(&ifaddrs)) {
    perror(""getifaddrs"");
    exit(1);
  }

  // print network interface list
  for (struct ifaddrs *ifa = ifaddrs; ifa; ifa = ifa->ifa_next) {
    tinyprint(1, ifa->ifa_name, ""\n"", NULL);

    char buf[128];
    if (sockaddr2str(ifa->ifa_addr, buf, sizeof(buf))) {
      tinyprint(1, ""addr: "", buf, ""\n"", NULL);
    }
    if (sockaddr2str(ifa->ifa_netmask, buf, sizeof(buf))) {
      tinyprint(1, ""netmask: "", buf, ""\n"", NULL);
    }
    if ((ifa->ifa_flags & IFF_BROADCAST) &&
        sockaddr2str(ifa->ifa_netmask, buf, sizeof(buf))) {
      tinyprint(1, ""broadcast: "", buf, ""\n"", NULL);
    } else if ((ifa->ifa_flags & IFF_POINTOPOINT) &&
               sockaddr2str(ifa->ifa_dstaddr, buf, sizeof(buf))) {
      tinyprint(1, ""dstaddr: "", buf, ""\n"", NULL);
    }

    tinyprint(1, ""flags:"", NULL);
    if (ifa->ifa_flags & IFF_UP) {
      tinyprint(1, "" IFF_UP"", NULL);
    }
    if (ifa->ifa_flags & IFF_DEBUG) {
      tinyprint(1, "" IFF_DEBUG"", NULL);
    }
    if (ifa->ifa_flags & IFF_LOOPBACK) {
      tinyprint(1, "" IFF_LOOPBACK"", NULL);
    }
    if (ifa->ifa_flags & IFF_MULTICAST) {
      tinyprint(1, "" IFF_MULTICAST"", NULL);
    }
    if (ifa->ifa_flags & IFF_ALLMULTI) {
      tinyprint(1, "" IFF_ALLMULTI"", NULL);
    }
    if (ifa->ifa_flags & IFF_NOARP) {
      tinyprint(1, "" IFF_NOARP"", NULL);
    }
    if (ifa->ifa_flags & IFF_PROMISC) {
      tinyprint(1, "" IFF_PROMISC"", NULL);
    }
    tinyprint(1, ""\n"", NULL);

    tinyprint(1, ""\n"", NULL);
  }

  // perform cleanup
  freeifaddrs(ifaddrs);

  // report success
  exit(0);
}
"
./repos/cosmopolitan/tool/viz/printpeb.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/calls/calls.h""
#include ""libc/calls/internal.h""
#include ""libc/dce.h""
#include ""libc/intrin/safemacros.internal.h""
#include ""libc/log/log.h""
#include ""libc/nt/dll.h""
#include ""libc/nt/enum/filetype.h""
#include ""libc/nt/enum/startf.h""
#include ""libc/nt/files.h""
#include ""libc/nt/process.h""
#include ""libc/nt/runtime.h""
#include ""libc/nt/struct/ldr.h""
#include ""libc/nt/struct/ldrdatatableentry.h""
#include ""libc/nt/struct/linkedlist.h""
#include ""libc/nt/struct/peb.h""
#include ""libc/nt/struct/systeminfo.h""
#include ""libc/nt/struct/teb.h""
#include ""libc/nt/struct/unicodestring.h""
#include ""libc/runtime/runtime.h""
#include ""libc/stdio/stdio.h""
#include ""libc/sysv/consts/madv.h""
#include ""libc/sysv/consts/o.h""
#include ""libc/time/time.h""
#include ""tool/decode/lib/flagger.h""
#include ""tool/decode/lib/idname.h""
#if defined(__x86_64__) && SupportsWindows()

char *GetString(const struct NtUnicodeString *s) {
  static char buf[1024];
  unsigned len = min(sizeof(buf) - 1, s->Length);
  for (unsigned i = 0; i < len; ++i) {
    buf[i] = (unsigned char)s->Data[i];
  }
  buf[len] = '\0';
  return &buf[0];
}

int NextBestThing(void) {
  int64_t fd = open(""/proc/self/maps"", O_RDONLY);
  posix_fadvise(fd, 0, 0, MADV_SEQUENTIAL);
  ssize_t wrote;
  while ((wrote = copyfd(fd, 1, -1)) != -1) {
    if (wrote == 0) break;
  }
  close(fd);
  return 0;
}

const struct IdName kNtStartfFlagNames[] = {
    {kNtStartfUseshowwindow, ""kNtStartfUseshowwindow""},
    {kNtStartfUsesize, ""kNtStartfUsesize""},
    {kNtStartfUseposition, ""kNtStartfUseposition""},
    {kNtStartfUsecountchars, ""kNtStartfUsecountchars""},
    {kNtStartfUsefillattribute, ""kNtStartfUsefillattribute""},
    {kNtStartfRunfullscreen, ""kNtStartfRunfullscreen""},
    {kNtStartfForceonfeedback, ""kNtStartfForceonfeedback""},
    {kNtStartfForceofffeedback, ""kNtStartfForceofffeedback""},
    {kNtStartfUsestdhandles, ""kNtStartfUsestdhandles""},
    {kNtStartfUsehotkey, ""kNtStartfUsehotkey""},
    {kNtStartfTitleislinkname, ""kNtStartfTitleislinkname""},
    {kNtStartfTitleisappid, ""kNtStartfTitleisappid""},
    {kNtStartfPreventpinning, ""kNtStartfPreventpinning""},
    {kNtStartfUntrustedsource, ""kNtStartfUntrustedsource""},
    {0, 0},
};

dontasan void PrintStartupInfo(void) {
#if 0
  printf(""\n\
╔──────────────────────────────────────────────────────────────────────────────╗\n\
│ new technology § startup info                                                │\n\
╚──────────────────────────────────────────────────────────────────────────────╝\n\
\n"");
#define X(D, F) \
  printf(""%s.%-22s= "" D ""\n"", ""__nt_startupinfo"", #F, __nt_startupinfo.F);
  X(""%u"", cb);
  X(""%p"", lpReserved);
  X(""%hs"", lpDesktop);
  X(""%hs"", lpTitle);
  X(""%u"", dwX);
  X(""%u"", dwY);
  X(""%u"", dwXSize);
  X(""%u"", dwYSize);
  X(""%u"", dwXCountChars);
  X(""%u"", dwYCountChars);
  X(""%u"", dwFillAttribute);
  printf(""%s.%-22s: %s\n"", ""__nt_startupinfo"", ""dwFlags"",
         RecreateFlags(kNtStartfFlagNames, __nt_startupinfo.dwFlags));
  X(""%hu"", wShowWindow);
  X(""%hu"", cbReserved2);
  X(""%s"", lpReserved2);
  X(""%ld"", hStdInput);
  X(""%ld"", hStdOutput);
  X(""%ld"", hStdError);
#undef X
#endif
}

void PrintSystemInfo(void) {
#if 0
  printf(""\n\
╔──────────────────────────────────────────────────────────────────────────────╗\n\
│ new technology § system info                                                 │\n\
╚──────────────────────────────────────────────────────────────────────────────╝\n\
\n"");
#define X(D, F) \
  printf(""%s.%-28s= "" D ""\n"", ""__nt_systeminfo"", #F, __nt_systeminfo.F);
  X(""%08x"", dwOemId);
  X(""%04hx"", wProcessorArchitecture);
  X(""%d"", dwPageSize);
  X(""%p"", lpMinimumApplicationAddress);
  X(""%p"", lpMaximumApplicationAddress);
  X(""%p"", dwActiveProcessorMask);
  X(""%u"", dwNumberOfProcessors);
  X(""%u"", dwProcessorType);
  X(""%u"", dwAllocationGranularity);
  X(""%hu"", wProcessorLevel);
  X(""%hu"", wProcessorRevision);
#undef X
#endif
}

const char *ft2str(int ft) {
  if (ft == kNtFileTypeUnknown) return ""kNtFileTypeUnknown"";
  if (ft == kNtFileTypeDisk) return ""kNtFileTypeDisk"";
  if (ft == kNtFileTypeChar) return ""kNtFileTypeChar"";
  if (ft == kNtFileTypePipe) return ""kNtFileTypePipe"";
  if (ft == kNtFileTypeRemote) return ""kNtFileTypeRemote"";
  return ""wut?"";
}

void PrintStdioInfo(void) {
  printf(""\n\
╔──────────────────────────────────────────────────────────────────────────────╗\n\
│ new technology § stdio info                                                  │\n\
╚──────────────────────────────────────────────────────────────────────────────╝\n\
\n"");
  printf(""%s: %ld (%s)\n"", ""g_fds.p[0].handle"", g_fds.p[0].handle,
         ft2str(GetFileType(g_fds.p[0].handle)));
  printf(""%s: %ld (%s)\n"", ""g_fds.p[1].handle"", g_fds.p[1].handle,
         ft2str(GetFileType(g_fds.p[1].handle)));
  printf(""%s: %ld (%s)\n"", ""g_fds.p[2].handle"", g_fds.p[2].handle,
         ft2str(GetFileType(g_fds.p[2].handle)));
}

dontasan void PrintTeb(void) {
  GetCurrentProcessId();
  SetLastError(0x1234);
  printf(""\n\
╔──────────────────────────────────────────────────────────────────────────────╗\n\
│ new technology § teb?                                                        │\n\
╚──────────────────────────────────────────────────────────────────────────────╝\n\
\n"");
  printf(""gs:0x%02x: %-39s = 0x%lx\n"", 0x00, ""NtGetSeh()"", _NtGetSeh());
  printf(""gs:0x%02x: %-39s = 0x%lx\n"", 0x08, ""NtGetStackHigh()"",
         _NtGetStackHigh());
  printf(""gs:0x%02x: %-39s = 0x%lx\n"", 0x10, ""NtGetStackLow()"",
         _NtGetStackLow());
  printf(""gs:0x%02x: %-39s = 0x%lx\n"", 0x18, ""_NtGetSubsystemTib()"",
         _NtGetSubsystemTib());
  printf(""gs:0x%02x: %-39s = 0x%lx\n"", 0x20, ""NtGetFib()"", _NtGetFib());
  printf(""gs:0x%02x: %-39s = 0x%lx\n"", 0x30, ""NtGetTeb()"", NtGetTeb());
  printf(""gs:0x%02x: %-39s = 0x%lx\n"", 0x38, ""NtGetEnv()"", _NtGetEnv());
  printf(""gs:0x%02x: %-39s = 0x%lx\n"", 0x40, ""NtGetPid()"", NtGetPid());
  printf(""gs:0x%02x: %-39s = 0x%lx\n"", 0x48, ""NtGetTid()"", NtGetTid());
  printf(""gs:0x%02x: %-39s = 0x%lx\n"", 0x50, ""NtGetRpc()"", _NtGetRpc());
  printf(""gs:0x%02x: %-39s = 0x%lx\n"", 0x58, ""NtGetTls()"", _NtGetTls());
  printf(""gs:0x%02x: %-39s = 0x%lx\n"", 0x60, ""NtGetPeb()"", NtGetPeb());
  printf(""gs:0x%02x: %-39s = 0x%lx\n"", 0x68, ""NtGetErr()"", NtGetErr());
}

void PrintPeb(void) {
  __seg_gs struct NtPeb *peb = NtGetPeb();
  printf(""\n\
╔──────────────────────────────────────────────────────────────────────────────╗\n\
│ new technology § peb                                                         │\n\
╚──────────────────────────────────────────────────────────────────────────────╝\n\
\n"");
  printf(""0x%04x: %-40s = %u\n"", offsetof(struct NtPeb, InheritedAddressSpace),
         ""InheritedAddressSpace"", (unsigned)peb->InheritedAddressSpace);
  printf(""0x%04x: %-40s = %u\n"",
         offsetof(struct NtPeb, ReadImageFileExecOptions),
         ""ReadImageFileExecOptions"", (unsigned)peb->ReadImageFileExecOptions);
  printf(""0x%04x: %-40s = %u\n"", offsetof(struct NtPeb, BeingDebugged),
         ""BeingDebugged"", (unsigned)peb->BeingDebugged);
  printf(""0x%04x: %-40s = %u\n"", offsetof(struct NtPeb, __wut1), ""__wut1"",
         (unsigned)peb->__wut1);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, Mutant), ""Mutant"",
         peb->Mutant);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, ImageBaseAddress),
         ""ImageBaseAddress"", peb->ImageBaseAddress);
  /* struct NtLdr *Ldr; */
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, ProcessParameters),
         ""ProcessParameters"", peb->ProcessParameters);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, SubSystemData),
         ""SubSystemData"", peb->SubSystemData);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, ProcessHeap),
         ""ProcessHeap"", peb->ProcessHeap);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, FastPebLock),
         ""FastPebLock"", peb->FastPebLock);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, __wut3), ""__wut3"",
         peb->__wut3);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, __wut4), ""__wut4"",
         peb->__wut4);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, __wut5), ""__wut5"",
         peb->__wut5);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, KernelCallbackTable),
         ""KernelCallbackTable"", peb->KernelCallbackTable);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, UserSharedInfoPtr),
         ""UserSharedInfoPtr"", peb->UserSharedInfoPtr);
  printf(""0x%04x: %-40s = 0x%x\n"", offsetof(struct NtPeb, SystemReserved),
         ""SystemReserved"", peb->SystemReserved);
  printf(""0x%04x: %-40s = 0x%x\n"", offsetof(struct NtPeb, __wut6), ""__wut6"",
         peb->__wut6);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, __wut7), ""__wut7"",
         peb->__wut7);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, TlsExpansionCounter),
         ""TlsExpansionCounter"", peb->TlsExpansionCounter);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, TlsBitmap),
         ""TlsBitmap"", peb->TlsBitmap);
  printf(""0x%04x: %-40s = 0x%x 0x%x\n"", offsetof(struct NtPeb, TlsBitmapBits),
         ""TlsBitmapBits"", peb->TlsBitmapBits[0], peb->TlsBitmapBits[1]);
  printf(""0x%04x: %-40s = 0x%lx\n"",
         offsetof(struct NtPeb, ReadOnlySharedMemoryBase),
         ""ReadOnlySharedMemoryBase"", peb->ReadOnlySharedMemoryBase);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, __wut8), ""__wut8"",
         peb->__wut8);
  printf(""0x%04x: %-40s = 0x%lx\n"",
         offsetof(struct NtPeb, ReadOnlyStaticServerData),
         ""ReadOnlyStaticServerData"", peb->ReadOnlyStaticServerData);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, AnsiCodePageData),
         ""AnsiCodePageData"", peb->AnsiCodePageData);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, OemCodePageData),
         ""OemCodePageData"", peb->OemCodePageData);
  printf(""0x%04x: %-40s = 0x%lx\n"",
         offsetof(struct NtPeb, UnicodeCaseTableData), ""UnicodeCaseTableData"",
         peb->UnicodeCaseTableData);
  printf(""0x%04x: %-40s = 0x%x\n"", offsetof(struct NtPeb, NumberOfProcessors),
         ""NumberOfProcessors"", peb->NumberOfProcessors);
  printf(""0x%04x: %-40s = 0x%x\n"", offsetof(struct NtPeb, NtGlobalFlag),
         ""NtGlobalFlag"", peb->NtGlobalFlag);
  printf(""0x%04x: %-40s = %ld\n"",
         offsetof(struct NtPeb, CriticalSectionTimeout),
         ""CriticalSectionTimeout"", peb->CriticalSectionTimeout);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, HeapSegmentReserve),
         ""HeapSegmentReserve"", peb->HeapSegmentReserve);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, HeapSegmentCommit),
         ""HeapSegmentCommit"", peb->HeapSegmentCommit);
  printf(""0x%04x: %-40s = 0x%lx\n"",
         offsetof(struct NtPeb, HeapDeCommitTotalFreeThreshold),
         ""HeapDeCommitTotalFreeThreshold"", peb->HeapDeCommitTotalFreeThreshold);
  printf(""0x%04x: %-40s = 0x%lx\n"",
         offsetof(struct NtPeb, HeapDeCommitFreeBlockThreshold),
         ""HeapDeCommitFreeBlockThreshold"", peb->HeapDeCommitFreeBlockThreshold);
  printf(""0x%04x: %-40s = 0x%x\n"", offsetof(struct NtPeb, NumberOfHeaps),
         ""NumberOfHeaps"", peb->NumberOfHeaps);
  printf(""0x%04x: %-40s = 0x%x\n"", offsetof(struct NtPeb, MaximumNumberOfHeaps),
         ""MaximumNumberOfHeaps"", peb->MaximumNumberOfHeaps);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, ProcessHeaps),
         ""ProcessHeaps"", peb->ProcessHeaps);
  printf(""0x%04x: %-40s = 0x%lx\n"",
         offsetof(struct NtPeb, GdiSharedHandleTable), ""GdiSharedHandleTable"",
         peb->GdiSharedHandleTable);
  printf(""0x%04x: %-40s = 0x%lx\n"",
         offsetof(struct NtPeb, ProcessStarterHelper), ""ProcessStarterHelper"",
         peb->ProcessStarterHelper);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, GdiDCAttributeList),
         ""GdiDCAttributeList"", peb->GdiDCAttributeList);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, LoaderLock),
         ""LoaderLock"", peb->LoaderLock);
  printf(""0x%04x: %-40s = 0x%x\n"", offsetof(struct NtPeb, OSMajorVersion),
         ""OSMajorVersion"", peb->OSMajorVersion);
  printf(""0x%04x: %-40s = 0x%x\n"", offsetof(struct NtPeb, OSMinorVersion),
         ""OSMinorVersion"", peb->OSMinorVersion);
  printf(""0x%04x: %-40s = %hu\n"", offsetof(struct NtPeb, OSBuildNumber),
         ""OSBuildNumber"", peb->OSBuildNumber);
  printf(""0x%04x: %-40s = %hu\n"", offsetof(struct NtPeb, OSCSDVersion),
         ""OSCSDVersion"", peb->OSCSDVersion);
  printf(""0x%04x: %-40s = 0x%x\n"", offsetof(struct NtPeb, OSPlatformId),
         ""OSPlatformId"", peb->OSPlatformId);
  printf(""0x%04x: %-40s = 0x%x\n"", offsetof(struct NtPeb, ImageSubsystem),
         ""ImageSubsystem"", peb->ImageSubsystem);
  printf(""0x%04x: %-40s = 0x%x\n"",
         offsetof(struct NtPeb, ImageSubsystemMajorVersion),
         ""ImageSubsystemMajorVersion"", peb->ImageSubsystemMajorVersion);
  printf(""0x%04x: %-40s = 0x%lx\n"",
         offsetof(struct NtPeb, ImageSubsystemMinorVersion),
         ""ImageSubsystemMinorVersion"", peb->ImageSubsystemMinorVersion);
  printf(""0x%04x: %-40s = 0x%lx\n"",
         offsetof(struct NtPeb, ImageProcessAffinityMask),
         ""ImageProcessAffinityMask"", peb->ImageProcessAffinityMask);
  printf(""0x%04x: %-40s = 0x%lx\n"",
         offsetof(struct NtPeb, ActiveProcessAffinityMask),
         ""ActiveProcessAffinityMask"", peb->ActiveProcessAffinityMask);
  /* ""0x%lx"", GdiHandleBuffer[38 - __SIZEOF_POINTER__]; */
  printf(""0x%04x: %-40s = 0x%lx\n"",
         offsetof(struct NtPeb, PostProcessInitRoutine),
         ""PostProcessInitRoutine"", peb->PostProcessInitRoutine);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, TlsExpansionBitmap),
         ""TlsExpansionBitmap"", peb->TlsExpansionBitmap);
  /* ""0x%x"", TlsExpansionBitmapBits[32]; */
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, SessionId),
         ""SessionId"", peb->SessionId);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, AppCompatFlags),
         ""AppCompatFlags"", peb->AppCompatFlags);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, AppCompatFlagsUser),
         ""AppCompatFlagsUser"", peb->AppCompatFlagsUser);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, pShimData),
         ""pShimData"", peb->pShimData);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, AppCompatInfo),
         ""AppCompatInfo"", peb->AppCompatInfo);
  printf(""0x%04x: %-40s = 0x%lx\n"",
         offsetof(struct NtPeb, ActivationContextData), ""ActivationContextData"",
         peb->ActivationContextData);
  printf(""0x%04x: %-40s = 0x%lx\n"",
         offsetof(struct NtPeb, ProcessAssemblyStorageMap),
         ""ProcessAssemblyStorageMap"", peb->ProcessAssemblyStorageMap);
  printf(""0x%04x: %-40s = 0x%lx\n"",
         offsetof(struct NtPeb, SystemDefaultActivationContextData),
         ""SystemDefaultActivationContextData"",
         peb->SystemDefaultActivationContextData);
  printf(""0x%04x: %-40s = 0x%lx\n"",
         offsetof(struct NtPeb, SystemAssemblyStorageMap),
         ""SystemAssemblyStorageMap"", peb->SystemAssemblyStorageMap);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtPeb, MinimumStackCommit),
         ""MinimumStackCommit"", peb->MinimumStackCommit);
}

void PrintPebLdr(void) {
  printf(""\n\
╔──────────────────────────────────────────────────────────────────────────────╗\n\
│ new technology § peb » ldr                                                   │\n\
╚──────────────────────────────────────────────────────────────────────────────╝\n\
\n"");
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtLdr, SizeOfThis),
         ""SizeOfThis"", NtGetPeb()->Ldr->SizeOfThis);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtLdr, IsInitialized),
         ""IsInitialized"", NtGetPeb()->Ldr->IsInitialized);
  printf(""0x%04x: %-40s = 0x%lx\n"", offsetof(struct NtLdr, SsHandle),
         ""SsHandle"", NtGetPeb()->Ldr->SsHandle);
  printf(""0x%04x: %-40s = 0x%lx\n"",
         offsetof(struct NtLdr, InLoadOrderModuleList), ""InLoadOrderModuleList"",
         NtGetPeb()->Ldr->InLoadOrderModuleList);
  printf(""0x%04x: %-40s = 0x%lx\n"",
         offsetof(struct NtLdr, InMemoryOrderModuleList),
         ""InMemoryOrderModuleList"", NtGetPeb()->Ldr->InMemoryOrderModuleList);
  printf(""0x%04x: %-40s = 0x%lx\n"",
         offsetof(struct NtLdr, InInitOrderModuleList), ""InInitOrderModuleList"",
         NtGetPeb()->Ldr->InInitOrderModuleList);
}

void PrintModulesLoadOrder(void) {
  {
    printf(""\n\
╔──────────────────────────────────────────────────────────────────────────────╗\n\
│ new technology § modules » load order                                        │\n\
╚──────────────────────────────────────────────────────────────────────────────╝\n\
\n"");
    struct NtLinkedList *head = &NtGetPeb()->Ldr->InLoadOrderModuleList;
    struct NtLinkedList *ldr = head->Next;
    do {
      const struct NtLdrDataTableEntry *dll =
          (const struct NtLdrDataTableEntry *)ldr;
      /* struct NtLinkedList InLoadOrderLinks; /\* msdn:reserved *\/ */
      /* struct NtLinkedList InMemoryOrderLinks; */
      /* struct NtLinkedList InInitOrderLinks; /\* msdn:reserved *\/ */
      printf(""%p\n"", ldr);
      printf(""%p vs. %p\n"", dll, GetModuleHandleW(dll->FullDllName.Data));
      printf(""0x%04x: %-40s = 0x%lx\n"",
             offsetof(struct NtLdrDataTableEntry, DllBase), ""DllBase"",
             dll->DllBase);
      printf(""0x%04x: %-40s = 0x%lx\n"",
             offsetof(struct NtLdrDataTableEntry, EntryPoint), ""EntryPoint"",
             dll->EntryPoint);
      printf(""0x%04x: %-40s = 0x%x\n"",
             offsetof(struct NtLdrDataTableEntry, SizeOfImage), ""SizeOfImage"",
             dll->SizeOfImage);
      printf(""0x%04x: %-40s = \""%s\""\n"",
             offsetof(struct NtLdrDataTableEntry, FullDllName), ""FullDllName"",
             GetString(&dll->FullDllName));
      printf(""0x%04x: %-40s = \""%s\""\n"",
             offsetof(struct NtLdrDataTableEntry, BaseDllName), ""BaseDllName"",
             GetString(&dll->BaseDllName));
      printf(""0x%04x: %-40s = 0x%x\n"",
             offsetof(struct NtLdrDataTableEntry, Flags), ""Flags"", dll->Flags);
      printf(""0x%04x: %-40s = %hu\n"",
             offsetof(struct NtLdrDataTableEntry, Load_Count), ""Load_Count"",
             dll->Load_Count);
      printf(""0x%04x: %-40s = %hu\n"",
             offsetof(struct NtLdrDataTableEntry, TlsIndex), ""TlsIndex"",
             dll->TlsIndex);
      /* union { */
      /*   struct NtLinkedList HashLinks; */
      /*   struct { */
      /*     void *SectionPointer; */
      /*     uint32_t CheckSum; */
      /*   }; */
      /* }; */
      /* union { */
      /*   void *LoadedImports; */
      /*   uint32_t TimeDateStamp; */
      /* }; */
      printf(""0x%04x: %-40s = 0x%lx\n"",
             offsetof(struct NtLdrDataTableEntry, EntryPointActivationContext),
             ""EntryPointActivationContext"", dll->EntryPointActivationContext);
      printf(""0x%04x: %-40s = 0x%lx\n"",
             offsetof(struct NtLdrDataTableEntry, PatchInformation),
             ""PatchInformation"", dll->PatchInformation);
      /* struct NtLinkedList ForwarderLinks; */
      /* struct NtLinkedList ServiceTagLinks; */
      /* struct NtLinkedList StaticLinks; */
      printf(""0x%04x: %-40s = 0x%lx\n"",
             offsetof(struct NtLdrDataTableEntry, ContextInformation),
             ""ContextInformation"", dll->ContextInformation);
      printf(""0x%04x: %-40s = 0x%lx\n"",
             offsetof(struct NtLdrDataTableEntry, OriginalBase), ""OriginalBase"",
             dll->OriginalBase);
      printf(""0x%04x: %-40s = %ld\n"",
             offsetof(struct NtLdrDataTableEntry, LoadTime), ""LoadTime"",
             dll->LoadTime);
      printf(""\n"");
    } while ((ldr = ldr->Next) && ldr != head);
  }
}

void PrintModulesMemoryOrder(void) {
  {
    printf(""\n\
╔──────────────────────────────────────────────────────────────────────────────╗\n\
│ new technology § modules » memory order                                      │\n\
╚──────────────────────────────────────────────────────────────────────────────╝\n\
\n"");
    struct NtLinkedList *head = &NtGetPeb()->Ldr->InMemoryOrderModuleList;
    struct NtLinkedList *ldr = head->Next;
    do {
      const struct NtLdrDataTableEntry *dll =
          (const struct NtLdrDataTableEntry *)ldr;
      /* struct NtLinkedList InLoadOrderLinks; /\* msdn:reserved *\/ */
      /* struct NtLinkedList InMemoryOrderLinks; */
      /* struct NtLinkedList InInitOrderLinks; /\* msdn:reserved *\/ */
      printf(""%p\n"", dll);
      printf(""0x%04x: %-40s = 0x%lx\n"",
             offsetof(struct NtLdrDataTableEntry, DllBase), ""DllBase"",
             dll->DllBase);
      printf(""0x%04x: %-40s = 0x%lx\n"",
             offsetof(struct NtLdrDataTableEntry, EntryPoint), ""EntryPoint"",
             dll->EntryPoint);
      printf(""0x%04x: %-40s = 0x%x\n"",
             offsetof(struct NtLdrDataTableEntry, SizeOfImage), ""SizeOfImage"",
             dll->SizeOfImage);
      printf(""0x%04x: %-40s = \""%s\""\n"",
             offsetof(struct NtLdrDataTableEntry, FullDllName), ""FullDllName"",
             GetString(&dll->FullDllName));
      printf(""0x%04x: %-40s = \""%s\""\n"",
             offsetof(struct NtLdrDataTableEntry, BaseDllName), ""BaseDllName"",
             GetString(&dll->BaseDllName));
      printf(""0x%04x: %-40s = 0x%x\n"",
             offsetof(struct NtLdrDataTableEntry, Flags), ""Flags"", dll->Flags);
      printf(""0x%04x: %-40s = %hu\n"",
             offsetof(struct NtLdrDataTableEntry, Load_Count), ""Load_Count"",
             dll->Load_Count);
      printf(""0x%04x: %-40s = %hu\n"",
             offsetof(struct NtLdrDataTableEntry, TlsIndex), ""TlsIndex"",
             dll->TlsIndex);
      /* /\* union { *\/ */
      /* /\*   struct NtLinkedList HashLinks; *\/ */
      /* /\*   struct { *\/ */
      /* /\*     void *SectionPointer; *\/ */
      /* /\*     uint32_t CheckSum; *\/ */
      /* /\*   }; *\/ */
      /* /\* }; *\/ */
      /* /\* union { *\/ */
      /* /\*   void *LoadedImports; *\/ */
      /* /\*   uint32_t TimeDateStamp; *\/ */
      /* /\* }; *\/ */
      /* printf(""0x%04x: %-40s = 0x%lx\n"", */
      /*        offsetof(struct NtLdrDataTableEntry,
       * EntryPointActivationContext), */
      /*        ""EntryPointActivationContext"",
       * dll->EntryPointActivationContext); */
      /* printf(""0x%04x: %-40s = 0x%lx\n"", */
      /*        offsetof(struct NtLdrDataTableEntry, PatchInformation), */
      /*        ""PatchInformation"", dll->PatchInformation); */
      /* /\* struct NtLinkedList ForwarderLinks; *\/ */
      /* /\* struct NtLinkedList ServiceTagLinks; *\/ */
      /* /\* struct NtLinkedList StaticLinks; *\/ */
      /* printf(""0x%04x: %-40s = 0x%lx\n"", */
      /*        offsetof(struct NtLdrDataTableEntry, ContextInformation), */
      /*        ""ContextInformation"", dll->ContextInformation); */
      /* printf(""0x%04x: %-40s = 0x%lx\n"", */
      /*        offsetof(struct NtLdrDataTableEntry, OriginalBase),
       * ""OriginalBase"", */
      /*        dll->OriginalBase); */
      /* printf(""0x%04x: %-40s = %ld\n"", */
      /*        offsetof(struct NtLdrDataTableEntry, LoadTime), ""LoadTime"", */
      /*        dll->LoadTime); */
      printf(""\n"");
    } while ((ldr = ldr->Next) && ldr != head);
  }
}

int main(int argc, char *argv[]) {
  if (IsLinux()) {
    return NextBestThing();
  }
  if (!IsWindows()) {
    fprintf(stderr, ""error: this tool is intended for windows\n"");
    return 1;
  }
  PrintStartupInfo();
  PrintSystemInfo();
  PrintStdioInfo();
  PrintTeb();
  PrintPeb();
  PrintPebLdr();
  PrintModulesLoadOrder();
  PrintModulesMemoryOrder();
  return 0;
}

#else
int main(int argc, char *argv[]) {
  fprintf(stderr, ""printpeb not supported on this cpu arch or build config\n"");
  return 1;
}
#endif /* __x86_64__ && SupportsWindows() */
"
./repos/cosmopolitan/tool/viz/memzoom.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""dsp/scale/cdecimate2xuint8x8.h""
#include ""libc/calls/calls.h""
#include ""libc/calls/struct/sigaction.h""
#include ""libc/calls/struct/siginfo.h""
#include ""libc/calls/struct/stat.h""
#include ""libc/calls/struct/termios.h""
#include ""libc/calls/struct/winsize.h""
#include ""libc/calls/termios.h""
#include ""libc/calls/ucontext.h""
#include ""libc/dce.h""
#include ""libc/errno.h""
#include ""libc/fmt/conv.h""
#include ""libc/fmt/itoa.h""
#include ""libc/intrin/bsf.h""
#include ""libc/intrin/bsr.h""
#include ""libc/intrin/hilbert.h""
#include ""libc/intrin/safemacros.internal.h""
#include ""libc/limits.h""
#include ""libc/log/log.h""
#include ""libc/macros.internal.h""
#include ""libc/runtime/runtime.h""
#include ""libc/sock/sock.h""
#include ""libc/sock/struct/pollfd.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#include ""libc/str/tab.internal.h""
#include ""libc/str/unicode.h""
#include ""libc/sysv/consts/ex.h""
#include ""libc/sysv/consts/exit.h""
#include ""libc/sysv/consts/fileno.h""
#include ""libc/sysv/consts/map.h""
#include ""libc/sysv/consts/o.h""
#include ""libc/sysv/consts/poll.h""
#include ""libc/sysv/consts/prot.h""
#include ""libc/sysv/consts/sig.h""
#include ""libc/sysv/consts/termios.h""
#include ""libc/time/time.h""
#include ""third_party/getopt/getopt.internal.h""

#define USAGE \
  "" [-hznmHNW] [-p PID] [PATH]\n\
\n\
DESCRIPTION\n\
\n\
  Memory Viewer\n\
\n\
FLAGS\n\
\n\
  -h or -?   help\n\
  -z         zoom\n\
  -m         morton ordering\n\
  -H         hilbert ordering\n\
  -N         natural scrolling\n\
  -W         white terminal background\n\
  -p PID     shows process virtual memory\n\
  -f INT     frames per second [default 10]\n\
\n\
SHORTCUTS\n\
\n\
  z or +     zoom\n\
  Z or -     unzoom\n\
  ctrl+wheel zoom point\n\
  wheel      scroll\n\
  l          linearize\n\
  m          mortonize\n\
  h          hilbertify\n\
  n          next mapping\n\
  N          next mapping ending\n\
  p          prev mapping\n\
  P          prev mapping ending\n\
  k          up\n\
  j          down\n\
  b          page up\n\
  space      page down\n\
  g          home\n\
  G          end\n\
  q          quit\n\
\n""

#define CTRL(C) ((C) ^ 0100)

#define MAXZOOM 14
#define COLOR   253

#define LINEAR  0
#define MORTON  1
#define HILBERT 2

#define INTERRUPTED 0x1
#define RESIZED     0x2

#define MOUSE_LEFT_DOWN       0
#define MOUSE_MIDDLE_DOWN     1
#define MOUSE_RIGHT_DOWN      2
#define MOUSE_LEFT_UP         4
#define MOUSE_MIDDLE_UP       5
#define MOUSE_RIGHT_UP        6
#define MOUSE_LEFT_DRAG       32
#define MOUSE_MIDDLE_DRAG     33
#define MOUSE_RIGHT_DRAG      34
#define MOUSE_WHEEL_UP        64
#define MOUSE_WHEEL_DOWN      65
#define MOUSE_CTRL_WHEEL_UP   80
#define MOUSE_CTRL_WHEEL_DOWN 81

struct Ranges {
  long i;
  struct Range {
    long a;
    long b;
  } p[512];
};

static const signed char kThePerfectKernel[8] = {-1, -3, 3, 17, 17, 3, -3, -1};

static bool white;
static bool natural;
static bool mousemode;

static int fd;
static int pid;
static int out;
static int fps;
static int zoom;
static int order;
static int action;

static long tyn;
static long txn;
static long size;
static long offset;
static long lowest;
static long highest;
static long canvassize;
static long buffersize;
static long displaysize;

static char *buffer;
static uint8_t *canvas;

static struct stat st;
static struct Ranges ranges;
static struct termios oldterm;

static char path[PATH_MAX];
static char mapspath[PATH_MAX];

static int Write(const char *s) {
  return write(out, s, strlen(s));
}

static void HideCursor(void) {
  Write(""\e[?25l"");
}

static void ShowCursor(void) {
  Write(""\e[?25h"");
}

static void EnableMouse(void) {
  mousemode = true;
  Write(""\e[?1000;1002;1015;1006h"");
}

static void DisableMouse(void) {
  mousemode = false;
  Write(""\e[?1000;1002;1015;1006l"");
}

static void LeaveScreen(void) {
  Write(""\e[H\e[J"");
}

static unsigned long rounddown2pow(unsigned long x) {
  return x ? 1ul << bsrl(x) : 0;
}

static void GetTtySize(void) {
  struct winsize wsize;
  wsize.ws_row = tyn + 1;
  wsize.ws_col = txn;
  tcgetwinsize(out, &wsize);
  tyn = MAX(2, wsize.ws_row) - 1;
  txn = MAX(17, wsize.ws_col) - 16;
  tyn = rounddown2pow(tyn);
  txn = rounddown2pow(txn);
  tyn = MIN(tyn, txn);
}

static void EnableRaw(void) {
  struct termios term;
  memcpy(&term, &oldterm, sizeof(term));
  term.c_cc[VMIN] = 1;
  term.c_cc[VTIME] = 1;
  term.c_iflag &= ~(INPCK | ISTRIP | PARMRK | INLCR | IGNCR | ICRNL | IXON);
  term.c_lflag &= ~(IEXTEN | ICANON | ECHO | ECHONL);
  term.c_cflag &= ~(CSIZE | PARENB);
  term.c_cflag |= CS8;
  term.c_iflag |= IUTF8;
  tcsetattr(out, TCSANOW, &term);
}

static void OnExit(void) {
  LeaveScreen();
  ShowCursor();
  DisableMouse();
  tcsetattr(out, TCSANOW, &oldterm);
}

static void OnSigInt(int sig, struct siginfo *sa, void *uc) {
  action |= INTERRUPTED;
}

static void OnSigWinch(int sig, struct siginfo *sa, void *uc) {
  action |= RESIZED;
}

static void Setup(void) {
  tyn = 80;
  txn = 24;
  action = RESIZED;
  tcgetattr(out, &oldterm);
  HideCursor();
  EnableRaw();
  EnableMouse();
  atexit(OnExit);
  sigaction(SIGINT, &(struct sigaction){.sa_sigaction = OnSigInt}, NULL);
  sigaction(SIGWINCH, &(struct sigaction){.sa_sigaction = OnSigWinch}, NULL);
}

static wontreturn void FailPath(const char *s, int rc) {
  Write(""error: "");
  Write(s);
  Write("": "");
  Write(path);
  Write(""\n"");
  exit(rc);
}

static void SetExtent(long lo, long hi) {
  lowest = lo;
  highest = hi;
  offset = MIN(hi, MAX(lo, offset));
}

static void Open(void) {
  if ((fd = open(path, O_RDONLY)) == -1) {
    FailPath(""open() failed"", errno);
  }
  fstat(fd, &st);
  size = st.st_size;
  SetExtent(0, size);
}

static void *Allocate(size_t n) {
  return mmap(NULL, n, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1,
              0);
}

static void SetupCanvas(void) {
  if (canvassize) {
    munmap(canvas, canvassize);
    munmap(buffer, buffersize);
  }
  displaysize = ROUNDUP(ROUNDUP((tyn * txn) << zoom, 16), 1ul << zoom);
  canvassize = ROUNDUP(displaysize, FRAMESIZE);
  buffersize = ROUNDUP(tyn * txn * 16 + 4096, FRAMESIZE);
  canvas = Allocate(canvassize);
  buffer = Allocate(buffersize);
}

/**
 * Interleaves bits.
 * @see https://en.wikipedia.org/wiki/Z-order_curve
 * @see unmorton()
 */
static unsigned long morton(unsigned long y, unsigned long x) {
  x = (x | x << 020) & 0x0000FFFF0000FFFF;
  x = (x | x << 010) & 0x00FF00FF00FF00FF;
  x = (x | x << 004) & 0x0F0F0F0F0F0F0F0F;
  x = (x | x << 002) & 0x3333333333333333;
  x = (x | x << 001) & 0x5555555555555555;
  y = (y | y << 020) & 0x0000FFFF0000FFFF;
  y = (y | y << 010) & 0x00FF00FF00FF00FF;
  y = (y | y << 004) & 0x0F0F0F0F0F0F0F0F;
  y = (y | y << 002) & 0x3333333333333333;
  y = (y | y << 001) & 0x5555555555555555;
  return x | y << 1;
}

static long IndexSquare(long y, long x) {
  switch (order) {
    case LINEAR:
      return y * txn + x;
    case MORTON:
      return morton(y, x);
    case HILBERT:
      return hilbert(txn, y, x);
    default:
      return 0;
  }
}

static long Index(long y, long x) {
  long i;
  if (order == LINEAR) {
    i = 0;
  } else {
    i = x / tyn;
    x = x % tyn;
  }
  return i * tyn * tyn + IndexSquare(y, x);
}

static void PreventBufferbloat(void) {
  struct timespec now, rate;
  static struct timespec last;
  now = timespec_real();
  rate = timespec_frommicros(1. / fps * 1e6);
  if (timespec_cmp(timespec_sub(now, last), rate) < 0) {
    timespec_sleep(timespec_sub(rate, timespec_sub(now, last)));
  }
  last = now;
}

static bool HasPendingInput(void) {
  struct pollfd fds[1];
  if (IsWindows()) return true; /* XXX */
  fds[0].fd = 0;
  fds[0].events = POLLIN;
  fds[0].revents = 0;
  poll(fds, ARRAYLEN(fds), 0);
  return fds[0].revents & (POLLIN | POLLERR);
}

static int GetCurrentRange(void) {
  int i;
  if (ranges.i) {
    for (i = 0; i < ranges.i; ++i) {
      if (offset < ranges.p[i].a) return MAX(0, i - 1);
      if (offset < ranges.p[i].b) return i;
    }
    return ranges.i - 1;
  } else {
    return -1;
  }
}

static void Move(long d) {
  d <<= zoom;
  offset = MIN(highest, MAX(lowest, (offset + d) >> zoom << zoom));
}

static void SetZoom(long y, long x, int d) {
  long a, b, i;
  if ((0 <= y && y < tyn) && (0 <= x && x < txn)) {
    i = Index(y, x);
    a = zoom;
    b = MIN(MAXZOOM, MAX(0, a + d));
    zoom = b;
    Move((i << a) - (i << b));
    SetupCanvas();
  }
}

static void OnZoom(long y, long x) {
  SetZoom(y, x, +1);
}

static void OnUnzoom(long y, long x) {
  SetZoom(y, x, -1);
}

static void OnUp(void) {
  Move(-(txn));
}

static void OnDown(void) {
  Move(txn);
}

static void OnPageUp(void) {
  Move(-(txn * (tyn - 2)));
}

static void OnPageDown(void) {
  Move(txn * (tyn - 2));
}

static void OnHome(void) {
  offset = lowest;
}

static void OnEnd(void) {
  offset = MAX(lowest, highest - txn * tyn);
}

static void OnLinear(void) {
  order = LINEAR;
  GetTtySize();
  SetupCanvas();
}

static void OnMorton(void) {
  order = MORTON;
  SetupCanvas();
}

static void OnHilbert(void) {
  order = HILBERT;
  SetupCanvas();
}

static void OnNext(void) {
  int i;
  if ((i = GetCurrentRange()) != -1) {
    if (i + 1 < ranges.i) {
      offset = ranges.p[i + 1].a;
    }
  }
}

static void OnPrev(void) {
  int i;
  if ((i = GetCurrentRange()) != -1) {
    if (i) {
      offset = ranges.p[i - 1].a;
    }
  }
}

static void OnNextEnd(void) {
  long i, n;
  if ((i = GetCurrentRange()) != -1) {
    n = (tyn * txn) << zoom;
    if (offset < ranges.p[i].b - n) {
      offset = ranges.p[i].b - n;
    } else if (i + 1 < ranges.i) {
      offset = MAX(ranges.p[i + 1].a, ranges.p[i + 1].b - n);
    }
  }
}

static void OnPrevEnd(void) {
  long i, n;
  if ((i = GetCurrentRange()) != -1) {
    n = (tyn * txn) << zoom;
    if (i) {
      offset = MAX(ranges.p[i - 1].a, ranges.p[i - 1].b - n);
    }
  }
}

static void OnMouse(char *p) {
  int e, x, y;
  e = strtol(p, &p, 10);
  if (*p == ';') ++p;
  x = min(txn, max(1, strtol(p, &p, 10))) - 1;
  if (*p == ';') ++p;
  y = min(tyn, max(1, strtol(p, &p, 10))) - 1;
  e |= (*p == 'm') << 2;
  switch (e) {
    case MOUSE_WHEEL_UP:
      if (natural) {
        OnDown();
        OnDown();
        OnDown();
      } else {
        OnUp();
        OnUp();
        OnUp();
      }
      break;
    case MOUSE_WHEEL_DOWN:
      if (natural) {
        OnUp();
        OnUp();
        OnUp();
      } else {
        OnDown();
        OnDown();
        OnDown();
      }
      break;
    case MOUSE_CTRL_WHEEL_UP:
      if (natural) {
        OnZoom(y, x);
      } else {
        OnUnzoom(y, x);
      }
      break;
    case MOUSE_CTRL_WHEEL_DOWN:
      if (natural) {
        OnUnzoom(y, x);
      } else {
        OnZoom(y, x);
      }
      break;
    default:
      break;
  }
}

static void ReadKeyboard(void) {
  char buf[32], *p = buf;
  bzero(buf, sizeof(buf));
  if (readansi(0, buf, sizeof(buf)) == -1) {
    if (errno == EINTR) return;
    exit(errno);
  }
  switch (*p++) {
    case 'q':
      exit(0);
    case '+':
    case 'z':
      OnZoom(0, 0);
      break;
    case '-':
    case 'Z':
      OnUnzoom(0, 0);
      break;
    case 'b':
      OnPageUp();
      break;
    case 'n':
      OnNext();
      break;
    case 'p':
      OnPrev();
      break;
    case 'N':
      OnNextEnd();
      break;
    case 'P':
      OnPrevEnd();
      break;
    case ' ':
    case CTRL('V'):
      OnPageDown();
      break;
    case 'g':
      OnHome();
      break;
    case 'G':
      OnEnd();
      break;
    case 'k':
    case CTRL('P'):
      OnUp();
      break;
    case 'j':
    case CTRL('N'):
      OnDown();
      break;
    case 'l':
      OnLinear();
      break;
    case 'm':
      if (order == MORTON) {
        OnLinear();
      } else {
        OnMorton();
      }
      break;
    case 'M':
      if (mousemode) {
        DisableMouse();
      } else {
        EnableMouse();
      }
      break;
    case 'h':
    case 'H':
      if (order == HILBERT) {
        OnLinear();
      } else {
        OnHilbert();
      }
      break;
    case '\e':
      switch (*p++) {
        case 'v':
          OnPageUp();
          break;
        case '[':
          switch (*p++) {
            case '<':
              OnMouse(p);
              break;
            case 'A':
              OnUp();
              break;
            case 'B':
              OnDown();
              break;
            case 'F':
              OnEnd();
              break;
            case 'H':
              OnHome();
              break;
            case '1':
              switch (*p++) {
                case '~':
                  OnHome();
                  break;
                default:
                  break;
              }
              break;
            case '4':
              switch (*p++) {
                case '~':
                  OnEnd();
                  break;
                default:
                  break;
              }
              break;
            case '5':
              switch (*p++) {
                case '~':
                  OnPageUp();
                  break;
                default:
                  break;
              }
              break;
            case '6':
              switch (*p++) {
                case '~':
                  OnPageDown();
                  break;
                default:
                  break;
              }
              break;
            case '7':
              switch (*p++) {
                case '~':
                  OnHome();
                  break;
                default:
                  break;
              }
              break;
            case '8':
              switch (*p++) {
                case '~':
                  OnEnd();
                  break;
                default:
                  break;
              }
              break;
            default:
              break;
          }
          break;
        default:
          break;
      }
      break;
    default:
      break;
  }
}

static void LoadRanges(void) {
  char b[512];
  struct Range range;
  int i, t, n, fd, err;
  if ((fd = open(mapspath, O_RDONLY)) == -1) {
    err = errno;
    Write(""error: process died\n"");
    exit(err);
  }
  t = 0;
  range.a = 0;
  range.b = 0;
  ranges.i = 0;
  for (;;) {
    if ((n = read(fd, b, sizeof(b))) == -1) exit(1);
    if (!n) break;
    for (i = 0; i < n; ++i) {
      switch (t) {
        case 0:
          if (isxdigit(b[i])) {
            range.a <<= 4;
            range.a += kHexToInt[b[i] & 255];
          } else if (b[i] == '-') {
            t = 1;
          }
          break;
        case 1:
          if (isxdigit(b[i])) {
            range.b <<= 4;
            range.b += kHexToInt[b[i] & 255];
          } else if (b[i] == ' ') {
            t = 2;
          }
          break;
        case 2:
          if (b[i] == '\n') {
            if (ranges.i < ARRAYLEN(ranges.p)) {
              ranges.p[ranges.i++] = range;
            }
            range.a = 0;
            range.b = 0;
            t = 0;
          }
          break;
        default:
          __builtin_unreachable();
      }
    }
  }
  close(fd);
  if (ranges.i) {
    SetExtent(ranges.p[0].a, ranges.p[ranges.i - 1].b);
  } else {
    SetExtent(0, 0);
  }
}

static int InvertXtermGreyscale(int x) {
  return -(x - 232) + 255;
}

static void Render(void) {
  char *p;
  int c, fg2, rc, fg;
  long i, y, x, w, n, got;
  p = buffer;
  p = stpcpy(p, ""\e[H"");
  for (y = 0; y < tyn; ++y) {
    fg = -1;
    for (x = 0; x < txn; ++x) {
      c = canvas[Index(y, x)];
      if (c < 32) {
        fg2 = 237 + c * ((COLOR - 237) / 32.);
      } else if (c >= 232) {
        fg2 = COLOR + (c - 232) * ((255 - COLOR) / (256. - 232));
      } else {
        fg2 = COLOR;
      }
      if (fg2 != fg) {
        fg = fg2;
        if (white) {
          fg = InvertXtermGreyscale(fg);
        }
        p = stpcpy(p, ""\e[38;5;"");
        p = FormatInt64(p, fg);
        *p++ = 'm';
      }
      w = tpenc(kCp437[c]);
      do {
        *p++ = w & 0xff;
        w >>= 8;
      } while (w);
    }
    p = stpcpy(p, ""\e[0m "");
    p += uint64toarray_radix16(offset + ((y * txn) << zoom), p);
    p = stpcpy(p, ""\e[K\r\n"");
  }
  p = stpcpy(p, ""\e[7m\e[K"");
  n = strlen(path);
  if (n > txn - 3 - 1 - 7) {
    p = mempcpy(p, path, txn - 1 - 7 - 3);
    p = stpcpy(p, ""..."");
  } else {
    p = stpcpy(p, path);
    for (i = n; i < txn - 1 - 7; ++i) {
      *p++ = ' ';
    }
  }
  p = stpcpy(p, "" memzoom\e[0m "");
  if (!pid) {
    p = FormatUint32(p, MIN(offset / (long double)size * 100, 100));
    p = stpcpy(p, ""%-"");
    p = FormatUint32(
        p,
        MIN((offset + ((tyn * txn) << zoom)) / (long double)size * 100, 100));
    p = stpcpy(p, ""% "");
  }
  p = FormatUint32(p, 1L << zoom);
  p = stpcpy(p, ""x\e[J"");
  PreventBufferbloat();
  for (i = 0, n = p - buffer; i < n; i += got) {
    got = 0;
    if ((rc = write(out, buffer + i, n - i)) == -1) {
      if (errno == EINTR) continue;
      exit(errno);
    }
    got = rc;
  }
}

static void Zoom(long have) {
  long i, n, r;
  n = canvassize;
  for (i = 0; i < zoom; ++i) {
    cDecimate2xUint8x8(n, canvas, kThePerfectKernel);
    n >>= 1;
  }
  if (n < tyn * txn) {
    bzero(canvas + n, canvassize - n);
  }
  if (have != -1) {
    n = have >> zoom;
    i = n / txn;
    r = n % txn;
    if (r) ++i;
    if (order == LINEAR) {
      for (; i < tyn; ++i) {
        canvas[txn * i] = '~';
      }
    }
  }
}

static void FileZoom(void) {
  long have;
  have = MIN(displaysize, size - offset);
  have = pread(fd, canvas, have, offset);
  have = MAX(0, have);
  bzero(canvas + have, canvassize - have);
  Zoom(have);
  Render();
}

static void RangesZoom(void) {
  long a, b, c, d, i;
  LoadRanges();
  memset(canvas, 1, canvassize);
  a = offset;
  b = MIN(highest, offset + ((tyn * txn) << zoom));
  for (i = 0; i < ranges.i; ++i) {
    if ((a >= ranges.p[i].a && a < ranges.p[i].b) ||
        (b >= ranges.p[i].a && b < ranges.p[i].b) ||
        (a < ranges.p[i].a && b >= ranges.p[i].b)) {
      c = MAX(a, ranges.p[i].a);
      d = MIN(b, ranges.p[i].b);
      pread(fd, canvas + (c - offset), d - c, c);
    }
  }
  Zoom(-1);
  Render();
}

static void MemZoom(void) {
  bool ok;
  ok = false;
  do {
    if (action & RESIZED) {
      GetTtySize();
      SetupCanvas();
      action &= ~RESIZED;
    }
    if (ok && HasPendingInput()) {
      ReadKeyboard();
      if (!IsWindows()) continue; /* XXX */
    }
    ok = true;
    if (pid) {
      RangesZoom();
    } else {
      FileZoom();
    }
  } while (!(action & INTERRUPTED));
}

static wontreturn void PrintUsage(int rc, int fd) {
  tinyprint(fd, ""SYNOPSIS\n\n "", program_invocation_name, USAGE, NULL);
  exit(rc);
}

static void GetOpts(int argc, char *argv[]) {
  int opt;
  char *p;
  fps = 10;
  while ((opt = getopt(argc, argv, ""?hmzHNWf:p:"")) != -1) {
    switch (opt) {
      case 'z':
        ++zoom;
        break;
      case 'm':
        order = MORTON;
        break;
      case 'H':
        order = HILBERT;
        break;
      case 'W':
        white = true;
        break;
      case 'N':
        natural = true;
        break;
      case 'f':
        fps = strtol(optarg, NULL, 0);
        fps = MAX(1, fps);
        break;
      case 'p':
        if (strcmp(optarg, ""self"") == 0) {
          pid = getpid();
        } else {
          pid = strtol(optarg, NULL, 0);
        }
        break;
      case 'h':
      case '?':
      default:
        if (opt == optopt) {
          PrintUsage(EXIT_SUCCESS, STDOUT_FILENO);
        } else {
          PrintUsage(EX_USAGE, STDERR_FILENO);
        }
    }
  }
  if (pid) {
    p = stpcpy(path, ""/proc/"");
    p = FormatInt64(p, pid);
    stpcpy(p, ""/mem"");
    p = stpcpy(mapspath, ""/proc/"");
    p = FormatInt64(p, pid);
    stpcpy(p, ""/maps"");
  } else {
    if (optind == argc) {
      PrintUsage(EX_USAGE, STDERR_FILENO);
    }
    if (!memccpy(path, argv[optind], '\0', sizeof(path))) {
      PrintUsage(EX_USAGE, STDERR_FILENO);
    }
  }
}

int main(int argc, char *argv[]) {
  if (!NoDebug()) ShowCrashReports();
  out = 1;
  GetOpts(argc, argv);
  Open();
  Setup();
  MemZoom();
  return 0;
}
"
./repos/cosmopolitan/tool/viz/bd.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2021 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/stdio/stdio.h""

/**
 * @fileoverview Braille Dump
 *
 * Written by Justine Tunney <jtunney@gmail.com>
 * https://twitter.com/justinetunney
 *
 * Designed by Ange Albertini (corkami)
 * https://twitter.com/angealbertini
 *
 * See also `hexdump -C`.
 */

const wchar_t K[256] = L""▁☺☻♥♦♣♠•◘○◙♂♀♪♫☼""  /* 0x00 */
                       L""►◄↕‼¶§▬↨↑↓→←∟↔▲▼""  /* 0x10 */
                       L"" !\""#$%&'()*+,-./"" /* 0x20 */
                       L""0123456789:;<=>?""  /* 0x30 */
                       L""@ABCDEFGHIJKLMNO""  /* 0x40 */
                       L""PQRSTUVWXYZ[\\]^_"" /* 0x50 */
                       L""`abcdefghijklmno""  /* 0x60 */
                       L""pqrstuvwxyz{|}~⌂""  /* 0x70 */
                       L""█⡀⢀⣀⠠⡠⢠⣠⠄⡄⢄⣄⠤⡤⢤⣤""  /* 0x80 */
                       L""⠁⡁⢁⣁⠡⡡⢡⣡⠅⡅⢅⣅⠥⡥⢥⣥""  /* 0x90 */
                       L""⠃⡃⢃⣃⠣⡣⢣⣣⠇⡇⢇⣇⠧⡧⢧⣧""  /* 0xa0 */
                       L""⠉⡉⢉⣉⠩⡩⢩⣩⠍⡍⢍⣍⠭⡭⢭⣭""  /* 0xb0 */
                       L""⠊⡊⢊⣊⠪⡪⢪⣪⠎⡎⢎⣎⠮⡮⢮⣮""  /* 0xc0 */
                       L""⠑⡑⢑⣑⠱⡱⢱⣱⠕⡕⢕⣕⠵⡵⢵⣵""  /* 0xd0 */
                       L""⠚⡚⢚⣚⠺⡺⢺⣺⠞⡞⢞⣞⠾⡾⢾⣾""  /* 0xe0 */
                       L""⠛⡛⢛⣛⠻⡻⢻⣻⠟⡟⢟⣟⠿⡿⢿⣿""; /* 0xf0 */

int main(int argc, char *argv[]) {
  long o;
  FILE *f;
  int b, c, i, n;
  wchar_t B[17], *q;
  char R[16], A[50], *p;
  if (!(f = argc > 1 ? fopen(argv[1], ""r"") : stdin)) {
    fprintf(stderr, ""ERROR: COULD NOT OPEN: %s\n"", argv[1]);
    return 1;
  }
  for (b = o = 0;;) {
    if (!(n = fread(R, 1, 16, f))) break;
    p = A, q = B;
    for (c = i = 0; i < n; ++i) {
      if (i == 8) *p++ = ' ';
      *p++ = ""0123456789abcdef""[(R[i] & 0xF0) >> 4];
      *p++ = ""0123456789abcdef""[(R[i] & 0x0F) >> 0];
      *p++ = ' ';
      *q++ = K[R[i] & 255];
      c |= R[i];
    }
    if (c || !o) {
      *p = *q = b = 0;
      printf(""%08x  %-49s │%ls│\n"", o, A, B);
    } else if (!b) {
      b = 1;
      printf(""*\n"");
    }
    o += n;
  }
  if (o) printf(""%08x\n"", o);
  return !feof(f);
}
"
./repos/cosmopolitan/tool/viz/lib/formatmatrix-float.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/math.h""
#include ""libc/mem/gc.h""
#include ""libc/x/x.h""
#include ""tool/viz/lib/formatstringtable.h""

static void *ConvertFloatToDoubleMatrix(long yn, long xn, double Md[yn][xn],
                                        const float Mf[yn][xn]) {
  long y, x;
  for (y = 0; y < yn; ++y) {
    for (x = 0; x < xn; ++x) {
      Md[y][x] = Mf[y][x];
    }
  }
  return Md;
}

void FormatMatrixFloat(long yn, long xn, const float M[yn][xn], int emit(),
                       void *arg, StringTableFormatter formatter,
                       const char *param1, const char *param2,
                       const char *param3, double digs,
                       double rounder(double)) {
  FormatMatrixDouble(yn, xn,
                     ConvertFloatToDoubleMatrix(
                         yn, xn, gc(xcalloc(yn * xn, sizeof(double))), M),
                     emit, arg, formatter, param1, param2, param3, digs,
                     rounder);
}

char *StringifyMatrixFloat(long yn, long xn, const float M[yn][xn],
                           StringTableFormatter formatter, const char *param1,
                           const char *param2, const char *param3, double digs,
                           double rounder(double)) {
  return StringifyMatrixDouble(
      yn, xn,
      ConvertFloatToDoubleMatrix(yn, xn, gc(xcalloc(yn * xn, sizeof(double))),
                                 M),
      formatter, param1, param2, param3, digs, rounder);
}
"
./repos/cosmopolitan/tool/viz/lib/gaussian.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/macros.internal.h""
#include ""libc/mem/mem.h""
#include ""libc/str/str.h""
#include ""libc/sysv/errfuns.h""
#include ""tool/viz/lib/convolution.h""
#include ""tool/viz/lib/graphic.h""

/**
 * Blurs image.
 * @see https://en.wikipedia.org/wiki/Kernel_(image_processing)
 */
long gaussian(long yn, long xn, unsigned char img[3][yn][xn]) {
#if 0
  long rc, c, y, x, b;
  unsigned *iy, *ix;
  unsigned char(*ta)[3][xn];
  iy = convoindex(2, yn, 2);
  ix = convoindex(2, xn, 2);
  ta = memalign(32, xn * 3);
  if (ta && ix && iy) {
    iy += 2;
    ix += 2;
    for (c = 0; c < 3; ++c) {
      for (y = 0; y < yn + 3; ++y) {
        if (y >= 3) memcpy(img[c][y - 3], (*ta)[y % 3], xn);
        if (y < yn) {
          for (x = 0; x < xn; ++x) {
            b = CONVOLVE5X5(/* clang-format off */
                            15, (1 / 256.), img[c],
                            1,  4,  6,  4, 1,
                            4, 16, 24, 16, 4,
                            6, 24, 36, 24, 6,
                            4, 16, 24, 16, 4,
                            1,  4,  6,  4, 1
                            /* clang-format on */);
            (*ta)[y % 3][x] = MIN(255, MAX(0, b));
          }
        }
      }
    }
    rc = 0;
  } else {
    rc = enomem();
  }
  free(ta);
  if (ix) free(ix - 2);
  if (iy) free(iy - 2);
  return rc;
#endif
  return 0;
}
"
./repos/cosmopolitan/tool/viz/lib/formatstringtable-basic.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/viz/lib/formatstringtable.h""

void *FormatStringTableBasic(long yn, long xn, const char *const T[yn][xn],
                             int emit(), void *a, const char *ignored1,
                             const char *ignored2, const char *ignored3) {
  return FormatStringTable(yn, xn, T, emit, a, """", "" "", ""\n"");
}
"
./repos/cosmopolitan/tool/viz/lib/formatstringtable-assertion.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/viz/lib/formatstringtable.h""

void *FormatStringTableForAssertion(long yn, long xn,
                                    const char *const T[yn][xn], int emit(),
                                    void *a, const char *ignored1,
                                    const char *ignored2,
                                    const char *ignored3) {
  return FormatStringTable(yn, xn, T, emit, a, ""\n"", "" "", """");
}
"
./repos/cosmopolitan/tool/viz/lib/formatmatrix-double.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/assert.h""
#include ""libc/fmt/conv.h""
#include ""libc/log/check.h""
#include ""libc/math.h""
#include ""libc/mem/gc.h""
#include ""libc/mem/mem.h""
#include ""libc/x/x.h""
#include ""third_party/gdtoa/gdtoa.h""
#include ""tool/viz/lib/formatstringtable.h""
#include ""tool/viz/lib/stringbuilder.h""

void *ConvertMatrixToStringTable(long yn, long xn, char *T[yn][xn],
                                 const double M[yn][xn], double digs,
                                 double rounder(double)) {
  long y, x;
  assert(yn && xn && !T[0][0]);
  for (y = 0; y < yn; ++y) {
    for (x = 0; x < xn; ++x) {
      T[y][x] = xmalloc(40);
      T[y][x][0] = '\0';
      g_dfmt_p(T[y][x], (void *)&M[y][x], digs, 40, 0);
    }
  }
  return T;
}

void FormatMatrixDouble(long yn, long xn, const double M[yn][xn], int emit(),
                        void *arg, StringTableFormatter formatter,
                        const char *param1, const char *param2,
                        const char *param3, double digs,
                        double rounder(double)) {
  FreeStringTableCells(
      yn, xn,
      formatter(
          yn, xn,
          ConvertMatrixToStringTable(
              yn, xn, gc(calloc(yn * xn, sizeof(char *))), M, digs, rounder),
          emit, arg, param1, param2, param3));
}

char *StringifyMatrixDouble(long yn, long xn, const double M[yn][xn],
                            StringTableFormatter formatter, const char *param1,
                            const char *param2, const char *param3, double digs,
                            double rounder(double)) {
  struct StringBuilder *sb = NewStringBuilder();
  FormatMatrixDouble(yn, xn, M, StringBuilderAppend, sb, formatter, param1,
                     param2, param3, digs, rounder);
  return FreeStringBuilder(sb);
}
"
./repos/cosmopolitan/tool/viz/lib/glyphs.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/

// The modes below use various unicodes for 'progressive' pixelization:
// each mode supersets the previous to increase resolution more and more.
// Ideally, a fully dense mapping of the (Y*X) space defined by kGlyph size
// would produce a picture perfect image, but at the cost of sampling speed.
// Therefore, supersets are parsimonious: they only add the minimal set of
// missing shapes that can increase resolution.
// Ideally, this should be based on a study of the residual, but some logic
// can go a long way: after some block pixelization, will need diagonals
// FIXME: then shouldn't box drawing go right after braille?

// TODO: explain the differences between each mode:
// Mode A is full, empty, half blocks top and bottom: , █,▄,▀
// Mode B superset: with quadrants:  ▐,▌,▝,▙,▗,▛,▖,▜,▘,▟,▞,▚,
// Mode C superset: with fractional eights along X and Y
//  _,▁,▂,▃,▄,▅,▆,▇ :█:▉,▊,▋,▌,▍,▎,▏
// Mode X use box drawing, mode X use diagonal blocks, mode X use braille etc

#define W(B, S) B##U << S
#define G(AA, AB, AC, AD, BA, BB, BC, BD, CA, CB, CC, CD, DA, DB, DC, DD, EA, \
          EB, EC, ED, FA, FB, FC, FD, GA, GB, GC, GD, HA, HB, HC, HD)         \
  (W(AA, 000) | W(AB, 001) | W(AC, 002) | W(AD, 003) | W(BA, 004) |           \
   W(BB, 005) | W(BC, 006) | W(BD, 007) | W(CA, 010) | W(CB, 011) |           \
   W(CC, 012) | W(CD, 013) | W(DA, 014) | W(DB, 015) | W(DC, 016) |           \
   W(DD, 017) | W(EA, 020) | W(EB, 021) | W(EC, 022) | W(ED, 023) |           \
   W(FA, 024) | W(FB, 025) | W(FC, 026) | W(FD, 027) | W(GA, 030) |           \
   W(GB, 031) | W(GC, 032) | W(GD, 033) | W(HA, 034) | W(HB, 035) |           \
   W(HC, 036) | W(HD, 037))

// The glyph size it set by the resolution of the most precise mode, ex:
// - Mode C: along the X axis, need >= 8 steps for the 8 fractional width
// FIXME: now we can only use 4 chars instead of the extra ▉,▊,▋,▌,▍,▎,▏
//
// - Mode X: along the Y axis, need >= 8 steps to separate the maximal 6 dots
// from the space left below, seen by overimposing an underline  ⠿_
// along the 3 dots, the Y axis is least 1,0,1,0,1,0,0,1 so 8 steps
//
// Problem: fonts are taller than wider, and terminals are traditionally 80x24, so
// - we shouldn't use square glyphs, 8x16 seems to be the minimal size
// - we should adapt the conversion to BMP to avoid accidental Y downsampling

const uint32_t kGlyphs[] = /* clang-format off */ {
    /* U+0020 ' ' empty block [ascii:20,cp437:20] */
    G(0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0),
    /* U+2588 '█' full block [cp437] */
    G(1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1),
    /* U+2584 '▄' lower half block [cp437:dc] */
    G(0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1),
    /* U+2580 '▀' upper half block [cp437] */
    G(1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0),
    // Mode B
    /* U+2590 '▐' right half block [cp437:de] */
    G(0,0,1,1,
      0,0,1,1,
      0,0,1,1,
      0,0,1,1,
      0,0,1,1,
      0,0,1,1,
      0,0,1,1,
      0,0,1,1),
    /* U+258c '▌' left half block [cp437] */
    G(1,1,0,0,
      1,1,0,0,
      1,1,0,0,
      1,1,0,0,
      1,1,0,0,
      1,1,0,0,
      1,1,0,0,
      1,1,0,0),
    /* U+259d '▝' quadrant upper right */
    G(0,0,1,1,
      0,0,1,1,
      0,0,1,1,
      0,0,1,1,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0),
    /* U+2599 '▙' quadrant upper left and lower left and lower right */
    G(1,1,0,0,
      1,1,0,0,
      1,1,0,0,
      1,1,0,0,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      1,1,1,0),
    /* U+2597 '▗' quadrant lower right */
    G(0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,1,1,
      0,0,1,1,
      0,0,1,1,
      0,0,1,1),
    /* U+259b '▛' quadrant upper left and upper right and lower left */
    G(1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      1,1,0,0,
      1,1,0,0,
      1,1,0,0,
      1,1,0,1),
    /* U+2596 '▖' quadrant lower left */
    G(0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      1,1,0,0,
      1,1,0,0,
      1,1,0,0,
      1,1,0,0),
    /* U+259c '▜' quadrant upper left and upper right and lower right */
    G(1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      0,0,1,1,
      0,0,1,1,
      0,0,1,1,
      0,0,1,0),
    /* U+2598 '▘' quadrant upper left */
    G(1,1,0,0,
      1,1,0,0,
      1,1,0,0,
      1,1,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0),
    /* U+259F '▟' quadrant upper right and lower left and lower right */
    G(0,0,1,1,
      0,0,1,1,
      0,0,1,1,
      0,0,1,1,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      1,1,1,0),
    /* U+259e '▞' quadrant upper right and lower left */
    G(0,0,1,1,
      0,0,1,1,
      0,0,1,1,
      0,0,1,1,
      1,1,0,0,
      1,1,0,0,
      1,1,0,0,
      1,1,0,0),
    /* U+259a '▚' quadrant upper left and lower right */
    G(1,1,0,0,
      1,1,0,0,
      1,1,0,0,
      1,1,0,0,
      0,0,1,1,
      0,0,1,1,
      0,0,1,1,
      0,0,1,0),
    // Mode C
    /* U+2594 '▔' upper one eighth block */
    G(1,1,1,1,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0),
    /* U+2581 '▁' lower one eighth block */
    G(0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      1,1,1,1),
    /* U+2582 '▂' lower one quarter block */
    G(0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      1,1,1,1,
      1,1,1,1),
    /* U+2583 '▃' lower three eighths block */
    G(0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1),
    /* U+2585 '▃' lower five eighths block */
    G(0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1),
    /* U+2586 '▆' lower three quarters block */
    G(0,0,0,0,
      0,0,0,0,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1),
    /* U+2587 '▇' lower seven eighths block */
    G(0,0,0,0,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1,
      1,1,1,1),
    /* U+258e '▎' left one quarter block */
    G(1,0,0,0,
      1,0,0,0,
      1,0,0,0,
      1,0,0,0,
      1,0,0,0,
      1,0,0,0,
      1,0,0,0,
      1,0,0,0),
    /* U+258a '▊' left three quarters block */
    G(1,1,1,0,
      1,1,1,0,
      1,1,1,0,
      1,1,1,0,
      1,1,1,0,
      1,1,1,0,
      1,1,1,0,
      1,1,1,0),
      /* ▁ *\
    2501▕━▎box drawings heavy horizontal
      \* ▔ */
    G(0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      1,1,1,1,
      1,1,1,1,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0),
      /* ▁ *\
   25019▕┉▎box drawings heavy quadruple dash horizontal
      \* ▔ */
    G(0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      1,0,1,0,
      0,1,0,1,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0),
      /* ▁ *\
    2503▕┃▎box drawings heavy vertical
      \* ▔ */
    G(0,1,1,0,
      0,1,1,0,
      0,1,1,0,
      0,1,1,0,
      0,1,1,0,
      0,1,1,0,
      0,1,1,0,
      0,1,1,0),
      /* ▁ *\
    254b▕╋▎box drawings heavy vertical and horizontal
      \* ▔ */
    G(0,1,1,0,
      0,1,1,0,
      0,1,1,0,
      1,1,1,1,
      1,1,1,1,
      0,1,1,0,
      0,1,1,0,
      0,1,1,0),
      /* ▁ *\
    2579▕╹▎box drawings heavy up
      \* ▔ */
    G(0,1,1,0,
      0,1,1,0,
      0,1,1,0,
      0,1,1,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0),
      /* ▁ *\
    257a▕╺▎box drawings heavy right
      \* ▔ */
    G(0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,1,1,
      0,0,1,1,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0),
      /* ▁ *\
    257b▕╻▎box drawings heavy down
      \* ▔ */
    G(0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,1,1,0,
      0,1,1,0,
      0,1,1,0,
      0,1,1,0),
      /* ▁ *\
    2578▕╸▎box drawings heavy left
      \* ▔ */
    G(0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      1,1,0,0,
      1,1,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0),
      /* ▁ *\
    250f▕┏▎box drawings heavy down and right
      \* ▔ */
    G(0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,1,1,1,
      0,1,1,1,
      0,1,1,0,
      0,1,1,0,
      0,1,1,0),
      /* ▁ *\
    251b▕┛▎box drawings heavy up and left
      \* ▔ */
    G(0,1,1,0,
      0,1,1,0,
      0,1,1,0,
      1,1,1,0,
      1,1,1,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0),
      /* ▁ *\
    2513▕┓▎box drawings heavy down and left
      \* ▔ */
    G(0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      1,1,1,0,
      1,1,1,0,
      0,1,1,0,
      0,1,1,0,
      0,1,1,0),
      /* ▁ *\
    2517▕┗▎box drawings heavy up and right
      \* ▔ */
    G(0,1,1,0,
      0,1,1,0,
      0,1,1,0,
      0,1,1,1,
      0,1,1,1,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0),
      /* ▁ *\
    25E2▕◢▎black lower right triangle
      \* ▔ */
    G(0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,1,
      0,0,1,1,
      1,1,1,1,
      0,0,0,0,
      0,0,0,0),
      /* ▁ *\
    25E3▕◣▎black lower left triangle
      \* ▔ */
    G(0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      1,0,0,0,
      1,1,0,0,
      1,1,1,1,
      0,0,0,0,
      0,0,0,0),
      /* ▁ *\
    25E4▕◥▎black upper right triangle
      \* ▔ */
    G(0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      1,1,1,1,
      0,0,1,1,
      0,0,0,1,
      0,0,0,0,
      0,0,0,0),
      /* ▁ *\
    25E5▕◤▎black upper left triangle
      \* ▔ */
    G(0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      1,1,1,1,
      1,1,0,0,
      1,0,0,0,
      0,0,0,0,
      0,0,0,0),
      /* ▁ *\
    2500▕═▎box drawings double horizontal
      \* ▔ */
    G(0,0,0,0,
      0,0,0,0,
      1,1,1,1,
      0,0,0,0,
      1,1,1,1,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0),
      /* ▁ *\
    23BB▕⎻▎horizontal scan line 3
      \* ▔ */
    G(0,0,0,0,
      0,0,0,0,
      1,1,1,1,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0),
      /* ▁ *\
    23BD▕⎼▎horizontal scan line 9
      \* ▔ */
    G(0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      1,1,1,1,
      0,0,0,0,
      0,0,0,0),
} /* clang-format on */;

const char16_t kRunes[] = {
    u' ', /* 0020 empty block [ascii:20,cp437:20] */
    u'█', /* 2588 full block [cp437] */
    u'▄', /* 2584 lower half block [cp437:dc] */
    u'▀', /* 2580 upper half block [cp437] */
    u'▐', /* 2590 right half block [cp437:de] */
    u'▌', /* 258C left half block */
    u'▝', /* 259D quadrant upper right */
    u'▙', /* 2599 quadrant upper left and lower left and lower right */
    u'▗', /* 2597 quadrant lower right */
    u'▛', /* 259B quadrant upper left and upper right and lower left */
    u'▖', /* 2596 quadrant lower left */
    u'▜', /* 259C quadrant upper left and upper right and lower right */
    u'▘', /* 2598 quadrant upper left */
    u'▟', /* 259F quadrant upper right and lower left and lower right */
    u'▞', /* 259E quadrant upper right and lower left */
    u'▚', /* 259A quadrant upper left and lower right */
    u'▔', /* 2594 upper one eighth block */
    u'▁', /* 2581 lower one eighth block */
    u'▂', /* 2582 lower one quarter block */
    u'▃', /* 2583 lower three eighths block */
    u'▅', /* 2585 lower five eighths block */
    u'▆', /* 2586 lower three quarters block */
    u'▇', /* 2587 lower seven eighths block */
    u'▎', /* 258E left one quarter block */
    u'▊', /* 258A left three quarters block */
    u'━', /* 2501 box drawings heavy horizontal */
    u'┉', /* 2509 box drawings heavy quadruple dash horizontal */
    u'┃', /* 2503 box drawings heavy vertical */
    u'╋', /* 254B box drawings heavy vertical & horiz. */
    u'╹', /* 2579 box drawings heavy up */
    u'╺', /* 257A box drawings heavy right */
    u'╻', /* 257B box drawings heavy down */
    u'╸', /* 2578 box drawings heavy left */
    u'┏', /* 250F box drawings heavy down and right */
    u'┛', /* 251B box drawings heavy up and left */
    u'┓', /* 2513 box drawings heavy down and left */
    u'┗', /* 2517 box drawings heavy up and right */
    u'◢', /* 25E2 black lower right triangle */
    u'◣', /* 25E3 black lower left triangle */
    u'◥', /* 25E4 black upper right triangle */
    u'◤', /* 25E5 black upper left triangle */
    u'═', /* 2550 box drawings double horizontal */
    u'⎻', /* 23BB horizontal scan line 3 */
    u'⎼', /* 23BD horizontal scan line 9 */
};
"
./repos/cosmopolitan/tool/viz/lib/halfblit.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/log/check.h""
#include ""tool/viz/lib/halfblit.h""

void *halfblit(size_t n, void *block) {
  unsigned y, x;
  char(*dst)[n << 0][n << 0] = block;
  char(*src)[n << 1][n << 1] = block;
  DCHECK_GE(n, 2);
  DCHECK_ALIGNED(16, block);
  for (y = 0; y < n; ++y) {
    for (x = 0; x < n; ++x) {
      (*dst)[y][x] = (*src)[y][x];
    }
  }
  return block;
}
"
./repos/cosmopolitan/tool/viz/lib/stringbuilder.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/log/check.h""
#include ""libc/macros.internal.h""
#include ""libc/mem/mem.h""
#include ""libc/str/str.h""
#include ""libc/x/x.h""
#include ""tool/viz/lib/stringbuilder.h""

static dontinline void StringBuilderGrow(size_t need, struct StringBuilder *sb) {
  size_t n2;
  n2 = MAX(16, sb->n);
  while (sb->i + need > n2) n2 += n2 >> 1;
  sb->p = xrealloc(sb->p, n2);
  sb->n = n2;
}

struct StringBuilder *NewStringBuilder(void) {
  return xcalloc(1, sizeof(struct StringBuilder));
}

int StringBuilderAppend(const char *s, struct StringBuilder *sb) {
  size_t size;
  CHECK_LE(sb->i, sb->n);
  size = strlen(s);
  if (sb->i + size + 1 > sb->n) StringBuilderGrow(size + 1, sb);
  memcpy(sb->p + sb->i, s, size + 1);
  sb->i += size;
  return 0;
}

char *FreeStringBuilder(struct StringBuilder *sb) {
  char *res;
  CHECK_LE(sb->i, sb->n);
  CHECK_EQ('\0', sb->p[sb->i]);
  res = xrealloc(sb->p, sb->i + 1);
  free(sb);
  return res;
}
"
./repos/cosmopolitan/tool/viz/lib/boxblur.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/viz/lib/convolve.h""
#include ""tool/viz/lib/graphic.h""

void boxblur(struct Graphic *g) {
  static const float kBoxBlurKernel[3][3] = {
      {+1.0, +1.0, +1.0},
      {+1.0, +1.0, +1.0},
      {+1.0, +1.0, +1.0},
  };
  convolve(g->yn, g->xn, g->b, 3, kBoxBlurKernel, 9.0, 0);
}
"
./repos/cosmopolitan/tool/viz/lib/writetoframebuffer.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/macros.internal.h""
#include ""tool/viz/lib/graphic.h""

void WriteToFrameBuffer(size_t dyn, size_t dxn, unsigned char dst[dyn][dxn][4],
                        size_t syn, size_t sxn, float src[syn][sxn][4],
                        size_t yn, size_t xn) {
  int ipix[4];
  float fpix[4];
  unsigned y, x, k, upix[4];
  for (y = 0; y < yn; ++y) {
    for (x = 0; x < xn; ++x) {
      for (k = 0; k < 4; ++k) fpix[k] = src[y][x][k];
      for (k = 0; k < 4; ++k) fpix[k] *= 255;
      for (k = 0; k < 4; ++k) ipix[k] = fpix[k] + .5f;
      for (k = 0; k < 4; ++k) upix[k] = MAX(0, ipix[k]);
      for (k = 0; k < 4; ++k) upix[k] = MIN(255, upix[k]);
      dst[y][x][0] = upix[2];
      dst[y][x][1] = upix[1];
      dst[y][x][2] = upix[0];
      dst[y][x][3] = 0;
    }
  }
}
"
./repos/cosmopolitan/tool/viz/lib/knobs.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/viz/lib/knobs.h""

bool pf1_;
bool pf2_;
bool pf3_;
bool pf4_;
bool pf5_;
bool pf6_;
bool pf7_;
bool pf8_;
bool pf9_;
bool pf10_;
bool pf11_;
bool pf12_;
"
./repos/cosmopolitan/tool/viz/lib/ycbcr2rgb3.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""dsp/core/c11.h""
#include ""dsp/core/c1331.h""
#include ""dsp/core/c1331s.h""
#include ""dsp/core/c161.h""
#include ""dsp/core/core.h""
#include ""dsp/core/half.h""
#include ""dsp/core/illumination.h""
#include ""dsp/core/q.h""
#include ""dsp/scale/scale.h""
#include ""libc/assert.h""
#include ""libc/calls/calls.h""
#include ""libc/calls/struct/sigset.h""
#include ""libc/calls/struct/timespec.h""
#include ""libc/intrin/bsr.h""
#include ""libc/intrin/pmulhrsw.h""
#include ""libc/log/check.h""
#include ""libc/log/log.h""
#include ""libc/macros.internal.h""
#include ""libc/math.h""
#include ""libc/mem/gc.h""
#include ""libc/mem/mem.h""
#include ""libc/nexgen32e/gc.internal.h""
#include ""libc/nexgen32e/nexgen32e.h""
#include ""libc/nexgen32e/x86feature.h""
#include ""libc/runtime/runtime.h""
#include ""libc/str/str.h""
#include ""libc/sysv/consts/sig.h""
#include ""libc/sysv/errfuns.h""
#include ""libc/time/time.h""
#include ""libc/x/x.h""
#include ""tool/viz/lib/graphic.h""
#include ""tool/viz/lib/knobs.h""
#include ""tool/viz/lib/ycbcr.h""

#define M        15
#define CLAMP(X) MIN(255, MAX(0, X))

const double kBt601Primaries[] = {.299, .587, .114};
const double kBt709Primaries[] = {871024 / 4096299., 8788810 / 12288897.,
                                  887015 / 12288897.};

const double kSrgbToXyz[3][3] = {
    {506752 / 1228815., 87881 / 245763., 12673 / 70218.},
    {87098 / 409605., 175762 / 245763., 12673 / 175545.},
    {7918 / 409605., 87881 / 737289., 1001167 / 1053270.},
};

long magikarp_latency_;
long gyarados_latency_;
long ycbcr2rgb_latency_;
struct timespec magikarp_start_;

struct YCbCr {
  bool yonly;
  int magnums[8][4];
  int lighting[6][4];
  unsigned char transfer[2][256];
  struct YCbCrSamplingSolution {
    long dyn, dxn;
    long syn, sxn;
    double ry, rx;
    double oy, ox;
    double py, px;
    struct SamplingSolution *cy, *cx;
  } luma, chroma;
};

static unsigned long roundup2pow(unsigned long x) {
  return x > 1 ? 2ul << bsrl(x - 1) : x ? 1 : 0;
}

static unsigned long rounddown2pow(unsigned long x) {
  return x ? 1ul << bsrl(x) : 0;
}

/**
 * Computes magnums for Y′CbCr decoding.
 *
 * @param swing should be 219 for TV, or 255 for JPEG
 * @param M is integer coefficient bits
 */
void YCbCrComputeCoefficients(int swing, double gamma,
                              const double primaries[3],
                              const double illuminant[3], int out_magnums[8][4],
                              int out_lighting[6][4],
                              unsigned char out_transfer[256]) {
  int i, j;
  double x;
  double f1[6][3];
  long longs[6][6];
  long bitlimit = roundup2pow(swing);
  long wordoffset = rounddown2pow((bitlimit - swing) / 2);
  long chromaswing = swing + 2 * (bitlimit / 2. - swing / 2. - wordoffset);
  long lumamin = wordoffset;
  long lumamax = wordoffset + swing;
  long diffmax = wordoffset + chromaswing - bitlimit / 2;
  long diffmin = -diffmax;
  double rEb = 1 - primaries[2] + primaries[0] + primaries[1];
  double rEgEb = 1 / primaries[1] * primaries[2] * rEb;
  double rEr = 1 - primaries[0] + primaries[1] + primaries[2];
  double rEgEr = 1 / primaries[1] * primaries[0] * rEr;
  double unswing = 1. / swing * bitlimit;
  double digital = 1. / swing * chromaswing;
  double reals[6][6] = {
      {rEr / digital},
      {-rEgEb / digital, -rEgEr / digital},
      {rEb / digital},
      {0, 0, unswing},
  };
  for (i = 0; i < 4; ++i) {
    GetIntegerCoefficients(longs[i], reals[i], M, diffmin, diffmax);
  }
  for (i = 0; i < 4; ++i) {
    for (j = 0; j < 4; ++j) {
      out_magnums[i][j] = longs[i][j];
    }
  }
  out_magnums[3][0] = wordoffset;
  out_magnums[3][1] = bitlimit / 2;
  GetChromaticAdaptationMatrix(f1, kIlluminantD65, illuminant);
  for (i = 0; i < 3; ++i) {
    for (j = 0; j < 3; ++j) {
      reals[i][j] = f1[i][j];
    }
  }
  for (i = 0; i < 6; ++i) {
    GetIntegerCoefficients(longs[i], reals[i], M, diffmin * 2, lumamax * 2);
  }
  for (i = 0; i < 6; ++i) {
    for (j = 0; j < 3; ++j) {
      out_lighting[i][j] = longs[i][j];
    }
  }
  for (i = 0; i < 256; ++i) {
    x = i;
    x /= 255;
    x = tv2pcgamma(x, gamma);
    x *= 255;
    out_transfer[i] = CLAMP(x);
  }
  memset(out_transfer, out_transfer[lumamin], lumamin);
  memset(out_transfer + lumamax + 1, out_transfer[lumamax], bitlimit - lumamax);
}

void YCbCrInit(struct YCbCr **ycbcr, bool yonly, int swing, double gamma,
               const double gamut[3], const double illuminant[3]) {
  int i;
  if (!*ycbcr) *ycbcr = xcalloc(1, sizeof(struct YCbCr));
  (*ycbcr)->yonly = yonly;
  bzero((*ycbcr)->magnums, sizeof((*ycbcr)->magnums));
  bzero((*ycbcr)->lighting, sizeof((*ycbcr)->lighting));
  YCbCrComputeCoefficients(swing, gamma, gamut, illuminant, (*ycbcr)->magnums,
                           (*ycbcr)->lighting, (*ycbcr)->transfer[0]);
  for (i = 0; i < 256; ++i) {
    (*ycbcr)->transfer[1][i] = i;
  }
}

void YCbCrFree(struct YCbCr **ycbcr) {
  if (*ycbcr) {
    FreeSamplingSolution((*ycbcr)->luma.cy), (*ycbcr)->luma.cy = NULL;
    FreeSamplingSolution((*ycbcr)->luma.cx), (*ycbcr)->luma.cx = NULL;
    FreeSamplingSolution((*ycbcr)->chroma.cy), (*ycbcr)->chroma.cy = NULL;
    FreeSamplingSolution((*ycbcr)->chroma.cx), (*ycbcr)->chroma.cx = NULL;
    free(*ycbcr), *ycbcr = NULL;
  }
}

void *YCbCrReallocPlane(long ys, long xs, const unsigned char p[ys][xs],
                        long yn, long xn) {
  long y;
  unsigned char(*res)[yn][xn];
  res = xmemalign(32, yn * xn);
  for (y = 0; y < yn; ++y) {
    memcpy((*res)[y], p[y], xn);
  }
  return res;
}

void YCbCrComputeSamplingSolution(struct YCbCrSamplingSolution *scale, long dyn,
                                  long dxn, long syn, long sxn, double ry,
                                  double rx, double oy, double ox, double py,
                                  double px) {
  if (scale->dyn != dyn || scale->dxn != dxn || scale->syn != syn ||
      scale->sxn != sxn || fabs(scale->ry - ry) > .001 ||
      fabs(scale->rx - rx) > .001 || fabs(scale->oy - oy) > .001 ||
      fabs(scale->ox - ox) > .001 || fabs(scale->py - py) > .001 ||
      fabs(scale->px - px) > .001) {
    INFOF(""recomputing sampling solution"");
    FreeSamplingSolution(scale->cy), scale->cy = NULL;
    FreeSamplingSolution(scale->cx), scale->cx = NULL;
    scale->cy = ComputeSamplingSolution(dyn, syn, ry, oy, py);
    scale->cx = ComputeSamplingSolution(dxn, sxn, rx, ox, px);
    scale->dyn = dyn, scale->dxn = dxn;
    scale->syn = syn, scale->sxn = sxn;
    scale->ry = ry, scale->rx = rx;
    scale->oy = oy, scale->ox = ox;
    scale->py = py, scale->px = px;
  }
}

void Y2Rgb(long yn, long xn, unsigned char RGB[restrict 3][yn][xn], long yys,
           long yxs, const unsigned char Y[restrict yys][yxs],
           const int K[8][4], const unsigned char T[256]) {
  long i, j;
  for (i = 0; i < yn; ++i) {
    for (j = 0; j < xn; ++j) {
      RGB[0][i][j] = T[Y[i][j]];
    }
  }
  memcpy(RGB[1], RGB[0], yn * xn);
  memcpy(RGB[2], RGB[0], yn * xn);
}

/**
 * Converts Y′CbCr samples to RGB.
 */
void YCbCr2Rgb(long yn, long xn, unsigned char RGB[restrict 3][yn][xn],
               long yys, long yxs, const unsigned char Y[restrict yys][yxs],
               long cys, long cxs, const unsigned char Cb[restrict cys][cxs],
               const unsigned char Cr[restrict cys][cxs], const int K[8][4],
               const int L[6][4], const unsigned char T[256]) {
  long i, j;
  short y, u, v, r, g, b;
  for (i = 0; i < yn; ++i) {
    for (j = 0; j < xn; ++j) {
      y = T[Y[i][j]];
      u = Cb[i][j] - K[3][1];
      v = Cr[i][j] - K[3][1];
      r = y + QRS(M, v * K[0][0]);
      g = y + QRS(M, u * K[1][0] + v * K[1][1]);
      b = y + QRS(M, u * K[2][0]);
      r = QRS(M, (MIN(235, MAX(16, r)) - K[3][0]) * K[3][2]);
      g = QRS(M, (MIN(235, MAX(16, g)) - K[3][0]) * K[3][2]);
      b = QRS(M, (MIN(235, MAX(16, b)) - K[3][0]) * K[3][2]);
      RGB[0][i][j] = CLAMP(QRS(M, r * L[0][0] + g * L[0][1] + b * L[0][2]));
      RGB[1][i][j] = CLAMP(QRS(M, r * L[1][0] + g * L[1][1] + b * L[1][2]));
      RGB[2][i][j] = CLAMP(QRS(M, r * L[2][0] + g * L[2][1] + b * L[2][2]));
    }
  }
}

void YCbCrConvert(struct YCbCr *me, long yn, long xn,
                  unsigned char RGB[restrict 3][yn][xn], long yys, long yxs,
                  const unsigned char Y[restrict yys][yxs], long cys, long cxs,
                  unsigned char Cb[restrict cys][cxs],
                  unsigned char Cr[restrict cys][cxs]) {
  struct timespec ts = timespec_real();
  if (!me->yonly) {
    YCbCr2Rgb(yn, xn, RGB, yys, yxs, Y, cys, cxs, Cb, Cr, me->magnums,
              me->lighting, me->transfer[pf10_]);
  } else {
    Y2Rgb(yn, xn, RGB, yys, yxs, Y, me->magnums, me->transfer[pf10_]);
  }
  ycbcr2rgb_latency_ = timespec_tomicros(timespec_sub(timespec_real(), ts));
}

void YCbCr2RgbScaler(struct YCbCr *me, long dyn, long dxn,
                     unsigned char RGB[restrict 3][dyn][dxn], long yys,
                     long yxs, unsigned char Y[restrict yys][yxs], long cys,
                     long cxs, unsigned char Cb[restrict cys][cxs],
                     unsigned char Cr[restrict cys][cxs], long yyn, long yxn,
                     long cyn, long cxn, double syn, double sxn, double pry,
                     double prx) {
  long scyn, scxn;
  double yry, yrx, cry, crx, yoy, yox, coy, cox;
  scyn = syn * cyn / yyn;
  scxn = sxn * cxn / yxn;
  if (HALF(yxn) > dxn && HALF(scxn) > dxn) {
    YCbCr2RgbScaler(me, dyn, dxn, RGB, yys, yxs,
                    Magikarp2xX(yys, yxs, Y, syn, sxn), cys, cxs,
                    Magkern2xX(cys, cxs, Cb, scyn, scxn),
                    Magkern2xX(cys, cxs, Cr, scyn, scxn), yyn, HALF(yxn), cyn,
                    HALF(cxn), syn, sxn / 2, pry, prx);
  } else if (HALF(yyn) > dyn && HALF(scyn) > dyn) {
    YCbCr2RgbScaler(me, dyn, dxn, RGB, yys, yxs,
                    Magikarp2xY(yys, yxs, Y, syn, sxn), cys, cxs,
                    Magkern2xY(cys, cxs, Cb, scyn, scxn),
                    Magkern2xY(cys, cxs, Cr, scyn, scxn), HALF(yyn), yxn,
                    HALF(cyn), scxn, syn / 2, sxn, pry, prx);
  } else {
    struct timespec ts = timespec_real();
    magikarp_latency_ = timespec_tomicros(timespec_sub(ts, magikarp_start_));
    yry = syn / dyn;
    yrx = sxn / dxn;
    cry = syn * cyn / yyn / dyn;
    crx = sxn * cxn / yxn / dxn;
    yoy = syn / scyn / 2 - pry * .5;
    yox = sxn / scxn / 2 - prx * .5;
    coy = syn / scyn / 2 - pry * .5;
    cox = sxn / scxn / 2 - prx * .5;
    INFOF(""gyarados pry=%.3f prx=%.3f syn=%.3f sxn=%.3f dyn=%ld dxn=%ld ""
          ""yyn=%ld ""
          ""yxn=%ld cyn=%ld cxn=%ld yry=%.3f yrx=%.3f cry=%.3f crx=%.3f ""
          ""yoy=%.3f ""
          ""yox=%.3f coy=%.3f cox=%.3f"",
          pry, prx, syn, sxn, dyn, dxn, yyn, yxn, cyn, cxn, yry, yrx, cry, crx,
          yoy, yox, coy, cox);
    YCbCrComputeSamplingSolution(&me->luma, dyn, dxn, syn, sxn, yry, yrx, yoy,
                                 yox, pry, prx);
    YCbCrComputeSamplingSolution(&me->chroma, dyn, dxn, scyn, scxn, cry, crx,
                                 coy, cox, pry, prx);
    if (pf8_) sharpen(1, yys, yxs, (void *)Y, yyn, yxn);
    if (pf9_) unsharp(1, yys, yxs, (void *)Y, yyn, yxn);
    GyaradosUint8(yys, yxs, Y, yys, yxs, Y, dyn, dxn, syn, sxn, 0, 255,
                  me->luma.cy, me->luma.cx, true);
    GyaradosUint8(cys, cxs, Cb, cys, cxs, Cb, dyn, dxn, scyn, scxn, 0, 255,
                  me->chroma.cy, me->chroma.cx, false);
    GyaradosUint8(cys, cxs, Cr, cys, cxs, Cr, dyn, dxn, scyn, scxn, 0, 255,
                  me->chroma.cy, me->chroma.cx, false);
    gyarados_latency_ = timespec_tomicros(timespec_sub(timespec_real(), ts));
    YCbCrConvert(me, dyn, dxn, RGB, yys, yxs, Y, cys, cxs, Cb, Cr);
    INFOF(""done"");
  }
}

/**
 * Converts Y′CbCr frame for PC display.
 *
 *    ""[The] experiments of Professor J. D. Forbes, which I
 *     witnessed… [established] that blue and yellow do not
 *     make green but a pinkish tint, when neither prevails
 *     in the combination [and the] result of mixing yellow
 *     and blue was, I believe, not previously known.
 *                                 — James Clerk Maxwell
 *
 * This function converts TV to PC graphics. We do that by
 *
 *   1. decimating w/ facebook magikarp photoshop cubic sharpen
 *   2. upsampling color difference planes, to be as big as luma plane
 *   3. converting color format
 *   4. expanding dynamic range
 *   5. transferring gamma from TV to PC convention
 *   6. resampling again to exact requested display / pixel geometry
 *
 * @param dyn/dxn is display height/width after scaling/conversion
 * @param RGB points to memory for packed de-interlaced RGB output
 * @param Y′ ∈ [16,235] is the luminance plane a gamma-corrected RGB
 *     weighted sum; a.k.a. black/white legacy component part of the
 *     TV signal; which may be used independently of the chrominance
 *     planes; and decodes to the range [0,1]
 * @param Cb/Cr ∈ [16,240] is blue/red chrominance difference planes
 *     which (if sampled at a different rate) will get stretched out
 *     over the luma plane appropriately
 * @param yys/yxs dimensions luma sample array
 * @param cys/cxs dimensions chroma sample arrays
 * @param yyn/yxn is number of samples in luma signal
 * @param cyn/cxn is number of samples in each chroma signal
 * @param syn/sxn is size of source signal
 * @param pry/prx is pixel aspect ratio, e.g. 1,1
 * @return RGB
 */
void *YCbCr2RgbScale(long dyn, long dxn,
                     unsigned char RGB[restrict 3][dyn][dxn], long yys,
                     long yxs, unsigned char Y[restrict yys][yxs], long cys,
                     long cxs, unsigned char Cb[restrict cys][cxs],
                     unsigned char Cr[restrict cys][cxs], long yyn, long yxn,
                     long cyn, long cxn, double syn, double sxn, double pry,
                     double prx, struct YCbCr **ycbcr) {
  long minyys, minyxs, mincys, mincxs;
  CHECK_LE(yyn, yys);
  CHECK_LE(yxn, yxs);
  CHECK_LE(cyn, cys);
  CHECK_LE(cxn, cxs);
  INFOF(""magikarp2x"");
  magikarp_start_ = timespec_real();
  minyys = MAX(ceil(syn), MAX(yyn, ceil(dyn * pry)));
  minyxs = MAX(ceil(sxn), MAX(yxn, ceil(dxn * prx)));
  mincys = MAX(cyn, ceil(dyn * pry));
  mincxs = MAX(cxn, ceil(dxn * prx));
  YCbCr2RgbScaler(*ycbcr, dyn, dxn, RGB, MAX(yys, minyys), MAX(yxs, minyxs),
                  (yys >= minyys && yxs >= minyxs
                       ? Y
                       : gc(YCbCrReallocPlane(yys, yxs, Y, minyys, minyxs))),
                  MAX(cys, mincys), MAX(cxs, mincxs),
                  (cys >= mincys && cxs >= mincxs
                       ? Cb
                       : gc(YCbCrReallocPlane(cys, cxs, Cb, mincys, mincxs))),
                  (cys >= mincys && cxs >= mincxs
                       ? Cr
                       : gc(YCbCrReallocPlane(cys, cxs, Cr, mincys, mincxs))),
                  yyn, yxn, cyn, cxn, syn, sxn, pry, prx);
  return RGB;
}
"
./repos/cosmopolitan/tool/viz/lib/unsharp.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/macros.internal.h""
#include ""libc/mem/mem.h""
#include ""libc/str/str.h""
#include ""libc/sysv/errfuns.h""
#include ""libc/time/time.h""
#include ""libc/x/x.h""
#include ""tool/viz/lib/convolution.h""
#include ""tool/viz/lib/graphic.h""

/**
 * Enhances image detail.
 * @see https://en.wikipedia.org/wiki/Kernel_(image_processing)
 */
long unsharp(long cn, long yw, long xw, unsigned char img[cn][yw][xw], long yn,
             long xn) {
  long rc, c, y, x;
  unsigned *iy, *ix;
  short(*t)[3][xn] = xmemalign(64, sizeof(short) * xn * 3);
  iy = convoindex(2, yn, 2);
  ix = convoindex(2, xn, 2);
  if (t && ix && iy) {
    iy += 2;
    ix += 2;
    for (c = 0; c < 3; ++c) {
      for (y = 0; y < yn + 3; ++y) {
        if (y >= 3) {
          for (x = 0; x < xn; ++x) {
            img[c][y - 3][x] = MIN(255, MAX(0, (*t)[y % 3][x]));
          }
          bzero((*t)[y % 3], sizeof(short) * xn);
        }
        if (y < yn) {
          for (x = 0; x < xn; ++x) {
            (*t)[y % 3][x] = CONVOLVE5X5(/* clang-format off */
                    7, (-1 / 256.), img[c],
                          1,  4,   6,  4, 1,
                          4, 16,  24, 16, 4,
                          6, 24,-476, 24, 6,
                          4, 16,  24, 16, 4,
                          1,  4,   6,  4, 1
                                         /* clang-format on */);
          }
        }
      }
    }
    rc = 0;
  } else {
    rc = enomem();
  }
  free(t);
  if (ix) free(ix - 2);
  if (iy) free(iy - 2);
  return rc;
}
"
./repos/cosmopolitan/tool/viz/lib/formatstringtable.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/viz/lib/formatstringtable.h""
#include ""libc/intrin/safemacros.internal.h""
#include ""libc/mem/mem.h""
#include ""libc/str/strwidth.h""

void *FreeStringTableCells(long yn, long xn, char *T[yn][xn]) {
  long y, x;
  for (y = 0; y < yn; ++y) {
    for (x = 0; x < xn; ++x) {
      free(T[y][x]);
      T[y][x] = 0;
    }
  }
  return T;
}

static unsigned GetBiggestCellWidth(long yn, long xn,
                                    const char *const T[yn][xn]) {
  long w, y, x;
  for (w = y = 0; y < yn; ++y) {
    for (x = 0; x < xn; ++x) {
      w = max(w, strwidth(T[y][x], 0));
    }
  }
  return w;
}

void *FormatStringTable(long yn, long xn, const char *const T[yn][xn],
                        int emit(), void *a, const char *startrow,
                        const char *comma, const char *endrow) {
  long w, y, x, i, n;
  w = GetBiggestCellWidth(yn, xn, T);
  for (y = 0; y < yn; ++y) {
    emit(startrow, a);
    for (x = 0; x < xn; ++x) {
      if (x) emit(comma, a);
      for (n = w - strwidth(T[y][x], 0), i = 0; i < n; ++i) emit("" "", a);
      emit(T[y][x], a);
    }
    emit(endrow, a);
  }
  return (/* unconst */ void *)T;
}
"
./repos/cosmopolitan/tool/viz/lib/convoindex.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/mem/mem.h""
#include ""tool/viz/lib/convolution.h""

/**
 * Creates padded array of array indices.
 *
 * This can be used to virtualize the memory of a matrix in one
 * dimension, to make it easy to avoid out-of-bounds access.
 *
 * @return value needs free(retval - leftpad)
 */
unsigned *convoindex(unsigned leftpad, unsigned n, unsigned rightpad) {
  unsigned i, j, *p;
  if ((p = malloc(sizeof(unsigned) * (leftpad + n + rightpad)))) {
    i = 0;
    for (j = 0; j < leftpad; ++j) p[i++] = 0;
    for (j = 0; j < n; ++j) p[i++] = j;
    for (j = 0; j < rightpad; ++j) p[i++] = n - 1;
  }
  return p;
}
"
./repos/cosmopolitan/tool/viz/lib/sobel.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/calls/calls.h""
#include ""libc/macros.internal.h""
#include ""libc/math.h""
#include ""libc/mem/mem.h""
#include ""libc/nexgen32e/nexgen32e.h""
#include ""libc/runtime/runtime.h""
#include ""tool/viz/lib/convolve.h""
#include ""tool/viz/lib/graphic.h""

#define LCB           {
#define RCB           }
#define BROADCAST(X)  LCB X, X, X, X RCB
#define FLIP(A, B, C) LCB C, B, A RCB

forceinline void ConvolveGradient(unsigned yn, unsigned xn,
                                  float (*img)[yn][xn][4], unsigned KW,
                                  const float (*ky)[KW][KW][4],
                                  const float (*kx)[KW][KW][4]) {
  size_t size;
  unsigned y, x, i, j, k;
  float py[4], px[4], (*tmp)[yn][xn][4];
  tmp = _mapanon((size = ROUNDUP(sizeof(float) * 4 * xn * yn, FRAMESIZE)));
  for (y = 0; y < yn - KW + 1; ++y) {
    for (x = 0; x < xn - KW + 1; ++x) {
      for (k = 0; k < 4; ++k) py[k] = 0;
      for (k = 0; k < 4; ++k) px[k] = 0;
      for (i = 0; i < KW; ++i) {
        for (j = 0; j < KW; ++j) {
          for (k = 0; k < 4; ++k) {
            py[k] += (*ky)[i][j][k] * (*img)[y + i][x + j][k];
            px[k] += (*kx)[i][j][k] * (*img)[y + i][x + j][k];
          }
        }
      }
      for (k = 0; k < 4; ++k) {
        (*tmp)[y + KW / 2][x + KW / 2][k] = sqrt(py[k] * py[k] + px[k] * px[k]);
      }
    }
  }
  memcpy(img, tmp, sizeof(float) * 4 * xn * yn);
  munmap(tmp, size);
}

void sobel(struct Graphic* g) {
  static const float kSobelEmbossKernelY[3][3][4] =
      FLIP(FLIP(BROADCAST(+1), BROADCAST(+2), BROADCAST(+1)),
           FLIP(BROADCAST(+0), BROADCAST(+0), BROADCAST(+0)),
           FLIP(BROADCAST(-1), BROADCAST(-2), BROADCAST(-1)));
  static const float kSobelEmbossKernelX[3][3][4] =
      FLIP(FLIP(BROADCAST(-1), BROADCAST(+0), BROADCAST(+1)),
           FLIP(BROADCAST(-2), BROADCAST(+0), BROADCAST(+2)),
           FLIP(BROADCAST(-1), BROADCAST(+0), BROADCAST(+1)));
  if (g->yn >= 3 && g->xn >= 3) {
    ConvolveGradient(g->yn, g->xn, g->b, 3, &kSobelEmbossKernelY,
                     &kSobelEmbossKernelX);
  }
}
"
./repos/cosmopolitan/tool/viz/lib/bilinearscale.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/viz/lib/bilinearscale.h""
#include ""dsp/core/twixt8.h""
#include ""libc/intrin/bsr.h""
#include ""libc/log/check.h""
#include ""libc/log/log.h""
#include ""libc/macros.internal.h""
#include ""libc/math.h""
#include ""libc/mem/gc.h""
#include ""libc/mem/mem.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#include ""libc/testlib/testlib.h""
#include ""libc/tinymath/emod.h""
#include ""libc/x/x.h""

static void ComputeScalingSolution(long dn, long sn, double r, double o,
                                   unsigned char pct[dn + 1], int idx[dn + 1]) {
  long i;
  double x;
  o -= .5;
  o += (r - 1) / 2;
  for (i = 0; i < dn + 1; ++i) {
    x = o + i * r;
    idx[i] = MIN(sn - 1, MAX(0, lround(x)));
    pct[i] = lround((x - idx[i]) * 255) % 256;
  }
}

static void BilinearScaler(long dcw, long dyw, long dxw,
                           unsigned char dst[dcw][dyw][dxw], long scw, long syw,
                           long sxw, const unsigned char src[scw][syw][sxw],
                           long c0, long cn, long dyn, long dxn, long syn,
                           long sxn, double ry, double rx, double oy, double ox,
                           int iy[dyn + 1], unsigned char py[dyn + 1],
                           int ix[dxn + 1], unsigned char px[dxn + 1],
                           unsigned char db[dxn], unsigned char sb[2][sxn]) {
  long c, y, x;
  ComputeScalingSolution(dxn, sxn, rx, ox, px, ix);
  ComputeScalingSolution(dyn, syn, ry, oy, py, iy);
  for (c = c0; c < cn; ++c) {
    for (y = 0; y < dyn; ++y) {
      memcpy(sb[0], src[c][iy[y + 0]], sxn);
      memcpy(sb[1], src[c][iy[y + 1]], sxn);
      for (x = 0; x < dxn; ++x) {
        db[x] = twixt8(twixt8(sb[0][ix[x]], sb[0][ix[x + 1]], px[x]),
                       twixt8(sb[1][ix[x]], sb[1][ix[x + 1]], px[x]), py[y]);
      }
      memcpy(dst[c][y], db, dxn);
    }
  }
}

void *BilinearScale(long dcw, long dyw, long dxw,
                    unsigned char dst[dcw][dyw][dxw], long scw, long syw,
                    long sxw, const unsigned char src[scw][syw][sxw], long c0,
                    long cn, long dyn, long dxn, long syn, long sxn, double ry,
                    double rx, double oy, double ox) {
  if (dyn > 0 && dxn > 0) {
    if (syn > 0 && sxn > 0) {
      DCHECK_LE(c0, cn);
      DCHECK_LE(cn, scw);
      DCHECK_LE(cn, dcw);
      DCHECK_LE(syn, syw);
      DCHECK_LE(sxn, sxw);
      DCHECK_LE(dyn, dyw);
      DCHECK_LE(dxn, dxw);
      DCHECK_LT(bsrl(cn) + bsrl(syn) + bsrl(sxn), 32);
      DCHECK_LT(bsrl(cn) + bsrl(dyn) + bsrl(dxn), 32);
      BilinearScaler(dcw, dyw, dxw, dst, scw, syw, sxw, src, c0, cn, dyn, dxn,
                     syn, sxn, ry, rx, oy, ox,
                     gc(xmemalign(64, ROUNDUP(sizeof(int) * (dyn + 1), 64))),
                     gc(xmemalign(64, ROUNDUP(dyn + 1, 64))),
                     gc(xmemalign(64, ROUNDUP(sizeof(int) * (dxn + 1), 64))),
                     gc(xmemalign(64, ROUNDUP(dxn + 1, 64))),
                     gc(xmemalign(64, ROUNDUP(dxn, 64))),
                     gc(xmemalign(64, ROUNDUP(sxn, 64) * 2)));
    } else {
      bzero(dst[c0], &dst[cn][0][0] - &dst[c0][0][0]);
    }
  }
  return dst;
}
"
./repos/cosmopolitan/tool/viz/lib/formatmatrix-short.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/assert.h""
#include ""libc/math.h""
#include ""libc/mem/gc.h""
#include ""libc/mem/mem.h""
#include ""libc/x/x.h""
#include ""libc/x/xasprintf.h""
#include ""tool/viz/lib/formatstringtable.h""
#include ""tool/viz/lib/stringbuilder.h""

static void *ConvertShortMatrixToStringTable(long yn, long xn, char *T[yn][xn],
                                             const short M[yn][xn]) {
  long y, x;
  assert(yn && xn && !T[0][0]);
  for (y = 0; y < yn; ++y) {
    for (x = 0; x < xn; ++x) {
      T[y][x] = xasprintf(""%d"", M[y][x]);
    }
  }
  return T;
}

void FormatMatrixShort(long yn, long xn, const short M[yn][xn], int emit(),
                       void *arg, StringTableFormatter formatter,
                       const char *param1, const char *param2,
                       const char *param3) {
  FreeStringTableCells(
      yn, xn,
      formatter(yn, xn,
                ConvertShortMatrixToStringTable(
                    yn, xn, gc(xcalloc(yn * xn, sizeof(char *))), M),
                emit, arg, param1, param2, param3));
}

char *StringifyMatrixShort(long yn, long xn, const short M[yn][xn],
                           StringTableFormatter formatter, const char *param1,
                           const char *param2, const char *param3) {
  struct StringBuilder *sb = NewStringBuilder();
  FormatMatrixShort(yn, xn, M, StringBuilderAppend, sb, formatter, param1,
                    param2, param3);
  return FreeStringBuilder(sb);
}
"
./repos/cosmopolitan/tool/viz/lib/resizegraphic.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""dsp/tty/quant.h""
#include ""libc/assert.h""
#include ""libc/mem/mem.h""
#include ""tool/viz/lib/graphic.h""

// TODO(jart): DELETE

struct Graphic *resizegraphic(struct Graphic *g, size_t yn, size_t xn) {
  yn &= ~1;
  g->b = pvalloc(yn * xn * sizeof(ttyrgb_m128));
  g->yn = yn;
  g->xn = xn;
  return g;
}
"
./repos/cosmopolitan/tool/viz/lib/formatmatrix-byte.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/assert.h""
#include ""libc/math.h""
#include ""libc/mem/gc.h""
#include ""libc/mem/mem.h""
#include ""libc/x/xasprintf.h""
#include ""tool/viz/lib/formatstringtable.h""
#include ""tool/viz/lib/stringbuilder.h""

static void *ConvertByteMatrixToStringTable(long yn, long xn, char *T[yn][xn],
                                            const unsigned char M[yn][xn]) {
  long y, x;
  assert(yn && xn && !T[0][0]);
  for (y = 0; y < yn; ++y) {
    for (x = 0; x < xn; ++x) {
      T[y][x] = xasprintf(""%d"", M[y][x]);
    }
  }
  return T;
}

void FormatMatrixByte(long yn, long xn, const unsigned char M[yn][xn],
                      int emit(), void *arg, StringTableFormatter formatter,
                      const char *param1, const char *param2,
                      const char *param3) {
  FreeStringTableCells(
      yn, xn,
      formatter(yn, xn,
                ConvertByteMatrixToStringTable(
                    yn, xn, gc(calloc(yn * xn, sizeof(char *))), M),
                emit, arg, param1, param2, param3));
}

char *StringifyMatrixByte(long yn, long xn, const unsigned char M[yn][xn],
                          StringTableFormatter formatter, const char *param1,
                          const char *param2, const char *param3) {
  struct StringBuilder *sb = NewStringBuilder();
  FormatMatrixByte(yn, xn, M, StringBuilderAppend, sb, formatter, param1,
                   param2, param3);
  return FreeStringBuilder(sb);
}
"
./repos/cosmopolitan/tool/viz/lib/formatstringtable-assembly.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/fmt/itoa.h""
#include ""libc/intrin/safemacros.internal.h""
#include ""libc/mem/gc.h""
#include ""libc/str/str.h""
#include ""libc/str/strwidth.h""
#include ""libc/x/x.h""
#include ""tool/viz/lib/formatstringtable.h""

#define STREQ(A, B) (strcasecmp(A, B) == 0)

static int GetArrayAlignment(long yn, long xn, int w, int align) {
  /* abi guaranteed to 16 after which gcc / clang disagree */
  int i, r;
  r = i = align;
  while ((i *= 2) <= __BIGGEST_ALIGNMENT__) {
    if (yn * xn * w >= i) {
      r = i;
    }
  }
  return r;
}

static const char *GetStorageSpecifier(const char *type, int *out_width,
                                       int *out_align) {
  if (STREQ(type, ""unsigned char"") || STREQ(type, ""char"") ||
      STREQ(type, ""signed char"")) {
    *out_width = 1;
    *out_align = 1;
    return ""byte"";
  } else if (STREQ(type, ""unsigned short"") || STREQ(type, ""short"") ||
             STREQ(type, ""signed short"")) {
    *out_width = 2;
    *out_align = 2;
    return ""short"";
  } else if (STREQ(type, ""unsigned int"") || STREQ(type, ""unsigned"") ||
             STREQ(type, ""int"") || STREQ(type, ""signed int"")) {
    *out_width = 4;
    *out_align = 4;
    return ""long"";
  } else if (STREQ(type, ""unsigned long"") || STREQ(type, ""unsigned"") ||
             STREQ(type, ""long"") || STREQ(type, ""signed long"")) {
    *out_width = 8;
    *out_align = 8;
    return ""quad"";
  } else if (STREQ(type, ""float"")) {
    *out_width = 4;
    *out_align = 4;
    return ""float"";
  } else if (STREQ(type, ""double"")) {
    *out_width = 8;
    *out_align = 8;
    return ""double"";
  } else {
    *out_width = __BIGGEST_ALIGNMENT__;
    *out_align = __BIGGEST_ALIGNMENT__;
    return type;
  }
}

static void EmitSection(long yn, long xn, int w, int arrayalign, int emit(),
                        void *a) {
  char alignstr[21];
  FormatUint32(alignstr, arrayalign);
  if (arrayalign <= 8 && yn * xn * w == 8) {
    emit(""\t.rodata.cst"", a);
    emit(""8\n"", a);
  } else if (arrayalign <= 16 && yn * xn * w == 16) {
    emit(""\t.rodata.cst"", a);
    emit(""16\n"", a);
  } else if (arrayalign <= 32 && yn * xn * w == 32) {
    emit(""\t.rodata.cst"", a);
    emit(""32\n"", a);
  } else if (arrayalign <= 64 && yn * xn * w == 64) {
    emit(""\t.rodata.cst"", a);
    emit(""64\n"", a);
  } else {
    emit(""\t.rodata\n"", a);
    emit(""\t.align\t"", a);
    emit(alignstr, a);
    emit(""\n"", a);
  }
}

void *FormatStringTableAsAssembly(long yn, long xn, const char *const T[yn][xn],
                                  int emit(), void *a, const char *type,
                                  const char *name, const char *scope) {
  int w, align;
  const char *storage;
  char ynstr[21], xnstr[21];
  name = firstnonnull(name, ""M"");
  storage = GetStorageSpecifier(firstnonnull(type, ""long""), &w, &align);
  FormatUint64(ynstr, yn);
  FormatUint64(xnstr, xn);
  EmitSection(yn, xn, w, GetArrayAlignment(yn, xn, w, align), emit, a);
  emit(name, a);
  emit("":"", a);
  if (strwidth(name, 0) >= 8) emit(""\n"", a);
  FormatStringTable(yn, xn, T, emit, a, gc(xstrcat(""\t."", storage, ""\t"")), "","",
                    ""\n"");
  emit(""\t.endobj\t"", a);
  emit(name, a);
  emit("","", a);
  emit(firstnonnull(scope, ""globl""), a);
  emit(""\n\t.previous\n"", a);
  return (/* unconst */ void *)T;
}
"
./repos/cosmopolitan/tool/viz/lib/dither.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""dsp/tty/quant.h""
#include ""libc/intrin/hilbert.h""
#include ""libc/log/check.h""
#include ""libc/log/log.h""
#include ""libc/macros.internal.h""
#include ""libc/math.h""
#include ""libc/mem/gc.h""
#include ""libc/mem/mem.h""
#include ""libc/str/str.h""
#include ""tool/viz/lib/graphic.h""
#include ""tool/viz/lib/knobs.h""

#define CLAMP(X) MIN(255, MAX(0, X))

struct Dither {
  struct {
    int m5[32 * 32][2];
    int m4[16 * 16][2];
    int m3[8 * 8][2];
    int m2[4 * 4][2];
    int m1[2 * 2][2];
    int m0[2 * 2][2];
  } memory;
  struct Chunk {
    long b;
    void *c;
  } chunks[6];
} kDither;

static struct Chunk ChunkInit(long b, int c[b * b][2]) {
  long i;
  axdx_t h;
  for (i = 0; i < b * b; ++i) {
    h = unhilbert(b, i);
    c[i][0] = h.ax;
    c[i][1] = h.dx;
  }
  return (struct Chunk){b, c};
}

static optimizesize void DitherInit(struct Dither *d) {
  d->chunks[0] = ChunkInit(1 << 0, d->memory.m0);
  d->chunks[1] = ChunkInit(1 << 1, d->memory.m1);
  d->chunks[2] = ChunkInit(1 << 2, d->memory.m2);
  d->chunks[3] = ChunkInit(1 << 3, d->memory.m3);
  d->chunks[4] = ChunkInit(1 << 4, d->memory.m4);
  d->chunks[5] = ChunkInit(1 << 5, d->memory.m5);
}

static int GetQuantError(unsigned char r, unsigned char g, unsigned char b) {
  struct TtyRgb q = tty2rgb(rgb2tty(r, g, b));
  return ((r - q.r) + (g - q.g) + (b - q.b)) / 3;
}

static int SerpentineDitherSq2(long yw, long xw, unsigned char rgb[3][yw][xw],
                               long y, long x, long b, const int ci[b * b][2],
                               int e) {
  long i;
  for (i = 0; i < b * b; ++i) {
    e = GetQuantError((rgb[0][y + ci[i][0]][x + ci[i][1]] =
                           CLAMP(rgb[0][y + ci[i][0]][x + ci[i][1]] + e)),
                      (rgb[1][y + ci[i][0]][x + ci[i][1]] =
                           CLAMP(rgb[1][y + ci[i][0]][x + ci[i][1]] + e)),
                      (rgb[2][y + ci[i][0]][x + ci[i][1]] =
                           CLAMP(rgb[2][y + ci[i][0]][x + ci[i][1]] + e))) *
        15 / 16;
  }
  return e;
}

static void SerpentineDither(long yw, long xw, unsigned char rgb[3][yw][xw],
                             long yn, long xn, long y, long x, long r,
                             const struct Dither *d) {
  void *c;
  long b, i, j, n, m;
  b = d->chunks[r].b;
  c = d->chunks[r].c;
  n = (yn - y) / b;
  m = (xn - x) / b;
  for (i = 0; i < n; ++i) {
    for (j = 0; j < m; ++j) {
      SerpentineDitherSq2(yw, xw, rgb, y + i * b, x + j * b, b, c, 0);
    }
  }
  if (r) {
    SerpentineDither(yw, xw, rgb, yn, xn, y + 0 * 0, x + m * b, r - 1, d);
    SerpentineDither(yw, xw, rgb, yn, xn, y + n * b, x + 0 * 0, r - 1, d);
    SerpentineDither(yw, xw, rgb, yn, xn, y + n * b, x + m * b, r - 1, d);
  }
}

/**
 * Makes color banding go away a little in low color modes.
 */
void dither(long yw, long xw, unsigned char rgb[3][yw][xw], long yn, long xn) {
  static bool once;
  if (!once) {
    DitherInit(&kDither);
    once = true;
  }
  SerpentineDither(yw, xw, rgb, yn, xn, 0, 0, ARRAYLEN(kDither.chunks) - 1,
                   &kDither);
}
"
./repos/cosmopolitan/tool/viz/lib/sharpen.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""dsp/core/ks8.h""
#include ""libc/macros.internal.h""
#include ""libc/mem/mem.h""
#include ""libc/str/str.h""
#include ""libc/sysv/errfuns.h""
#include ""libc/time/time.h""
#include ""libc/x/x.h""
#include ""tool/viz/lib/convolution.h""
#include ""tool/viz/lib/graphic.h""

#define SHARPEN(...) KS8(0, 0, 0, 0, -1, -1, 5, -1, -1, 0, 0, 0, __VA_ARGS__)

long sharpen(long cn, long yw, long xw, unsigned char p[cn][yw][xw], long yn,
             long xn) {
  long rc, c, y, x;
  short(*ta)[3][xn];
  unsigned *iy, *ix;
  if (yn >= 3 && xn > 0) {
    ta = memalign(32, sizeof(short) * xn * 3);
    iy = convoindex(1, yn, 1);
    ix = convoindex(1, xn, 1);
    if (ta && iy && ix) {
      iy += 1;
      ix += 1;
      for (c = 0; c < 3; ++c) {
        for (y = 0; y < yn + 3; ++y) {
          if (y >= 3) {
            for (x = 0; x < xn; ++x) {
              p[c][y - 3][x] = MIN(255, MAX(0, (*ta)[y % 3][x]));
            }
          }
          if (y < yn) {
            for (x = 0; x < xn; ++x) {
              (*ta)[y % 3][x] =
                  SHARPEN(p[c][iy[y - 1]][x], p[c][y][ix[x - 1]], p[c][y][x],
                          p[c][y][ix[x + 1]], p[c][iy[y + 1]][x]);
            }
          }
        }
      }
      rc = 0;
    } else {
      rc = enomem();
    }
    free(ta);
    if (ix) free(ix - 1);
    if (iy) free(iy - 1);
  } else {
    rc = einval();
  }
  return rc;
}
"
./repos/cosmopolitan/tool/viz/lib/perlin3.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/macros.internal.h""
#include ""libc/math.h""
#include ""tool/viz/lib/graphic.h""

static int perm[513];

static double lerp(double t, double a, double b) {
  return a + t * (b - a);
}

static double fade(double t) {
  return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

static double grad(int hash, double x, double y, double z) {
  int h;
  double u, v;
  h = hash & 15;
  u = h < 8 ? x : y;
  v = h < 4 ? y : (h == 12 || h == 14) ? x : z;
  return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
}

/**
 * Perlin's improved noise algorithm.
 *
 * @see http://mrl.nyu.edu/~perlin/noise/
 * @note it's bryce3d cgi basically
 */
double perlin3(double x, double y, double z) /* clang-format off */ {
  double u, v, w;
  int X, Y, Z, AA, AB, BA, BB;
  X = floor(x);
  Y = floor(y);
  Z = floor(z);
  X &= 0xff;
  Y &= 0xff;
  Z &= 0xff;
  x -= floor(x);
  y -= floor(y);
  z -= floor(z);
  u = fade(x);
  v = fade(y);
  w = fade(z);
  AA = perm[perm[X    ] + Y    ] + Z;
  AB = perm[perm[X    ] + Y + 1] + Z;
  BA = perm[perm[X + 1] + Y    ] + Z;
  BB = perm[perm[X + 1] + Y + 1] + Z;
  return lerp(w, lerp(v, lerp(u, grad(perm[AA    ], x    , y    , z    ),
                                 grad(perm[BA    ], x - 1, y    , z    )),
                         lerp(u, grad(perm[AB    ], x    , y - 1, z    ),
                                 grad(perm[BB    ], x - 1, y - 1, z    ))),
                 lerp(v, lerp(u, grad(perm[AA + 1], x    , y    , z - 1),
                                 grad(perm[BA + 1], x - 1, y    , z - 1)),
                         lerp(u, grad(perm[AB + 1], x    , y - 1, z - 1),
                                 grad(perm[BB + 1], x - 1, y - 1, z - 1))));
} /* clang-format on */

static const uint8_t kPerm[] = {
    151, 160, 137, 91,  90,  15,  131, 13,  201, 95,  96,  53,  194, 233, 7,
    225, 140, 36,  103, 30,  69,  142, 8,   99,  37,  240, 21,  10,  23,  190,
    6,   148, 247, 120, 234, 75,  0,   26,  197, 62,  94,  252, 219, 203, 117,
    35,  11,  32,  57,  177, 33,  88,  237, 149, 56,  87,  174, 20,  125, 136,
    171, 168, 68,  175, 74,  165, 71,  134, 139, 48,  27,  166, 77,  146, 158,
    231, 83,  111, 229, 122, 60,  211, 133, 230, 220, 105, 92,  41,  55,  46,
    245, 40,  244, 102, 143, 54,  65,  25,  63,  161, 1,   216, 80,  73,  209,
    76,  132, 187, 208, 89,  18,  169, 200, 196, 135, 130, 116, 188, 159, 86,
    164, 100, 109, 198, 173, 186, 3,   64,  52,  217, 226, 250, 124, 123, 5,
    202, 38,  147, 118, 126, 255, 82,  85,  212, 207, 206, 59,  227, 47,  16,
    58,  17,  182, 189, 28,  42,  223, 183, 170, 213, 119, 248, 152, 2,   44,
    154, 163, 70,  221, 153, 101, 155, 167, 43,  172, 9,   129, 22,  39,  253,
    19,  98,  108, 110, 79,  113, 224, 232, 178, 185, 112, 104, 218, 246, 97,
    228, 251, 34,  242, 193, 238, 210, 144, 12,  191, 179, 162, 241, 81,  51,
    145, 235, 249, 14,  239, 107, 49,  192, 214, 31,  181, 199, 106, 157, 184,
    84,  204, 176, 115, 121, 50,  45,  127, 4,   150, 254, 138, 236, 205, 93,
    222, 114, 67,  29,  24,  72,  243, 141, 128, 195, 78,  66,  215, 61,  156,
    180,
};

__attribute__((__constructor__)) static void init(void) {
  unsigned i;
  for (i = 0; i < 256; ++i) {
    perm[i] = kPerm[i];
    perm[i + 256] = kPerm[i];
  }
}
"
./repos/cosmopolitan/tool/viz/lib/getxtermcodes.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""dsp/tty/quant.h""
#include ""libc/macros.internal.h""
#include ""tool/viz/lib/graphic.h""

void getxtermcodes(struct TtyRgb *p, const struct Graphic *g) {
  unsigned y, x;
  unsigned char(*img)[3][g->yn][g->xn] = g->b;
  for (y = 0; y < g->yn; ++y) {
    for (x = 0; x < g->xn; ++x) {
      *p++ = rgb2tty((*img)[0][y][x], (*img)[1][y][x], (*img)[2][y][x]);
    }
  }
}
"
./repos/cosmopolitan/tool/viz/lib/formatstringtable-code.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/intrin/safemacros.internal.h""
#include ""libc/fmt/itoa.h""
#include ""tool/viz/lib/formatstringtable.h""

void *FormatStringTableAsCode(long yn, long xn, const char *const T[yn][xn],
                              int emit(), void *arg, const char *type,
                              const char *name, const char *ignored) {
  char ynstr[21], xnstr[21];
  FormatUint64(ynstr, yn);
  FormatUint64(xnstr, xn);
  emit(type, arg);
  emit("" "", arg);
  emit(firstnonnull(name, ""M""), arg);
  emit(""["", arg);
  emit(ynstr, arg);
  emit(""]["", arg);
  emit(xnstr, arg);
  emit(""] = {"", arg);
  FormatStringTable(yn, xn, T, emit, arg, ""\n    {"", "", "", ""},"");
  emit(""\n};\n"", arg);
  return (/* unconst */ void *)T;
}
"
./repos/cosmopolitan/tool/viz/lib/emboss.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/viz/lib/convolve.h""
#include ""tool/viz/lib/graphic.h""
/* clang-format off */

void emboss(struct Graphic *g) {
  static const float kEmbossKernel[3][3] = {
      {-2.0, -1.0, +0.0},
      {-1.0, +1.0, +1.0},
      {+0.0, +1.0, +2.0},
  };
  convolve(g->yn, g->xn, g->b, 3, kEmbossKernel, 1, 0);
}
"
./repos/cosmopolitan/tool/plinko/plinko.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2021 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/plinko.h""
#include ""libc/thread/tls.h""

__static_yoink(""__zipos_get"");

int main(int argc, char *argv[]) {
  __tls_enabled = false;
  Plinko(argc, argv);
  return 0;
}
"
./repos/cosmopolitan/tool/plinko/lib/bind.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/cons.h""
#include ""tool/plinko/lib/plinko.h""

struct Binding Bind(int x, int y, int a, int u, dword p1, dword p2) {
  int k, v;
  dword a1 = 0;
  while (x) {
    if (x < 0) {
      if (y <= 0) {
        k = Car(x), x = Cdr(x);
        v = Car(y), y = Cdr(y);
        if (k) {
          if (k > 0) {
            if (!a1) {
              a1 = MAKE(k, FasterRecurse(v, a, p1, p2));
            } else {
              u = Alist(k, FasterRecurse(v, a, p1, p2), u);
            }
          } else {
            u = pairlis(k, FasterRecurse(v, a, p1, p2), u);
          }
        }
      } else {
        u = pairlis(x, FasterRecurse(y, a, p1, p2), u);
        y = 0;
        break;
      }
    } else {
      u = Alist(x, evlis(y, a, p1, p2), u);
      y = 0;
      break;
    }
  }
  if (y < 0) {
    Error(""bind: too many arguments x=%S y=%S"", x, y);
  }
  return (struct Binding){u, a1};
}
"
./repos/cosmopolitan/tool/plinko/lib/print.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/build/lib/case.h""
#include ""tool/plinko/lib/char.h""
#include ""tool/plinko/lib/plinko.h""
#include ""tool/plinko/lib/print.h""
#include ""tool/plinko/lib/tree.h""

int PrintDot(int fd) {
  return PrintChar(fd, L'.');
}

int PrintSpace(int fd) {
  return PrintChar(fd, L' ');
}

void PrintNewline(int fd) {
  PrintChar(fd, L'\n');
}

int PrintIndent(int fd, int n) {
  int i;
  for (i = 0; n > 0; --n) {
    i += PrintSpace(fd);
  }
  return i;
}

int PrintZeroes(int fd, int n) {
  int i;
  for (i = 0; n > 0; --n) {
    i += PrintChar(fd, L'0');
  }
  return i;
}

int PrintDepth(int fd, int n) {
  int i, j;
  for (j = i = 0; n > 0; --n, ++j) {
    if (j < ARRAYLEN(g_depths)) {
      i += PrintChar(fd, g_depths[j][0]);
      i += PrintChar(fd, g_depths[j][1]);
      i += PrintChar(fd, g_depths[j][2]);
    }
  }
  return i;
}

int PrintListDot(int fd, int x) {
  int n;
  n = PrintSpace(fd);
  n += PrintDot(fd);
  n += PrintSpace(fd);
  n += Print(fd, x);
  return n;
}

bool ShouldForceDot(int x) {
  return Cdr(x) < 0 && (Car(Cdr(x)) == kClosure || Car(Cdr(x)) == kLambda ||
                        Car(Cdr(x)) == kMacro);
}

bool ShouldConcealClosure(int x) {
  return !logc &&
         (Car(x) == kClosure /*  && Cdr(x) < 0 && Car(Cdr(x)) < 0 && */
          /* Car(Car(Cdr(x))) == kLambda && CountAtoms(x, 256, 0) >= 256 */);
}

int PrintList(int fd, int x) {
  int n = 0;
  DCHECK_LE(x, 0);
  if (x < cx) {
    n += PrintChar(fd, L'!');
    n += PrintInt(fd, x, 0, 0, 0, 10, true);
  } else {
    if (ShouldConcealClosure(x)) {
      x = Car(Cdr(x));
    }
    n += PrintChar(fd, L'(');
    if (x < 0) {
      n += Print(fd, Car(x));
      if (ShouldForceDot(x)) {
        n += PrintListDot(fd, Cdr(x));
      } else {
        while ((x = Cdr(x))) {
          if (x < 0) {
            n += PrintSpace(fd);
            n += Print(fd, Car(x));
          } else {
            n += PrintListDot(fd, x);
            break;
          }
        }
      }
    }
    n += PrintChar(fd, L')');
  }
  return n;
}

bool HasWeirdCharacters(int x) {
  int c;
  dword e;
  do {
    e = Get(x);
    c = LO(e);
    x = HI(e);
    if (c == L'`' || c == L'""' || c == L'\'' || IsSpace(c) || IsParen(c) ||
        IsSpace(c) || IsLower(c) || IsC0(c)) {
      return true;
    }
  } while (x != TERM);
  return false;
}

int PrintString(int fd, int x) {
  dword e;
  int c, u, n;
  n = PrintChar(fd, L'""');
  do {
    e = Get(x);
    c = LO(e);
    x = HI(e);
    DCHECK_GT(c, 0);
    DCHECK_LT(c, TERM);
    if (c < 0200) {
      u = c;
      c = L'\\';
      switch (c) {
        CASE(L'\a', c |= L'a' << 010);
        CASE(L'\b', c |= L'b' << 010);
        CASE(00033, c |= L'e' << 010);
        CASE(L'\f', c |= L'f' << 010);
        CASE(L'\n', c |= L'n' << 010);
        CASE(L'\r', c |= L'r' << 010);
        CASE(L'\t', c |= L't' << 010);
        CASE(L'\v', c |= L'v' << 010);
        CASE(L'\\', c |= L'\\' << 010);
        CASE(L'""', c |= L'""' << 010);
        default:
          if (32 <= c && c < 127) {
            c = u;
          } else {
            c |= ((L'0' + c / 8 / 8 % 8) << 010 | (L'0' + c / 8 % 8) << 020 |
                  (L'0' + c % 8) << 030);
          }
          break;
      }
      do {
        n += PrintChar(fd, c & 255);
      } while ((c >>= 010));
    } else {
      n += PrintChar(fd, c);
    }
  } while (x != TERM);
  n += PrintChar(fd, L'""');
  return n;
}

int PrintAtom(int fd, int x) {
  dword e;
  int c, n = 0;
  DCHECK_GE(x, 0);
  if (x == 0) {
    if (symbolism && !literally) {
      n += PrintChar(fd, L'⊥');
    } else {
      n += PrintChar(fd, L'N');
      n += PrintChar(fd, L'I');
      n += PrintChar(fd, L'L');
    }
  } else if (x == 1) {
    if (symbolism && !literally) {
      n += PrintChar(fd, L'⊤');
    } else {
      n += PrintChar(fd, L'T');
    }
  } else if (x >= TERM) {
    n += PrintChar(fd, L'!');
    n += PrintInt(fd, x, 0, 0, 0, 10, true);
  } else if (symbolism && (c = Symbolize(x)) != -1) {
    n += PrintChar(fd, c);
  } else {
    if (!literally && HasWeirdCharacters(x)) {
      n += PrintString(fd, x);
    } else {
      do {
        e = Get(x);
        c = LO(e);
        n += PrintChar(fd, c);
      } while ((x = HI(e)) != TERM);
    }
  }
  return n;
}

int EnterPrint(int x) {
#if 0
  int i;
  if (x < 0) {
    DCHECK_GE(pdp, 0);
    DCHECK_LT(pdp, ARRAYLEN(g_print));
    if (x < 0) {
      for (i = 0; i < pdp; ++i) {
        if (x == g_print[i]) {
          x = kCycle;
          break;
        }
      }
    }
    g_print[pdp++] = x;
    if (pdp == ARRAYLEN(g_print)) {
      x = kTrench;
    }
  }
#endif
  return x;
}

void LeavePrint(int x) {
#if 0
  if (x < 0) {
    --pdp;
  }
#endif
}

int Print(int fd, int x) {
  int n;
  GetName(&x);
  x = EnterPrint(x);
  if (1. / x < 0) {
    n = PrintList(fd, x);
  } else {
    n = PrintAtom(fd, x);
  }
  LeavePrint(x);
  return n;
}
"
./repos/cosmopolitan/tool/plinko/lib/printheap.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/fmt/itoa.h""
#include ""libc/runtime/symbols.internal.h""
#include ""libc/str/str.h""
#include ""tool/plinko/lib/plinko.h""
#include ""tool/plinko/lib/printf.h""

static const char *GetElfSymbol(uintptr_t funcaddr) {
  int s;
  static char buf[19];
  struct SymbolTable *t;
  if ((t = GetSymbolTable())) {
    if ((s = __get_symbol(t, funcaddr)) != -1) {
      return t->name_base + t->names[s];
    }
  }
  buf[0] = '0';
  buf[1] = 'x';
  uint64toarray_radix16(funcaddr, buf + 2);
  return buf;
}

static const char *GetDispatchName(int x) {
  const char *s;
  s = GetElfSymbol(LO(GetShadow(x)));
  if (startswith(s, ""Dispatch"")) s += 8;
  return s;
}

void PrintHeap(int i) {
  for (; i-- > cx;) {
    Printf(""%10d (%10d . %10d) %10s[%10d] %p%n"", i, LO(Get(i)), HI(Get(i)),
           GetDispatchName(i), HI(GetShadow(i)), i);
  }
}
"
./repos/cosmopolitan/tool/plinko/lib/printf.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/printf.h""
#include ""libc/intrin/strace.internal.h""
#include ""libc/nexgen32e/rdtsc.h""
#include ""libc/runtime/runtime.h""
#include ""libc/str/str.h""
#include ""libc/time/clockstonanos.internal.h""
#include ""tool/plinko/lib/char.h""
#include ""tool/plinko/lib/plinko.h""
#include ""tool/plinko/lib/print.h""

static inline long GetVarInt(va_list va, signed char t) {
  if (t <= 0) return va_arg(va, int);
  return va_arg(va, long);
}

static int PrintStr(int fd, const char *s, int cols) {
  int n, k = 0, i = 0;
  n = strlen(s);
  k += PrintIndent(fd, +cols - n);
  while (i < n) k += PrintChar(fd, s[i++]);
  k += PrintIndent(fd, -cols - n);
  return k;
}

int Printf(const char *f, ...) {
  int n;
  va_list va;
  va_start(va, f);
  n = Vfnprintf(f, va, 1, 0);
  va_end(va);
  return n;
}

int Fprintf(int fd, const char *f, ...) {
  int n;
  va_list va;
  va_start(va, f);
  n = Vfnprintf(f, va, fd, 0);
  va_end(va);
  return n;
}

int Fnprintf(int fd, int n, const char *f, ...) {
  va_list va;
  va_start(va, f);
  n = Vfnprintf(f, va, fd, n);
  va_end(va);
  return n;
}

int Vfprintf(const char *f, va_list va, int fd) {
  return Vfnprintf(f, va, fd, 0);
}

int Vfnprintf(const char *f, va_list va, int fd, int n) {
  enum { kPlain, kEsc, kCsi };
  static int recursive;
  dword t, u;
  const char *s;
  signed char type;
  char quot, ansi, gotr, pdot, zero;
  int b, c, x, y, si, prec, cols, sign;
  gotr = false;
  t = rdtsc();
  ftrace_enabled(-1);
  strace_enabled(-1);
  ++recursive;
  for (ansi = 0;;) {
    for (;;) {
      if (!(c = *f++ & 0377) || c == L'%') break;
      if (c >= 0300) {
        for (b = 0200; c & b; b >>= 1) {
          c ^= b;
        }
        while ((*f & 0300) == 0200) {
          c <<= 6;
          c |= *f++ & 0177;
        }
      }
      switch (ansi) {
        case kPlain:
          if (c == 033) {
            ansi = kEsc;
          } else if (c != L'\n' && c != L'\r') {
            n += GetMonospaceCharacterWidth(c);
          } else {
            n = 0;
          }
          break;
        case kEsc:
          if (c == '[') {
            ansi = kCsi;
          } else {
            ansi = kPlain;
          }
          break;
        case kCsi:
          if (0x40 <= c && c <= 0x7e) {
            ansi = kPlain;
          }
          break;
        default:
          __builtin_unreachable();
      }
    EmitFormatByte:
      PrintChar(fd, c);
    }
    if (!c) break;
    prec = 0;
    pdot = 0;
    cols = 0;
    quot = 0;
    type = 0;
    zero = 0;
    sign = 1;
    for (;;) {
      switch ((c = *f++)) {
        default:
          goto EmitFormatByte;
        case L'n':
          PrintNewline(fd);
          n = 0;
          break;
        case L'l':
          ++type;
          continue;
        case L'0':
        case L'1':
        case L'2':
        case L'3':
        case L'4':
        case L'5':
        case L'6':
        case L'7':
        case L'8':
        case L'9':
          si = pdot ? prec : cols;
          si *= 10;
          si += c - '0';
          goto UpdateCols;
        case L'*':
          si = va_arg(va, int);
        UpdateCols:
          if (pdot) {
            prec = si;
          } else {
            if (si < 0) {
              si = -si;
              sign = -1;
            } else if (!si) {
              zero = 1;
            }
            cols = si;
          }
          continue;
        case L'-':
          sign = -1;
          continue;
        case L'.':
          pdot = 1;
          continue;
        case L'_':
        case L',':
        case L'\'':
          quot = c;
          continue;
        case L'I':
          if (depth >= 0) {
            n += PrintDepth(fd, depth);
          } else {
            n += PrintIndent(fd, sp * 2);
          }
          break;
        case L'J':
          if (depth >= 0) {
            n += PrintDepth(fd, depth - 1);
          } else {
            n += PrintIndent(fd, (sp - 1) * 2);
          }
          break;
        case L'V':
          y = depth >= 0 ? depth : sp;
          if (y) {
            n += PrintIndent(fd, (y - 1) * 2);
            n += PrintChar(fd, L'├');
            n += PrintChar(fd, L'─');
          }
          break;
        case L'W':
          y = depth >= 0 ? depth : sp;
          if (y) {
            n += PrintIndent(fd, (y - 1) * 2);
            n += PrintChar(fd, L'│');
            n += PrintChar(fd, L' ');
          }
          break;
        case L'X':
          y = depth >= 0 ? depth : sp;
          if (y) {
            n += PrintIndent(fd, (y - 1) * 2);
            n += PrintChar(fd, L'└');
            n += PrintChar(fd, L'─');
          }
          break;
        case L'p':
          if (simpler) goto SimplePrint;
          // fallthrough
        case L'P':
          n += PrettyPrint(fd, va_arg(va, int),
                           MAX(0, depth > 0 ? n - depth * 3 : n));
          break;
        case L'T':
          PrintTree(fd, va_arg(va, int), n);
          break;
        case L'R':
          gotr = true;
          n += PrintInt(fd, ClocksToNanos(tick, t), cols * sign, quot, zero, 10,
                        true);
          break;
        case L'S':
        SimplePrint:
          n += Print(fd, va_arg(va, int));
          break;
        case L'A':
          y = va_arg(va, int);
          x = va_arg(va, int);
          n += PrintChar(fd, L'[');
          n += PrintArgs(fd, y, x, 0);
          n += PrintChar(fd, L']');
          break;
        case L'K':
          if ((b = va_arg(va, int)) < 0) {
            PrintChar(fd, L'(');
            for (;;) {
              n += Print(fd, Car(Car(b)));
              if ((b = Cdr(b)) >= 0) break;
              PrintChar(fd, L' ');
            }
            PrintChar(fd, L')');
          } else {
            n += Print(fd, b);
          }
          break;
        case L'd':
          n += PrintInt(fd, GetVarInt(va, type), cols * sign, quot, zero, 10,
                        true);
          break;
        case L'u':
          n +=
              PrintInt(fd, GetVarInt(va, type), cols * sign, quot, zero, 10, 0);
          break;
        case L'b':
          n += PrintInt(fd, GetVarInt(va, type), cols * sign, quot, zero, 2, 0);
          break;
        case L'o':
          n += PrintInt(fd, GetVarInt(va, type), cols * sign, quot, zero, 8, 0);
          break;
        case L'x':
          n +=
              PrintInt(fd, GetVarInt(va, type), cols * sign, quot, zero, 16, 0);
          break;
        case L's':
          s = va_arg(va, const char *);
          if (!s) s = ""NULL"";
          n += PrintStr(fd, s, cols * sign);
          break;
        case L'c':
          n += PrintChar(fd, va_arg(va, int));
          break;
      }
      break;
    }
  }
  --recursive;
  ftrace_enabled(+1);
  strace_enabled(+1);
  if (!recursive) {
    u = rdtsc();
    if (gotr) {
      tick = u;
    } else {
      tick -= u >= t ? u - t : ~t + u + 1;
    }
  }
  return n;
}
"
./repos/cosmopolitan/tool/plinko/lib/cmp.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/plinko.h""

/**
 * Compares LISP data structures
 *
 *     (≷ 𝑥 𝑦) ⟹ (⊥) | ⊥ | ⊤
 *
 * Where
 *
 *     (⊥) means less than       a.k.a. -1
 *      ⊥  means equal           a.k.a.  0
 *      ⊤  means greater than    a.k.a. +1
 *
 * The comparison is performed as follows:
 *
 *     (≷ 𝑥 𝑥) ⟹ ⊥                   everything's equal to itself
 *     (≡ 𝑥 𝑦) ⟶ (≡ (≷ 𝑥 𝑦) ⊥)       (eq) and (cmp) agree if (eq) returns t
 *     (≡ (≷ 𝑥 𝑦) ⊥) ⟺ (equal 𝑥 𝑦)   (cmp) returns eq iff (equal) returns t
 *     (≷ (ℶ x 𝑦) (ℶ x 𝑦)) ⟹ ⊥       i.e. this does deep comparisons
 *     (≷ ⊥ 𝑥) ⟹ (⊥)                 nil is less than everything non-nil
 *     (≷ 𝑥 ⊥) ⟹ ⊤                   comparisons are always symmetric
 *     (≷ 𝑖 𝑗) ⟹ (⊥)                 atom vs. atom compares unicodes
 *     (≷ 𝑖𝑗 𝑘𝑙) ⟺ (≷ (𝑖 𝑗) (𝑘 𝑙))   atom characters treated like lists
 *     (≷ 𝑖 (x . 𝑦)) ⟹ (⊥)           atom vs. cons is always less than
 *     (≷ (x . 𝑦) (x . 𝑦)) ⟹ ⊥       cons vs. cons just recurses
 *     (≷ (𝑥) (⊥ 𝑦)) ⟹ ⊤             e.g. cmp returns gt because 𝑥 > ⊥
 *     (≷ (𝑥) (𝑧 𝑦)) ⟹ (⊥)           e.g. cmp returns lt because ⊥ < (𝑦)
 *     (≷ (x . 𝑦) (x 𝑦)) ⟹ (⊥)       e.g. cmp returns lt because 𝑦 < (𝑦)
 *
 * @return -1, 0, +1
 */
int Cmp(int x, int y) {
  int c;
  dword t, u;
  if (x == y) return 0;
  if (x > 1 && y > 1) {
    if (LO(Get(x)) < LO(Get(x))) return -1;
    if (LO(Get(x)) > LO(Get(x))) return +1;
  }
  for (;; x = Cdr(x), y = Cdr(y)) {
    if (x == y) return 0;
    if (!x) return -1;
    if (!y) return +1;
    if (x < 0) {
      if (y >= 0) return +1;
      if ((c = Cmp(Car(x), Car(y)))) return c;
    } else {
      if (y < 0) return -1;
      for (;;) {
        t = x != 1 ? Get(x) : MAKE(L'T', TERM);
        u = y != 1 ? Get(y) : MAKE(L'T', TERM);
        if (LO(t) != LO(u)) {
          return LO(t) < LO(u) ? -1 : +1;
        }
        x = HI(t);
        y = HI(u);
        if (x == y) return 0;
        if (x == TERM) return -1;
        if (y == TERM) return +1;
      }
      if (Car(x) != Car(y)) {
        return Car(x) < Car(y) ? -1 : +1;
      }
    }
  }
}
"
./repos/cosmopolitan/tool/plinko/lib/hasatom.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/plinko.h""

nosideeffect bool HasAtom(int v, int x) {
  if (!x) return false;
  if (x > 0) return v == x;
  return HasAtom(v, Car(x)) || HasAtom(v, Cdr(x));
}
"
./repos/cosmopolitan/tool/plinko/lib/iscdr.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/plinko.h""

/**
 * Matches
 *
 *     (⍆ X)
 *
 * @return X on success, or 0 on mismatch
 * @note ⍆ means CDR
 */
int IsCdr(int x_) {
  dword w_;
  if (x_ >= 0) return 0;
  w_ = Get(x_);  // (⍆ X)
  int ax_ = LO(w_);
  int dx_ = HI(w_);
  if (ax_ != kCdr) return 0;
  if (dx_ >= 0) return 0;
  w_ = Get(dx_);  // (X)
  int adx_ = LO(w_);
  int ddx_ = HI(w_);
  int X = adx_;
  if (ddx_) return 0;
  return X;
}
"
./repos/cosmopolitan/tool/plinko/lib/iscar.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/plinko.h""

/**
 * Matches
 *
 *     (⍅ X)
 *
 * @return X on success, or 0 on mismatch
 * @note ⍅ means CAR
 */
int IsCar(int x_) {
  dword w_;
  if (x_ >= 0) return 0;
  w_ = Get(x_);  // (⍅ X)
  int ax_ = LO(w_);
  int dx_ = HI(w_);
  if (ax_ != kCar) return 0;
  if (dx_ >= 0) return 0;
  w_ = Get(dx_);  // (X)
  int adx_ = LO(w_);
  int ddx_ = HI(w_);
  int X = adx_;
  if (ddx_) return 0;
  return X;
}
"
./repos/cosmopolitan/tool/plinko/lib/vars.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/runtime/runtime.h""
#include ""tool/plinko/lib/plinko.h""

#ifdef __llvm__
dword cGets;
dword *g_mem;
#endif

unsigned short sp;

bool ftrace;
bool mtrace;
bool gtrace;
bool noname;
bool literally;
bool symbolism;

bool dump;     // -d causes globals to be printed at exit
bool trace;    // -t causes evaluator to print explanations
bool loga;     // -a flag causes -t to print massive environment
bool logc;     // -c flag causes -t to print jupiterian closures
bool quiet;    // tracks (quiet) state which suppresses (print)
bool stats;    // -s causes statistics to be printed after each evaluation
bool simpler;  // -S usually disables pretty printing so you can | cut -c-80

int cx;       // cons stack pointer
int ax;       // used by read atom interner
int dx;       // used by read for lookahead
int bp[4];    // buffer pointers for file descriptors
int pdp;      // used by print to prevent stack overflow
int depth;    // when tracing is enabled tracks trace depth
int fails;    // failure count to influence process exit code
int cHeap;    // statistical approximate of minimum cx during work
int cAtoms;   // statistical count of characters in atom hash tree
int cFrost;   // monotonic frostline of defined permanent cons cells
int globals;  // cons[rbtree;bool  0] of globally scoped definitions i.e. 𝑎
int revglob;  // reverse mapped rbtree of globals (informational printing)
int ordglob;  // the original defined order for all global definition keys

int kTrace;
int kMtrace;
int kFtrace;
int kGtrace;
int kEq;
int kGc;
int kCmp;
int kCar;
int kBackquote;
int kDefun;
int kDefmacro;
int kAppend;
int kBeta;
int kAnd;
int kCdr;
int kRead;
int kDump;
int kQuote;
int kProgn;
int kLambda;
int kDefine;
int kMacro;
int kQuiet;
int kSplice;
int kPrinc;
int kPrint;
int kPprint;
int kIgnore;
int kExpand;
int kCond;
int kAtom;
int kOr;
int kCons;
int kIntegrate;
int kString;
int kSquare;
int kCurly;
int kFork;
int kGensym;
int kTrench;
int kYcombinator;
int kBecause;
int kTherefore;
int kUnion;
int kImplies;
int kNand;
int kNor;
int kXor;
int kIff;
int kPartial;
int kError;
int kExit;
int kClosure;
int kFunction;
int kCycle;
int kFlush;
int kIgnore0;
int kComma;
int kIntersection;
int kList;
int kMember;
int kNot;
int kReverse;
int kSqrt;
int kSubset;
int kSuperset;
int kPrintheap;
int kImpossible;
int kUnchanged;
int kOrder;

jmp_buf crash;
jmp_buf exiter;

char g_buffer[4][512];
unsigned short g_depths[128][3];

dword tick;
dword cSets;
dword *g_dis;
EvalFn *eval;
BindFn *bind_;
char **inputs;
EvalFn *expand;
EvlisFn *evlis;
PairFn *pairlis;
TailFn *kTail[8];
RecurseFn *recurse;

int g_copy[256];
int g_print[256];
int kAlphabet[26];
dword g_stack[STACK];
int kConsAlphabet[26];

long g_assoc_histogram[12];
long g_gc_lop_histogram[30];
long g_gc_marks_histogram[30];
long g_gc_dense_histogram[30];
long g_gc_sparse_histogram[30];
long g_gc_discards_histogram[30];
"
./repos/cosmopolitan/tool/plinko/lib/iswide.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/macros.internal.h""
#include ""tool/plinko/lib/char.h""

static const unsigned short kWides[][2] = {
    {0x1100, 0x115F},  // HANGUL CHOSEONG KIYEOK..HANGUL CHOSEONG FILLER
    {0x231A, 0x231B},  // WATCH..HOURGLASS
    {0x2329, 0x2329},  // LEFT-POINTING ANGLE BRACKET
    {0x232A, 0x232A},  // RIGHT-POINTING ANGLE BRACKET
    {0x23E9, 0x23EC},  // BLACK RIGHT-POINTING DOUBLE TRIANGLE...
    {0x23F0, 0x23F0},  // ALARM CLOCK
    {0x23F3, 0x23F3},  // HOURGLASS WITH FLOWING SAND
    {0x25FD, 0x25FE},  // WHITE MEDIUM SMALL SQUARE..BLACK MEDIUM SMALL SQUARE
    {0x2614, 0x2615},  // UMBRELLA WITH RAIN DROPS..HOT BEVERAGE
    {0x2648, 0x2653},  // ARIES..PISCES
    {0x267F, 0x267F},  // WHEELCHAIR SYMBOL
    {0x2693, 0x2693},  // ANCHOR
    {0x26A1, 0x26A1},  // HIGH VOLTAGE SIGN
    {0x26AA, 0x26AB},  // MEDIUM WHITE CIRCLE..MEDIUM BLACK CIRCLE
    {0x26BD, 0x26BE},  // SOCCER BALL..BASEBALL
    {0x26C4, 0x26C5},  // SNOWMAN WITHOUT SNOW..SUN BEHIND CLOUD
    {0x26CE, 0x26CE},  // OPHIUCHUS
    {0x26D4, 0x26D4},  // NO ENTRY
    {0x26EA, 0x26EA},  // CHURCH
    {0x26F2, 0x26F3},  // FOUNTAIN..FLAG IN HOLE
    {0x26F5, 0x26F5},  // SAILBOAT
    {0x26FA, 0x26FA},  // TENT
    {0x26FD, 0x26FD},  // FUEL PUMP
    {0x2705, 0x2705},  // WHITE HEAVY CHECK MARK
    {0x270A, 0x270B},  // RaiseD FIST..RaiseD HAND
    {0x2728, 0x2728},  // SPARKLES
    {0x274C, 0x274C},  // CROSS MARK
    {0x274E, 0x274E},  // NEGATIVE SQUARED CROSS MARK
    {0x2753, 0x2755},  // BLACK QUESTION MARK ORNAMENT..WHITE EXCLAMATION MARK
    {0x2757, 0x2757},  // HEAVY EXCLAMATION MARK SYMBOL
    {0x2795, 0x2797},  // HEAVY PLUS SIGN..HEAVY DIVISION SIGN
    {0x27B0, 0x27B0},  // CURLY LOOP
    {0x27BF, 0x27BF},  // DOUBLE CURLY LOOP
    {0x2B1B, 0x2B1C},  // BLACK LARGE SQUARE..WHITE LARGE SQUARE
    {0x2B50, 0x2B50},  // WHITE MEDIUM STAR
    {0x2B55, 0x2B55},  // HEAVY LARGE CIRCLE
    {0x2E80, 0x2E99},  // CJK RADICAL REPEAT..CJK RADICAL RAP
    {0x2E9B, 0x2EF3},  // CJK RADICAL CHOKE..CJK RADICAL C-SIMPLIFIED TURTLE
    {0x2F00, 0x2FD5},  // KANGXI RADICAL ONE..KANGXI RADICAL FLUTE
    {0x2FF0, 0x2FFB},  // IDEOGRAPHIC DESCRIPTION CHARACTER LTR..OVERLAID
    {0x3000, 0x3000},  // IDEOGRAPHIC SPACE
    {0x3001, 0x3003},  // IDEOGRAPHIC COMMA..DITTO MARK
    {0x3004, 0x3004},  // JAPANESE INDUSTRIAL STANDARD SYMBOL
    {0x3005, 0x3005},  // IDEOGRAPHIC ITERATION MARK
    {0x3006, 0x3006},  // IDEOGRAPHIC CLOSING MARK
    {0x3007, 0x3007},  // IDEOGRAPHIC NUMBER ZERO
    {0x3008, 0x3008},  // LEFT ANGLE BRACKET
    {0x3009, 0x3009},  // RIGHT ANGLE BRACKET
    {0x300A, 0x300A},  // LEFT DOUBLE ANGLE BRACKET
    {0x300B, 0x300B},  // RIGHT DOUBLE ANGLE BRACKET
    {0x300C, 0x300C},  // LEFT CORNER BRACKET
    {0x300D, 0x300D},  // RIGHT CORNER BRACKET
    {0x300E, 0x300E},  // LEFT WHITE CORNER BRACKET
    {0x300F, 0x300F},  // RIGHT WHITE CORNER BRACKET
    {0x3010, 0x3010},  // LEFT BLACK LENTICULAR BRACKET
    {0x3011, 0x3011},  // RIGHT BLACK LENTICULAR BRACKET
    {0x3012, 0x3013},  // POSTAL MARK..GETA MARK
    {0x3014, 0x3014},  // LEFT TORTOISE SHELL BRACKET
    {0x3015, 0x3015},  // RIGHT TORTOISE SHELL BRACKET
    {0x3016, 0x3016},  // LEFT WHITE LENTICULAR BRACKET
    {0x3017, 0x3017},  // RIGHT WHITE LENTICULAR BRACKET
    {0x3018, 0x3018},  // LEFT WHITE TORTOISE SHELL BRACKET
    {0x3019, 0x3019},  // RIGHT WHITE TORTOISE SHELL BRACKET
    {0x301A, 0x301A},  // LEFT WHITE SQUARE BRACKET
    {0x301B, 0x301B},  // RIGHT WHITE SQUARE BRACKET
    {0x301C, 0x301C},  // WAVE DASH
    {0x301D, 0x301D},  // REVERSED DOUBLE PRIME QUOTATION MARK
    {0x301E, 0x301F},  // DOUBLE PRIME QUOTATION MARK..LOW DOUBLE PRIME
    {0x3020, 0x3020},  // POSTAL MARK FACE
    {0x3021, 0x3029},  // HANGZHOU NUMERAL ONE..HANGZHOU NUMERAL NINE
    {0x302A, 0x302D},  // IDEOGRAPHIC LEVEL TONE MARK..ENTERING TONE MARK
    {0x302E, 0x302F},  // HANGUL SINGLE DOT TONE MARK..DOUBLE DOT TONE MARK
    {0x3030, 0x3030},  // WAVY DASH
    {0x3031, 0x3035},  // VERTICAL KANA REPEAT MARK..KANA REPEAT MARK LOWER
    {0x3036, 0x3037},  // CIRCLED POSTAL MARK..IDEOGRAPHIC TELEGRAPH LF SYMBOL
    {0x3038, 0x303A},  // HANGZHOU NUMERAL TEN..HANGZHOU NUMERAL THIRTY
    {0x303B, 0x303B},  // VERTICAL IDEOGRAPHIC ITERATION MARK
    {0x303C, 0x303C},  // MASU MARK
    {0x303D, 0x303D},  // PART ALTERNATION MARK
    {0x303E, 0x303E},  // IDEOGRAPHIC VARIATION INDICATOR
    {0x3041, 0x3096},  // HIRAGANA LETTER SMALL A..HIRAGANA LETTER SMALL KE
    {0x3099, 0x309A},  // COMBINING KATAKANA-HIRAGANA VOICED SOUND MARK...
    {0x309B, 0x309C},  // KATAKANA-HIRAGANA VOICED SOUND MARK...
    {0x309D, 0x309E},  // HIRAGANA ITERATION MARK..VOICED ITERATION MARK
    {0x309F, 0x309F},  // HIRAGANA DIGRAPH YORI
    {0x30A0, 0x30A0},  // KATAKANA-HIRAGANA DOUBLE HYPHEN
    {0x30A1, 0x30FA},  // KATAKANA LETTER SMALL A..KATAKANA LETTER VO
    {0x30FB, 0x30FB},  // KATAKANA MIDDLE DOT
    {0x30FC, 0x30FE},  // KATAKANA-HIRAGANA PROLONGED SOUND MARK..ITERATION
    {0x30FF, 0x30FF},  // KATAKANA DIGRAPH KOTO
    {0x3105, 0x312F},  // BOPOMOFO LETTER B..BOPOMOFO LETTER NN
    {0x3131, 0x318E},  // HANGUL LETTER KIYEOK..HANGUL LETTER ARAEAE
    {0x3190, 0x3191},  // IDEOGRAPHIC ANNOTATION LINKING MARK..REVERSE
    {0x3192, 0x3195},  // IDEOGRAPHIC ANNOTATION ONE MARK..FOUR
    {0x3196, 0x319F},  // IDEOGRAPHIC ANNOTATION TOP MARK..MAN
    {0x31A0, 0x31BF},  // BOPOMOFO LETTER BU..BOPOMOFO LETTER AH
    {0x31C0, 0x31E3},  // CJK STROKE T..CJK STROKE Q
    {0x31F0, 0x31FF},  // KATAKANA LETTER SMALL KU..KATAKANA LETTER SMALL RO
    {0x3200, 0x321E},  // PARENTHESIZED HANGUL KIYEOK..CHARACTER O HU
    {0x3220, 0x3229},  // PARENTHESIZED IDEOGRAPH ONE..TEN
    {0x322A, 0x3247},  // PARENTHESIZED IDEOGRAPH MOON..CIRCLED IDEOGRAPH KOTO
    {0x3250, 0x3250},  // PARTNERSHIP SIGN
    {0x3251, 0x325F},  // CIRCLED NUMBER TWENTY ONE..CIRCLED 35
    {0x3260, 0x327F},  // CIRCLED HANGUL KIYEOK..KOREAN STANDARD SYMBOL
    {0x3280, 0x3289},  // CIRCLED IDEOGRAPH ONE..CIRCLED IDEOGRAPH TEN
    {0x328A, 0x32B0},  // CIRCLED IDEOGRAPH MOON..CIRCLED IDEOGRAPH NIGHT
    {0x32B1, 0x32BF},  // CIRCLED NUMBER THIRTY SIX..CIRCLED NUMBER FIFTY
    {0x32C0, 0x32FF},  // TELEGRAPH SYMBOL FOR JANUARY..SQUARE ERA NAME REIWA
    {0x3300, 0x33FF},  // SQUARE APAATO..SQUARE GAL
    {0x3400, 0x4DBF},  // CJK UNIFIED IDEOGRAPH
    {0x4E00, 0x9FFF},  // CJK UNIFIED IDEOGRAPH
    {0xA000, 0xA014},  // YI SYLLABLE IT..YI SYLLABLE E
    {0xA015, 0xA015},  // YI SYLLABLE WU
    {0xA016, 0xA48C},  // YI SYLLABLE BIT..YI SYLLABLE YYR
    {0xA490, 0xA4C6},  // YI RADICAL QOT..YI RADICAL KE
    {0xA960, 0xA97C},  // HANGUL CHOSEONG TIKEUT-MIEUM..SSANGYEORINHIEUH
    {0xAC00, 0xD7A3},  // HANGUL SYLLABLE GA..HANGUL SYLLABLE HIH
    {0xF900, 0xFA6D},  // CJK COMPATIBILITY IDEOGRAPH
    {0xFA6E, 0xFA6F},  // RESERVED
    {0xFA70, 0xFAD9},  // CJK COMPATIBILITY IDEOGRAPH
    {0xFADA, 0xFAFF},  // RESERVED
    {0xFE10, 0xFE16},  // PRESENTATION FORM FOR VERTICAL COMMA..QUESTION
    {0xFE17, 0xFE17},  // VERTICAL LEFT WHITE LENTICULAR BRACKET
    {0xFE18, 0xFE18},  // VERTICAL RIGHT WHITE LENTICULAR BRAKCET
    {0xFE19, 0xFE19},  // PRESENTATION FORM FOR VERTICAL HORIZONTAL ELLIPSIS
    {0xFE30, 0xFE30},  // PRESENTATION FORM FOR VERTICAL TWO DOT LEADER
    {0xFE31, 0xFE32},  // VERTICAL EM DASH..VERTICAL EN DASH
    {0xFE33, 0xFE34},  // VERTICAL LOW LINE..VERTICAL WAVY LOW LINE
    {0xFE35, 0xFE35},  // PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS
    {0xFE36, 0xFE36},  // PRESENTATION FORM FOR VERTICAL RIGHT PARENTHESIS
    {0xFE37, 0xFE37},  // PRESENTATION FORM FOR VERTICAL LEFT CURLY BRACKET
    {0xFE38, 0xFE38},  // PRESENTATION FORM FOR VERTICAL RIGHT CURLY BRACKET
    {0xFE39, 0xFE39},  // VERTICAL LEFT TORTOISE SHELL BRACKET
    {0xFE3A, 0xFE3A},  // VERTICAL RIGHT TORTOISE SHELL BRACKET
    {0xFE3B, 0xFE3B},  // VERTICAL LEFT BLACK LENTICULAR BRACKET
    {0xFE3C, 0xFE3C},  // VERTICAL RIGHT BLACK LENTICULAR BRACKET
    {0xFE3D, 0xFE3D},  // VERTICAL LEFT DOUBLE ANGLE BRACKET
    {0xFE3E, 0xFE3E},  // VERTICAL RIGHT DOUBLE ANGLE BRACKET
    {0xFE3F, 0xFE3F},  // VERTICAL LEFT ANGLE BRACKET
    {0xFE40, 0xFE40},  // VERTICAL RIGHT ANGLE BRACKET
    {0xFE41, 0xFE41},  // VERTICAL LEFT CORNER BRACKET
    {0xFE42, 0xFE42},  // VERTICAL RIGHT CORNER BRACKET
    {0xFE43, 0xFE43},  // VERTICAL LEFT WHITE CORNER BRACKET
    {0xFE44, 0xFE44},  // VERTICAL RIGHT WHITE CORNER BRACKET
    {0xFE45, 0xFE46},  // SESAME DOT..WHITE SESAME DOT
    {0xFE47, 0xFE47},  // VERTICAL LEFT SQUARE BRACKET
    {0xFE48, 0xFE48},  // VERTICAL RIGHT SQUARE BRACKET
    {0xFE49, 0xFE4C},  // DASHED OVERLINE..DOUBLE WAVY OVERLINE
    {0xFE4D, 0xFE4F},  // DASHED LOW LINE..WAVY LOW LINE
    {0xFE50, 0xFE52},  // SMALL COMMA..SMALL FULL STOP
    {0xFE54, 0xFE57},  // SMALL SEMICOLON..SMALL EXCLAMATION MARK
    {0xFE58, 0xFE58},  // SMALL EM DASH
    {0xFE59, 0xFE59},  // SMALL LEFT PARENTHESIS
    {0xFE5A, 0xFE5A},  // SMALL RIGHT PARENTHESIS
    {0xFE5B, 0xFE5B},  // SMALL LEFT CURLY BRACKET
    {0xFE5C, 0xFE5C},  // SMALL RIGHT CURLY BRACKET
    {0xFE5D, 0xFE5D},  // SMALL LEFT TORTOISE SHELL BRACKET
    {0xFE5E, 0xFE5E},  // SMALL RIGHT TORTOISE SHELL BRACKET
    {0xFE5F, 0xFE61},  // SMALL NUMBER SIGN..SMALL ASTERISK
    {0xFE62, 0xFE62},  // SMALL PLUS SIGN
    {0xFE63, 0xFE63},  // SMALL HYPHEN-MINUS
    {0xFE64, 0xFE66},  // SMALL LESS-THAN SIGN..SMALL EQUALS SIGN
    {0xFE68, 0xFE68},  // SMALL REVERSE SOLIDUS
    {0xFE69, 0xFE69},  // SMALL DOLLAR SIGN
    {0xFE6A, 0xFE6B},  // SMALL PERCENT SIGN..SMALL COMMERCIAL AT
    {0xFF01, 0xFF03},  // EXCLAMATION MARK..NUMBER SIGN
    {0xFF04, 0xFF04},  // DOLLAR SIGN
    {0xFF05, 0xFF07},  // PERCENT SIGN..APOSTROPHE
    {0xFF08, 0xFF08},  // LEFT PARENTHESIS
    {0xFF09, 0xFF09},  // RIGHT PARENTHESIS
    {0xFF0A, 0xFF0A},  // ASTERISK
    {0xFF0B, 0xFF0B},  // PLUS SIGN
    {0xFF0C, 0xFF0C},  // COMMA
    {0xFF0D, 0xFF0D},  // HYPHEN-MINUS
    {0xFF0E, 0xFF0F},  // FULL STOP..SOLIDUS
    {0xFF10, 0xFF19},  // DIGIT ZERO..DIGIT NINE
    {0xFF1A, 0xFF1B},  // COLON..SEMICOLON
    {0xFF1C, 0xFF1E},  // LESS-THAN..GREATER-THAN
    {0xFF1F, 0xFF20},  // QUESTION MARK..COMMERCIAL AT
    {0xFF21, 0xFF3A},  // LATIN CAPITAL LETTER A..Z
    {0xFF3B, 0xFF3B},  // LEFT SQUARE BRACKET
    {0xFF3C, 0xFF3C},  // REVERSE SOLIDUS
    {0xFF3D, 0xFF3D},  // RIGHT SQUARE BRACKET
    {0xFF3E, 0xFF3E},  // CIRCUMFLEX ACCENT
    {0xFF3F, 0xFF3F},  // LOW LINE
    {0xFF40, 0xFF40},  // GRAVE ACCENT
    {0xFF41, 0xFF5A},  // LATIN SMALL LETTER A..Z
    {0xFF5B, 0xFF5B},  // LEFT CURLY BRACKET
    {0xFF5C, 0xFF5C},  // VERTICAL LINE
    {0xFF5D, 0xFF5D},  // RIGHT CURLY BRACKET
    {0xFF5E, 0xFF5E},  // TILDE
    {0xFF5F, 0xFF5F},  // LEFT WHITE PARENTHESIS
    {0xFF60, 0xFF60},  // RIGHT WHITE PARENTHESIS
    {0xFFE0, 0xFFE1},  // CENT SIGN..POUND SIGN
    {0xFFE2, 0xFFE2},  // NOT SIGN
    {0xFFE3, 0xFFE3},  // MACRON
    {0xFFE4, 0xFFE4},  // BROKEN BAR
    {0xFFE5, 0xFFE6},  // YEN SIGN..WON SIGN
};

static const int kAstralWides[][2] = {
    {0x16FE0, 0x16FE1},  // TANGUT ITERATION MARK..NUSHU ITERATION MARK
    {0x16FE2, 0x16FE2},  // OLD CHINESE HOOK MARK
    {0x16FE3, 0x16FE3},  // OLD CHINESE ITERATION MARK
    {0x16FE4, 0x16FE4},  // KHITAN SMALL SCRIPT FILLER
    {0x16FF0, 0x16FF1},  // VIETNAMESE ALTERNATE READING MARK CA..NHAY
    {0x17000, 0x187F7},  // TANGUT IDEOGRAPH
    {0x18800, 0x18AFF},  // TANGUT COMPONENT
    {0x18B00, 0x18CD5},  // KHITAN SMALL SCRIPT CHARACTER
    {0x18D00, 0x18D08},  // TANGUT IDEOGRAPH
    {0x1AFF0, 0x1AFF3},  // KATAKANA LETTER MINNAN TONE-2..5
    {0x1AFF5, 0x1AFFB},  // KATAKANA LETTER MINNAN TONE-7..5
    {0x1AFFD, 0x1AFFE},  // KATAKANA LETTER MINNAN NASALIZED TONE-7..8
    {0x1B000, 0x1B0FF},  // KATAKANA LETTER ARCHAIC E..HENTAIGANA LETTER RE-2
    {0x1B100, 0x1B122},  // HENTAIGANA LETTER RE-3..KATAKANA LETTER ARCHAIC WU
    {0x1B150, 0x1B152},  // HIRAGANA LETTER SMALL WI..HIRAGANA LETTER SMALL WO
    {0x1B164, 0x1B167},  // KATAKANA LETTER SMALL WI..KATAKANA LETTER SMALL N
    {0x1B170, 0x1B2FB},  // NUSHU CHARACTER-1B170..NUSHU CHARACTER-1B2FB
    {0x1F004, 0x1F004},  // MAHJONG TILE RED DRAGON
    {0x1F0CF, 0x1F0CF},  // PLAYING CARD BLACK JOKER
    {0x1F18E, 0x1F18E},  // NEGATIVE SQUARED AB
    {0x1F191, 0x1F19A},  // SQUARED CL..SQUARED VS
    {0x1F200, 0x1F202},  // SQUARE HIRAGANA HOKA..SQUARED KATAKANA SA
    {0x1F210, 0x1F23B},  // SQUARED CJK UNIFIED IDEOGRAPH
    {0x1F240, 0x1F248},  // TORTOISE SHELL BRACKETED CJK UNIFIED IDEOGRAPH
    {0x1F250, 0x1F251},  // CIRCLED IDEOGRAPH ADVANTAGE..ACCEPT
    {0x1F260, 0x1F265},  // ROUNDED SYMBOL FOR FU..ROUNDED SYMBOL FOR CAI
    {0x1F300, 0x1F320},  // CYCLONE..SHOOTING STAR
    {0x1F32D, 0x1F335},  // HOT DOG..CACTUS
    {0x1F337, 0x1F37C},  // TULIP..BABY BOTTLE
    {0x1F37E, 0x1F393},  // BOTTLE WITH POPPING CORK..GRADUATION CAP
    {0x1F3A0, 0x1F3CA},  // CAROUSEL HORSE..SWIMMER
    {0x1F3CF, 0x1F3D3},  // CRICKET BAT AND BALL..TABLE TENNIS PADDLE AND BALL
    {0x1F3E0, 0x1F3F0},  // HOUSE BUILDING..EUROPEAN CASTLE
    {0x1F3F4, 0x1F3F4},  // WAVING BLACK FLAG
    {0x1F3F8, 0x1F3FA},  // BADMINTON RACQUET AND SHUTTLECOCK..AMPHORA
    {0x1F3FB, 0x1F3FF},  // EMOJI MODIFIER FITZPATRICK TYPE-1-2..6
    {0x1F400, 0x1F43E},  // RAT..PAW PRINTS
    {0x1F440, 0x1F440},  // EYES
    {0x1F442, 0x1F4FC},  // EAR..VIDEOCASSETTE
    {0x1F4FF, 0x1F53D},  // PRAYER BEADS..DOWN-POINTING SMALL RED TRIANGLE
    {0x1F54B, 0x1F54E},  // KAABA..MENORAH WITH NINE BRANCHES
    {0x1F550, 0x1F567},  // CLOCK FACE ONE OCLOCK..CLOCK FACE TWELVE-THIRTY
    {0x1F57A, 0x1F57A},  // MAN DANCING
    {0x1F595, 0x1F596},  // REVERSED HAND WITH MIDDLE FINGER EXTENDED..FINGERS
    {0x1F5A4, 0x1F5A4},  // BLACK HEART
    {0x1F5FB, 0x1F5FF},  // MOUNT FUJI..MOYAI
    {0x1F600, 0x1F64F},  // GRINNING FACE..PERSON WITH FOLDED HANDS
    {0x1F680, 0x1F6C5},  // ROCKET..LEFT LUGGAGE
    {0x1F6CC, 0x1F6CC},  // SLEEPING ACCOMMODATION
    {0x1F6D0, 0x1F6D2},  // PLACE OF WORSHIP..SHOPPING TROLLEY
    {0x1F6D5, 0x1F6D7},  // HINDU TEMPLE..ELEVATOR
    {0x1F6DD, 0x1F6DF},  // PLAYGROUND SLIDE..RING BUOY
    {0x1F6EB, 0x1F6EC},  // AIRPLANE DEPARTURE..AIRPLANE ARRIVING
    {0x1F6F4, 0x1F6FC},  // SCOOTER..ROLLER SKATE
    {0x1F7E0, 0x1F7EB},  // LARGE ORANGE CIRCLE..LARGE BROWN SQUARE
    {0x1F7F0, 0x1F7F0},  // HEAVY EQUALS SIGN
    {0x1F90C, 0x1F93A},  // PINCHED FINGERS..FENCER
    {0x1F93C, 0x1F945},  // WRESTLERS..GOAL NET
    {0x1F947, 0x1F9FF},  // FIRST PLACE MEDAL..NAZAR AMULET
    {0x1FA70, 0x1FA74},  // BALLET SHOES..THONG SANDAL
    {0x1FA78, 0x1FA7C},  // DROP OF BLOOD..CRUTCH
    {0x1FA80, 0x1FA86},  // YO-YO..NESTING DOLLS
    {0x1FA90, 0x1FAAC},  // RINGED PLANET..HAMSA
    {0x1FAB0, 0x1FABA},  // FLY..NEST WITH EGGS
    {0x1FAC0, 0x1FAC5},  // ANATOMICAL HEART..PERSON WITH CROWN
    {0x1FAD0, 0x1FAD9},  // BLUEBERRIES..JAR
    {0x1FAE0, 0x1FAE7},  // MELTING FACE..BUBBLES
    {0x1FAF0, 0x1FAF6},  // HAND WITH INDEX FINGER THUMB CROSSED..HEART HANDS
    {0x20000, 0x2A6DF},  // CJK UNIFIED IDEOGRAPH
    {0x2A6E0, 0x2A6FF},  // RESERVED
    {0x2A700, 0x2B738},  // CJK UNIFIED IDEOGRAPH
    {0x2B739, 0x2B73F},  // RESERVED
    {0x2B740, 0x2B81D},  // CJK UNIFIED IDEOGRAPH
    {0x2B81E, 0x2B81F},  // RESERVED
    {0x2B820, 0x2CEA1},  // CJK UNIFIED IDEOGRAPH
    {0x2CEA2, 0x2CEAF},  // RESERVED
    {0x2CEB0, 0x2EBE0},  // CJK UNIFIED IDEOGRAPH
    {0x2EBE1, 0x2F7FF},  // RESERVED
    {0x2F800, 0x2FA1D},  // CJK COMPATIBILITY IDEOGRAPH
    {0x2FA1E, 0x2FA1F},  // RESERVED
    {0x2FA20, 0x2FFFD},  // RESERVED
    {0x30000, 0x3134A},  // CJK UNIFIED IDEOGRAPH
    {0x3134B, 0x3FFFD},  // RESERVED
};

pureconst bool IsWide(int c) {
  int m, l, r, n;
  if (c < 0x1100) {
    return false;
  } else if (c < 0x10000) {
    l = 0;
    r = n = sizeof(kWides) / sizeof(kWides[0]);
    while (l < r) {
      m = (l & r) + ((l ^ r) >> 1);  // floor((a+b)/2)
      if (kWides[m][1] < c) {
        l = m + 1;
      } else {
        r = m;
      }
    }
    return l < n && kWides[l][0] <= c && c <= kWides[l][1];
  } else {
    l = 0;
    r = n = sizeof(kAstralWides) / sizeof(kAstralWides[0]);
    while (l < r) {
      m = (l & r) + ((l ^ r) >> 1);  // floor((a+b)/2)
      if (kAstralWides[m][1] < c) {
        l = m + 1;
      } else {
        r = m;
      }
    }
    return l < n && kAstralWides[l][0] <= c && c <= kAstralWides[l][1];
  }
}

pureconst int GetMonospaceCharacterWidth(int c) {
  return !IsControl(c) + IsWide(c);
}
"
./repos/cosmopolitan/tool/plinko/lib/makesclosures.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/plinko.h""

bool MakesClosures(int x) {
  int h;
  if (x < 0 && (h = Car(x)) != kQuote && h != kClosure) {
    if (h == kMacro) return true;
    if (h == kLambda) return true;
    if (h == kCond) {
      while ((x = Cdr(x)) < 0) {
        if ((h = Car(x)) < 0) {
          if (MakesClosures(Car(h))) return true;
          if ((h = Cdr(h)) < 0) {
            if (MakesClosures(Car(h))) return true;
          }
        }
      }
    } else {
      while (x) {
        if (x < 0) {
          h = Car(x);
          x = Cdr(x);
        } else {
          h = x;
          x = 0;
        }
        MakesClosures(h);
      }
    }
  }
  return false;
}
"
./repos/cosmopolitan/tool/plinko/lib/trace.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/trace.h""
#include ""tool/plinko/lib/plinko.h""
#include ""tool/plinko/lib/printf.h""

void EnableTracing(void) {
  eval = EvalTrace;
  bind_ = BindTrace;
  evlis = EvlisTrace;
  pairlis = PairlisTrace;
  recurse = RecurseTrace;
  expand = mtrace ? ExpandTrace : Expand;
  kTail[0] = DispatchTailTrace;
  kTail[4] = DispatchTailTrace;
  kTail[5] = DispatchTailGcTrace;
  kTail[6] = DispatchTailTrace;
  kTail[7] = DispatchTailTmcGcTrace;
}

static inline int ShortenExpression(int e) {
  return e;
}

static bool AlwaysTrace(int e) {
  return true;
}
static bool LimitedTrace(int e) {
  return e < 0;
}

static relegated struct T TailTracer(dword ea, dword tm, dword r, dword p1,
                                     dword p2, TailFn *f) {
  if (depth < ARRAYLEN(g_depths)) {
    Fprintf(2, ""%J╠═Tail[%p @ %d] p1=%S p2=%S δ %'Rns%n"",
            ShortenExpression(LO(ea)), LO(ea), LO(p1), LO(p2));
  }
  return f(ea, tm, r, p1, p2);
}

relegated struct T DispatchTailTrace(dword ea, dword tm, dword r, dword p1,
                                     dword p2) {
  return TailTracer(ea, tm, r, p1, p2, DispatchTail);
}

relegated struct T DispatchTailGcTrace(dword ea, dword tm, dword r, dword p1,
                                       dword p2) {
  return TailTracer(ea, tm, r, p1, p2, DispatchTailGc);
}

relegated struct T DispatchTailTmcGcTrace(dword ea, dword tm, dword r, dword p1,
                                          dword p2) {
  int x;
  if (depth < ARRAYLEN(g_depths)) {
    x = LO(tm);
    x = x < 0 ? x : ~x;
    Fprintf(2, ""%J╟⟿Cons[%p @ %d] δ %'Rns%n"", x, x);
  }
  return TailTracer(ea, tm, r, p1, p2, DispatchTailTmcGc);
}

static relegated int Trace(int e, int a, EvalFn *f, bool p(int), const char *s,
                           const unsigned short c[5]) {
  int d, r, rp, S = sp;
  DCHECK_GE(depth, -1);
  d = depth;
  depth = MAX(d, 0);
  if (depth < ARRAYLEN(g_depths)) {
    if (p(e)) {
      if (loga) {
        Fprintf(2, ""%I%c%c%s[e=%S @ %d; a=%S @ %d] δ %'Rns%n"", c[0], c[1], s,
                ShortenExpression(e), e, a, a);
      } else {
        Fprintf(2, ""%I%c%c%s[%S @ %d] δ %'Rns%n"", c[0], c[1], s,
                ShortenExpression(e), e);
      }
    }
    g_depths[depth][0] = c[2];
    g_depths[depth][1] = L' ';
    g_depths[depth][2] = L' ';
  }
  ++depth;
  r = f(e, a);
  --depth;
  if (depth < ARRAYLEN(g_depths) && p(e)) {
    rp = r != e ? r : kUnchanged;
    if (sp == S) {
      Fprintf(2, ""%I%c%c%p @ %d %'Rns%n"", c[3], c[4], rp, r);
    } else {
      Fprintf(2, ""%I%c%c%p @ %d %'Rns [STACK SKEW S=%d vs. sp=%d]%n"", c[3],
              c[4], rp, r, S, sp);
    }
  }
  depth = d;
  return r;
}

relegated int RecurseTrace(dword ea, dword p1, dword p2) {
  int r;
  const char *s = ""Recurse"";
  const unsigned short c[5] = u""╔═║╚═"";
  if (depth < ARRAYLEN(g_depths)) {
    if (loga) {
      Fprintf(2,
              ""%I%c%c%s[LO(ea)=%S @ %d; HI(ea)=%S @ %d] p1=%S p2=%S δ %'Rns%n"",
              c[0], c[1], s, ShortenExpression(LO(ea)), LO(ea), HI(ea), HI(ea),
              LO(p1), LO(p2));
    } else {
      Fprintf(2, ""%I%c%c%s[%S @ %d] p1=%S p2=%S δ %'Rns%n"", c[0], c[1], s,
              ShortenExpression(LO(ea)), LO(ea), LO(p1), LO(p2));
    }
    g_depths[depth][0] = c[2];
    g_depths[depth][1] = L' ';
    g_depths[depth][2] = L' ';
  }
  ++depth;
  r = Recurse(ea, p1, p2);
  --depth;
  if (depth < ARRAYLEN(g_depths)) {
    if (r != LO(ea)) {
      Fprintf(2, ""%I%c%c%p @ %d δ %'Rns%n"", c[3], c[4], r, r);
    } else {
      Fprintf(2, ""%I%c%cⁿ/ₐ δ %'Rns%n"", c[3], c[4]);
    }
  }
  return r;
}

relegated int EvlisTrace(int e, int a, dword p1, dword p2) {
  int r, d;
  const char *s = ""Evlis"";
  const unsigned short c[5] = u""╒─┆╘─"";
  DCHECK_GE(depth, -1);
  d = depth;
  depth = MAX(d, 0);
  if (depth < ARRAYLEN(g_depths)) {
    if (loga) {
      Fprintf(2, ""%I%c%c%s[e=%S @ %d; a=%S @ %d] δ %'Rns%n"", c[0], c[1], s,
              ShortenExpression(e), e, a, a);
    } else {
      Fprintf(2, ""%I%c%c%s[%S @ %d] δ %'Rns%n"", c[0], c[1], s,
              ShortenExpression(e), e);
    }
    g_depths[depth][0] = c[2];
    g_depths[depth][1] = L' ';
    g_depths[depth][2] = L' ';
  }
  ++depth;
  r = Evlis(e, a, p1, p2);
  --depth;
  if (depth < ARRAYLEN(g_depths)) {
    if (r != e) {
      Fprintf(2, ""%I%c%c%p @ %d δ %'Rns%n"", c[3], c[4], r, r);
    } else {
      Fprintf(2, ""%I%c%cⁿ/ₐ δ %'Rns%n"", c[3], c[4]);
    }
  }
  depth = d;
  return r;
}

relegated int Trace3(int x, int y, int a, PairFn *f, const char *s,
                     const unsigned short c[5]) {
  int r;
  if (depth < ARRAYLEN(g_depths)) {
    if (loga) {
      Fprintf(2, ""%I%c%c%s[x=%S; y=%S; a=%S] δ %'Rns%n"", c[0], c[1], s,
              ShortenExpression(x), ShortenExpression(y), a);
    } else {
      Fprintf(2, ""%I%c%c%s[x=%S; y=%S] δ %'Rns%n"", c[0], c[1], s,
              ShortenExpression(x), ShortenExpression(y));
    }
    g_depths[depth][0] = c[2];
    g_depths[depth][1] = L' ';
    g_depths[depth][2] = L' ';
  }
  ++depth;
  r = f(x, y, a);
  --depth;
  return r;
}

relegated struct Binding BindTrace(int x, int y, int a, int u, dword p1,
                                   dword p2) {
  struct Binding r;
  if (depth < ARRAYLEN(g_depths)) {
    if (loga) {
      Fprintf(2, ""%I%c%c%s[x=%S; y=%S; a=%S; u=%S] δ %'Rns%n"", L'╒', L'─',
              ""Bind"", ShortenExpression(x), ShortenExpression(y), a, u);
    } else {
      Fprintf(2, ""%I%c%c%s[x=%S; y=%S] δ %'Rns%n"", L'╒', L'─', ""Bind"",
              ShortenExpression(x), ShortenExpression(y));
    }
    g_depths[depth][0] = L'┋';
    g_depths[depth][1] = L' ';
    g_depths[depth][2] = L' ';
  }
  ++depth;
  r = Bind(x, y, a, u, p1, p2);
  --depth;
  return r;
}

int EvalTrace(int e, int a) {
  return Trace(e, a, Eval, AlwaysTrace, ""Eval"", u""╔═║╚═"");
}

int ExpandTrace(int e, int a) {
  return Trace(e, a, Expand, LimitedTrace, ""Expand"", u""┌─│└─"");
}

int PairlisTrace(int x, int y, int a) {
  return Trace3(x, y, a, Pairlis, ""Pairlis"", u""╒─┊╘─"");
}
"
./repos/cosmopolitan/tool/plinko/lib/error.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/log/log.h""
#include ""libc/runtime/runtime.h""
#include ""tool/plinko/lib/error.h""
#include ""tool/plinko/lib/plinko.h""
#include ""tool/plinko/lib/printf.h""
#include ""tool/plinko/lib/stack.h""

relegated wontreturn void Raise(int x) {
  Flush(1);
  Flush(2);
  longjmp(crash, ~x);
}

relegated wontreturn void Error(const char *f, ...) {
  int n;
  va_list va;
  Flush(1);
  Flush(2);
  va_start(va, f);
  n = Fprintf(2, ""\e[1;31merror\e[0m: "");
  n = Vfnprintf(f, va, 2, n);
  Fprintf(2, ""%n"");
  va_end(va);
  Raise(kError);
}

relegated wontreturn void OutOfMemory(void) {
  Error(""out of memory"");
}

relegated wontreturn void StackOverflow(void) {
  Error(""stack overflow"");
}

relegated wontreturn void React(int e, int x, int k) {
  if (!sp || e != LO(GetCurrentFrame())) Push(e);
  Push(x);
  Raise(k);
}
"
./repos/cosmopolitan/tool/plinko/lib/tree.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/tree.h""
#include ""libc/log/check.h""
#include ""tool/plinko/lib/index.h""

int Nod(int E, int L, int R, int C) {
#ifndef NDEBUG
  DCHECK_LE(L, 0);
  DCHECK_LE(R, 0);
  DCHECK_EQ(0, C & ~1);
#endif
  return Cons(Cons(E, (L | R) ? Cons(L, R) : 0), C);
}

static void CheckTreeImpl(int N) {
  int p, L, R;
  if (N >= 0) Error(""N is atom: %S"", N);
  if (Car(N) >= 0) Error(""Car(N) is an atom: %S"", N);
  if (Cdr(N) & ~1) Error(""Cdr(N) is non-bool: %S"", N);
  if ((L = Lit(N))) {
    if ((p = Cmp(Key(Ent(L)), Key(Ent(N)))) != -1) {
      Error(""Cmp(Key(L), Key(N)) != -1%n""
            ""Result = %d%n""
            ""Key(L) = %p%n""
            ""Key(N) = %p"",
            p, Key(Ent(L)), Key(Ent(N)));
    }
    if (Red(N) && Red(L)) {
      Error(""left node and its parent are both red%n%T"", N);
    }
    CheckTreeImpl(L);
  }
  if ((R = Rit(N))) {
    if ((p = Cmp(Key(Ent(R)), Key(Ent(N)))) != +1) {
      Error(""Cmp(Key(R), Key(N)) != +1%n""
            ""Result = %d%n""
            ""Key(R) = %p%n""
            ""Key(N) = %p"",
            p, Key(Ent(R)), Key(Ent(N)));
    }
    if (Red(N) && Red(R)) {
      Error(""right node and its parent are both red%n%T"", N);
    }
    CheckTreeImpl(R);
  }
}

static int CheckTree(int N) {
#if DEBUG_TREE
  if (N) {
    if (Red(N)) Error(""tree root is red%n%T"", N);
    CheckTreeImpl(N);
  }
#endif
  return N;
}

static int BalTree(int E, int L, int R, int C) {
  // Chris Okasaki ""Red-Black Trees in a Functional Setting"";
  // Functional Pearls, Cambridge University Press, Jan 1993.
  int LL, LR, RL, RR;
  if (!C) {
    LL = Lit(L);
    LR = Rit(L);
    RL = Lit(R);
    RR = Rit(R);
    if (Red(L) && Red(LR)) {
      // Degenerate Case No. 1
      // Complete the Triforce
      //
      //        Z
      //       ╱ ╲             𝐘
      //      𝐗   d           ╱ ╲
      //     ╱ ╲       →     X   Z
      //    a   𝐘           ╱ ╲ ╱ ╲
      //       ╱ ╲         a  b c  d
      //      b   c
      //
      // ((Z ((X a (Y b . c) . t) . t) . d)) →
      // ((Y ((X a . b)) (Z c . d)) . t)
      L = Nod(Ent(L), LL, Lit(LR), 0);
      R = Nod(E, Rit(LR), R, 0);
      E = Ent(LR);
      C = 1;
    } else if (Red(L) && Red(LL)) {
      // Degenerate Case No. 2
      // Complete the Triforce
      //
      //          Z
      //         ╱ ╲           𝐘
      //        𝐘   d         ╱ ╲
      //       ╱ ╲      →    X   Z
      //      𝐗   c         ╱ ╲ ╱ ╲
      //     ╱ ╲           a  b c  d
      //    a   b
      //
      // ((Z ((Y ((X a . b) . t) . c) . t) . d)) →
      // ((Y ((X a . b)) (Z c . d)) . t)
      R = Nod(E, LR, R, 0);
      E = Ent(L);
      L = Bkn(LL);
      C = 1;
    } else if (Red(R) && Red(RR)) {
      // Degenerate Case No. 3
      // Complete the Triforce
      //
      //     X
      //    ╱ ╲               𝐘
      //   a   𝐘             ╱ ╲
      //      ╱ ╲     →     X   Z
      //     b   𝐙         ╱ ╲ ╱ ╲
      //        ╱ ╲       a  b c  d
      //       c   d
      //
      // ((X a (Y b (Z c . d) . t) . t)) →
      // ((Y ((X a . b)) (Z c . d)) . t)
      L = Nod(E, L, RL, 0);
      E = Ent(R);
      R = Bkn(RR);
      C = 1;
    } else if (Red(R) && Red(RL)) {
      // Degenerate Case No. 4
      // Complete the Triforce
      //
      //       X
      //      ╱ ╲             𝐘
      //     a   𝐙           ╱ ╲
      //        ╱ ╲    →    X   Z
      //       𝐘   d       ╱ ╲ ╱ ╲
      //      ╱ ╲         a  b c  d
      //     b   c
      //
      // ((X a (Z ((Y b . c) . t) . d) . t)) →
      // ((Y ((X a . b)) (Z c . d)) . t)
      L = Nod(E, L, Lit(RL), 0);
      R = Nod(Ent(R), Rit(RL), RR, 0);
      E = Ent(RL);
      C = 1;
    }
  }
  return Nod(E, L, R, C);
}

static int InsTree(int E, int N, int KEEP) {
  int P, L, R;
  if (N) {
    P = Cmp(Key(E), Key(Ent(N)));
    if (P < 0) {
      if ((L = InsTree(E, Lit(N), KEEP)) > 0) return L;  // rethrow
      if (L != Lit(N)) N = BalTree(Ent(N), L, Rit(N), Tail(N));
    } else if (P > 0) {
      if ((R = InsTree(E, Rit(N), KEEP)) > 0) return R;  // rethrow
      if (R != Rit(N)) N = BalTree(Ent(N), Lit(N), R, Tail(N));
    } else if (KEEP < 0 || (!KEEP && !Equal(Val(E), Val(Ent(N))))) {
      N = Cons(Cons(E, Chl(N)), Red(N));
    } else if (KEEP > 1) {
      N = KEEP;  // throw
    }
  } else {
    N = Cons(Cons(E, 0), 1);
  }
  return N;
}

/**
 * Inserts entry into red-black tree.
 *
 *        DICTIONARY NODE           SET NODE          ATOM SET NODE
 *
 *           ┌───┬───┐              ┌───┬───┐          ┌───┬───┐
 *           │ ┬ │ 𝑐 │              │ ┬ │ 𝑐 │          │ ┬ │ 𝑐 │
 *           └─│─┴───┘              └─│─┴───┘          └─│─┴───┘
 *           ┌─┴─┬───┐              ┌─┴─┬───┐          ┌─┴─┬───┐
 *           │ ┬ │ ┬ │              │ ┬ │ ┬ │          │ 𝑣 │ ┬ │
 *           └─│─┴─│─┘              └─│─┴─│─┘          └───┴─│─┘
 *      ┌───┬──┴┐ ┌┴──┬───┐    ┌───┬──┴┐ ┌┴──┬───┐         ┌─┴─┬───┐
 *      │ 𝑥 │ 𝑦 │ │ L │ R │    │ 𝑥 │ ⊥ │ │ L │ R │         │ L │ R │
 *      └───┴───┘ └───┴───┘    └───┴───┘ └───┴───┘         └───┴───┘
 *
 * @param E is entry which may be
 *     -  (𝑥 . 𝑦) where 𝑥 is the key and 𝑦 is arbitrary tag-along content
 *     -  𝑣 for memory-efficient sets of atoms
 * @param N is red-black tree node which should look like
 *     -  ⊥ is an tree or atom set with zero elements
 *     -  (((𝑥 ⋯) . (𝑙 . 𝑟)) . ⊥) is a black node a.k.a. (((𝑥 ⋯) 𝑙 . 𝑟))
 *     -  (((𝑥 ⋯) . (𝑙 . 𝑟)) . ⊤) is a red node   a.k.a. (((𝑥 ⋯) 𝑙 . 𝑟) . ⊤)
 *     -  ((𝑣 𝑙 . 𝑟)) a memory-efficient black node for an atom set
 *     -  ((𝑣 𝑙 . 𝑟)) is functionally equivalent to (((𝑣) 𝑙 . 𝑟))
 *     -  ((𝑣 ⊥ . ⊥)) is an atom set with a single element
 *     -  ((𝑣)) is functionally equivalent to ((𝑣 ⊥ . ⊥)) or ((𝑣 . (⊥ . ⊥)) . ⊥)
 *     -  𝑣 is crash therefore (((⋯) 𝑣)) and ⊥(((⋯) ⊥ . 𝑣)) are crash
 *     -  (𝑣) is crash, first element must be a cons cell
 *     -  ((⋯) . 𝑥) is crash if 𝑥 isn't ⊤ or ⊥
 * @param KEEP may be
 *     - -1 to replace existing entries always
 *     -  0 to replace existing entries if values are non-equal
 *     -  1 to return N if
 *     - >1 specifies arbitrary tombstone to return if key exists
 * @return ((𝑒 𝑙 . 𝑟) . 𝑐) if found where 𝑒 can be 𝑣 or (𝑥 . 𝑦)
 *     - or KEEP if not found and KEEP > 1
 *     - or ⊥ if not found
 */
int PutTree(int E, int N, int KEEP) {
  DCHECK_LE(N, 0);
  DCHECK_LE(Car(N), 0);
  DCHECK_GE(KEEP, -1);
  return CheckTree(Bkn(InsTree(E, N, KEEP)));
}

/**
 * Finds node in binary tree.
 * @return ((𝑒 𝑙 . 𝑟) . 𝑐) if found, otherwise 0
 */
int GetTree(int k, int N) {
  int p;
  while (N) {
    p = Cmp(k, Key(Ent(N)));
    if (p < 0) {
      N = Lit(N);
    } else if (p > 0) {
      N = Rit(N);
    } else {
      break;
    }
  }
  return N;
}

int GetTreeCount(int k, int N, int *c) {
  int p;
  while (N) {
    ++*c;
    p = Cmp(k, Key(Ent(N)));
    if (p < 0) {
      N = Lit(N);
    } else if (p > 0) {
      N = Rit(N);
    } else {
      break;
    }
  }
  return N;
}
"
./repos/cosmopolitan/tool/plinko/lib/pairlis.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/cons.h""
#include ""tool/plinko/lib/error.h""
#include ""tool/plinko/lib/plinko.h""

int Pairlis(int x, int y, int a) {
  if (!x) return a;
  if (x > 0) return Alist(x, y, a);
  if (y <= 0) {
    a = pairlis(Cdr(x), Cdr(y), a);
    return Car(x) ? pairlis(Car(x), Car(y), a) : a;
  } else {
    Error(""argument structure%n""
          "" want: %S%n""
          ""  got: %S"",
          x, y);
  }
}
"
./repos/cosmopolitan/tool/plinko/lib/printvars.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/plinko.h""
#include ""tool/plinko/lib/print.h""

int PrintArgs(int fd, int keys, int vals, int n) {
  if (!keys) return n;
  if (keys > 0) {
    if (!(vals < 0 && Car(vals) == kClosure)) {
      if (n) {
        n += PrintChar(fd, L';');
        n += PrintChar(fd, L' ');
      }
      n += Print(fd, keys);
      n += PrintChar(fd, L'=');
      n += Print(fd, vals);
    }
    return n;
  }
  if (vals > 0) {
    if (n) {
      n += PrintChar(fd, L';');
      n += PrintChar(fd, L' ');
    }
    n += Print(fd, Car(keys));
    n += PrintChar(fd, L'=');
    n += PrintChar(fd, L'!');
    n += Print(fd, vals);
    vals = 0;
  } else {
    n += PrintArgs(fd, Car(keys), Car(vals), n);
  }
  if (!Cdr(keys)) return n;
  return PrintArgs(fd, Cdr(keys), Cdr(vals), n);
}
"
./repos/cosmopolitan/tool/plinko/lib/symbolize.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/plinko.h""

pureconst int Symbolize(int x) {
  if (literally) return -1;
  if (x == TERM) return -1;
  DCHECK_LT(x, TERM);
  switch (LO(Get(x))) {
    case L'A':
      if (x == kAtom) return L'α';
      if (x == kAnd) return L'∧';
      if (x == kAppend) return L'║';
      return -1;
    case L'B':
      if (x == kBeta) return L'β';
      if (x == kBecause) return L'∵';
      return -1;
    case L'C':
      if (x == kCar) return L'⍅';
      if (x == kCdr) return L'⍆';
      if (x == kClosure) return L'⅄';
      if (x == kCond) return L'ζ';
      if (x == kCons) return L'ℶ';
      if (x == kCmp) return L'≷';
      if (x == kCycle) return L'⟳';
      return -1;
    case L'D':
      if (x == kDefine) return L'≝';
      if (x == kDefmacro) return L'Ψ';
      if (x == kDefun) return L'Λ';
      return -1;
    case L'E':
      if (x == kEq) return L'≡';
      if (x == kExpand) return L'ə';
      return -1;
    case L'F':
      if (x == kFunction) return L'𝑓';
      if (x == kFork) return L'⋔';
      return -1;
    case L'P':
      if (x == kPartial) return L'∂';
      return -1;
    case L'I':
      if (x == kIff) return L'⟺';
      if (x == kImplies) return L'⟶';
      if (x == kIntegrate) return L'∫';
      if (x == kIntersection) return L'∩';
      return -1;
    case L'L':
      if (x == kLambda) return L'λ';
      if (x == kList) return L'ℒ';
      return -1;
    case L'M':
      if (x == kMacro) return L'ψ';
      if (x == kMember) return L'∊';
      return -1;
    case L'N':
      if (!x) return L'⊥';
      if (x == kNand) return L'⊼';
      if (x == kNor) return L'⊽';
      if (x == kNot) return L'¬';
      return -1;
    case L'O':
      if (x == kOr) return L'∨';
      if (x == kOrder) return L'⊙';
      return -1;
    case L'Q':
      if (x == kQuote) return L'Ω';
      return -1;
    case L'R':
      if (x == kReverse) return L'Я';
      return -1;
    case L'S':
      if (x == kSqrt) return L'√';
      if (x == kSubset) return L'⊂';
      if (x == kSuperset) return L'⊃';
      return -1;
    case L'T':
      if (x == 1) return L'⊤';
      if (x == kTherefore) return L'∴';
      return -1;
    case L'U':
      if (x == kUnion) return L'∪';
      if (x == kImpossible) return L'∅';
      return -1;
    case L'X':
      if (x == kXor) return L'⊻';
      return -1;
    case L'Y':
      if (x == kYcombinator) return L'𝕐';
      return -1;
    default:
      return -1;
  }
}
"
./repos/cosmopolitan/tool/plinko/lib/readstring.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/build/lib/case.h""
#include ""tool/plinko/lib/char.h""
#include ""tool/plinko/lib/plinko.h""

int ReadString(int fd, unsigned x) {
  int i, n, y, z;
  ax = y = TERM;
  if (x == L'""') {
    dx = ReadByte(fd);
    return ax;
  } else {
    z = ReadByte(fd);
    if (x == L'\\') {
      x = z;
      z = ReadByte(fd);
      switch (x) {
        CASE(L'a', x = L'\a');
        CASE(L'b', x = L'\b');
        CASE(L'e', x = 00033);
        CASE(L'f', x = L'\f');
        CASE(L'n', x = L'\n');
        CASE(L'r', x = L'\r');
        CASE(L't', x = L'\t');
        CASE(L'v', x = L'\v');
        case L'x':
          n = 2;
          goto ReadHexEscape;
        case L'u':
          n = 4;
          goto ReadHexEscape;
        case L'U':
          n = 8;
          goto ReadHexEscape;
        default:
          if (IsDigit(x)) {
            x = GetDiglet(x);
            for (i = 0; IsDigit(z) && i < 2; ++i) {
              x *= 8;
              x += GetDiglet(z);
              z = ReadByte(fd);
            }
          }
          break;
        ReadHexEscape:
          for (x = i = 0; IsHex(z) && i < n; ++i) {
            x *= 16;
            x += GetDiglet(z);
            z = ReadByte(fd);
          }
          break;
      }
    }
    y = ReadString(fd, z);
  }
  return Intern(x, y);
}
"
./repos/cosmopolitan/tool/plinko/lib/preplan.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/log/countbranch.h""
#include ""libc/runtime/runtime.h""
#include ""tool/plinko/lib/cons.h""
#include ""tool/plinko/lib/index.h""
#include ""tool/plinko/lib/plinko.h""
#include ""tool/plinko/lib/printf.h""

static int CopyTree(int x) {
  int a, b;
  if (x >= 0) return x;
  b = CopyTree(Cdr(x));
  a = CopyTree(Car(x));
  return Cons(a, b);
}

static int PreplanCond(int e, int a, int s) {
  int f, g;
  if (!(e = Cdr(e))) return 0;
  if ((f = Car(e)) < 0) {
    if ((g = Cdr(f)) < 0) {
      f = List(Preplan(Car(f), a, s), Preplan(Car(g), a, s));
    } else {
      f = Cons(Preplan(Car(f), a, s), 0);
    }
  }
  return Cons(f, PreplanCond(e, a, s));
}

static int PreplanList(int e, int a, int s) {
  if (e >= 0) return e;
  return Cons(Preplan(Car(e), a, s), PreplanList(Cdr(e), a, s));
}

int Preplan(int e, int a, int s) {
  int f, x;
  struct qword q;
  if (e >= 0) return e;
  f = Car(e);
  if (f != kQuote) {
    if (f == kClosure) {
      /*
       * (CLOSURE (LAMBDA (X Y) Z) . A)
       * -1 = (   Z, -0) c[6]
       * -2 = (   Y, -0) c[5]
       * -3 = (   X, -2) c[4]
       * -4 = (  -3, -1) c[3]
       * -5 = (LAMB, -4) c[2]
       * -6 = (  -5,  A) c[1]
       * -7 = (CLOS, -5) c[0]
       */
      e = Cons(kClosure, Cons(Preplan(Cadr(e), Cddr(e), 0), Cddr(e)));
    } else if (f == kCond) {
      e = Cons(kCond, PreplanCond(e, a, s));
    } else if (f == kLambda || f == kMacro) {
      /*
       * (LAMBDA (X Y) Z)
       * -1 = (   Z, -0) l[4]
       * -2 = (   Y, -0) l[3]
       * -3 = (   X, -2) l[2]
       * -4 = (  -3, -1) l[1]
       * -5 = (LAMB, -4) l[0]
       */
      x = Preplan(Caddr(e), a, Shadow(Cadr(e), s));
      x = Cons(x, 0);
      x = Cons(CopyTree(Cadr(e)), x);
      e = Cons(f, x);
    } else {
      e = PreplanList(e, a, s);
    }
  }
  if (LO(GetShadow(e)) == EncodeDispatchFn(DispatchPlan)) {
    if ((q = IsIf(e)).ax) {
      /* x = Cons(LO(q.ax), Cons(HI(q.ax), LO(q.dx))); */
      /*
       * guarantees this order
       * -1 = (   Z, -0) if[5]
       * -2 = (   Y, -0) if[4]
       * -3 = (   X, -2) if[3]
       * -4 = (  -1, -0) if[2]
       * -5 = (  -3, -4) if[1]
       * -6 = (COND, -5) if[0]
       */
      e = Cons(LO(q.dx), 0);
      e = List3(kCond, List(LO(q.ax), HI(q.ax)), e);
      SetShadow(e, MAKE(DF(DispatchIf), 0));
    } else {
      SetShadow(e, Plan(e, a, s));
    }
  }
  return e;
}
"
./repos/cosmopolitan/tool/plinko/lib/printint.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/log/check.h""
#include ""tool/plinko/lib/print.h""
#include ""tool/plinko/lib/types.h""

int PrintInt(int fd, long x, int cols, char quot, char zero, int base,
             bool issigned) {
  dword y;
  char z[32];
  int i, j, k, n;
  DCHECK_LE(base, 36);
  i = j = 0;
  y = x < 0 && issigned ? -x : x;
  do {
    if (quot && j == 3) z[i++ & 31] = quot, j = 0;
    z[i++ & 31] = ""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ""[y % base];
  } while (++j, (y /= base));
  k = i + (x < 0 && issigned);
  if (zero) {
    n = PrintZeroes(fd, +cols - k);
  } else {
    n = PrintIndent(fd, +cols - k);
  }
  if (x < 0 && issigned) n += PrintChar(fd, L'-');
  while (i) n += PrintChar(fd, z[--i & 31]);
  PrintIndent(fd, -cols - n);
  return n;
}
"
./repos/cosmopolitan/tool/plinko/lib/intern.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/cons.h""
#include ""tool/plinko/lib/plinko.h""

static inline int Probe(unsigned h, unsigned p) {
  return (h + p * p) & MASK(TERM);
}

static inline int Hash(unsigned h, unsigned x) {
  return MAX(2, ((h * 0xdeaadead) ^ x) & MASK(TERM));
}

static int Interner(dword t, int h, int p) {
  dword u;
  if ((u = Get(h))) {
    if (u != t) {
      h = Interner(t, Probe(h, p), p + 1);
    }
    return h;
  } else if (++cAtoms < TERM / 2) {
    Set(h, t);
    SetShadow(h, DF(DispatchLookup));
    return h;
  } else {
    Error(""too many atoms"");
  }
}

int Intern(int x, int y) {
  return Interner(MAKE(x, y), (ax = Hash(x, ax)), 1);
}
"
./repos/cosmopolitan/tool/plinko/lib/isconstant.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2021 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/plinko.h""

pureconst bool IsConstant(int e) {
  unsigned f = LO(GetShadow(e));
  if (f == EncodeDispatchFn(DispatchNil)) return true;
  if (f == EncodeDispatchFn(DispatchTrue)) return true;
  if (f == EncodeDispatchFn(DispatchPrecious)) return true;
  if (f == EncodeDispatchFn(DispatchQuote)) return true;
  return false;
}
"
./repos/cosmopolitan/tool/plinko/lib/evlis.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/cons.h""
#include ""tool/plinko/lib/plinko.h""

int Evlis(int x, int a, dword p1, dword p2) {
  if (!x) return x;
  if (x > 0) return FasterRecurse(x, a, p1, p2);
  int y = FasterRecurse(Car(x), a, p1, p2);
  return Cons(y, Evlis(Cdr(x), a, p1, p2));
}
"
./repos/cosmopolitan/tool/plinko/lib/gc.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/gc.h""
#include ""libc/assert.h""
#include ""libc/intrin/bsf.h""
#include ""libc/intrin/popcnt.h""
#include ""libc/limits.h""
#include ""libc/log/check.h""
#include ""libc/log/countbranch.h""
#include ""libc/log/log.h""
#include ""libc/macros.internal.h""
#include ""libc/mem/mem.h""
#include ""libc/str/str.h""
#include ""tool/plinko/lib/cons.h""
#include ""tool/plinko/lib/histo.h""
#include ""tool/plinko/lib/plinko.h""
#include ""tool/plinko/lib/print.h""
#include ""tool/plinko/lib/printf.h""
#include ""tool/plinko/lib/stack.h""

forceinline void SetBit(dword M[], unsigned i) {
  M[i / DWBITS] |= (dword)1 << (i % DWBITS);
}

forceinline nosideeffect bool HasBit(const dword M[], unsigned i) {
  return (M[i / DWBITS] >> (i % DWBITS)) & 1;
}

struct Gc *NewGc(int A) {
  int B = cx;
  unsigned n;
  struct Gc *G;
  DCHECK_LE(B, A);
  DCHECK_LE(A, 0);
  if (B < cHeap) cHeap = B;
  n = ROUNDUP(A - B, DWBITS) / DWBITS;
  G = Addr(BANE);
  bzero(G->M, n * sizeof(G->M[0]));
  G->n = n;
  G->A = A;
  G->B = B;
  G->P = (unsigned *)(G->M + n);
  *G->P++ = 0;
  return G;
}

void Marker(const dword M[], int A, int x) {
  int i;
  dword t;
  do {
    i = ~(x - A);
    if (HasBit(M, i)) return;
    SetBit((void *)M, i);
    if (HI(GetShadow(x)) < A) {
      Marker(M, A, HI(GetShadow(x)));
    }
    t = Get(x);
    if (LO(t) < A) {
      Marker(M, A, LO(t));
    }
  } while ((x = HI(t)) < A);
}

int Census(struct Gc *G) {
  int n, t, l;
  unsigned i, j;
  i = G->A - G->B;
  n = i / DWBITS;
  for (j = t = 0; j < n; ++j) {
    G->P[j] = t += popcnt(G->M[j]);
  }
  if (i % DWBITS) {
    t += popcnt(G->M[j]);
  }
  G->noop = t == i;
  for (l = j = 0; j < G->n; ++j) {
    if (!~G->M[j]) {
      l += DWBITS;
    } else {
      l += bsfl(~G->M[j]);
      break;
    }
  }
  G->C = G->A - l;
#if HISTO_GARBAGE
  HISTO(g_gc_marks_histogram, t);
  HISTO(g_gc_discards_histogram, i - t);
  HISTO(g_gc_lop_histogram, l);
#endif
  return t;
}

int Relocater(const dword M[], const unsigned P[], int A, int x) {
  long n;
  unsigned i, r;
  i = ~(x - A);
  n = i / DWBITS;
  r = i % DWBITS;
  return A + ~(P[n - 1] + popcnt(M[n] & (((dword)1 << r) - 1)));
}

void Sweep(struct Gc *G) {
  dword m;
  int a, b, d, i, j;
  if (G->noop) return;
  i = 0;
  b = d = G->A;
  for (; i < G->n; ++i) {
    m = G->M[i];
    if (~m) {
      j = bsfl(~m);
      m >>= j;
      m <<= j;
      d -= j;
      break;
    } else {
      b -= DWBITS;
      d -= DWBITS;
    }
  }
  for (; i < G->n; b -= DWBITS, m = G->M[++i]) {
    for (; m; m &= ~((dword)1 << j)) {
      a = b + ~(j = bsfl(m));
      Set(--d, MAKE(Relocate(G, LO(Get(a))), Relocate(G, HI(Get(a)))));
      SetShadow(d, MAKE(LO(GetShadow(a)), Relocate(G, HI(GetShadow(a)))));
    }
  }
  cx = d;
}

int MarkSweep(int A, int x) {
  struct Gc *G;
  if (x >= A) return cx = A, x;
  G = NewGc(A);
  Mark(G, x);
  Census(G);
  x = Relocate(G, x);
  Sweep(G);
  return x;
}
"
./repos/cosmopolitan/tool/plinko/lib/char.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/char.h""

pureconst bool IsHex(int c) {
  return ((L'0' <= c && c <= L'9') || (L'A' <= c && c <= L'F') ||
          (L'a' <= c && c <= L'f'));
}

pureconst int GetDiglet(int c) {
  if (IsDigit(c)) return c - L'0';
  if (IsUpper(c)) return c - L'A' + 10;
  if (IsLower(c)) return c - L'a' + 10;
  return -1;
}

pureconst bool IsSpace(int c) {
  switch (c) {
    case L' ':
    case L'\t':
    case L'\n':
    case L'\f':
    case L'\v':
    case L'\r':
      return true;
    default:
      return false;
  }
}

pureconst bool IsParen(int c) {
  switch (c) {
    case L'(':
    case L')':
    case L'[':
    case L']':
    case L'{':
    case L'}':
      return true;
    default:
      return false;
  }
}
"
./repos/cosmopolitan/tool/plinko/lib/plinko.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/plinko.h""
#include ""libc/calls/calls.h""
#include ""libc/calls/struct/sigaction.h""
#include ""libc/calls/syscall-sysv.internal.h""
#include ""libc/errno.h""
#include ""libc/intrin/likely.h""
#include ""libc/intrin/strace.internal.h""
#include ""libc/log/countbranch.h""
#include ""libc/log/countexpr.h""
#include ""libc/log/log.h""
#include ""libc/macros.internal.h""
#include ""libc/nexgen32e/rdtsc.h""
#include ""libc/runtime/runtime.h""
#include ""libc/runtime/stack.h""
#include ""libc/runtime/symbols.internal.h""
#include ""libc/stdio/stdio.h""
#include ""libc/str/str.h""
#include ""libc/sysv/consts/arch.h""
#include ""libc/sysv/consts/map.h""
#include ""libc/sysv/consts/o.h""
#include ""libc/sysv/consts/prot.h""
#include ""libc/sysv/consts/sig.h""
#include ""libc/time/clockstonanos.internal.h""
#include ""third_party/getopt/getopt.internal.h""
#include ""tool/build/lib/case.h""
#include ""tool/plinko/lib/char.h""
#include ""tool/plinko/lib/error.h""
#include ""tool/plinko/lib/gc.h""
#include ""tool/plinko/lib/histo.h""
#include ""tool/plinko/lib/index.h""
#include ""tool/plinko/lib/print.h""
#include ""tool/plinko/lib/printf.h""
#include ""tool/plinko/lib/stack.h""
#include ""tool/plinko/lib/trace.h""
#include ""tool/plinko/lib/tree.h""

STATIC_STACK_SIZE(0x100000);

#define PUTS(f, s) write(f, s, strlen(s))

#define DISPATCH(ea, tm, r, p1, p2) \
  GetDispatchFn(LO(ea))(ea, tm, r, p1, p2, GetShadow(LO(ea)))

static void Unwind(int S) {
  int s;
  dword t;
  while (sp > S) {
    s = --sp & MASK(STACK);
    if ((t = g_stack[s])) {
      g_stack[s] = 0;
      cx = ~HI(t);
    }
  }
}

static void Backtrace(int S) {
  int i;
  dword f;
  for (i = 0; sp > S && i < STACK; ++i) {
    f = Pop();
    Fprintf(2, ""%d %p%n"", ~HI(f), LO(f));
    g_stack[sp & MASK(STACK)] = 0;
  }
}

forceinline bool ShouldIgnoreGarbage(int A) {
  static unsigned cadence;
  if (DEBUG_GARBAGE) return false;
  if (!(++cadence & AVERSIVENESS)) return false;
  return true;
}

static inline bool ShouldPanicAboutGarbage(int A) {
  return false;
}

static inline bool ShouldAbort(int A) {
  return cx <= A + BANE / STACK * 3;  // hacked thrice permitted memory
}

static relegated dontinline int ErrorExpr(void) {
  Raise(kError);
}

static int Order(int x, int y) {
  if (x < y) return -1;
  if (x > y) return +1;
  return 0;
}

static int Append(int x, int y) {
  if (!x) return y;
  return Cons(Car(x), Append(Cdr(x), y));
}

static int ReconstructAlist(int a) {
  int r;
  for (r = 0; a < 0; a = Cdr(a)) {
    if (Car(a) == kClosure) {
      return Reverse(r, a);
    }
    if (Caar(a) < 0) {
      r = Reverse(r, a);
    } else if (!Assoc(Caar(a), r)) {
      r = Cons(Car(a), r);
    }
  }
  return Reverse(r, 0);
}

static bool AtomEquals(int x, const char *s) {
  dword t;
  do {
    if (!*s) return false;
    t = Get(x);
    if (LO(t) != *s++) return false;  // xxx: ascii
  } while ((x = HI(t)) != TERM);
  return !*s;
}

static pureconst int LastCons(int x) {
  while (Cdr(x)) x = Cdr(x);
  return x;
}

static pureconst int LastChar(int x) {
  dword e;
  do e = Get(x);
  while ((x = HI(e)) != TERM);
  return LO(e);
}

forceinline pureconst bool IsClosure(int x) {
  return x < 0 && Car(x) == kClosure;
}

forceinline pureconst bool IsQuote(int x) {
  return x < 0 && Car(x) == kQuote;
}

static int Quote(int x) {
  if (IsClosure(x)) return x;
  if (IsPrecious(x)) return x;
  return List(kQuote, x);
}

static int QuoteList(int x) {
  if (!x) return x;
  return Cons(Quote(Car(x)), QuoteList(Cdr(x)));
}

static int GetAtom(const char *s) {
  int x, y;
  ax = y = TERM;
  x = *s++ & 255;
  if (*s) y = GetAtom(s);
  return Intern(x, y);
}

static int Gensym(void) {
  char B[16], t;
  static unsigned g;
  unsigned a, b, x, n;
  n = 0;
  x = g++;
  B[n++] = L'G';
  do B[n++] = L'0' + (x & 7);
  while ((x >>= 3));
  B[n] = 0;
  for (a = 1, b = n - 1; a < b; ++a, --b) {
    t = B[a];
    B[a] = B[b];
    B[b] = t;
  }
  return GetAtom(B);
}

static nosideeffect bool Member(int v, int x) {
  while (x) {
    if (x > 0) return v == x;
    if (v == Car(x)) return true;
    x = Cdr(x);
  }
  return false;
}

static int GetBindings(int x, int a) {
  int r, b;
  for (r = 0; x < 0; x = Cdr(x)) {
    if ((b = Assoc(Car(x), a))) {
      r = Cons(b, r);
    } else {
      Error(""could not find dependency %S in %p"", Car(x), a);
    }
  }
  return r;
}

static int Lambda(int e, int a, dword p1, dword p2) {
  int u;
  if (p1) a = Alist(LO(p1), HI(p1), a);
  if (p2) a = Alist(LO(p2), HI(p2), a);
  if (DEBUG_CLOSURE || logc) {
    u = FindFreeVariables(e, 0, 0);
    a = GetBindings(u, a);
  }
  return Enclose(e, a);
}

static int Function(int e, int a, dword p1, dword p2) {
  int u;
  if (e < 0 && Car(e) == kLambda) e = Lambda(e, a, p1, p2);
  if (e >= 0 || Car(e) != kClosure) Error(""not a closure"");
  a = Cddr(e);
  e = Cadr(e);
  u = FindFreeVariables(e, 0, 0);
  a = GetBindings(u, a);
  return Enclose(e, a);
}

static int Simplify(int e, int a) {
  return Function(e, a, 0, 0);
}

static int PrintFn(int x) {
  int y;
  DCHECK_LT(x, TERM);
  y = Car(x);
  while ((x = Cdr(x))) {
    if (!quiet) {
      Print(1, y);
      PrintSpace(1);
    }
    y = Car(x);
  }
  if (!quiet) {
    Print(1, y);
    PrintNewline(1);
  }
  return y;
}

static int PprintFn(int x) {
  int y, n;
  DCHECK_LT(x, TERM);
  n = 0;
  y = Car(x);
  while ((x = Cdr(x))) {
    if (!quiet) {
      n += Print(1, y);
      n += PrintSpace(1);
    }
    y = Car(x);
  }
  if (!quiet) {
    PrettyPrint(1, y, n);
    PrintNewline(1);
  }
  Flush(1);
  return y;
}

static relegated struct T DispatchRetImpossible(dword ea, dword tm, dword r) {
  Fprintf(2, ""ERROR: \e[7;31mIMPOSSIBLE RETURN\e[0m NO %d%n"");
  Raise(LO(ea));
}

static relegated struct T DispatchTailImpossible(dword ea, dword tm, dword r,
                                                 dword p1, dword p2) {
  Fprintf(2, ""ERROR: \e[7;31mIMPOSSIBLE TAIL\e[0m NO %d%n"");
  Raise(LO(ea));
}

static struct T DispatchRet(dword ea, dword tm, dword r) {
  return (struct T){LO(ea)};
}

static struct T DispatchLeave(dword ea, dword tm, dword r) {
  Pop();
  return (struct T){LO(ea)};
}

static struct T DispatchLeaveGc(dword ea, dword tm, dword r) {
  int A, e;
  e = LO(ea);
  A = GetFrameCx();
  if (e < A && cx < A && UNLIKELY(!ShouldIgnoreGarbage(A))) {
    e = MarkSweep(A, e);
  }
  Pop();
  return (struct T){e};
}

static struct T DispatchLeaveTmcGc(dword ea, dword tm, dword r) {
  int A, e;
  A = GetFrameCx();
  e = Reverse(LO(tm), LO(ea));
  if (!ShouldIgnoreGarbage(A)) {
    e = MarkSweep(A, e);
  }
  Pop();
  return (struct T){e};
}

RetFn *const kRet[] = {
    DispatchRet,            //
    DispatchRetImpossible,  //
    DispatchRetImpossible,  //
    DispatchRetImpossible,  //
    DispatchLeave,          //
    DispatchLeaveGc,        //
    DispatchRetImpossible,  //
    DispatchLeaveTmcGc,     //
};

struct T DispatchTail(dword ea, dword tm, dword r, dword p1, dword p2) {
  return DISPATCH(ea, tm, r, p1, p2);
}

struct T DispatchTailGc(dword ea, dword tm, dword r, dword p1, dword p2) {
  int A;
  struct Gc *G;
  A = GetFrameCx();
  if (cx < A && UNLIKELY(!ShouldIgnoreGarbage(A))) {
    if (ShouldPanicAboutGarbage(A)) {
      if (!ShouldAbort(A)) {
        ea = MAKE(LO(ea), ReconstructAlist(HI(ea)));
      } else {
        Raise(kCycle);
      }
    }
    G = NewGc(A);
    Mark(G, LO(ea));
    Mark(G, HI(ea));
    Mark(G, HI(p1));
    Mark(G, HI(p2));
    Census(G);
    p1 = MAKE(LO(p1), Relocate(G, HI(p1)));
    p2 = MAKE(LO(p2), Relocate(G, HI(p2)));
    ea = MAKE(Relocate(G, LO(ea)), Relocate(G, HI(ea)));
    Sweep(G);
  }
  return DISPATCH(ea, tm, r, p1, p2);
}

struct T DispatchTailTmcGc(dword ea, dword tm, dword r, dword p1, dword p2) {
  int A;
  struct Gc *G;
  A = GetFrameCx();
  if (UNLIKELY(!ShouldIgnoreGarbage(A))) {
    if (ShouldPanicAboutGarbage(A)) {
      if (!ShouldAbort(A)) {
        ea = MAKE(LO(ea), ReconstructAlist(HI(ea)));
      } else {
        Raise(kCycle);
      }
    }
    G = NewGc(A);
    Mark(G, LO(tm));
    Mark(G, LO(ea));
    Mark(G, HI(ea));
    Mark(G, HI(p1));
    Mark(G, HI(p2));
    Census(G);
    p1 = MAKE(LO(p1), Relocate(G, HI(p1)));
    p2 = MAKE(LO(p2), Relocate(G, HI(p2)));
    ea = MAKE(Relocate(G, LO(ea)), Relocate(G, HI(ea)));
    tm = MAKE(Relocate(G, LO(tm)), Relocate(G, HI(tm)));
    Sweep(G);
  }
  return DISPATCH(ea, tm, r, p1, p2);
}

struct T DispatchNil(dword ea, dword tm, dword r, dword p1, dword p2, dword d) {
  return Ret(0, tm, r);  // 𝑥 ⟹ ⊥
}

struct T DispatchTrue(dword ea, dword tm, dword r, dword p1, dword p2,
                      dword d) {
  return Ret(1, tm, r);  // 𝑥 ⟹ ⊤
}

struct T DispatchPrecious(dword ea, dword tm, dword r, dword p1, dword p2,
                          dword d) {
  return Ret(ea, tm, r);  // 𝑘 ⟹ 𝑘
}

struct T DispatchIdentity(dword ea, dword tm, dword r, dword p1, dword p2,
                          dword d) {
  return Ret(ea, tm, r);  // e.g. (⅄ (λ 𝑥 𝑦) 𝑎) ⟹ (⅄ (λ 𝑥 𝑦) 𝑎)
}

struct T DispatchShortcut(dword ea, dword tm, dword r, dword p1, dword p2,
                          dword d) {
  return Ret(MAKE(HI(d), 0), tm, r);
}

struct T DispatchLookup(dword ea, dword tm, dword r, dword p1, dword p2,
                        dword d) {
  int e, a, kv;
  e = LO(ea);
  a = HI(ea);
  DCHECK(!IsPrecious(e));
  DCHECK_GT(e, 0);
  DCHECK_LE(a, 0);
  if (LO(p1) == LO(ea)) return Ret(MAKE(HI(p1), 0), tm, r);
  if (LO(p2) == LO(ea)) return Ret(MAKE(HI(p2), 0), tm, r);
  if ((kv = Assoc(e, a))) {
    return Ret(MAKE(Cdr(kv), 0), tm, r);  // (eval 𝑘 (…(𝑘 𝑣)…)) ⟹ 𝑣
  } else {
    Error(""crash variable %S%n"", e);
  }
}

struct T DispatchQuote(dword ea, dword tm, dword r, dword p1, dword p2,
                       dword d) {
  return Ret(MAKE(HI(d), 0), tm, r);  // (Ω 𝑥) ⟹ 𝑥
}

struct T DispatchAtom(dword ea, dword tm, dword r, dword p1, dword p2,
                      dword d) {
  int x = FasterRecurse(HI(d), HI(ea), p1, p2);
  return Ret(MAKE(x >= 0, 0), tm, r);  // (α (𝑥 . 𝑦)) ⟹ ⊥, (α 𝑘) ⟹ ⊤
}

struct T DispatchCar(dword ea, dword tm, dword r, dword p1, dword p2, dword d) {
  int x = FasterRecurse(HI(d), HI(ea), p1, p2);
  return Ret(MAKE(Head(x), 0), tm, r);  // (⍅ (𝑥 . 𝑦)) ⟹ 𝑥
}

struct T DispatchCdr(dword ea, dword tm, dword r, dword p1, dword p2, dword d) {
  int x = FasterRecurse(HI(d), HI(ea), p1, p2);
  return Ret(MAKE(Tail(x), 0), tm, r);  // (⍆ (𝑥 . 𝑦)) ⟹ 𝑦
}

struct T DispatchEq(dword ea, dword tm, dword r, dword p1, dword p2, dword d) {
  int x = FasterRecurse(ARG1(LO(ea)), HI(ea), p1, p2);
  int y = FasterRecurse(HI(d), HI(ea), p1, p2);
  return Ret(MAKE(x == y, 0), tm, r);  // (≡ 𝑥 𝑥) ⟹ ⊤, (≡ 𝑥 𝑦) ⟹ ⊥
}

struct T DispatchCmp(dword ea, dword tm, dword r, dword p1, dword p2, dword d) {
  int x = FasterRecurse(ARG1(LO(ea)), HI(ea), p1, p2);
  int y = FasterRecurse(HI(d), HI(ea), p1, p2);
  return Ret(MAKE(Cmp(x, y), 0), tm, r);  // (≷ 𝑥 𝑦) ⟹ (⊥) | ⊥ | ⊤
}

struct T DispatchOrder(dword ea, dword tm, dword r, dword p1, dword p2,
                       dword d) {
  int x = FasterRecurse(ARG1(LO(ea)), HI(ea), p1, p2);
  int y = FasterRecurse(HI(d), HI(ea), p1, p2);
  return Ret(MAKE(Order(x, y), 0), tm, r);  // (⊙ 𝑥 𝑦) ⟹ (⊥) | ⊥ | ⊤
}

struct T DispatchCons(dword ea, dword tm, dword r, dword p1, dword p2,
                      dword d) {
  int x;
  if (cx < cHeap) cHeap = cx;
  x = Car(Cdr(LO(ea)));
  x = FasterRecurse(x, HI(ea), p1, p2);
  if (!HI(d)) return Ret(MAKE(Cons(x, 0), 0), tm, r);
  if (~r & NEED_POP) {
    r |= NEED_POP;
    Push(LO(ea));
  }
  r |= NEED_GC | NEED_TMC;
  tm = MAKE(Cons(x, LO(tm)), 0);
  return TailCall(MAKE(HI(d), HI(ea)), tm, r, p1, p2);  // (ℶ x 𝑦) ↩ (tm 𝑥′ . 𝑦)
}

struct T DispatchLambda(dword ea, dword tm, dword r, dword p1, dword p2,
                        dword d) {
  // (eval (𝑘 𝑥 𝑦) 𝑎) ⟹ (⅄ (𝑘 𝑥 𝑦) . 𝑎)
  SetFrame(r, LO(ea));
  r |= NEED_GC;
  return Ret(MAKE(Lambda(LO(ea), HI(ea), p1, p2), 0), tm, r);
}

struct T DispatchCond(dword ea, dword tm, dword r, dword p1, dword p2,
                      dword d) {
  int y, z, c = HI(d);
  if (r & NEED_POP) {
    Repush(LO(ea));
  }
  do {
    if (!Cdr(c) && !Cdr(Car(c))) {
      // (ζ …(𝑝)) ↩ 𝑝
      return TailCall(MAKE(Car(Car(c)), HI(ea)), tm, r, p1, p2);
    }
    if (~r & NEED_POP) {
      r |= NEED_POP;
      Push(LO(ea));
    }
    if ((y = FasterRecurse(Car(Car(c)), HI(ea), p1, p2))) {
      if ((z = Cdr(Car(c))) < 0) {
        // (ζ …(𝑝 𝑏)…) ↩ 𝑏 if 𝑝′
        return TailCall(MAKE(Car(z), HI(ea)), tm, r, p1, p2);
      } else {
        // (ζ …(𝑝)…) ⟹ 𝑝′ if 𝑝′
        return Ret(MAKE(y, 0), tm, r);
      }
    }
  } while ((c = Cdr(c)));
  return Ret(MAKE(c, 0), tm, r);  // (ζ) ⟹ ⊥
}

struct T DispatchIf(dword ea, dword tm, dword r, dword p1, dword p2, dword d) {
  return TailCall(
      MAKE(Get(LO(ea) + 4 + !FasterRecurse(Get(LO(ea) + 3), HI(ea), p1, p2)),
           HI(ea)),
      tm, r, p1, p2);
}

struct T DispatchPrinc(dword ea, dword tm, dword r, dword p1, dword p2,
                       dword d) {
  bool b;
  int e;
  e = LO(ea);
  SetFrame(r, e);
  b = literally;
  literally = true;
  e = recurse(MAKE(Head(Tail(e)), HI(ea)), p1, p2);
  Print(1, e);
  literally = b;
  return Ret(MAKE(e, 0), tm, r);
}

struct T DispatchFlush(dword ea, dword tm, dword r, dword p1, dword p2,
                       dword d) {
  SetFrame(r, LO(ea));
  Flush(1);
  return Ret(MAKE(kIgnore0, 0), tm, r);
}

struct T DispatchPrint(dword ea, dword tm, dword r, dword p1, dword p2,
                       dword d) {
  int a, f, x, A;
  f = LO(ea);
  a = HI(ea);
  SetFrame(r, f);
  for (;;) {
    f = Cdr(f);
    if (!Cdr(f)) {
      if (quiet) {
        return TailCall(MAKE(Car(f), a), tm, r, p1, p2);
      } else {
        x = recurse(MAKE(Car(f), a), p1, p2);
        Print(1, x);
        PrintNewline(1);
        return Ret(MAKE(x, 0), tm, r);
      }
    }
    if (!quiet) {
      A = cx;
      x = recurse(MAKE(Car(f), a), p1, p2);
      Print(1, x);
      PrintSpace(1);
      MarkSweep(A, 0);
    }
  }
}

struct T DispatchPprint(dword ea, dword tm, dword r, dword p1, dword p2,
                        dword d) {
  int a, f, x, n, A;
  f = LO(ea);
  a = HI(ea);
  SetFrame(r, f);
  for (n = 0;;) {
    f = Cdr(f);
    if (!Cdr(f)) {
      if (quiet) {
        return TailCall(MAKE(Car(f), a), tm, r, p1, p2);
      } else {
        x = recurse(MAKE(Car(f), a), p1, p2);
        PrettyPrint(1, x, n);
        PrintNewline(1);
        return Ret(MAKE(x, 0), tm, r);
      }
    }
    if (!quiet) {
      A = cx;
      x = recurse(MAKE(Car(f), a), p1, p2);
      n += Print(1, x);
      n += PrintSpace(1);
      MarkSweep(A, 0);
    }
  }
}

struct T DispatchPrintheap(dword ea, dword tm, dword r, dword p1, dword p2,
                           dword d) {
  int x, A;
  SetFrame(r, LO(ea));
  if (Cdr(LO(ea))) {
    A = cx;
    x = recurse(MAKE(Cadr(LO(ea)), HI(ea)), p1, p2);
    PrintHeap(A);
  } else {
    PrintHeap(0);
    x = 0;
  }
  return Ret(x, tm, r);
}

struct T DispatchGc(dword ea, dword tm, dword r, dword p1, dword p2, dword d) {
  int A, e;
  SetFrame(r, LO(ea));
  A = GetFrameCx();
  e = recurse(MAKE(HI(d), HI(ea)), p1, p2);
  if (e < A && cx < A && !ShouldIgnoreGarbage(A)) {
    e = MarkSweep(A, e);
  }
  return Ret(MAKE(e, 0), tm, r);
}

struct T DispatchProgn(dword ea, dword tm, dword r, dword p1, dword p2,
                       dword d) {
  int A, y, x = HI(d);
  for (;;) {
    y = Car(x);
    x = Cdr(x);
    if (!x) {
      if (r & NEED_POP) {
        Repush(y);
      }
      return TailCall(MAKE(y, HI(ea)), tm, r, p1, p2);  // (progn ⋯ 𝑥) ↩ 𝑥
    }
    A = cx;
    recurse(MAKE(y, HI(ea)), p1, p2);  // evaluate for effect
    MarkSweep(A, 0);
  }
}

struct T DispatchGensym(dword ea, dword tm, dword r, dword p1, dword p2,
                        dword d) {
  return Ret(MAKE(Gensym(), 0), tm, r);
}

struct T DispatchQuiet(dword ea, dword tm, dword r, dword p1, dword p2,
                       dword d) {
  SAVE(quiet, true);
  ea = MAKE(recurse(MAKE(Cadr(LO(ea)), HI(ea)), p1, p2), 0);
  RESTORE(quiet);
  return Ret(ea, tm, r);
}

struct T DispatchTrace(dword ea, dword tm, dword r, dword p1, dword p2,
                       dword d) {
  START_TRACE;
  ea = MAKE(recurse(MAKE(Cadr(LO(ea)), HI(ea)), p1, p2), 0);
  END_TRACE;
  return Ret(ea, tm, r);
}

struct T DispatchFtrace(dword ea, dword tm, dword r, dword p1, dword p2,
                        dword d) {
  ftrace_install();
  ftrace_enabled(+1);
  ea = MAKE(recurse(MAKE(Cadr(LO(ea)), HI(ea)), p1, p2), 0);
  ftrace_enabled(-1);
  return Ret(ea, tm, r);
}

struct T DispatchBeta(dword ea, dword tm, dword r, dword p1, dword p2,
                      dword d) {
  SetFrame(r, LO(ea));
  r |= NEED_GC;
  return Ret(MAKE(Simplify(recurse(MAKE(HI(d), HI(ea)), p1, p2), HI(ea)), 0),
             tm, r);
}

struct T DispatchFunction(dword ea, dword tm, dword r, dword p1, dword p2,
                          dword d) {
  // (eval (𝑓 (𝑘 𝑥 𝑦)) 𝑎) ⟹ (⅄ (𝑘 𝑥 𝑦) . prune 𝑎 wrt (𝑘 𝑥 𝑦))
  SetFrame(r, LO(ea));
  r |= NEED_GC;
  return Ret(
      MAKE(Function(recurse(MAKE(HI(d), HI(ea)), p1, p2), HI(ea), p1, p2), 0),
      tm, r);
}

struct T DispatchIgnore0(dword ea, dword tm, dword r, dword p1, dword p2,
                         dword d) {
  return Ret(MAKE(kIgnore0, 0), tm, r);
}

struct T DispatchIgnore1(dword ea, dword tm, dword r, dword p1, dword p2,
                         dword d) {
  int x = recurse(MAKE(Car(Cdr(LO(ea))), HI(ea)), p1, p2);
  return Ret(MAKE(List(kIgnore, x), 0), tm, r);
}

struct T DispatchExpand(dword ea, dword tm, dword r, dword p1, dword p2,
                        dword d) {
  int x;
  SetFrame(r, LO(ea));
  r |= NEED_GC;
  x = HI(d);
  x = recurse(MAKE(x, HI(ea)), p1, p2);
  return Ret(MAKE(expand(x, HI(ea)), 0), tm, r);
}

static int GrabArgs(int x, int a, dword p1, dword p2) {
  if (x >= 0) return x;
  return Cons(recurse(MAKE(Car(x), a), p1, p2), GrabArgs(Cdr(x), a, p1, p2));
}

struct T DispatchError(dword ea, dword tm, dword r, dword p1, dword p2,
                       dword d) {
  int e, x;
  e = LO(ea);
  SetFrame(r, e);
  r |= NEED_GC;
  x = GrabArgs(Cdr(e), HI(ea), p1, p2);
  Raise(Cons(Car(e), x));
}

struct T DispatchExit(dword ea, dword tm, dword r, dword p1, dword p2,
                      dword d) {
  longjmp(exiter, 1);
}

struct T DispatchRead(dword ea, dword tm, dword r, dword p1, dword p2,
                      dword d) {
  return Ret(MAKE(Read(0), 0), tm, r);
}

struct T DispatchFuncall(dword ea, dword tm, dword r, dword p1, dword p2,
                         dword d) {
  int a, b, e, f, t, u, y, p, z;
  e = LO(ea);
  a = HI(ea);
  DCHECK_LT(e, 0);
  SetFrame(r, e);
  r |= NEED_GC;
  f = Car(e);
  z = Cdr(e);
  y = HI(d) ? HI(d) : FasterRecurse(f, a, p1, p2);
Delegate:
  if (y < 0) {
    t = Car(y);
    if (t == kClosure) {
      // (eval ((⅄ (λ 𝑥 𝑦) 𝑏) 𝑧) 𝑎) ↩ (eval ((λ 𝑥 𝑦) 𝑧) 𝑏)
      y = Cdr(y);  // ((λ 𝑥 𝑦) 𝑏)
      u = Cdr(y);  //          𝑏
      y = Car(y);  //  (λ 𝑥 𝑦)
      t = Car(y);  //   λ
    } else {
      u = a;
    }
    p = Car(Cdr(y));
    b = Car(Cdr(Cdr(y)));
    if (t == kLambda) {
      if (!(p > 0 && b < 0 && Cdr(b) == p)) {
        struct Binding bz = bind_(p, z, a, u, p1, p2);
        return TailCall(MAKE(b, bz.u), tm, r, bz.p1, 0);
      } else {
        // fast path ((lambda 𝑣 (𝑦 . 𝑣)) 𝑧) ↩ (𝑦′ 𝑧)
        y = recurse(MAKE(Car(b), u), 0, 0);
        goto Delegate;
      }
    } else if (t == kMacro) {
      // (eval ((ψ 𝑥 𝑦) 𝑥) 𝑎) ↩ (eval (eval 𝑦 ((𝑥ᵢ 𝑥ᵢ) 𝑎)) 𝑎)
      return TailCall(MAKE(eval(b, pairlis(p, Exlis(z, a), u)), a), tm, r, 0,
                      0);
    }
  } else if (y > 1 && y != f && IsPrecious(y)) {
    // unplanned builtin calls
    // e.g. ((cond (p car) (cdr)) x)
    return TailCall(MAKE(Cons(y, z), a), tm, r, p1, p2);
  }
  React(e, y, kFunction);
}

struct T DispatchCall1(dword ea, dword tm, dword r, dword p1, dword p2,
                       dword d) {
  int b, e, u, y, p;
  e = LO(ea);
  DCHECK_LT(e, 0);
  SetFrame(r, e);
  y = HI(d);
  // (eval ((⅄ (λ 𝑥 𝑦) 𝑏) 𝑧) 𝑎) ↩ (eval ((λ 𝑥 𝑦) 𝑧) 𝑏)
  y = Cdr(y);  // ((λ 𝑥 𝑦) 𝑏)
  u = Cdr(y);  //          𝑏
  y = Car(y);  //  (λ 𝑥 𝑦)
  p = Car(Cdr(y));
  b = Car(Cdr(Cdr(y)));
  return TailCall(MAKE(b, u), tm, r,
                  MAKE(Car(p), FasterRecurse(Car(Cdr(LO(ea))), HI(ea), p1, p2)),
                  0);
}

struct T DispatchCall2(dword ea, dword tm, dword r, dword p1, dword p2,
                       dword d) {
  int b, e, u, y, p;
  e = LO(ea);
  DCHECK_LT(e, 0);
  SetFrame(r, e);
  y = HI(d);
  // (eval ((⅄ (λ 𝑥 𝑦) 𝑏) 𝑧) 𝑎) ↩ (eval ((λ 𝑥 𝑦) 𝑧) 𝑏)
  y = Cdr(y);  // ((λ 𝑥 𝑦) 𝑏)
  u = Cdr(y);  //          𝑏
  y = Car(y);  //  (λ 𝑥 𝑦)
  p = Car(Cdr(y));
  b = Car(Cdr(Cdr(y)));
  return TailCall(
      MAKE(b, u), tm, r,
      MAKE(Car(p), FasterRecurse(Car(Cdr(LO(ea))), HI(ea), p1, p2)),
      MAKE(Car(Cdr(p)), FasterRecurse(Car(Cdr(Cdr(LO(ea)))), HI(ea), p1, p2)));
}

struct T DispatchLet1(dword ea, dword tm, dword r, dword p1, dword p2,
                      dword d) {
  // Fast path DispatchFuncall() for ((λ (𝑣) 𝑦) 𝑧₀) expressions
  // HI(d) contains ((𝑣) 𝑦)
  if (UNLIKELY(trace))
    Fprintf(2, ""%J╟─%s[%p @ %d] δ %'Rns%n"", ""DispatchLet1"", LO(ea), LO(ea));
  int v = Car(Car(HI(d)));
  int y = Car(Cdr(HI(d)));
  int z = FasterRecurse(Car(Cdr(LO(ea))), HI(ea), p1, p2);
  int a = HI(ea);
  if (!LO(p1) || LO(p1) == v) {
    p1 = MAKE(v, z);
  } else if (!LO(p2) || LO(p2) == v) {
    p2 = MAKE(v, z);
  } else {
    a = Alist(LO(p2), HI(p2), a);
    p2 = p1;
    p1 = MAKE(v, z);
  }
  return TailCall(MAKE(y, a), tm, r, p1, p2);
}

int Eval(int e, int a) {
  return ((ForceIntTailDispatchFn *)GetDispatchFn(e))(MAKE(e, a), 0, 0, 0, 0,
                                                      GetShadow(e));
}

static void ResetStats(void) {
  cHeap = cx;
  cGets = 0;
  cSets = 0;
}

static void PrintStats(long usec) {
  Fprintf(2,
          "";; heap    %'16ld  nsec    %'16ld%n""
          "";; gets    %'16ld  sets    %'16ld%n""
          "";; atom    %'16ld  frez    %'16ld%n"",
          -cHeap - -cFrost, usec, cGets, cSets, cAtoms, -cFrost);
}

static wontreturn int Exit(void) {
  exit(0 <= fails && fails <= 255 ? fails : 255);
}

static wontreturn void PrintUsage(void) {
  PUTS(!!fails + 1, ""Usage: "");
  PUTS(!!fails + 1, program_invocation_name);
  PUTS(!!fails + 1, "" [-MNSacdfgqstz?h] <input.lisp >errput.lisp\n\
  -d  dump global defines, on success\n\
  -s  print statistics upon each eval\n\
  -z  uses alternative unicode glyphs\n\
  -f  print log of all function calls\n\
  -S  avoid pretty printing most case\n\
  -c  dont conceal transitive closure\n\
  -a  log name bindings in the traces\n\
  -t  hyper verbose jump table traces\n\
  -M  enable tracing of macro expands\n\
  -N  disable define name substitutes\n\
  -g  will log garbage collector pass\n\
  -q  makes (print) and (pprint) noop\n\
"");
  Exit();
}

int Plinko(int argc, char *argv[]) {
  int S, x;
  bool trace;
  uint64_t t1, t2;
  tick = kStartTsc;
#ifndef NDEBUG
  ShowCrashReports();
#endif
  signal(SIGPIPE, SIG_DFL);

  depth = -1;
  trace = false;
  while ((x = getopt(argc, argv, ""MNSacdfgqstz?h"")) != -1) {
    switch (x) {
      CASE(L'd', dump = true);
      CASE(L's', stats = true);
      CASE(L'z', symbolism = true);
      CASE(L'f', ftrace = true);
      CASE(L'S', simpler = true);
      CASE(L'c', logc = true);
      CASE(L'a', loga = true);
      CASE(L't', trace = true);
      CASE(L'g', gtrace = true);
      CASE(L'q', quiet = true);
      CASE(L'M', mtrace = true);
      CASE(L'N', noname = true);
      CASE(L'?', PrintUsage());
      CASE(L'h', PrintUsage());
      default:
        ++fails;
        PrintUsage();
    }
  }

  if (sys_arch_prctl(ARCH_SET_FS, 0x200000000000) == -1 ||
      sys_arch_prctl(ARCH_SET_GS, (intptr_t)DispatchPlan) == -1) {
    fputs(""error: "", stderr);
    fputs(strerror(errno), stderr);
    fputs(""\nyour operating system doesn't allow you change both ""
          ""the %fs and %gs registers\nin your processor. that's a shame, ""
          ""since they're crucial for performance.\n"",
          stderr);
    exit(1);
  }

  if (mmap((void *)0x200000000000,
           ROUNDUP((TERM + 1) * sizeof(g_mem[0]), FRAMESIZE),
           PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED, -1,
           0) == MAP_FAILED ||
      mmap((void *)(0x200000000000 +
                    (BANE & (BANE | MASK(BANE))) * sizeof(g_mem[0])),
           (BANE & (BANE | MASK(BANE))) * sizeof(g_mem[0]),
           PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED, -1,
           0) == MAP_FAILED ||
      mmap((void *)0x400000000000,
           ROUNDUP((TERM + 1) * sizeof(g_mem[0]), FRAMESIZE),
           PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED, -1,
           0) == MAP_FAILED ||
      mmap((void *)(0x400000000000 +
                    (BANE & (BANE | MASK(BANE))) * sizeof(g_mem[0])),
           (BANE & (BANE | MASK(BANE))) * sizeof(g_mem[0]),
           PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED, -1,
           0) == MAP_FAILED) {
    fputs(""error: "", stderr);
    fputs(strerror(errno), stderr);
    fputs(""\nyour operating system doesn't allow you to allocate\n""
          ""outrageous amounts of overcommit memory, which is a shame, since\n""
          ""the pml4t feature in your processor was intended to give you that\n""
          ""power since it's crucial for sparse data applications and lisp.\n""
          ""for instance, the way racket works around this problem is by\n""
          ""triggering thousands of segmentation faults as part of normal\n""
          ""operation\n"",
          stderr);
    exit(1);
  }

  g_mem = (void *)0x200000000000;

  inputs = argv + optind;
  if (*inputs) {
    close(0);
    DCHECK_NE(-1, open(*inputs++, O_RDONLY));
  }

  eval = Eval;
  bind_ = Bind;
  evlis = Evlis;
  expand = Expand;
  recurse = Recurse;
  pairlis = Pairlis;
  kTail[0] = DispatchTail;
  kTail[1] = DispatchTailImpossible;
  kTail[2] = DispatchTailImpossible;
  kTail[3] = DispatchTailImpossible;
  kTail[4] = DispatchTail;
  kTail[5] = DispatchTailGc;
  kTail[6] = DispatchTailImpossible;
  kTail[7] = DispatchTailTmcGc;
  if (trace) EnableTracing();

  cx = -1;
  cFrost = cx;
  Setup();
  cFrost = cx;

  if (!setjmp(exiter)) {
    for (;;) {
      S = sp;
      DCHECK_EQ(0, S);
      DCHECK_EQ(cx, cFrost);
      if (!(x = setjmp(crash))) {
        x = Read(0);
        x = expand(x, globals);
        if (stats) ResetStats();
        if (x < 0 && Car(x) == kDefine) {
          globals = Define(x, globals);
          cFrost = cx;
        } else {
          t1 = rdtsc();
          x = eval(x, globals);
          if (x < 0 && Car(x) == kIgnore) {
            MarkSweep(cFrost, 0);
          } else {
            Fprintf(1, ""%p%n"", x);
            MarkSweep(cFrost, 0);
            if (stats) {
              t2 = rdtsc();
              PrintStats(ClocksToNanos(t1, t2));
            }
          }
        }
      } else {
        x = ~x;
        ++fails;
        eval = Eval;
        expand = Expand;
        Fprintf(2, ""?%p%s%n"", x, cx == BANE ? "" [HEAP OVERFLOW]"" : """");
        Backtrace(S);
        Exit();
        Unwind(S);
        MarkSweep(cFrost, 0);
      }
    }
  }

#if HISTO_ASSOC
  PrintHistogram(2, ""COMPARES PER ASSOC"", g_assoc_histogram,
                 ARRAYLEN(g_assoc_histogram));
#endif
#if HISTO_GARBAGE
  PrintHistogram(2, ""GC MARKS PER COLLECTION"", g_gc_marks_histogram,
                 ARRAYLEN(g_gc_marks_histogram));
  PrintHistogram(2, ""GC DISCARDS PER COLLECTION"", g_gc_discards_histogram,
                 ARRAYLEN(g_gc_discards_histogram));
  PrintHistogram(2, ""GC MARKS / DISCARDS FOR DENSE COLLECTIONS"",
                 g_gc_dense_histogram, ARRAYLEN(g_gc_dense_histogram));
  PrintHistogram(2, ""GC DISCARDS / MARKS FOR SPARSE COLLECTIONS"",
                 g_gc_sparse_histogram, ARRAYLEN(g_gc_sparse_histogram));
  PrintHistogram(2, ""GC LOP"", g_gc_lop_histogram, ARRAYLEN(g_gc_lop_histogram));
#endif

  if (dump && !fails) {
    DumpDefines(kDefine, globals, Reverse(ordglob, 0));
  }
  Exit();
}
"
./repos/cosmopolitan/tool/plinko/lib/isif.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2021 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/plinko.h""

/**
 * Matches
 *
 *     (ζ (X Y) (Z))
 *
 * @return MAKE4(X,Y,Z,0) on success, or ZERO4 on mismatch
 * @note ζ means COND
 */
struct qword IsIf(int x_) {
  dword w_;
  if (x_ >= 0) return ZERO4;
  w_ = Get(x_);  // (ζ (X Y) (Z))
  int ax_ = LO(w_);
  int dx_ = HI(w_);
  if (ax_ != kCond) return ZERO4;
  if (dx_ >= 0) return ZERO4;
  w_ = Get(dx_);  // ((X Y) (Z))
  int adx_ = LO(w_);
  int ddx_ = HI(w_);
  if (adx_ >= 0) return ZERO4;
  w_ = Get(adx_);  // (X Y)
  int aadx_ = LO(w_);
  int dadx_ = HI(w_);
  if (ddx_ >= 0) return ZERO4;
  w_ = Get(ddx_);  // ((Z))
  int addx_ = LO(w_);
  int dddx_ = HI(w_);
  int X = aadx_;
  if (addx_ >= 0) return ZERO4;
  w_ = Get(addx_);  // (Z)
  int aaddx_ = LO(w_);
  int daddx_ = HI(w_);
  if (dadx_ >= 0) return ZERO4;
  w_ = Get(dadx_);  // (Y)
  int adadx_ = LO(w_);
  int ddadx_ = HI(w_);
  if (dddx_) return ZERO4;
  int Y = adadx_;
  int Z = aaddx_;
  if (ddadx_) return ZERO4;
  if (daddx_) return ZERO4;
  return MAKE4(X, Y, Z, 0);
}
"
./repos/cosmopolitan/tool/plinko/lib/assoc.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/histo.h""
#include ""tool/plinko/lib/index.h""
#include ""tool/plinko/lib/plinko.h""
#include ""tool/plinko/lib/tree.h""

/**
 * Performs lookup of binding.
 *
 * We perform lookups into an association list, e.g.
 *
 *       ┌───┬───┐ ┌───┬───┐ ┌───┬───┐
 *       │ 𝑘₀│ 𝑣₀│ │ 𝑘₁│ 𝑣₁│ │ 𝑘₂│ 𝑣₂│
 *       └─┬─┴───┘ └─┬─┴───┘ └─┬─┴───┘
 *       ┌─│─┬───┐ ┌─│─┬───┐ ┌─│─┬───┐
 *     𝑎=│ ┴ │ ├───┤ ┴ │ ├───┤ ┴ │ 0 │
 *       └───┴───┘ └───┴───┘ └───┴───┘
 *
 * For example, if 𝑘₁ is queried then we return:
 *
 *     ┌───┬───┐
 *     │ 𝑘₁│ 𝑣₁│
 *     └───┴───┘
 *
 * However there's a twist: the association is allowed to turn into a
 * red-black tree. That would look like this:
 *
 *       ┌───┬───┐ ┌───┬───┐
 *       │ 𝑘₀│ 𝑣₀│ │ 𝑘₁│ 𝑣₁│
 *       └─┬─┴───┘ └─┬─┴───┘
 *       ┌─│─┬───┐ ┌─│─┬───┐ ┌───┬───┐
 *     𝑎=│ ┴ │ ├───┤ ┴ │ ├───│ ┬ │ 𝑐 │
 *       └───┴───┘ └───┴───┘ └─│─┴───┘
 *                           ┌─┴─┬───┐
 *                           │ ┬ │ ┬ │
 *                           └─│─┴─│─┘
 *                      ┌───┬──┴┐ ┌┴──┬───┐
 *                      │ 𝑘₂│ 𝑣₂│ │ L │ R │
 *                      └───┴───┘ └───┴───┘
 *
 * We're able to tell a tree node apart from an association list node
 * because we make the assumption that 𝑘ᵢ is an atom. On the other hand
 * 𝑣ᵢ can be anything.
 *
 * @param k is an atom
 * @param a is an association list and/or red-black tree
 * @return entry cons cell or 0 if not found
 */
int Assoc(int k, int a) {
  int i, j, e, c, r;
  DCHECK_GE(k, 0);
  i = a;
  r = 0;
  if (k && k != 1) {
    for (c = 0; i;) {
      e = Head(i);
      i = Cdr(i);
      j = Head(e);
      ++c;
      if (j == k) {
        r = e;
        break;
      } else if (j < 0 && (j =
#if HISTO_ASSOC
                               GetTreeCount(k, e, &c)
#else
                               GetTree(k, e)
#endif
                               )) {
        r = Ent(j);
        break;
      }
    }
#if HISTO_ASSOC
    HISTO(g_assoc_histogram, c);
#endif
  }
  return r;
}
"
./repos/cosmopolitan/tool/plinko/lib/countreferences.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/log/check.h""
#include ""tool/plinko/lib/index.h""
#include ""tool/plinko/lib/plinko.h""

/**
 * Counts references to variable.
 *
 * @param v is atom name of variable
 * @param m is count after which we should stop counting
 * @param e is expression
 * @return number of counted references greater than zero
 * @note this produces garbage when recursing into let
 */
int CountReferences(int v, int m, int e) {
  int f, r;
  DCHECK_GT(v, 0);
  if (e >= 0) {
    r = e == v;
  } else {
    f = Car(e);
    if (f == kQuote || f == kClosure) {
      r = 0;
    } else if (f == kLambda || f == kMacro) {
      if (m > 0 && !HasAtom(v, Cadr(e))) {
        r = CountReferences(v, m, Caddr(e));
      } else {
        r = 0;
      }
    } else if (f == kCond) {
      for (r = 0; (e = Cdr(e)) < 0 && r < m;) {
        if ((f = Car(e)) < 0) {
          r += CountReferences(v, m - r, Car(f));
          if ((f = Cdr(f)) < 0) {
            r += CountReferences(v, m - r, Car(f));
          }
        }
      }
    } else {
      for (r = 0; e && r < m;) {
        if (e < 0) {
          f = Car(e);
          e = Cdr(e);
        } else {
          f = e;
          e = 0;
        }
        r += CountReferences(v, m - r, f);
      }
    }
  }
  DCHECK_GE(r, 0);
  return r;
}
"
./repos/cosmopolitan/tool/plinko/lib/expand.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/log/check.h""
#include ""tool/plinko/lib/config.h""
#include ""tool/plinko/lib/cons.h""
#include ""tool/plinko/lib/gc.h""
#include ""tool/plinko/lib/index.h""
#include ""tool/plinko/lib/plinko.h""
#include ""tool/plinko/lib/trace.h""

int Exlis(int x, int a) {
  int y;
  if (!x) return x;
  if (x > 0) return expand(x, a);
  y = expand(Car(x), a);
  return Keep(x, Cons(y, Exlis(Cdr(x), a)));
}

static int Expander(int e, int a) {
  int f, u, x, y, s;
  for (s = 0;;) {
    DCHECK_LT(e, TERM);
    DCHECK_LE(a, 0);
    if (e >= 0) return e;
    if ((f = Car(e)) > 0) {
      if (f == kQuote) return e;
      if (f == kClosure) return e;
      if (f == kTrace) {
        START_TRACE;
        x = Cadr(e);
        y = expand(x, a);
        e = x == y ? e : List(Car(e), y);
        END_TRACE;
        return e;
      }
      if (HasAtom(f, s)) return e;
      s = Cons(f, s);
    }
    e = Exlis(e, a);
    if (f >= 0) {
      if (!(f = Assoc(f, a))) return e;
      f = Cdr(f);
      if (f >= 0) return e;
    }
    if (Car(f) == kClosure) {
      u = Cddr(f);
      f = Cadr(f);
    } else {
      u = a;
    }
    if (Head(f) != kMacro) return e;
    e = eval(Caddr(f), pairlis(Cadr(f), Cdr(e), u));
  }
}

int Expand(int e, int a) {
  int r, A;
  A = cx;
  Push(List(kExpand, e));
  r = Keep(e, Expander(e, a));
  Pop();
  r = MarkSweep(A, r);
  return r;
}
"
./repos/cosmopolitan/tool/plinko/lib/isdelegate.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2021 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/plinko.h""

/**
 * Matches
 *
 *     (λ V (F . V) . Q)
 *
 * @return F on success, or 0 on mismatch
 * @note Q is ignored
 * @note V must be a non-nil atom
 * @note λ means LAMBDA
 */
int IsDelegate(int x_) {
  dword w_;
  if (x_ >= 0) return 0;
  w_ = Get(x_);  // (λ V (F . V) . Q)
  int ax_ = LO(w_);
  int dx_ = HI(w_);
  if (ax_ != kLambda) return 0;
  if (dx_ >= 0) return 0;
  w_ = Get(dx_);  // (V (F . V) . Q)
  int adx_ = LO(w_);
  int ddx_ = HI(w_);
  int V = adx_;
  if (V <= 0) return 0;
  if (ddx_ >= 0) return 0;
  w_ = Get(ddx_);  // ((F . V) . Q)
  int addx_ = LO(w_);
  if (addx_ >= 0) return 0;
  w_ = Get(addx_);  // (F . V)
  int aaddx_ = LO(w_);
  int daddx_ = HI(w_);
  int F = aaddx_;
  if (daddx_ != V) return 0;
  return F;
}
"
./repos/cosmopolitan/tool/plinko/lib/planfuncalls.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/cons.h""
#include ""tool/plinko/lib/index.h""
#include ""tool/plinko/lib/plinko.h""

void PlanFuncalls(int n, dword p, int x) {
  int h;
  if (x < 0 && (h = Car(x)) != kQuote && h != kClosure && h != kMacro) {
    if (h == kLambda) {
      if (!HasAtom(n, Cadr(x))) {
        PlanFuncalls(n, p, Caddr(x));
      }
    } else if (h == kCond) {
      while ((x = Cdr(x)) < 0) {
        if ((h = Car(x)) < 0) {
          PlanFuncalls(n, p, Car(h));
          if ((h = Cdr(h)) < 0) {
            PlanFuncalls(n, p, Car(h));
          }
        }
      }
    } else {
      if (h == n) {
        SetShadow(x, p);
      }
      while (x) {
        if (x < 0) {
          h = Car(x);
          x = Cdr(x);
        } else {
          h = x;
          x = 0;
        }
        PlanFuncalls(n, p, h);
      }
    }
  }
}
"
./repos/cosmopolitan/tool/plinko/lib/read.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/calls/calls.h""
#include ""libc/errno.h""
#include ""libc/intrin/strace.internal.h""
#include ""libc/log/check.h""
#include ""libc/runtime/runtime.h""
#include ""libc/str/str.h""
#include ""libc/sysv/consts/o.h""
#include ""tool/plinko/lib/char.h""
#include ""tool/plinko/lib/cons.h""
#include ""tool/plinko/lib/error.h""
#include ""tool/plinko/lib/plinko.h""
#include ""tool/plinko/lib/printf.h""

static int Read1(int);
static int Read2(int);

dontinstrument int ReadSpaces(int fd) {
  size_t n;
  ssize_t rc;
  for (;;) {
    rc = read(fd, g_buffer[fd], sizeof(g_buffer[fd]) - 1);
    if (rc != -1) {
      if ((n = rc)) {
        g_buffer[fd][n] = 0;
        bp[fd] = 1;
        return g_buffer[fd][0] & 255;
      } else if (fd == 0 && *inputs) {
        close(0);
        if (open(*inputs++, O_RDONLY) == -1) {
          ++fails;
          Flush(1);
          Fprintf(2, ""error: open(%s) %s%n"", inputs[-1], strerror(errno));
          longjmp(exiter, 1);
        }
      } else {
        Flush(1);
        Flush(2);
        longjmp(exiter, 1);
      }
    } else if (errno != EINTR) {
      ++fails;
      Flush(1);
      Fprintf(2, ""error: read(%d) %s%n"", fd, strerror(errno));
      longjmp(exiter, 1);
    }
  }
}

dontinstrument int ReadByte(int fd) {
  int c;
  if ((c = g_buffer[fd][bp[fd]++] & 255)) return c;
  return ReadSpaces(fd);
}

dontinstrument int ReadChar(int fd) {
  int b, a = dx;
  for (;;) {
    dx = ReadByte(fd);
    if (dx != ';') {
      break;
    } else {
      do b = ReadByte(fd);
      while ((b != '\n'));
    }
  }
  if (a >= 0300) {
    for (b = 0200; a & b; b >>= 1) {
      a ^= b;
    }
    while ((dx & 0300) == 0200) {
      a <<= 6;
      a |= dx & 0177;
      dx = ReadByte(fd);
    }
  }
  if (0 < a && a < TERM) {
    return ToUpper(a);
  }
  Error(""thompson-pike varint outside permitted range"");
}

static int ReadListItem(int fd, int closer, int f(int)) {
  int x, y;
  if ((x = f(fd)) > 0) {
    if (Get(x) == MAKE(closer, TERM)) return -0;
    if (Get(x) == MAKE(L'.', TERM)) {
      x = f(fd);
      if ((y = ReadListItem(fd, closer, Read1))) {
        Error(""multiple list items after dot: %S"", y);
      }
      return x;
    }
  }
  return ShareCons(x, ReadListItem(fd, closer, Read1));
}

static int ReadList(int fd, int closer) {
  int t;
  ++fails;
  t = ReadListItem(fd, closer, Read2);
  --fails;
  return t;
}

static int TokenizeInteger(int fd, int b) {
  dword a;
  int c, i;
  for (i = a = 0;; ++i) {
    if ((c = GetDiglet(ToUpper(dx))) != -1 && c < b) {
      a = (a * b) + c;
      ReadChar(fd);
    } else {
      ax = TERM;
      return Intern(a, TERM);
    }
  }
}

static void ConsumeComment(int fd) {
  int c, t = 1;
  for (;;) {
    c = ReadChar(fd);
    if (c == '#' && dx == '|') ++t;
    if (!t) return;
    if (c == '|' && dx == '#') --t;
  }
}

static int ReadAtomRest(int fd, int x) {
  int y;
  ax = y = TERM;
  if (x == L'\\') x = ReadChar(fd);
  if (!IsSpace(dx) && !IsParen(dx) && !IsMathAlnum(x) && !IsMathAlnum(dx)) {
    y = ReadAtomRest(fd, ReadChar(fd));
  }
  return Intern(x, y);
}

static int ReadAtom(int fd) {
  int a, s, x;
  x = ReadChar(fd);
  if ((s = Desymbolize(x)) != -1) return s;
  a = ReadAtomRest(fd, x);
  if (LO(Get(a)) == L'T' && HI(Get(a)) == TERM) {
    a = 1;
  } else if (LO(Get(a)) == L'N' && HI(Get(a)) != TERM &&
             LO(Get(HI(Get(a)))) == L'I' && HI(Get(HI(Get(a)))) != TERM &&
             LO(Get(HI(Get(HI(Get(a)))))) == L'L' &&
             HI(Get(HI(Get(HI(Get(a)))))) == TERM) {
    a = 0;
  }
  return a;
}

static int TokenizeComplicated(int fd) {
  int c;
  ReadChar(fd);
  switch ((c = ReadChar(fd))) {
    case L'\'':
      return List(kFunction, Read(fd));
    case L'B':
      return TokenizeInteger(fd, 2);
    case L'X':
      return TokenizeInteger(fd, 16);
    case L'Z':
      return TokenizeInteger(fd, 36);
    case L'O':
      return TokenizeInteger(fd, 8);
    case L'|':
      ConsumeComment(fd);
      return Read(fd);
    default:
      Error(""unsuppported complicated syntax #%c [0x%x]"", c, c);
  }
}

static int Read2(int fd) {
  int r, l;
  while (IsSpace((l = dx))) ReadChar(fd);
  switch (dx) {
    case L'#':
      r = TokenizeComplicated(fd);
      break;
    case L'\'':
      ReadChar(fd);
      r = ShareList(kQuote, Read(fd));
      break;
    case L'`':
      ReadChar(fd);
      r = ShareList(kBackquote, Read(fd));
      break;
    case L',':
      ReadChar(fd);
      if (dx == L'@') {
        ReadChar(fd);
        r = ShareList(kSplice, Read(fd));
      } else {
        r = ShareList(kComma, Read(fd));
      }
      break;
    case L'""':
      r = ShareList(kString, ReadString(fd, ReadByte(fd)));
      break;
    case L'(':
      ReadChar(fd);
      r = ReadList(fd, L')');
      break;
    case L'[':
      ReadChar(fd);
      r = ShareList(kSquare, ReadList(fd, L']'));
      break;
    case L'{':
      ReadChar(fd);
      r = ShareList(kCurly, ReadList(fd, L'}'));
      break;
    default:
      r = ReadAtom(fd);
      break;
  }
  return r;
}

static int ReadLambda(int fd, int n) {
  int a, c, r, q = 0;
  do {
    c = ReadChar(fd);
    if (c == L'λ') {
      for (a = 0; (c = ReadChar(fd)) != '.';) {
        a = Cons(Intern(c, TERM), a);
      }
      for (r = ReadLambda(fd, n); a; a = Cdr(a)) {
        r = List3(kLambda, Cons(Car(a), 0), r);
      }
    } else if (c == L'(') {
      r = ReadLambda(fd, n + 1);
    } else if (c == L')') {
      break;
    } else if (IsSpace(c)) {
      Raise(kRead);
    } else {
      r = Intern(c, TERM);
    }
    if (!q) {
      q = r;
    } else {
      q = List(q, r);
    }
    if (!n && dx == L')') break;
  } while (!IsSpace(dx));
  return q;
}

static int Read1(int fd) {
  while (IsSpace(dx)) ReadChar(fd);
  // todo: fix horrible i/o
  if (dx == 0xCE && (g_buffer[fd][bp[fd]] & 255) == 0xbb) {
    return ReadLambda(fd, 0);
  }
  return Read2(fd);
}

int Read(int fd) {
  int r;
  ftrace_enabled(-1);
  strace_enabled(-1);
  r = Read1(fd);
  strace_enabled(+1);
  ftrace_enabled(+1);
  return r;
}
"
./repos/cosmopolitan/tool/plinko/lib/plan.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/log/countbranch.h""
#include ""tool/plinko/lib/cons.h""
#include ""tool/plinko/lib/error.h""
#include ""tool/plinko/lib/index.h""
#include ""tool/plinko/lib/plinko.h""
#include ""tool/plinko/lib/printf.h""
#include ""tool/plinko/lib/stack.h""
#include ""tool/plinko/lib/types.h""

nosideeffect int CountSimpleParameters(int x) {
  int i;
  for (i = 0; x; ++i, x = Cdr(x)) {
    if (x > 0) return -1;       // variadic args aren't simple
    if (!Car(x)) return -1;     // nil parameters aren't simple
    if (Car(x) < 0) return -1;  // destructured parameters aren't simple
  }
  return i;
}

nosideeffect int CountSimpleArguments(int x) {
  int i;
  for (i = 0; x; ++i, x = Cdr(x)) {
    if (x > 0) return -1;  // apply isn't simple
  }
  return i;
}

static dword PlanQuote(int e, int a, int s) {
  if (Cdr(e) >= 0) React(e, e, kQuote);     // one normal parameter required
  return MAKE(DF(DispatchQuote), Cadr(e));  // >1 prms is sectorlisp comment
}

static dword PlanCar(int e, int a, int s) {
  if (!Cdr(e)) return DF(DispatchNil);  // (⍅) ⟺ (⍅ ⊥)
  if (Cddr(e)) React(e, e, kCar);       // too many args
  if (!Cadr(e)) return DF(DispatchNil);
  return MAKE(DF(DispatchCar), Cadr(e));
}

static dword PlanCdr(int e, int a, int s) {
  if (!Cdr(e)) return DF(DispatchNil);  // (⍆) ⟺ (⍆ ⊥)
  if (Cddr(e)) React(e, e, kCdr);       // too many args
  if (!ARG1(e)) return DF(DispatchNil);
  return MAKE(DF(DispatchCdr), Cadr(e));
}

static dword PlanAtom(int e, int a, int s) {
  if (CountSimpleArguments(Cdr(e)) != 1) React(e, e, kAtom);
  return MAKE(DF(DispatchAtom), Cadr(e));
}

static dword PlanEq(int e, int a, int s) {
  int n = CountSimpleArguments(Cdr(e));
  if (n != 2 && n != 1) React(e, e, kAtom);  // (≡ 𝑥) is our (null 𝑥)
  return MAKE(DF(DispatchEq), Caddr(e));
}

static dword PlanCmp(int e, int a, int s) {
  if (CountSimpleArguments(Cdr(e)) != 2) React(e, e, kCmp);
  return MAKE(DF(DispatchCmp), Caddr(e));
}

static dword PlanOrder(int e, int a, int s) {
  if (CountSimpleArguments(Cdr(e)) != 2) React(e, e, kOrder);
  return MAKE(DF(DispatchOrder), Caddr(e));
}

static dword PlanCons(int e, int a, int s) {
  int p = CountSimpleArguments(Cdr(e));
  if (p == -1) Error(""cons dot arg"");
  if (p > 2) Error(""too many args"");
  return MAKE(DF(DispatchCons), Caddr(e));
}

static dword PlanLambda(int e, int a, int s) {
  if (CountSimpleArguments(Cdr(e)) == -1) Error(""bad lambda: %S"", e);
  return DF(DispatchLambda);
}

static dword PlanCond(int e, int a, int s) {
  int x;
  if (!Cdr(e)) return DF(DispatchNil);  // (ζ) ⟺ ⊥
  for (x = e; (x = Cdr(x));) {
    if (x > 0) React(e, e, kCond);            // (ζ . 𝑣) not allowed
    if (Car(x) >= 0) React(e, e, kCond);      // (ζ 𝑣) not allowed
    if (Cdr(Car(x)) > 0) React(e, e, kCond);  // (ζ (𝑥 . 𝑣)) not allowed
  }
  return MAKE(DF(DispatchCond), Cdr(e));
}

static dword PlanProgn(int e, int a, int s) {
  if (!Cdr(e)) return DF(DispatchNil);  // (progn) ⟺ ⊥
  if (CountSimpleArguments(Cdr(e)) == -1) React(e, e, kProgn);
  return MAKE(DF(DispatchProgn), Cdr(e));
}

static dword PlanQuiet(int e, int a, int s) {
  if (Cdr(e) > 0) React(e, e, kQuiet);   // apply not allowed
  if (!Cdr(e)) React(e, e, kQuiet);      // zero args not allowed
  if (Cdr(Cdr(e))) React(e, e, kQuiet);  // >1 args not allowed
  return DF(DispatchQuiet);
}

static dword PlanTrace(int e, int a, int s) {
  if (Cdr(e) > 0) React(e, e, kTrace);   // apply not allowed
  if (!Cdr(e)) React(e, e, kTrace);      // zero args not allowed
  if (Cdr(Cdr(e))) React(e, e, kTrace);  // >1 args not allowed
  return DF(DispatchTrace);
}

static dword PlanFtrace(int e, int a, int s) {
  if (Cdr(e) > 0) React(e, e, kFtrace);   // apply not allowed
  if (!Cdr(e)) React(e, e, kFtrace);      // zero args not allowed
  if (Cdr(Cdr(e))) React(e, e, kFtrace);  // >1 args not allowed
  return DF(DispatchFtrace);
}

static dword PlanFunction(int e, int a, int s) {
  if (CountSimpleArguments(Cdr(e)) != 1) Raise(kFunction);
  return MAKE(DF(DispatchFunction), Cadr(e));
}

static dword PlanBeta(int e, int a, int s) {
  if (CountSimpleArguments(Cdr(e)) != 1) Raise(kBeta);
  return MAKE(DF(DispatchBeta), Cadr(e));
}

static dword PlanIgnore(int e, int a, int s) {
  if (!Cdr(e)) return DF(DispatchIgnore0);
  if (Cdr(e) > 0) React(e, e, kIgnore);   // apply not allowed
  if (!Cdr(e)) React(e, e, kIgnore);      // zero args not allowed
  if (Cdr(Cdr(e))) React(e, e, kIgnore);  // >1 args not allowed
  return DF(DispatchIgnore1);
}

static dword PlanExpand(int e, int a, int s) {
  if (CountSimpleArguments(Cdr(e)) != 1) React(e, e, kExpand);
  return MAKE(DF(DispatchExpand), Cadr(e));
}

static dword PlanPrint(int e, int a, int s) {
  if (CountSimpleArguments(Cdr(e)) == -1) React(e, e, kPrint);
  return DF(DispatchPrint);
}

static dword PlanGensym(int e, int a, int s) {
  if (CountSimpleArguments(Cdr(e))) React(e, e, kGensym);
  return DF(DispatchGensym);
}

static dword PlanPprint(int e, int a, int s) {
  if (CountSimpleArguments(Cdr(e)) == -1) React(e, e, kPprint);
  return DF(DispatchPprint);
}

static dword PlanPrintheap(int e, int a, int s) {
  int p = CountSimpleArguments(Cdr(e));
  if (p != 0 && p != 1) React(e, e, kPrintheap);
  return DF(DispatchPrintheap);
}

static dword PlanGc(int e, int a, int s) {
  if (CountSimpleArguments(Cdr(e)) != 1) React(e, e, kGc);
  return MAKE(DF(DispatchGc), Cadr(e));
}

static dword PlanPrinc(int e, int a, int s) {
  if (CountSimpleArguments(Cdr(e)) == -1) React(e, e, kPrinc);
  return DF(DispatchPrinc);
}

static dword PlanFlush(int e, int a, int s) {
  if (CountSimpleArguments(Cdr(e)) == -1) React(e, e, kFlush);
  return DF(DispatchFlush);
}

static dword PlanError(int e, int a, int s) {
  return DF(DispatchError);
}

static dword PlanExit(int e, int a, int s) {
  if (Cdr(e)) React(e, e, kExit);
  return DF(DispatchExit);
}

static dword PlanRead(int e, int a, int s) {
  if (Cdr(e)) React(e, e, kRead);
  return DF(DispatchRead);
}

static dword PlanDefine(int e, int a, int s) {
  return DF(DispatchIdentity);
}

static dword PlanClosure(int e, int a, int s) {
  return DF(DispatchIdentity);
}

static dword PlanLet(int e, int a, int s) {
  int n;
  if ((n = CountSimpleArguments(Cdr(e))) == -1) return DF(DispatchFuncall);
  if (CountSimpleArguments(Car(e)) < 3) React(e, e, kLambda);  // need (λ 𝑥 𝑦)
  switch (CountSimpleParameters(Cadr(Car(e)))) {
    case -1:
      return DF(DispatchFuncall);
    case 0:
      if (n != 0) Error(""let argument count mismatch: %S"", e);
      return MAKE(DF(DispatchShortcut), Caddr(Car(e)));  // ((λ ⊥ 𝑦)) becomes 𝑦
    case 1:
      if (n != 1) Error(""let argument count mismatch: %S"", e);
      return MAKE(DF(DispatchLet1), Cdar(e));
    default:
      return MAKE(DF(DispatchFuncall), 0);
  }
}

static dontinline dword PlanPrecious(int e, int a, int s, int f) {
  DCHECK_GT(f, 0);
  if (f == kCar) return PlanCar(e, a, s);
  if (f == kCdr) return PlanCdr(e, a, s);
  if (f == kGc) return PlanGc(e, a, s);
  if (f == kEq) return PlanEq(e, a, s);
  if (f == kCmp) return PlanCmp(e, a, s);
  if (f == kBeta) return PlanBeta(e, a, s);
  if (f == kCond) return PlanCond(e, a, s);
  if (f == kAtom) return PlanAtom(e, a, s);
  if (f == kCons) return PlanCons(e, a, s);
  if (f == kExit) return PlanExit(e, a, s);
  if (f == kRead) return PlanRead(e, a, s);
  if (f == kOrder) return PlanOrder(e, a, s);
  if (f == kQuote) return PlanQuote(e, a, s);
  if (f == kProgn) return PlanProgn(e, a, s);
  if (f == kQuiet) return PlanQuiet(e, a, s);
  if (f == kTrace) return PlanTrace(e, a, s);
  if (f == kPrint) return PlanPrint(e, a, s);
  if (f == kPrinc) return PlanPrinc(e, a, s);
  if (f == kFlush) return PlanFlush(e, a, s);
  if (f == kError) return PlanError(e, a, s);
  if (f == kMacro) return PlanLambda(e, a, s);
  if (f == kFtrace) return PlanFtrace(e, a, s);
  if (f == kLambda) return PlanLambda(e, a, s);
  if (f == kGensym) return PlanGensym(e, a, s);
  if (f == kPprint) return PlanPprint(e, a, s);
  if (f == kIgnore) return PlanIgnore(e, a, s);
  if (f == kExpand) return PlanExpand(e, a, s);
  if (f == kDefine) return PlanDefine(e, a, s);
  if (f == kClosure) return PlanClosure(e, a, s);
  if (f == kFunction) return PlanFunction(e, a, s);
  if (f == kPrintheap) return PlanPrintheap(e, a, s);
  if (!a) {
    Push(e);
    Push(f);
    Raise(kFunction);
  }
  return DF(DispatchFuncall);
}

dontinline dword Plan(int e, int a, int s) {
  int c, f, p, x1, x2, x3, x4;
  DCHECK_LT(e, 0);

  if ((x1 = IsCar(e))) {
    if ((x2 = IsCar(x1))) {
      if ((x3 = IsCar(x2))) {
        if ((x4 = IsCar(x3))) return MAKE(DF(DispatchCaaaar), x4);
        if ((x4 = IsCdr(x3))) return MAKE(DF(DispatchCaaadr), x4);
        return MAKE(DF(DispatchCaaar), x3);
      }
      if ((x3 = IsCdr(x2))) {
        if ((x4 = IsCar(x3))) return MAKE(DF(DispatchCaadar), x4);
        if ((x4 = IsCdr(x3))) return MAKE(DF(DispatchCaaddr), x4);
        return MAKE(DF(DispatchCaaar), x3);
      }
      return MAKE(DF(DispatchCaar), x2);
    }
    if ((x2 = IsCdr(x1))) {
      if ((x3 = IsCar(x2))) {
        if ((x4 = IsCar(x3))) return MAKE(DF(DispatchCadaar), x4);
        if ((x4 = IsCdr(x3))) return MAKE(DF(DispatchCadadr), x4);
        return MAKE(DF(DispatchCadar), x3);
      }
      if ((x3 = IsCdr(x2))) {
        if ((x4 = IsCar(x3))) return MAKE(DF(DispatchCaddar), x4);
        if ((x4 = IsCdr(x3))) return MAKE(DF(DispatchCadddr), x4);
        return MAKE(DF(DispatchCaddr), x3);
      }
      return MAKE(DF(DispatchCadr), x2);
    }
    return MAKE(DF(DispatchCar), x1);
  }

  if ((x1 = IsCdr(e))) {
    if ((x2 = IsCar(x1))) {
      if ((x3 = IsCar(x2))) {
        if ((x4 = IsCar(x3))) return MAKE(DF(DispatchCdaaar), x4);
        if ((x4 = IsCdr(x3))) return MAKE(DF(DispatchCdaadr), x4);
        return MAKE(DF(DispatchCdaar), x3);
      }
      if ((x3 = IsCdr(x2))) {
        if ((x4 = IsCar(x3))) return MAKE(DF(DispatchCdadar), x4);
        if ((x4 = IsCdr(x3))) return MAKE(DF(DispatchCdaddr), x4);
        return MAKE(DF(DispatchCdadr), x3);
      }
      return MAKE(DF(DispatchCdar), x2);
    }
    if ((x2 = IsCdr(x1))) {
      if ((x3 = IsCar(x2))) {
        if ((x4 = IsCar(x3))) return MAKE(DF(DispatchCddaar), x4);
        if ((x4 = IsCdr(x3))) return MAKE(DF(DispatchCddadr), x4);
        return MAKE(DF(DispatchCddar), x3);
      }
      if ((x3 = IsCdr(x2))) {
        if ((x4 = IsCar(x3))) return MAKE(DF(DispatchCdddar), x4);
        if ((x4 = IsCdr(x3))) return MAKE(DF(DispatchCddddr), x4);
        return MAKE(DF(DispatchCdddr), x3);
      }
      return MAKE(DF(DispatchCddr), x2);
    }
    return MAKE(DF(DispatchCdr), x1);
  }

  if ((f = Car(e)) > 0) {
    if (LO(GetShadow(f)) == EncodeDispatchFn(DispatchPrecious)) {
      return PlanPrecious(e, a, s, f);
    }
    if (!HasAtom(f, s) && (f = Assoc(f, a))) {
      f = Cdr(f);
      if (IsYcombinator(f)) {
        return DF(DispatchYcombine);
      } else if (f < 0 && Car(f) == kClosure && f > e) {
        if (Car(Cadr(f)) == kLambda) {
          c = CountSimpleArguments(Cdr(e));
          p = CountSimpleParameters(Cadr(Cadr(f)));
          if (c == 1 && p == 1) {
            return MAKE(DF(DispatchCall1), f);
          } else if (c == 2 && p == 2) {
            return MAKE(DF(DispatchCall2), f);
          }
        }
        return MAKE(DF(DispatchFuncall), f);
      }
    }
  } else if (Car(f) == kLambda) {
    return PlanLet(e, a, s);
  }

  return DF(DispatchFuncall);
}

struct T DispatchPlan(dword ea, dword tm, dword r, dword p1, dword p2,
                      dword d) {
  SetShadow(LO(ea), (d = Plan(LO(ea), HI(ea), 0)));
  return DecodeDispatchFn(d)(ea, tm, r, p1, p2, d);
}
"
./repos/cosmopolitan/tool/plinko/lib/setup.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/str/str.h""
#include ""tool/plinko/lib/cons.h""
#include ""tool/plinko/lib/plinko.h""

static void SetInput(const char *s) {
  bp[0] = 0;
  dx = L' ';
  strcpy(stpcpy(g_buffer[0], s), "" "");
}

static void Programme(int i, DispatchFn *f, int x) {
  SetShadow(i, MAKE(EncodeDispatchFn(f), x));
}

static void Program(int i, DispatchFn *f) {
  Programme(i, f, 0);
}

static void ProgramPrecious(int i) {
  Program(i, DispatchPrecious);
}

static void ProgramLookup(int i) {
  Program(i, DispatchLookup);
}

static void ProgramIgnore0(int i) {
  Program(i, DispatchIgnore0);
}

static void ProgramPlan(int i) {
  Program(i, DispatchPlan);
}

void Setup(void) {
  int i;
  char buf[4] = ""(A)"";
  SetShadow(-1, DF(DispatchPlan));
  SetShadow(0, DF(DispatchPrecious));
  SetShadow(+1, DF(DispatchPrecious));
  PROG(ProgramPrecious, kEq, ""EQ"");
  PROG(ProgramPrecious, kGc, ""GC"");
  PROG(ProgramPrecious, kCmp, ""CMP"");
  PROG(ProgramPrecious, kCar, ""CAR"");
  PROG(ProgramPrecious, kCdr, ""CDR"");
  PROG(ProgramPrecious, kBeta, ""BETA"");
  PROG(ProgramPrecious, kAtom, ""ATOM"");
  PROG(ProgramPrecious, kCond, ""COND"");
  PROG(ProgramPrecious, kCons, ""CONS"");
  PROG(ProgramPrecious, kRead, ""READ"");
  PROG(ProgramPrecious, kDump, ""DUMP"");
  PROG(ProgramPrecious, kExit, ""EXIT"");
  PROG(ProgramPrecious, kFork, ""FORK"");
  PROG(ProgramPrecious, kQuote, ""QUOTE"");
  PROG(ProgramPrecious, kProgn, ""PROGN"");
  PROG(ProgramPrecious, kMacro, ""MACRO"");
  PROG(ProgramPrecious, kQuiet, ""QUIET"");
  PROG(ProgramPrecious, kError, ""ERROR"");
  PROG(ProgramPrecious, kTrace, ""TRACE"");
  PROG(ProgramPrecious, kPrint, ""PRINT"");
  PROG(ProgramPrecious, kPrinc, ""PRINC"");
  PROG(ProgramPrecious, kFlush, ""FLUSH"");
  PROG(ProgramPrecious, kOrder, ""ORDER"");
  PROG(ProgramPrecious, kGensym, ""GENSYM"");
  PROG(ProgramPrecious, kPprint, ""PPRINT"");
  PROG(ProgramPrecious, kIgnore, ""IGNORE"");
  PROG(ProgramPrecious, kMtrace, ""MTRACE"");
  PROG(ProgramPrecious, kFtrace, ""FTRACE"");
  PROG(ProgramPrecious, kGtrace, ""GTRACE"");
  PROG(ProgramPrecious, kLambda, ""LAMBDA"");
  PROG(ProgramPrecious, kDefine, ""DEFINE"");
  PROG(ProgramPrecious, kExpand, ""EXPAND"");
  PROG(ProgramPrecious, kClosure, ""CLOSURE"");
  PROG(ProgramPrecious, kPartial, ""PARTIAL"");
  PROG(ProgramPrecious, kFunction, ""FUNCTION"");
  PROG(ProgramPrecious, kIntegrate, ""INTEGRATE"");
  PROG(ProgramPrecious, kPrintheap, ""PRINTHEAP"");
  PROG(ProgramPrecious, kImpossible, ""IMPOSSIBLE"");
  PROG(ProgramLookup, kComma, ""COMMA_"");
  PROG(ProgramLookup, kSplice, ""SPLICE_"");
  PROG(ProgramLookup, kBackquote, ""BACKQUOTE_"");
  PROG(ProgramLookup, kString, ""STRING_"");
  PROG(ProgramLookup, kSquare, ""SQUARE_"");
  PROG(ProgramLookup, kCurly, ""CURLY_"");
  PROG(ProgramLookup, kDefun, ""DEFUN"");
  PROG(ProgramLookup, kDefmacro, ""DEFMACRO"");
  PROG(ProgramLookup, kAppend, ""APPEND"");
  PROG(ProgramLookup, kOr, ""OR"");
  PROG(ProgramLookup, kAnd, ""AND"");
  PROG(ProgramLookup, kIntersection, ""INTERSECTION"");
  PROG(ProgramLookup, kList, ""LIST"");
  PROG(ProgramLookup, kMember, ""MEMBER"");
  PROG(ProgramLookup, kNot, ""NOT"");
  PROG(ProgramLookup, kReverse, ""REVERSE"");
  PROG(ProgramLookup, kSqrt, ""SQRT"");
  PROG(ProgramLookup, kSubset, ""SUBSET"");
  PROG(ProgramLookup, kSuperset, ""SUPERSET"");
  PROG(ProgramLookup, kBecause, ""BECAUSE"");
  PROG(ProgramLookup, kTherefore, ""THEREFORE"");
  PROG(ProgramLookup, kUnion, ""UNION"");
  PROG(ProgramLookup, kImplies, ""IMPLIES"");
  PROG(ProgramLookup, kYcombinator, ""YCOMBINATOR"");
  PROG(ProgramLookup, kNand, ""NAND"");
  PROG(ProgramLookup, kNor, ""NOR"");
  PROG(ProgramLookup, kXor, ""XOR"");
  PROG(ProgramLookup, kIff, ""IFF"");
  PROG(ProgramLookup, kCycle, ""CYCLE"");
  PROG(ProgramLookup, kTrench, ""𝕋ℝ𝔼ℕℂℍ"");
  PROG(ProgramLookup, kUnchanged, ""ⁿ/ₐ"");
  PROG(ProgramIgnore0, kIgnore0, ""(IGNORE)"");
  for (i = 0; i < 26; ++i, ++buf[1]) {
    PROG(ProgramPlan, kConsAlphabet[i], buf);
  }
  for (buf[0] = L'A', buf[1] = 0, i = 0; i < 26; ++i, ++buf[0]) {
    if (buf[0] != 'T') {
      PROG(ProgramLookup, kAlphabet[i], buf);
    } else {
      kAlphabet[i] = 1;
    }
  }
}
"
./repos/cosmopolitan/tool/plinko/lib/prettyprint.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/log/check.h""
#include ""libc/nt/struct/size.h""
#include ""tool/plinko/lib/plinko.h""
#include ""tool/plinko/lib/print.h""
#include ""tool/plinko/lib/tree.h""

static void PrettyPrintList(int fd, int x, int n) {
  int y, once, func, mode, argwidth, funcwidth, forcedot;
  DCHECK_GE(n, 0);
  DCHECK_LE(x, 0);
  if (x < cx) {
    n += PrintChar(fd, L'!');
    n += PrintInt(fd, x, 0, 0, 0, 10, true);
  } else {
    if (ShouldConcealClosure(x)) {
      x = Car(Cdr(x));
    }
    PrintChar(fd, L'(');
    if (x < 0) {
      func = Car(x);
      funcwidth = PrettyPrint(fd, func, ++n);
      if (func == kDefine) {
        PrintSpace(fd);
        PrettyPrint(fd, Car(Cdr(x)), n);
        forcedot = 0;
        x = Cdr(x);
        mode = Cdr(x) < 0;
        once = 1;
        n += 1;
      } else if ((func == kLambda || func == kMacro) &&
                 (Cdr(x) < 0 && Cdr(Cdr(x)) < 0)) {
        PrintSpace(fd);
        if (!Car(Cdr(x))) {
          PrintChar(fd, L'(');
          PrintChar(fd, L')');
        } else {
          PrettyPrint(fd, Car(Cdr(x)), n);
        }
        x = Cdr(x);
        mode = 1;
        forcedot = 0;
        once = 1;
        n += 1;
      } else {
        if (func >= 0) {
          n += funcwidth + 1;
        }
        mode = func < 0 && Car(func) != kQuote;
        once = mode;
        forcedot = 0;
      }
      if (!forcedot && ShouldForceDot(x)) {
        forcedot = true;
        n += 2;
      }
      while ((x = Cdr(x))) {
        y = x;
        argwidth = 0;
        if (y < 0 && !forcedot) {
          y = Car(y);
        } else {
          argwidth += PrintSpace(fd);
          argwidth += PrintDot(fd);
          mode = y < 0;
          x = 0;
        }
        if (y >= 0) {
          argwidth += PrintSpace(fd);
          argwidth += PrintAtom(fd, y);
          if (!once) n += argwidth;
        } else {
          if (once && (y < 0 || mode)) {
            mode = 1;
            PrintNewline(fd);
            if (depth >= 0) PrintDepth(fd, depth);
            PrintIndent(fd, n);
          } else {
            if (y < 0) mode = 1;
            PrintSpace(fd);
          }
          once = 1;
          PrettyPrint(fd, y, n);
        }
        forcedot = 0;
      }
    }
    PrintChar(fd, L')');
  }
}

/**
 * Prints LISP data structure with style.
 *
 * @param fd is where i/o goes
 * @param x is thing to print
 * @param n is indent level
 */
int PrettyPrint(int fd, int x, int n) {
  DCHECK_GE(n, 0);
  if (!noname) {
    GetName(&x);
  }
  x = EnterPrint(x);
  if (1. / x < 0) {
    PrettyPrintList(fd, x, n);
    n = 0;
  } else {
    n = PrintAtom(fd, x);
  }
  LeavePrint(x);
  return n;
}
"
./repos/cosmopolitan/tool/plinko/lib/index.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/index.h""

#define INDEXER(NAME, EVAL)                                                 \
  struct T NAME(dword ea, dword tm, dword r, dword p1, dword p2, dword d) { \
    return Ret(MAKE(EVAL(FasterRecurse(HI(d), HI(ea), p1, p2)), 0), tm, r); \
  }

INDEXER(DispatchCaar, Caar);
INDEXER(DispatchCadr, Cadr);
INDEXER(DispatchCdar, Cdar);
INDEXER(DispatchCddr, Cddr);
INDEXER(DispatchCaaar, Caaar);
INDEXER(DispatchCaadr, Caadr);
INDEXER(DispatchCadar, Cadar);
INDEXER(DispatchCaddr, Caddr);
INDEXER(DispatchCdaar, Cdaar);
INDEXER(DispatchCdadr, Cdadr);
INDEXER(DispatchCddar, Cddar);
INDEXER(DispatchCdddr, Cdddr);
INDEXER(DispatchCaaaar, Caaaar);
INDEXER(DispatchCaaadr, Caaadr);
INDEXER(DispatchCaadar, Caadar);
INDEXER(DispatchCaaddr, Caaddr);
INDEXER(DispatchCadaar, Cadaar);
INDEXER(DispatchCadadr, Cadadr);
INDEXER(DispatchCaddar, Caddar);
INDEXER(DispatchCadddr, Cadddr);
INDEXER(DispatchCdaaar, Cdaaar);
INDEXER(DispatchCdaadr, Cdaadr);
INDEXER(DispatchCdadar, Cdadar);
INDEXER(DispatchCdaddr, Cdaddr);
INDEXER(DispatchCddaar, Cddaar);
INDEXER(DispatchCddadr, Cddadr);
INDEXER(DispatchCdddar, Cdddar);
INDEXER(DispatchCddddr, Cddddr);
"
./repos/cosmopolitan/tool/plinko/lib/enclose.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/config.h""
#include ""tool/plinko/lib/cons.h""
#include ""tool/plinko/lib/error.h""
#include ""tool/plinko/lib/gc.h""
#include ""tool/plinko/lib/index.h""
#include ""tool/plinko/lib/plinko.h""
#include ""tool/plinko/lib/printf.h""
#include ""tool/plinko/lib/stack.h""

static void CheckClosureFullyDefined(int e, int a, int s) {
  int f;
  Push(e);
  if (e >= 0) {
    if (!IsPrecious(e) && !HasAtom(e, s) && !Assoc(e, a)) {
      Error(""crash binding in closure"");
    }
  } else if ((f = Car(e)) != kQuote && f != kClosure) {
    if (f == kLambda || f == kMacro) {
      CheckClosureFullyDefined(Caddr(e), a, Cons(Cadr(e), s));
    } else if (f == kCond) {
      while ((e = Cdr(e)) < 0) {
        if ((f = Car(e)) < 0) {
          CheckClosureFullyDefined(Car(f), a, s);
          if ((f = Cdr(f)) < 0) {
            CheckClosureFullyDefined(Car(f), a, s);
          }
        }
      }
    } else {
      do {
        if (e < 0) {
          CheckClosureFullyDefined(Car(e), a, s);
          e = Cdr(e);
        } else {
          CheckClosureFullyDefined(e, a, s);
          e = 0;
        }
      } while (e);
    }
  }
  Pop();
}

static void CheckClosure(int e, int a) {
  int A;
  if (DEBUG_CLOSURE && logc) {
    A = cx;
    CheckClosureFullyDefined(e, a, 0);
    MarkSweep(A, 0);
  }
}

int Enclose(int e, int a) {
  CheckClosure(e, a);
  return Cons(kClosure, Cons(e, a));
}
"
./repos/cosmopolitan/tool/plinko/lib/countatoms.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/plinko.h""

nosideeffect int CountAtoms(int x, int max, int res) {
  if (!x || res >= max) return res;
  if (x > 0) return res + 1;
  return CountAtoms(Cdr(x), max, CountAtoms(Car(x), max, res));
}
"
./repos/cosmopolitan/tool/plinko/lib/histo.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/assert.h""
#include ""tool/plinko/lib/histo.h""
#include ""tool/plinko/lib/plinko.h""
#include ""tool/plinko/lib/printf.h""

void PrintHistogram(int fd, const char *s, const long *h, size_t n) {
  long t;
  bool islast;
  int j, p, m;
  char buf[101];
  size_t i, logos;
  if (!(t = GetLongSum(h, n))) return;
  Fprintf(fd, ""%s%n"", s);
  for (i = 0; i < n; ++i) {
    if (!h[i]) continue;
    p = h[i] * 1000000 / t;
    assert(0 <= p && p <= 1000000);
    for (j = 0, m = p / 10000; j < m; ++j) {
      buf[j] = '#';
    }
    buf[j] = 0;
    if (i) {
      logos = 1;
      logos <<= i - 1;
    } else {
      logos = 0;
    }
    islast = i == n - 1;
    Fprintf(fd, ""%'16lu%s %'*ld %3d.%04d%% %s%n"", logos, islast ? ""+"" : """",
            16 - islast, h[i], p / 10000, p % 10000, buf);
  }
}
"
./repos/cosmopolitan/tool/plinko/lib/printchar.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/intrin/bsr.h""
#include ""tool/plinko/lib/char.h""
#include ""tool/plinko/lib/ktpenc.h""
#include ""tool/plinko/lib/plinko.h""

int PrintChar(int fd, int s) {
  unsigned c;
  int d, e, i, n;
  c = s & 0xffffffff;
  if (bp[fd] + 6 > sizeof(g_buffer[fd])) Flush(fd);
  if (c < 0200) {
    g_buffer[fd][bp[fd]++] = c;
    if (c == L'\n') Flush(fd);
  } else {
    d = c;
    e = kTpEnc[bsrl(d) - 7];
    i = n = e & 255;
    do g_buffer[fd][bp[fd] + i--] = 0200 | (d & 077);
    while (d >>= 6, i);
    g_buffer[fd][bp[fd]] = d | e >> 8;
    bp[fd] += n + 1;
  }
  return GetMonospaceCharacterWidth(c);
}
"
./repos/cosmopolitan/tool/plinko/lib/reverse.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/cons.h""
#include ""tool/plinko/lib/plinko.h""

int Reverse(int x, int y) {
  dword t;
  while (x < 0) {
    t = Get(x);
    x = HI(t);
    y = Cons(LO(t), y);
  }
  return y;
}
"
./repos/cosmopolitan/tool/plinko/lib/dispatchycombine.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/cons.h""
#include ""tool/plinko/lib/index.h""
#include ""tool/plinko/lib/plinko.h""
#include ""tool/plinko/lib/stack.h""

struct T DispatchRecur(dword ea, dword tm, dword r, dword p1, dword p2,
                       dword d) {
  struct Binding bz;
  bz = bind_(Car(Car(HI(d))), Cdr(LO(ea)), HI(ea), Cdr(HI(d)), p1, p2);
  return TailCall(MAKE(Cdr(Car(HI(d))), bz.u), tm, r, bz.p1, 0);
}

struct T DispatchRecur1(dword ea, dword tm, dword r, dword p1, dword p2,
                        dword d) {
  return TailCall(
      MAKE(Car(HI(d) + 5), Cdr(HI(d) + 1)), tm, r,
      MAKE(Car(HI(d) + 4), FasterRecurse(Car(Cdr(LO(ea))), HI(ea), p1, p2)), 0);
}

struct T DispatchRecur2(dword ea, dword tm, dword r, dword p1, dword p2,
                        dword d) {
  return TailCall(
      MAKE(Car(HI(d) + 6), Cdr(HI(d))), tm, r,
      MAKE(Car(HI(d) + 4), FasterRecurse(Car(Cdr(LO(ea))), HI(ea), p1, p2)),
      MAKE(Car(HI(d) + 5),
           FasterRecurse(Car(Cdr(Cdr(LO(ea)))), HI(ea), p1, p2)));
}

struct T DispatchYcombine(dword ea, dword tm, dword r, dword p1, dword p2,
                          dword d) {
  int ycomb, p, name, lambda, closure;
  SetFrame(r, LO(ea));
  r |= NEED_GC;
  ycomb = recurse(MAKE(Car(LO(ea)), HI(ea)), p1, p2);
  DCHECK(IsYcombinator(ycomb));
  ycomb = Cadr(ycomb);
  lambda = recurse(MAKE(Cadr(ea), HI(ea)), p1, p2);
  closure =
      recurse(MAKE(Caddr(ycomb), Alist(Car(Cadr(ycomb)), lambda, 0)), 0, 0);
  if (Car(lambda) == kClosure) lambda = Car(Cdr(lambda));
  DCHECK_EQ(kClosure, Car(closure));
  DCHECK_EQ(kLambda, Car(lambda));
  DCHECK_EQ(kLambda, Car(Car(Cdr(closure))));
  name = Car(Cadr(lambda));
  lambda = Cadr(closure);
  closure = Enclose(lambda, Cddr(closure));
  closure = Preplan(closure, Cddr(closure), 0);
  lambda = Cadr(closure);
  if ((p = CountSimpleParameters(Cadr(lambda))) == 1 || p == 2) {
    if (p == 1) {
      PlanFuncalls(name, MAKE(DF(DispatchRecur1), closure), Caddr(lambda));
    } else {
      PlanFuncalls(name, MAKE(DF(DispatchRecur2), closure), Caddr(lambda));
    }
  } else {
    PlanFuncalls(name,
                 MAKE(DF(DispatchRecur),
                      Cons(Cons(Cadr(Cadr(closure)), Caddr(Cadr(closure))),
                           Cddr(closure))),
                 Caddr(lambda));
  }
  return Ret(MAKE(closure, 0), tm, r);
}
"
./repos/cosmopolitan/tool/plinko/lib/define.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Copying of this file is authorized only if (1) you are Justine Tunney, or    │
│ (2) you make absolutely no changes to your copy.                             │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL WARRANTIES     │
│ WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF             │
│ MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR      │
│ ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES       │
│ WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN        │
│ ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF      │
│ OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.               │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/log/check.h""
#include ""tool/plinko/lib/cons.h""
#include ""tool/plinko/lib/gc.h""
#include ""tool/plinko/lib/index.h""
#include ""tool/plinko/lib/plinko.h""
#include ""tool/plinko/lib/print.h""
#include ""tool/plinko/lib/printf.h""
#include ""tool/plinko/lib/tree.h""

void GetName(int *x) {
  int t;
  if (*x < 0) {
    if ((t = GetTree(*x, revglob))) {
      *x = Val(Ent(t));
    }
  }
}

int Define(int e, int a) {
  struct Gc *G;
  int k, v, x, r, o;
  DCHECK_EQ(kDefine, Car(e));
  if (Cdr(e) >= 0) Error(""bad define: %S"", e);
  if (Cadr(e) <= 0) Error(""scheme define: %S"", e);
  if (Cddr(e) >= 0 || Caddr(e) == kLambda) {
    /*
     * compatibility with sectorlisp friendly branch, e.g.
     *
     *   (DEFINE 𝑘 . 𝑣)
     *   (DEFINE 𝑘 . (LAMBDA ⋯))
     *
     * are equivalent to the following
     *
     *   (DEFINE 𝑘 (QUOTE 𝑣))
     *   (DEFINE 𝑘 (QUOTE (LAMBDA ⋯)))
     */
    e = Cdr(e);
    k = Car(e);
  } else if (!Cdddr(e)) {
    k = Cadr(e);
    v = Caddr(e);
    x = eval(v, a);
    e = Cons(k, x);
  } else {
    Error(""too many args: %S"", e);
  }
  a = Cons(PutTree(e, Car(a), 0), 0);
  r = PutTree(Cons(Cdr(e), Car(e)), revglob, 0);
  o = Cons(k, ordglob);
  G = NewGc(cFrost);
  Mark(G, a);
  Mark(G, r);
  Mark(G, o);
  Census(G);
  a = Relocate(G, a);
  r = Relocate(G, r);
  o = Relocate(G, o);
  Sweep(G);
  revglob = r;
  ordglob = o;
  return a;
}

/**
 * Prints stuff declared by Define().
 *
 * The output is primarily intended for describing the internal machine
 * state, with a focus on readability. If closures are printed, with -c
 * then each nugget can be copied back into the machine on its own, b/c
 * each definition is a transitive closure that totally defines all its
 * dependencies. However it's quite verbose, so the normal mode is just
 * readable and can be finessed back into a good program with some work
 * although one thing that's really cool is it peels away macros in the
 * hope it can help demystify amazingly dense recreational abstractions
 *
 * @param t is symbol to use for DEFINE
 * @param a is an association list and/or red-black tree
 * @param o is ordering of names
 * @see Assoc() for documentation on structure of 𝑎
 */
int DumpDefines(int t, int a, int o) {
  int e;
  bool nn;
  nn = noname;
  noname = true;
  for (; o; o = Cdr(o)) {
    e = Assoc(Car(o), a);
    Printf(""%n%p%n"", Cons(t, Cons(Car(e), Cons(Cdr(e), -0))));
  }
  noname = nn;
  return 0;
}
"
./repos/cosmopolitan/tool/plinko/lib/ktpenc.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/

const short kTpEnc[25] = {0140001, 0140001, 0140001, 0140001, 0160002,
                          0160002, 0160002, 0160002, 0160002, 0170003,
                          0170003, 0170003, 0170003, 0170003, 0174004,
                          0174004, 0174004, 0174004, 0174004, 0176005,
                          0176005, 0176005, 0176005, 0176005, 0176005};
"
./repos/cosmopolitan/tool/plinko/lib/desymbolize.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/build/lib/case.h""
#include ""tool/plinko/lib/plinko.h""

pureconst int Desymbolize(int c) {
  return -1;
  switch (c) {
    CASE(L'⊥', return 0);
    CASE(L'⊤', return 1);
    CASE(L'≡', return kEq);
    CASE(L'⍅', return kCar);
    CASE(L'⊷', return kCar);
    CASE(L'⍆', return kCdr);
    CASE(L'⊶', return kCdr);
    CASE(L'α', return kAtom);
    CASE(L'ζ', return kCond);
    CASE(L'ℶ', return kCons);
    CASE(L'β', return kBeta);
    CASE(L'ψ', return kMacro);
    CASE(L'λ', return kLambda);
    CASE(L'⅄', return kClosure);
    CASE(L'∂', return kPartial);
    CASE(L'║', return kAppend);
    CASE(L'≷', return kCmp);
    CASE(L'∧', return kAnd);
    CASE(L'∨', return kOr);
    CASE(L'⋔', return kFork);
    CASE(L'Λ', return kDefun);
    CASE(L'≝', return kDefine);
    CASE(L'ə', return kExpand);
    CASE(L'Ψ', return kDefmacro);
    CASE(L'𝑓', return kFunction);
    CASE(L'∫', return kIntegrate);
    CASE(L'∅', return kImpossible);
    CASE(L'𝕐', return kYcombinator);
    CASE(L'∩', return kIntersection);
    CASE(L'ℒ', return kList);
    CASE(L'∊', return kMember);
    CASE(L'¬', return kNot);
    CASE(L'Ω', return kQuote);
    CASE(L'Я', return kReverse);
    CASE(L'√', return kSqrt);
    CASE(L'⊂', return kSubset);
    CASE(L'⊃', return kSuperset);
    CASE(L'∵', return kBecause);
    CASE(L'∴', return kTherefore);
    CASE(L'∪', return kUnion);
    CASE(L'⟶', return kImplies);
    CASE(L'⊼', return kNand);
    CASE(L'⊽', return kNor);
    CASE(L'⊻', return kXor);
    CASE(L'⟺', return kIff);
    CASE(L'⟳', return kCycle);
    CASE(L'⊙', return kOrder);
    default:
      return -1;
  }
}
"
./repos/cosmopolitan/tool/plinko/lib/cons.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/cons.h""
#include ""tool/plinko/lib/char.h""

int List(int x, int y) {
  return Cons(x, Cons(y, -0));
}

int List3(int x, int y, int z) {
  return Cons(x, List(y, z));
}

int List4(int a, int b, int c, int d) {
  return Cons(a, List3(b, c, d));
}

int Shadow(int p, int s) {
  int t = GetCommonCons(p, s);
  return t ? t : Cons(p, s);
}

int GetCommonCons(int x, int y) {
  if (!y) {
    if (!x) return -1;
    if (x > 0 && cFrost < -1 && IsUpper(LO(Get(x))) && HI(Get(x)) == TERM) {
      return kConsAlphabet[LO(Get(x)) - L'A'];
    }
  }
  return 0;
}

int ShareCons(int x, int y) {
  int i;
  if ((i = GetCommonCons(x, y))) return i;
#if 0
  t = MAKE(x, y);
  for (i = cx, n = MIN(0, i + 64); i < n; ++i) {
    if (t == Get(i)) {
      return i;
    }
  }
#endif
  return Cons(x, y);
}

int ShareList(int x, int y) {
  return ShareCons(x, ShareCons(y, -0));
}
"
./repos/cosmopolitan/tool/plinko/lib/printtree.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/print.h""
#include ""tool/plinko/lib/printf.h""
#include ""tool/plinko/lib/tree.h""

void PrintTree(int fd, int N, int n) {
  if (N >= 0) {
    Print(fd, N);
  } else {
    Fnprintf(fd, n, ""%s %S%n%I"", Red(N) ? ""RED"" : ""BLK"", Key(Ent(N)));
    PrintIndent(fd, n);
    Fnprintf(fd, n + 2, ""%I- %T%n%I"", Lit(N));
    PrintIndent(fd, n);
    Fnprintf(fd, n + 2, ""%I- %T"", Rit(N));
  }
}
"
./repos/cosmopolitan/tool/plinko/lib/flush.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/calls/calls.h""
#include ""libc/errno.h""
#include ""libc/runtime/runtime.h""
#include ""libc/str/str.h""
#include ""tool/plinko/lib/plinko.h""
#include ""tool/plinko/lib/printf.h""

void Flush(int fd) {
  int n, i = 0;
  while (i < bp[fd]) {
    if ((n = write(fd, g_buffer[fd] + i, bp[fd] - i)) > 0) {
      i += n;
    } else if (errno != EINTR) {
      ++fails;
      Fprintf(2, ""error: write() %s%n"", strerror(errno));
      longjmp(exiter, 1);
    }
  }
  bp[fd] = 0;
}
"
./repos/cosmopolitan/tool/plinko/lib/getlongsum.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""libc/limits.h""
#include ""libc/stdckdint.h""
#include ""tool/plinko/lib/histo.h""

long GetLongSum(const long *h, size_t n) {
  long t;
  size_t i;
  for (t = i = 0; i < n; ++i) {
    if (ckd_add(&t, t, h[i])) {
      t = LONG_MAX;
      break;
    }
  }
  return t;
}
"
./repos/cosmopolitan/tool/plinko/lib/isycombinator.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/plinko.h""

/**
 * Matches
 *
 *     (⅄ (λ (N) ((λ (W) (W W)) (λ (V) (N (λ M ((V V) . M)))))) . Q)
 *
 * @return true if matches, otherwise false
 * @note M must be a non-nil atom
 * @note N must be a non-nil atom
 * @note Q is ignored
 * @note V must be a non-nil atom
 * @note W must be a non-nil atom
 * @note λ means LAMBDA
 * @note ⅄ means CLOSURE
 */
bool IsYcombinator(int x_) {
  dword w_;
  if (x_ >= 0) return false;
  w_ = Get(x_);
  int ax_ = LO(w_);
  int dx_ = HI(w_);
  if (ax_ != kClosure) return false;
  if (dx_ >= 0) return false;
  w_ = Get(dx_);  // ((λ (N) ((λ (W) (W W)) (λ (V) (N (λ M ((V V) . M)))))) . Q)
  int adx_ = LO(w_);
  if (adx_ >= 0) return false;
  w_ = Get(adx_);  // (λ (N) ((λ (W) (W W)) (λ (V) (N (λ M ((V V) . M))))))
  int aadx_ = LO(w_);
  int dadx_ = HI(w_);
  if (aadx_ != kLambda) return false;
  if (dadx_ >= 0) return false;
  w_ = Get(dadx_);  // ((N) ((λ (W) (W W)) (λ (V) (N (λ M ((V V) . M))))))
  int adadx_ = LO(w_);
  int ddadx_ = HI(w_);
  if (adadx_ >= 0) return false;
  w_ = Get(adadx_);  // (N)
  int aadadx_ = LO(w_);
  int dadadx_ = HI(w_);
  if (ddadx_ >= 0) return false;
  w_ = Get(ddadx_);  // (((λ (W) (W W)) (λ (V) (N (λ M ((V V) . M))))))
  int addadx_ = LO(w_);
  int dddadx_ = HI(w_);
  int N = aadadx_;
  if (N <= 0) return false;
  if (addadx_ >= 0) return false;
  w_ = Get(addadx_);  // ((λ (W) (W W)) (λ (V) (N (λ M ((V V) . M)))))
  int aaddadx_ = LO(w_);
  int daddadx_ = HI(w_);
  if (dadadx_) return false;
  if (dddadx_) return false;
  if (aaddadx_ >= 0) return false;
  w_ = Get(aaddadx_);  // (λ (W) (W W))
  int aaaddadx_ = LO(w_);
  int daaddadx_ = HI(w_);
  if (daddadx_ >= 0) return false;
  w_ = Get(daddadx_);  // ((λ (V) (N (λ M ((V V) . M)))))
  int adaddadx_ = LO(w_);
  int ddaddadx_ = HI(w_);
  if (aaaddadx_ != kLambda) return false;
  if (adaddadx_ >= 0) return false;
  w_ = Get(adaddadx_);  // (λ (V) (N (λ M ((V V) . M))))
  int aadaddadx_ = LO(w_);
  int dadaddadx_ = HI(w_);
  if (daaddadx_ >= 0) return false;
  w_ = Get(daaddadx_);  // ((W) (W W))
  int adaaddadx_ = LO(w_);
  int ddaaddadx_ = HI(w_);
  if (ddaddadx_) return false;
  if (adaaddadx_ >= 0) return false;
  w_ = Get(adaaddadx_);  // (W)
  int aadaaddadx_ = LO(w_);
  int dadaaddadx_ = HI(w_);
  if (aadaddadx_ != kLambda) return false;
  if (ddaaddadx_ >= 0) return false;
  w_ = Get(ddaaddadx_);  // ((W W))
  int addaaddadx_ = LO(w_);
  int dddaaddadx_ = HI(w_);
  if (dadaddadx_ >= 0) return false;
  w_ = Get(dadaddadx_);  // ((V) (N (λ M ((V V) . M))))
  int adadaddadx_ = LO(w_);
  int ddadaddadx_ = HI(w_);
  int W = aadaaddadx_;
  if (W <= 0) return false;
  if (adadaddadx_ >= 0) return false;
  w_ = Get(adadaddadx_);  // (V)
  int aadadaddadx_ = LO(w_);
  int dadadaddadx_ = HI(w_);
  if (addaaddadx_ >= 0) return false;
  w_ = Get(addaaddadx_);  // (W W)
  int aaddaaddadx_ = LO(w_);
  int daddaaddadx_ = HI(w_);
  if (ddadaddadx_ >= 0) return false;
  w_ = Get(ddadaddadx_);  // ((N (λ M ((V V) . M))))
  int addadaddadx_ = LO(w_);
  int dddadaddadx_ = HI(w_);
  if (dadaaddadx_) return false;
  int V = aadadaddadx_;
  if (V <= 0) return false;
  if (dddaaddadx_) return false;
  if (addadaddadx_ >= 0) return false;
  w_ = Get(addadaddadx_);  // (N (λ M ((V V) . M)))
  int aaddadaddadx_ = LO(w_);
  int daddadaddadx_ = HI(w_);
  if (aaddaaddadx_ != W) return false;
  if (dadadaddadx_) return false;
  if (daddaaddadx_ >= 0) return false;
  w_ = Get(daddaaddadx_);  // (W)
  int adaddaaddadx_ = LO(w_);
  int ddaddaaddadx_ = HI(w_);
  if (dddadaddadx_) return false;
  if (adaddaaddadx_ != W) return false;
  if (aaddadaddadx_ != N) return false;
  if (ddaddaaddadx_) return false;
  if (daddadaddadx_ >= 0) return false;
  w_ = Get(daddadaddadx_);  // ((λ M ((V V) . M)))
  int adaddadaddadx_ = LO(w_);
  int ddaddadaddadx_ = HI(w_);
  if (adaddadaddadx_ >= 0) return false;
  w_ = Get(adaddadaddadx_);  // (λ M ((V V) . M))
  int aadaddadaddadx_ = LO(w_);
  int dadaddadaddadx_ = HI(w_);
  if (ddaddadaddadx_) return false;
  if (aadaddadaddadx_ != kLambda) return false;
  if (dadaddadaddadx_ >= 0) return false;
  w_ = Get(dadaddadaddadx_);  // (M ((V V) . M))
  int adadaddadaddadx_ = LO(w_);
  int ddadaddadaddadx_ = HI(w_);
  int M = adadaddadaddadx_;
  if (M <= 0) return false;
  if (ddadaddadaddadx_ >= 0) return false;
  w_ = Get(ddadaddadaddadx_);  // (((V V) . M))
  int addadaddadaddadx_ = LO(w_);
  int dddadaddadaddadx_ = HI(w_);
  if (addadaddadaddadx_ >= 0) return false;
  w_ = Get(addadaddadaddadx_);  // ((V V) . M)
  int aaddadaddadaddadx_ = LO(w_);
  int daddadaddadaddadx_ = HI(w_);
  if (dddadaddadaddadx_) return false;
  if (aaddadaddadaddadx_ >= 0) return false;
  w_ = Get(aaddadaddadaddadx_);  // (V V)
  int aaaddadaddadaddadx_ = LO(w_);
  int daaddadaddadaddadx_ = HI(w_);
  if (daddadaddadaddadx_ != M) return false;
  if (aaaddadaddadaddadx_ != V) return false;
  if (daaddadaddadaddadx_ >= 0) return false;
  w_ = Get(daaddadaddadaddadx_);  // (V)
  int adaaddadaddadaddadx_ = LO(w_);
  int ddaaddadaddadaddadx_ = HI(w_);
  if (adaaddadaddadaddadx_ != V) return false;
  if (ddaaddadaddadaddadx_) return false;
  return true;
}
"
./repos/cosmopolitan/tool/plinko/lib/findfreevariables.c,https://github.com/jart/cosmopolitan.git,"/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2022 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include ""tool/plinko/lib/cons.h""
#include ""tool/plinko/lib/index.h""
#include ""tool/plinko/lib/plinko.h""

/**
 * Finds free variables in expression.
 *
 * @param e is expression
 * @param r is atom list result accumulator
 * @param s is atom tree of shadowed bindings
 * @return atom list of crash bindings without duplicates
 * @note this produces garbage when recursing into let
 */
int FindFreeVariables(int e, int r, int s) {
  int f, t;
  if (e >= 0) {
    if (!IsConstant(e) && !HasAtom(e, s) && !HasAtom(e, r)) {
      t = GetCommonCons(e, r);
      r = t ? t : Cons(e, r);
    }
  } else {
    f = Car(e);
    if (f != kQuote && f != kClosure) {
      if (f == kLambda || f == kMacro) {
        r = FindFreeVariables(Caddr(e), r, Shadow(Cadr(e), s));
      } else if (f == kCond) {
        while ((e = Cdr(e)) < 0) {
          if ((f = Car(e)) < 0) {
            r = FindFreeVariables(Car(f), r, s);
            if ((f = Cdr(f)) < 0) {
              r = FindFreeVariables(Car(f), r, s);
            }
          }
        }
      } else {
        while (e) {
          if (e < 0) {
            f = Car(e);
            e = Cdr(e);
          } else {
            f = e;
            e = 0;
          }
          r = FindFreeVariables(f, r, s);
        }
      }
    }
  }
  return r;
}
"
./repos/libevent/buffer_iocp.c,https://github.com/libevent/libevent,"/*
 * Copyright (c) 2009-2012 Niels Provos and Nick Mathewson
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
   @file buffer_iocp.c

   This module implements overlapped read and write functions for evbuffer
   objects on Windows.
*/
#include ""event2/event-config.h""
#include ""evconfig-private.h""

#include ""event2/buffer.h""
#include ""event2/buffer_compat.h""
#include ""event2/util.h""
#include ""event2/thread.h""
#include ""util-internal.h""
#include ""evthread-internal.h""
#include ""evbuffer-internal.h""
#include ""iocp-internal.h""
#include ""mm-internal.h""

#include <winsock2.h>
#include <winerror.h>
#include <windows.h>
#include <stdio.h>

#define MAX_WSABUFS 16

/** An evbuffer that can handle overlapped IO. */
struct evbuffer_overlapped {
	struct evbuffer buffer;
	/** The socket that we're doing overlapped IO on. */
	evutil_socket_t fd;

	/** pending I/O type */
	unsigned read_in_progress : 1;
	unsigned write_in_progress : 1;

	/** The first pinned chain in the buffer. */
	struct evbuffer_chain *first_pinned;

	/** How many chains are pinned; how many of the fields in buffers
	 * are we using. */
	int n_buffers;
	WSABUF buffers[MAX_WSABUFS];
};

/** Given an evbuffer, return the corresponding evbuffer structure, or NULL if
 * the evbuffer isn't overlapped. */
static inline struct evbuffer_overlapped *
upcast_evbuffer(struct evbuffer *buf)
{
	if (!buf || !buf->is_overlapped)
		return NULL;
	return EVUTIL_UPCAST(buf, struct evbuffer_overlapped, buffer);
}

/** Unpin all the chains noted as pinned in 'eo'. */
static void
pin_release(struct evbuffer_overlapped *eo, unsigned flag)
{
	int i;
	struct evbuffer_chain *next, *chain = eo->first_pinned;

	for (i = 0; i < eo->n_buffers; ++i) {
		EVUTIL_ASSERT(chain);
		next = chain->next;
		evbuffer_chain_unpin_(chain, flag);
		chain = next;
	}
}

void
evbuffer_commit_read_(struct evbuffer *evbuf, ev_ssize_t nBytes)
{
	struct evbuffer_overlapped *buf = upcast_evbuffer(evbuf);
	struct evbuffer_chain **chainp;
	size_t remaining, len;
	unsigned i;

	EVBUFFER_LOCK(evbuf);
	EVUTIL_ASSERT(buf->read_in_progress && !buf->write_in_progress);
	EVUTIL_ASSERT(nBytes >= 0); /* XXXX Can this be false? */

	evbuffer_unfreeze(evbuf, 0);

	chainp = evbuf->last_with_datap;
	if (!((*chainp)->flags & EVBUFFER_MEM_PINNED_R))
		chainp = &(*chainp)->next;
	remaining = nBytes;
	for (i = 0; remaining > 0 && i < (unsigned)buf->n_buffers; ++i) {
		EVUTIL_ASSERT(*chainp);
		len = buf->buffers[i].len;
		if (remaining < len)
			len = remaining;
		(*chainp)->off += len;
		evbuf->last_with_datap = chainp;
		remaining -= len;
		chainp = &(*chainp)->next;
	}

	pin_release(buf, EVBUFFER_MEM_PINNED_R);

	buf->read_in_progress = 0;

	evbuf->total_len += nBytes;
	evbuf->n_add_for_cb += nBytes;

	evbuffer_invoke_callbacks_(evbuf);

	evbuffer_decref_and_unlock_(evbuf);
}

void
evbuffer_commit_write_(struct evbuffer *evbuf, ev_ssize_t nBytes)
{
	struct evbuffer_overlapped *buf = upcast_evbuffer(evbuf);

	EVBUFFER_LOCK(evbuf);
	EVUTIL_ASSERT(buf->write_in_progress && !buf->read_in_progress);
	evbuffer_unfreeze(evbuf, 1);
	evbuffer_drain(evbuf, nBytes);
	pin_release(buf,EVBUFFER_MEM_PINNED_W);
	buf->write_in_progress = 0;
	evbuffer_decref_and_unlock_(evbuf);
}

struct evbuffer *
evbuffer_overlapped_new_(evutil_socket_t fd)
{
	struct evbuffer_overlapped *evo;

	evo = mm_calloc(1, sizeof(struct evbuffer_overlapped));
	if (!evo)
		return NULL;

	LIST_INIT(&evo->buffer.callbacks);
	evo->buffer.refcnt = 1;
	evo->buffer.last_with_datap = &evo->buffer.first;

	evo->buffer.is_overlapped = 1;
	evo->fd = fd;

	return &evo->buffer;
}

int
evbuffer_launch_write_(struct evbuffer *buf, ev_ssize_t at_most,
		struct event_overlapped *ol)
{
	struct evbuffer_overlapped *buf_o = upcast_evbuffer(buf);
	int r = -1;
	int i;
	struct evbuffer_chain *chain;
	DWORD bytesSent;

	if (!buf) {
		/* No buffer, or it isn't overlapped */
		return -1;
	}

	EVBUFFER_LOCK(buf);
	EVUTIL_ASSERT(!buf_o->read_in_progress);
	if (buf->freeze_start || buf_o->write_in_progress)
		goto done;
	if (!buf->total_len) {
		/* Nothing to write */
		r = 0;
		goto done;
	} else if (at_most < 0 || (size_t)at_most > buf->total_len) {
		at_most = buf->total_len;
	}
	evbuffer_freeze(buf, 1);

	buf_o->first_pinned = NULL;
	buf_o->n_buffers = 0;
	memset(buf_o->buffers, 0, sizeof(buf_o->buffers));

	chain = buf_o->first_pinned = buf->first;

	for (i=0; i < MAX_WSABUFS && chain; ++i, chain=chain->next) {
		WSABUF *b = &buf_o->buffers[i];
		b->buf = (char*)( chain->buffer + chain->misalign );
		evbuffer_chain_pin_(chain, EVBUFFER_MEM_PINNED_W);

		if ((size_t)at_most > chain->off) {
			/* XXXX Cast is safe for now, since win32 has no
			   mmaped chains.  But later, we need to have this
			   add more WSAbufs if chain->off is greater than
			   ULONG_MAX */
			b->len = (unsigned long)chain->off;
			at_most -= chain->off;
		} else {
			b->len = (unsigned long)at_most;
			++i;
			break;
		}
	}

	buf_o->n_buffers = i;
	evbuffer_incref_(buf);
	if (WSASend(buf_o->fd, buf_o->buffers, i, &bytesSent, 0,
		&ol->overlapped, NULL)) {
		int error = WSAGetLastError();
		if (error != WSA_IO_PENDING) {
			/* An actual error. */
			pin_release(buf_o, EVBUFFER_MEM_PINNED_W);
			evbuffer_unfreeze(buf, 1);
			evbuffer_free(buf); /* decref */
			goto done;
		}
	}

	buf_o->write_in_progress = 1;
	r = 0;
done:
	EVBUFFER_UNLOCK(buf);
	return r;
}

int
evbuffer_launch_read_(struct evbuffer *buf, size_t at_most,
		struct event_overlapped *ol)
{
	struct evbuffer_overlapped *buf_o = upcast_evbuffer(buf);
	int r = -1, i;
	int nvecs;
	int npin=0;
	struct evbuffer_chain *chain=NULL, **chainp;
	DWORD bytesRead;
	DWORD flags = 0;
	struct evbuffer_iovec vecs[MAX_WSABUFS];

	if (!buf_o)
		return -1;
	EVBUFFER_LOCK(buf);
	EVUTIL_ASSERT(!buf_o->write_in_progress);
	if (buf->freeze_end || buf_o->read_in_progress)
		goto done;

	buf_o->first_pinned = NULL;
	buf_o->n_buffers = 0;
	memset(buf_o->buffers, 0, sizeof(buf_o->buffers));

	if (evbuffer_expand_fast_(buf, at_most, MAX_WSABUFS) == -1)
		goto done;
	evbuffer_freeze(buf, 0);

	nvecs = evbuffer_read_setup_vecs_(buf, at_most,
	    vecs, MAX_WSABUFS, &chainp, 1);
	for (i=0;i<nvecs;++i) {
		WSABUF_FROM_EVBUFFER_IOV(
			&buf_o->buffers[i],
			&vecs[i]);
	}

	buf_o->n_buffers = nvecs;
	buf_o->first_pinned = chain = *chainp;

	npin=0;
	for ( ; chain; chain = chain->next) {
		evbuffer_chain_pin_(chain, EVBUFFER_MEM_PINNED_R);
		++npin;
	}
	EVUTIL_ASSERT(npin == nvecs);

	evbuffer_incref_(buf);
	if (WSARecv(buf_o->fd, buf_o->buffers, nvecs, &bytesRead, &flags,
		    &ol->overlapped, NULL)) {
		int error = WSAGetLastError();
		if (error != WSA_IO_PENDING) {
			/* An actual error. */
			pin_release(buf_o, EVBUFFER_MEM_PINNED_R);
			evbuffer_unfreeze(buf, 0);
			evbuffer_free(buf); /* decref */
			goto done;
		}
	}

	buf_o->read_in_progress = 1;
	r = 0;
done:
	EVBUFFER_UNLOCK(buf);
	return r;
}

evutil_socket_t
evbuffer_overlapped_get_fd_(struct evbuffer *buf)
{
	struct evbuffer_overlapped *buf_o = upcast_evbuffer(buf);
	return buf_o ? buf_o->fd : -1;
}

void
evbuffer_overlapped_set_fd_(struct evbuffer *buf, evutil_socket_t fd)
{
	struct evbuffer_overlapped *buf_o = upcast_evbuffer(buf);
	EVBUFFER_LOCK(buf);
	/* XXX is this right?, should it cancel current I/O operations? */
	if (buf_o)
		buf_o->fd = fd;
	EVBUFFER_UNLOCK(buf);
}
"
./repos/libevent/arc4random.c,https://github.com/libevent/libevent,"/* Portable arc4random.c based on arc4random.c from OpenBSD.
 * Portable version by Chris Davis, adapted for Libevent by Nick Mathewson
 * Copyright (c) 2010 Chris Davis, Niels Provos, and Nick Mathewson
 * Copyright (c) 2010-2012 Niels Provos and Nick Mathewson
 *
 * Note that in Libevent, this file isn't compiled directly.  Instead,
 * it's included from evutil_rand.c
 */

/*
 * Copyright (c) 1996, David Mazieres <dm@uun.org>
 * Copyright (c) 2008, Damien Miller <djm@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Arc4 random number generator for OpenBSD.
 *
 * This code is derived from section 17.1 of Applied Cryptography,
 * second edition, which describes a stream cipher allegedly
 * compatible with RSA Labs ""RC4"" cipher (the actual description of
 * which is a trade secret).  The same algorithm is used as a stream
 * cipher called ""arcfour"" in Tatu Ylonen's ssh package.
 *
 * Here the stream cipher has been modified always to include the time
 * when initializing the state.  That makes it impossible to
 * regenerate the same random sequence twice, so this can't be used
 * for encryption, but will generate good random numbers.
 *
 * RC4 is a registered trademark of RSA Laboratories.
 */

#ifndef ARC4RANDOM_EXPORT
#define ARC4RANDOM_EXPORT
#endif

#ifndef ARC4RANDOM_UINT32
#define ARC4RANDOM_UINT32 uint32_t
#endif

#ifndef ARC4RANDOM_NO_INCLUDES
#include ""evconfig-private.h""
#ifdef _WIN32
#include <bcrypt.h>
#include <process.h>
#include <winerror.h>
#else
#include <fcntl.h>
#include <unistd.h>
#include <sys/param.h>
#include <sys/time.h>
#ifdef EVENT__HAVE_SYS_SYSCTL_H
#include <sys/sysctl.h>
#endif
#ifdef EVENT__HAVE_SYS_RANDOM_H
#include <sys/random.h>
#endif
#endif
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#endif

/* Add platform entropy 32 bytes (256 bits) at a time. */
#define ADD_ENTROPY 32

#define REKEY_BASE (1024*1024) /* NB. should be a power of 2 */

struct arc4_stream {
	unsigned char i;
	unsigned char j;
	unsigned char s[256];
};

#ifdef _WIN32
#define getpid _getpid
#define pid_t int
#endif

#ifndef O_RDONLY
#define O_RDONLY _O_RDONLY
#endif

static int rs_initialized;
static struct arc4_stream rs;
static pid_t arc4_stir_pid;
static int arc4_count;

static inline unsigned char arc4_getbyte(void);

static inline void
arc4_init(void)
{
	int     n;

	for (n = 0; n < 256; n++)
		rs.s[n] = n;
	rs.i = 0;
	rs.j = 0;
}

static inline void
arc4_addrandom(const unsigned char *dat, int datlen)
{
	int     n;
	unsigned char si;

	rs.i--;
	for (n = 0; n < 256; n++) {
		rs.i = (rs.i + 1);
		si = rs.s[rs.i];
		rs.j = (rs.j + si + dat[n % datlen]);
		rs.s[rs.i] = rs.s[rs.j];
		rs.s[rs.j] = si;
	}
	rs.j = rs.i;
}

#ifndef _WIN32
static ssize_t
read_all(int fd, unsigned char *buf, size_t count)
{
	size_t numread = 0;
	ssize_t result;

	while (numread < count) {
		result = read(fd, buf+numread, count-numread);
		if (result<0)
			return -1;
		else if (result == 0)
			break;
		numread += result;
	}

	return (ssize_t)numread;
}
#endif

#ifdef _WIN32
#define TRY_SEED_WIN32
static int
arc4_seed_win32(void)
{
	unsigned char buf[ADD_ENTROPY];

	if (BCryptGenRandom(NULL, buf, sizeof(buf),
		BCRYPT_USE_SYSTEM_PREFERRED_RNG))
		return -1;
	arc4_addrandom(buf, sizeof(buf));
	evutil_memclear_(buf, sizeof(buf));
	return 0;
}
#endif

#if defined(EVENT__HAVE_GETRANDOM)
#define TRY_SEED_GETRANDOM
static int
arc4_seed_getrandom(void)
{
	unsigned char buf[ADD_ENTROPY];
	size_t len;
	ssize_t n = 0;

	for (len = 0; len < sizeof(buf); len += n) {
		n = getrandom(&buf[len], sizeof(buf) - len, 0);
		if (n < 0)
			return -1;
	}
	arc4_addrandom(buf, sizeof(buf));
	evutil_memclear_(buf, sizeof(buf));
	return 0;
}
#endif /* EVENT__HAVE_GETRANDOM */

#if defined(EVENT__HAVE_SYS_SYSCTL_H) && defined(EVENT__HAVE_SYSCTL)
#if EVENT__HAVE_DECL_CTL_KERN && EVENT__HAVE_DECL_KERN_ARND
#define TRY_SEED_SYSCTL_BSD
static int
arc4_seed_sysctl_bsd(void)
{
	/* Based on code from William Ahern and from OpenBSD, this function
	 * tries to use the KERN_ARND syscall to get entropy from the kernel.
	 * This can work even if /dev/urandom is inaccessible for some reason
	 * (e.g., we're running in a chroot). */
	int mib[] = { CTL_KERN, KERN_ARND };
	unsigned char buf[ADD_ENTROPY];
	size_t len, n;
	int i, any_set;

	memset(buf, 0, sizeof(buf));

	len = sizeof(buf);
	if (sysctl(mib, 2, buf, &len, NULL, 0) == -1) {
		for (len = 0; len < sizeof(buf); len += sizeof(unsigned)) {
			n = sizeof(unsigned);
			if (n + len > sizeof(buf))
			    n = len - sizeof(buf);
			if (sysctl(mib, 2, &buf[len], &n, NULL, 0) == -1)
				return -1;
		}
	}
	/* make sure that the buffer actually got set. */
	for (i=any_set=0; i<sizeof(buf); ++i) {
		any_set |= buf[i];
	}
	if (!any_set)
		return -1;

	arc4_addrandom(buf, sizeof(buf));
	evutil_memclear_(buf, sizeof(buf));
	return 0;
}
#endif
#endif /* defined(EVENT__HAVE_SYS_SYSCTL_H) */

#ifdef __linux__
#define TRY_SEED_PROC_SYS_KERNEL_RANDOM_UUID
static int
arc4_seed_proc_sys_kernel_random_uuid(void)
{
	/* Occasionally, somebody will make /proc/sys accessible in a chroot,
	 * but not /dev/urandom.  Let's try /proc/sys/kernel/random/uuid.
	 * Its format is stupid, so we need to decode it from hex.
	 */
	int fd;
	char buf[128];
	unsigned char entropy[64];
	int bytes, n, i, nybbles;
	for (bytes = 0; bytes<ADD_ENTROPY; ) {
		fd = evutil_open_closeonexec_(""/proc/sys/kernel/random/uuid"", O_RDONLY, 0);
		if (fd < 0)
			return -1;
		n = read(fd, buf, sizeof(buf));
		close(fd);
		if (n<=0)
			return -1;
		memset(entropy, 0, sizeof(entropy));
		for (i=nybbles=0; i<n; ++i) {
			if (EVUTIL_ISXDIGIT_(buf[i])) {
				int nyb = evutil_hex_char_to_int_(buf[i]);
				if (nybbles & 1) {
					entropy[nybbles/2] |= nyb;
				} else {
					entropy[nybbles/2] |= nyb<<4;
				}
				++nybbles;
			}
		}
		if (nybbles < 2)
			return -1;
		arc4_addrandom(entropy, nybbles/2);
		bytes += nybbles/2;
	}
	evutil_memclear_(entropy, sizeof(entropy));
	evutil_memclear_(buf, sizeof(buf));
	return 0;
}
#endif

#ifndef _WIN32
#define TRY_SEED_URANDOM
static char *arc4random_urandom_filename = NULL;

static int arc4_seed_urandom_helper_(const char *fname)
{
	unsigned char buf[ADD_ENTROPY];
	int fd;
	size_t n;

	fd = evutil_open_closeonexec_(fname, O_RDONLY, 0);
	if (fd<0)
		return -1;
	n = read_all(fd, buf, sizeof(buf));
	close(fd);
	if (n != sizeof(buf))
		return -1;
	arc4_addrandom(buf, sizeof(buf));
	evutil_memclear_(buf, sizeof(buf));
	return 0;
}

static int
arc4_seed_urandom(void)
{
	/* This is adapted from Tor's crypto_seed_rng() */
	static const char *filenames[] = {
		""/dev/srandom"", ""/dev/urandom"", ""/dev/random"", NULL
	};
	int i;
	if (arc4random_urandom_filename)
		return arc4_seed_urandom_helper_(arc4random_urandom_filename);

	for (i = 0; filenames[i]; ++i) {
		if (arc4_seed_urandom_helper_(filenames[i]) == 0) {
			return 0;
		}
	}

	return -1;
}
#endif

static int
arc4_seed(void)
{
	int ok = 0;
	/* We try every method that might work, and don't give up even if one
	 * does seem to work.  There's no real harm in over-seeding, and if
	 * one of these sources turns out to be broken, that would be bad. */
#ifdef TRY_SEED_WIN32
	if (0 == arc4_seed_win32())
		ok = 1;
#endif
#ifdef TRY_SEED_GETRANDOM
	if (0 == arc4_seed_getrandom())
		ok = 1;
#endif
#ifdef TRY_SEED_URANDOM
	if (0 == arc4_seed_urandom())
		ok = 1;
#endif
#ifdef TRY_SEED_PROC_SYS_KERNEL_RANDOM_UUID
	if (arc4random_urandom_filename == NULL &&
	    0 == arc4_seed_proc_sys_kernel_random_uuid())
		ok = 1;
#endif
#ifdef TRY_SEED_SYSCTL_BSD
	if (0 == arc4_seed_sysctl_bsd())
		ok = 1;
#endif
	return ok ? 0 : -1;
}

static inline unsigned int
arc4_getword(void);
static int
arc4_stir(void)
{
	int     i;
	ARC4RANDOM_UINT32 rekey_fuzz; 

	if (!rs_initialized) {
		arc4_init();
		rs_initialized = 1;
	}

	if (0 != arc4_seed())
		return -1;

	/*
	 * Discard early keystream, as per recommendations in
	 * ""Weaknesses in the Key Scheduling Algorithm of RC4"" by
	 * Scott Fluhrer, Itsik Mantin, and Adi Shamir.
	 * http://www.wisdom.weizmann.ac.il/~itsik/RC4/Papers/Rc4_ksa.ps
	 *
	 * Ilya Mironov's ""(Not So) Random Shuffles of RC4"" suggests that
	 * we drop at least 2*256 bytes, with 12*256 as a conservative
	 * value.
	 *
	 * RFC4345 says to drop 6*256.
	 *
	 * At least some versions of this code drop 4*256, in a mistaken
	 * belief that ""words"" in the Fluhrer/Mantin/Shamir paper refers
	 * to processor words.
	 *
	 * We add another sect to the cargo cult, and choose 12*256.
	 */
	for (i = 0; i < 12*256; i++)
		(void)arc4_getbyte();

	rekey_fuzz = arc4_getword();
	/* rekey interval should not be predictable */
	arc4_count = REKEY_BASE + (rekey_fuzz % REKEY_BASE);

	return 0;
}


static void
arc4_stir_if_needed(void)
{
	pid_t pid = getpid();

	if (arc4_count <= 0 || !rs_initialized || arc4_stir_pid != pid)
	{
		arc4_stir_pid = pid;
		arc4_stir();
	}
}

static inline unsigned char
arc4_getbyte(void)
{
	unsigned char si, sj;

	rs.i = (rs.i + 1);
	si = rs.s[rs.i];
	rs.j = (rs.j + si);
	sj = rs.s[rs.j];
	rs.s[rs.i] = sj;
	rs.s[rs.j] = si;
	return (rs.s[(si + sj) & 0xff]);
}

static inline unsigned int
arc4_getword(void)
{
	unsigned int val;

	val = (unsigned)arc4_getbyte() << 24;
	val |= arc4_getbyte() << 16;
	val |= arc4_getbyte() << 8;
	val |= arc4_getbyte();

	return val;
}

#ifndef ARC4RANDOM_NOSTIR
ARC4RANDOM_EXPORT int
arc4random_stir(void)
{
	int val;
	ARC4_LOCK_();
	val = arc4_stir();
	ARC4_UNLOCK_();
	return val;
}
#endif

#ifndef ARC4RANDOM_NOADDRANDOM
ARC4RANDOM_EXPORT void
arc4random_addrandom(const unsigned char *dat, int datlen)
{
	int j;
	ARC4_LOCK_();
	if (!rs_initialized)
		arc4_stir();
	for (j = 0; j < datlen; j += 256) {
		/* arc4_addrandom() ignores all but the first 256 bytes of
		 * its input.  We want to make sure to look at ALL the
		 * data in 'dat', just in case the user is doing something
		 * crazy like passing us all the files in /var/log. */
		arc4_addrandom(dat + j, datlen - j);
	}
	ARC4_UNLOCK_();
}
#endif

#ifndef ARC4RANDOM_NORANDOM
ARC4RANDOM_EXPORT ARC4RANDOM_UINT32
arc4random(void)
{
	ARC4RANDOM_UINT32 val;
	ARC4_LOCK_();
	arc4_count -= 4;
	arc4_stir_if_needed();
	val = arc4_getword();
	ARC4_UNLOCK_();
	return val;
}
#endif

#ifndef EVENT__HAVE_ARC4RANDOM_BUF
ARC4RANDOM_EXPORT void
arc4random_buf(void *buf_, size_t n)
{
	unsigned char *buf = buf_;
	ARC4_LOCK_();
	arc4_stir_if_needed();
	while (n--) {
		if (--arc4_count <= 0)
			arc4_stir();
		buf[n] = arc4_getbyte();
	}
	ARC4_UNLOCK_();
}
#endif  /* #ifndef EVENT__HAVE_ARC4RANDOM_BUF */

#ifndef ARC4RANDOM_NOUNIFORM
/*
 * Calculate a uniformly distributed random number less than upper_bound
 * avoiding ""modulo bias"".
 *
 * Uniformity is achieved by generating new random numbers until the one
 * returned is outside the range [0, 2**32 % upper_bound).  This
 * guarantees the selected random number will be inside
 * [2**32 % upper_bound, 2**32) which maps back to [0, upper_bound)
 * after reduction modulo upper_bound.
 */
ARC4RANDOM_EXPORT unsigned int
arc4random_uniform(unsigned int upper_bound)
{
	ARC4RANDOM_UINT32 r, min;

	if (upper_bound < 2)
		return 0;

	/* 2**32 % x == (2**32 - x) % x */
	min = -upper_bound % upper_bound;

	/*
	 * This could theoretically loop forever but each retry has
	 * p > 0.5 (worst case, usually far better) of selecting a
	 * number inside the range we need, so it should rarely need
	 * to re-roll.
	 */
	for (;;) {
		r = arc4random();
		if (r >= min)
			break;
	}

	return r % upper_bound;
}
#endif
"
./repos/libevent/bufferevent_async.c,https://github.com/libevent/libevent,"/*
 * Copyright (c) 2009-2012 Niels Provos and Nick Mathewson
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include ""event2/event-config.h""
#include ""evconfig-private.h""

#ifdef EVENT__HAVE_SYS_TIME_H
#include <sys/time.h>
#endif

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef EVENT__HAVE_STDARG_H
#include <stdarg.h>
#endif
#ifdef EVENT__HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifdef _WIN32
#include <winsock2.h>
#include <winerror.h>
#include <ws2tcpip.h>
#endif

#include <sys/queue.h>

#include ""event2/util.h""
#include ""event2/bufferevent.h""
#include ""event2/buffer.h""
#include ""event2/bufferevent_struct.h""
#include ""event2/event.h""
#include ""event2/util.h""
#include ""event-internal.h""
#include ""log-internal.h""
#include ""mm-internal.h""
#include ""bufferevent-internal.h""
#include ""util-internal.h""
#include ""iocp-internal.h""

#ifndef SO_UPDATE_CONNECT_CONTEXT
/* Mingw is sometimes missing this */
#define SO_UPDATE_CONNECT_CONTEXT 0x7010
#endif

/* prototypes */
static int be_async_enable(struct bufferevent *, short);
static int be_async_disable(struct bufferevent *, short);
static void be_async_destruct(struct bufferevent *);
static int be_async_flush(struct bufferevent *, short, enum bufferevent_flush_mode);
static int be_async_ctrl(struct bufferevent *, enum bufferevent_ctrl_op, union bufferevent_ctrl_data *);

struct bufferevent_async {
	struct bufferevent_private bev;
	struct event_overlapped connect_overlapped;
	struct event_overlapped read_overlapped;
	struct event_overlapped write_overlapped;
	size_t read_in_progress;
	size_t write_in_progress;
	unsigned ok : 1;
	unsigned read_added : 1;
	unsigned write_added : 1;
};

const struct bufferevent_ops bufferevent_ops_async = {
	""socket_async"",
	evutil_offsetof(struct bufferevent_async, bev.bev),
	be_async_enable,
	be_async_disable,
	NULL, /* Unlink */
	be_async_destruct,
	bufferevent_generic_adj_timeouts_,
	be_async_flush,
	be_async_ctrl,
};

static inline void
be_async_run_eventcb(struct bufferevent *bev, short what, int options)
{ bufferevent_run_eventcb_(bev, what, options|BEV_TRIG_DEFER_CALLBACKS); }

static inline void
be_async_trigger_nolock(struct bufferevent *bev, short what, int options)
{ bufferevent_trigger_nolock_(bev, what, options|BEV_TRIG_DEFER_CALLBACKS); }

static inline int
fatal_error(int err)
{
	switch (err) {
		/* We may have already associated this fd with a port.
		 * Let's hope it's this port, and that the error code
		 * for doing this neer changes. */
		case ERROR_INVALID_PARAMETER:
			return 0;
	}
	return 1;
}

static inline struct bufferevent_async *
upcast(struct bufferevent *bev)
{
	struct bufferevent_async *bev_a;
	if (!BEV_IS_ASYNC(bev))
		return NULL;
	bev_a = EVUTIL_UPCAST(bev, struct bufferevent_async, bev.bev);
	return bev_a;
}

static inline struct bufferevent_async *
upcast_connect(struct event_overlapped *eo)
{
	struct bufferevent_async *bev_a;
	bev_a = EVUTIL_UPCAST(eo, struct bufferevent_async, connect_overlapped);
	EVUTIL_ASSERT(BEV_IS_ASYNC(&bev_a->bev.bev));
	return bev_a;
}

static inline struct bufferevent_async *
upcast_read(struct event_overlapped *eo)
{
	struct bufferevent_async *bev_a;
	bev_a = EVUTIL_UPCAST(eo, struct bufferevent_async, read_overlapped);
	EVUTIL_ASSERT(BEV_IS_ASYNC(&bev_a->bev.bev));
	return bev_a;
}

static inline struct bufferevent_async *
upcast_write(struct event_overlapped *eo)
{
	struct bufferevent_async *bev_a;
	bev_a = EVUTIL_UPCAST(eo, struct bufferevent_async, write_overlapped);
	EVUTIL_ASSERT(BEV_IS_ASYNC(&bev_a->bev.bev));
	return bev_a;
}

static void
bev_async_del_write(struct bufferevent_async *beva)
{
	struct bufferevent *bev = &beva->bev.bev;

	if (beva->write_added) {
		beva->write_added = 0;
		event_base_del_virtual_(bev->ev_base);
	}
}

static void
bev_async_del_read(struct bufferevent_async *beva)
{
	struct bufferevent *bev = &beva->bev.bev;

	if (beva->read_added) {
		beva->read_added = 0;
		event_base_del_virtual_(bev->ev_base);
	}
}

static void
bev_async_add_write(struct bufferevent_async *beva)
{
	struct bufferevent *bev = &beva->bev.bev;

	if (!beva->write_added) {
		beva->write_added = 1;
		event_base_add_virtual_(bev->ev_base);
	}
}

static void
bev_async_add_read(struct bufferevent_async *beva)
{
	struct bufferevent *bev = &beva->bev.bev;

	if (!beva->read_added) {
		beva->read_added = 1;
		event_base_add_virtual_(bev->ev_base);
	}
}

static void
bev_async_consider_writing(struct bufferevent_async *beva)
{
	size_t at_most;
	int limit;
	struct bufferevent *bev = &beva->bev.bev;

	/* Don't write if there's a write in progress, or we do not
	 * want to write, or when there's nothing left to write. */
	if (beva->write_in_progress || beva->bev.connecting)
		return;
	if (!beva->ok || !(bev->enabled&EV_WRITE) ||
	    !evbuffer_get_length(bev->output)) {
		bev_async_del_write(beva);
		return;
	}

	at_most = evbuffer_get_length(bev->output);

	/* This is safe so long as bufferevent_get_write_max never returns
	 * more than INT_MAX.  That's true for now. XXXX */
	limit = (int)bufferevent_get_write_max_(&beva->bev);
	if (at_most >= (size_t)limit && limit >= 0)
		at_most = limit;

	if (beva->bev.write_suspended) {
		bev_async_del_write(beva);
		return;
	}

	/*  XXXX doesn't respect low-water mark very well. */
	bufferevent_incref_(bev);
	if (evbuffer_launch_write_(bev->output, at_most,
	    &beva->write_overlapped)) {
		bufferevent_decref_(bev);
		beva->ok = 0;
		be_async_run_eventcb(bev, BEV_EVENT_ERROR, 0);
	} else {
		beva->write_in_progress = at_most;
		bufferevent_decrement_write_buckets_(&beva->bev, at_most);
		bev_async_add_write(beva);
	}
}

static void
bev_async_consider_reading(struct bufferevent_async *beva)
{
	size_t cur_size;
	size_t read_high;
	size_t at_most;
	int limit;
	struct bufferevent *bev = &beva->bev.bev;

	/* Don't read if there is a read in progress, or we do not
	 * want to read. */
	if (beva->read_in_progress || beva->bev.connecting)
		return;
	if (!beva->ok || !(bev->enabled&EV_READ)) {
		bev_async_del_read(beva);
		return;
	}

	/* Don't read if we're full */
	cur_size = evbuffer_get_length(bev->input);
	read_high = bev->wm_read.high;
	if (read_high) {
		if (cur_size >= read_high) {
			bev_async_del_read(beva);
			return;
		}
		at_most = read_high - cur_size;
	} else {
		at_most = 16384; /* FIXME totally magic. */
	}

	/* XXXX This over-commits. */
	/* XXXX see also not above on cast on bufferevent_get_write_max_() */
	limit = (int)bufferevent_get_read_max_(&beva->bev);
	if (at_most >= (size_t)limit && limit >= 0)
		at_most = limit;

	if (beva->bev.read_suspended) {
		bev_async_del_read(beva);
		return;
	}

	bufferevent_incref_(bev);
	if (evbuffer_launch_read_(bev->input, at_most, &beva->read_overlapped)) {
		beva->ok = 0;
		be_async_run_eventcb(bev, BEV_EVENT_ERROR, 0);
		bufferevent_decref_(bev);
	} else {
		beva->read_in_progress = at_most;
		bufferevent_decrement_read_buckets_(&beva->bev, at_most);
		bev_async_add_read(beva);
	}

	return;
}

static void
be_async_outbuf_callback(struct evbuffer *buf,
    const struct evbuffer_cb_info *cbinfo,
    void *arg)
{
	struct bufferevent *bev = arg;
	struct bufferevent_async *bev_async = upcast(bev);

	/* If we added data to the outbuf and were not writing before,
	 * we may want to write now. */

	bufferevent_incref_and_lock_(bev);

	if (cbinfo->n_added)
		bev_async_consider_writing(bev_async);

	bufferevent_decref_and_unlock_(bev);
}

static void
be_async_inbuf_callback(struct evbuffer *buf,
    const struct evbuffer_cb_info *cbinfo,
    void *arg)
{
	struct bufferevent *bev = arg;
	struct bufferevent_async *bev_async = upcast(bev);

	/* If we drained data from the inbuf and were not reading before,
	 * we may want to read now */

	bufferevent_incref_and_lock_(bev);

	if (cbinfo->n_deleted)
		bev_async_consider_reading(bev_async);

	bufferevent_decref_and_unlock_(bev);
}

static int
be_async_enable(struct bufferevent *buf, short what)
{
	struct bufferevent_async *bev_async = upcast(buf);

	if (!bev_async->ok)
		return -1;

	if (bev_async->bev.connecting) {
		/* Don't launch anything during connection attempts. */
		return 0;
	}

	if (what & EV_READ)
		BEV_RESET_GENERIC_READ_TIMEOUT(buf);
	if (what & EV_WRITE)
		BEV_RESET_GENERIC_WRITE_TIMEOUT(buf);

	/* If we newly enable reading or writing, and we aren't reading or
	   writing already, consider launching a new read or write. */

	if (what & EV_READ)
		bev_async_consider_reading(bev_async);
	if (what & EV_WRITE)
		bev_async_consider_writing(bev_async);
	return 0;
}

static int
be_async_disable(struct bufferevent *bev, short what)
{
	struct bufferevent_async *bev_async = upcast(bev);
	/* XXXX If we disable reading or writing, we may want to consider
	 * canceling any in-progress read or write operation, though it might
	 * not work. */

	if (what & EV_READ) {
		BEV_DEL_GENERIC_READ_TIMEOUT(bev);
		bev_async_del_read(bev_async);
	}
	if (what & EV_WRITE) {
		BEV_DEL_GENERIC_WRITE_TIMEOUT(bev);
		bev_async_del_write(bev_async);
	}

	return 0;
}

static void
be_async_destruct(struct bufferevent *bev)
{
	struct bufferevent_async *bev_async = upcast(bev);
	struct bufferevent_private *bev_p = BEV_UPCAST(bev);
	evutil_socket_t fd;

	EVUTIL_ASSERT(!upcast(bev)->write_in_progress &&
			!upcast(bev)->read_in_progress);

	bev_async_del_read(bev_async);
	bev_async_del_write(bev_async);

	fd = evbuffer_overlapped_get_fd_(bev->input);
	if (fd != (evutil_socket_t)EVUTIL_INVALID_SOCKET &&
		(bev_p->options & BEV_OPT_CLOSE_ON_FREE)) {
		evutil_closesocket(fd);
		evbuffer_overlapped_set_fd_(bev->input, EVUTIL_INVALID_SOCKET);
	}
}

/* GetQueuedCompletionStatus doesn't reliably yield WSA error codes, so
 * we use WSAGetOverlappedResult to translate. */
static void
bev_async_set_wsa_error(struct bufferevent *bev, struct event_overlapped *eo)
{
	DWORD bytes, flags;
	evutil_socket_t fd;

	fd = evbuffer_overlapped_get_fd_(bev->input);
	WSAGetOverlappedResult(fd, &eo->overlapped, &bytes, FALSE, &flags);
}

static int
be_async_flush(struct bufferevent *bev, short what,
    enum bufferevent_flush_mode mode)
{
	return 0;
}

static void
connect_complete(struct event_overlapped *eo, ev_uintptr_t key,
    ev_ssize_t nbytes, int ok)
{
	struct bufferevent_async *bev_a = upcast_connect(eo);
	struct bufferevent *bev = &bev_a->bev.bev;
	evutil_socket_t sock;

	BEV_LOCK(bev);

	EVUTIL_ASSERT(bev_a->bev.connecting);
	bev_a->bev.connecting = 0;
	sock = evbuffer_overlapped_get_fd_(bev_a->bev.bev.input);
	/* XXXX Handle error? */
	setsockopt(sock, SOL_SOCKET, SO_UPDATE_CONNECT_CONTEXT, NULL, 0);

	if (ok)
		bufferevent_async_set_connected_(bev);
	else
		bev_async_set_wsa_error(bev, eo);

	be_async_run_eventcb(bev, ok ? BEV_EVENT_CONNECTED : BEV_EVENT_ERROR, 0);

	event_base_del_virtual_(bev->ev_base);

	bufferevent_decref_and_unlock_(bev);
}

static void
read_complete(struct event_overlapped *eo, ev_uintptr_t key,
    ev_ssize_t nbytes, int ok)
{
	struct bufferevent_async *bev_a = upcast_read(eo);
	struct bufferevent *bev = &bev_a->bev.bev;
	short what = BEV_EVENT_READING;
	ev_ssize_t amount_unread;
	BEV_LOCK(bev);
	EVUTIL_ASSERT(bev_a->read_in_progress);

	amount_unread = bev_a->read_in_progress - nbytes;
	evbuffer_commit_read_(bev->input, nbytes);
	bev_a->read_in_progress = 0;
	if (amount_unread)
		bufferevent_decrement_read_buckets_(&bev_a->bev, -amount_unread);

	if (!ok)
		bev_async_set_wsa_error(bev, eo);

	if (bev_a->ok) {
		if (ok && nbytes) {
			BEV_RESET_GENERIC_READ_TIMEOUT(bev);
			be_async_trigger_nolock(bev, EV_READ, 0);
			bev_async_consider_reading(bev_a);
		} else if (!ok) {
			what |= BEV_EVENT_ERROR;
			bev_a->ok = 0;
			be_async_run_eventcb(bev, what, 0);
		} else if (!nbytes) {
			what |= BEV_EVENT_EOF;
			bev_a->ok = 0;
			be_async_run_eventcb(bev, what, 0);
		}
	}

	bufferevent_decref_and_unlock_(bev);
}

static void
write_complete(struct event_overlapped *eo, ev_uintptr_t key,
    ev_ssize_t nbytes, int ok)
{
	struct bufferevent_async *bev_a = upcast_write(eo);
	struct bufferevent *bev = &bev_a->bev.bev;
	short what = BEV_EVENT_WRITING;
	ev_ssize_t amount_unwritten;

	BEV_LOCK(bev);
	EVUTIL_ASSERT(bev_a->write_in_progress);

	amount_unwritten = bev_a->write_in_progress - nbytes;
	evbuffer_commit_write_(bev->output, nbytes);
	bev_a->write_in_progress = 0;

	if (amount_unwritten)
		bufferevent_decrement_write_buckets_(&bev_a->bev,
		                                     -amount_unwritten);


	if (!ok)
		bev_async_set_wsa_error(bev, eo);

	if (bev_a->ok) {
		if (ok && nbytes) {
			BEV_RESET_GENERIC_WRITE_TIMEOUT(bev);
			be_async_trigger_nolock(bev, EV_WRITE, 0);
			bev_async_consider_writing(bev_a);
		} else if (!ok) {
			what |= BEV_EVENT_ERROR;
			bev_a->ok = 0;
			be_async_run_eventcb(bev, what, 0);
		} else if (!nbytes) {
			what |= BEV_EVENT_EOF;
			bev_a->ok = 0;
			be_async_run_eventcb(bev, what, 0);
		}
	}

	bufferevent_decref_and_unlock_(bev);
}

struct bufferevent *
bufferevent_async_new_(struct event_base *base,
    evutil_socket_t fd, int options)
{
	struct bufferevent_async *bev_a;
	struct bufferevent *bev;
	struct event_iocp_port *iocp;

	options |= BEV_OPT_THREADSAFE;

	if (!(iocp = event_base_get_iocp_(base)))
		return NULL;

	if (fd >= 0 && event_iocp_port_associate_(iocp, fd, 1)<0) {
		if (fatal_error(GetLastError()))
			return NULL;
	}

	if (!(bev_a = mm_calloc(1, sizeof(struct bufferevent_async))))
		return NULL;

	bev = &bev_a->bev.bev;
	if (!(bev->input = evbuffer_overlapped_new_(fd))) {
		mm_free(bev_a);
		return NULL;
	}
	if (!(bev->output = evbuffer_overlapped_new_(fd))) {
		evbuffer_free(bev->input);
		mm_free(bev_a);
		return NULL;
	}

	if (bufferevent_init_common_(&bev_a->bev, base, &bufferevent_ops_async,
		options)<0)
		goto err;

	evbuffer_add_cb(bev->input, be_async_inbuf_callback, bev);
	evbuffer_add_cb(bev->output, be_async_outbuf_callback, bev);

	event_overlapped_init_(&bev_a->connect_overlapped, connect_complete);
	event_overlapped_init_(&bev_a->read_overlapped, read_complete);
	event_overlapped_init_(&bev_a->write_overlapped, write_complete);

	bufferevent_init_generic_timeout_cbs_(bev);

	bev_a->ok = fd >= 0;

	return bev;
err:
	bufferevent_free(&bev_a->bev.bev);
	return NULL;
}

void
bufferevent_async_set_connected_(struct bufferevent *bev)
{
	struct bufferevent_async *bev_async = upcast(bev);
	bev_async->ok = 1;
	/* Now's a good time to consider reading/writing */
	be_async_enable(bev, bev->enabled);
}

int
bufferevent_async_can_connect_(struct bufferevent *bev)
{
	const struct win32_extension_fns *ext =
	    event_get_win32_extension_fns_();

	if (BEV_IS_ASYNC(bev) &&
	    event_base_get_iocp_(bev->ev_base) &&
	    ext && ext->ConnectEx)
		return 1;

	return 0;
}

int
bufferevent_async_connect_(struct bufferevent *bev, evutil_socket_t fd,
	const struct sockaddr *sa, int socklen)
{
	BOOL rc;
	struct bufferevent_async *bev_async = upcast(bev);
	struct sockaddr_storage ss;
	const struct win32_extension_fns *ext =
	    event_get_win32_extension_fns_();

	EVUTIL_ASSERT(ext && ext->ConnectEx && fd >= 0 && sa != NULL);

	/* ConnectEx() requires that the socket be bound to an address
	 * with bind() before using, otherwise it will fail. We attempt
	 * to issue a bind() here, taking into account that the error
	 * code is set to WSAEINVAL when the socket is already bound. */
	memset(&ss, 0, sizeof(ss));
	if (sa->sa_family == AF_INET) {
		struct sockaddr_in *sin = (struct sockaddr_in *)&ss;
		sin->sin_family = AF_INET;
		sin->sin_addr.s_addr = INADDR_ANY;
	} else if (sa->sa_family == AF_INET6) {
		struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&ss;
		sin6->sin6_family = AF_INET6;
		sin6->sin6_addr = in6addr_any;
	} else {
		/* Well, the user will have to bind() */
		return -1;
	}
	if (bind(fd, (struct sockaddr *)&ss, sizeof(ss)) < 0 &&
	    WSAGetLastError() != WSAEINVAL)
		return -1;

	event_base_add_virtual_(bev->ev_base);
	bufferevent_incref_(bev);
	rc = ext->ConnectEx(fd, sa, socklen, NULL, 0, NULL,
			    &bev_async->connect_overlapped.overlapped);
	if (rc || WSAGetLastError() == ERROR_IO_PENDING)
		return 0;

	event_base_del_virtual_(bev->ev_base);
	bufferevent_decref_(bev);

	return -1;
}

static int
be_async_ctrl(struct bufferevent *bev, enum bufferevent_ctrl_op op,
    union bufferevent_ctrl_data *data)
{
	switch (op) {
	case BEV_CTRL_GET_FD:
		data->fd = evbuffer_overlapped_get_fd_(bev->input);
		return 0;
	case BEV_CTRL_SET_FD: {
		struct bufferevent_async *bev_a = upcast(bev);
		struct event_iocp_port *iocp;

		if (data->fd == evbuffer_overlapped_get_fd_(bev->input))
			return 0;
		if (!(iocp = event_base_get_iocp_(bev->ev_base)))
			return -1;
		if (event_iocp_port_associate_(iocp, data->fd, 1) < 0) {
			if (fatal_error(GetLastError()))
				return -1;
		}
		evbuffer_overlapped_set_fd_(bev->input, data->fd);
		evbuffer_overlapped_set_fd_(bev->output, data->fd);
		bev_a->ok = data->fd >= 0;
		return 0;
	}
	case BEV_CTRL_CANCEL_ALL: {
		struct bufferevent_async *bev_a = upcast(bev);
		evutil_socket_t fd = evbuffer_overlapped_get_fd_(bev->input);
		if (fd != (evutil_socket_t)EVUTIL_INVALID_SOCKET &&
		    (bev_a->bev.options & BEV_OPT_CLOSE_ON_FREE)) {
			closesocket(fd);
			evbuffer_overlapped_set_fd_(bev->input, EVUTIL_INVALID_SOCKET);
		}
		bev_a->ok = 0;
		return 0;
	}
	case BEV_CTRL_GET_UNDERLYING:
	default:
		return -1;
	}
}


"
./repos/libevent/buffer.c,https://github.com/libevent/libevent,"/*
 * Copyright (c) 2002-2007 Niels Provos <provos@citi.umich.edu>
 * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include ""event2/event-config.h""
#include ""evconfig-private.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <io.h>
#endif

#include <sys/types.h>

#ifdef EVENT__HAVE_SYS_TIME_H
#include <sys/time.h>
#endif

#ifdef EVENT__HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#endif

#ifdef EVENT__HAVE_SYS_UIO_H
#include <sys/uio.h>
#endif

#ifdef EVENT__HAVE_SYS_IOCTL_H
#include <sys/ioctl.h>
#endif

#ifdef EVENT__HAVE_SYS_MMAN_H
#include <sys/mman.h>
#endif

#ifdef EVENT__HAVE_SYS_SENDFILE_H
#include <sys/sendfile.h>
#endif
#ifdef EVENT__HAVE_SYS_STAT_H
#include <sys/stat.h>
#endif


#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef EVENT__HAVE_STDARG_H
#include <stdarg.h>
#endif
#ifdef EVENT__HAVE_UNISTD_H
#include <unistd.h>
#endif
#include <limits.h>

#include ""event2/event.h""
#include ""event2/buffer.h""
#include ""event2/buffer_compat.h""
#include ""event2/bufferevent.h""
#include ""event2/bufferevent_compat.h""
#include ""event2/bufferevent_struct.h""
#include ""event2/thread.h""
#include ""log-internal.h""
#include ""mm-internal.h""
#include ""util-internal.h""
#include ""evthread-internal.h""
#include ""evbuffer-internal.h""
#include ""bufferevent-internal.h""
#include ""event-internal.h""

/* some systems do not have MAP_FAILED */
#ifndef MAP_FAILED
#define MAP_FAILED	((void *)-1)
#endif

/* send file support */
#if defined(EVENT__HAVE_SYS_SENDFILE_H) && defined(EVENT__HAVE_SENDFILE) && defined(__linux__)
#define USE_SENDFILE		1
#define SENDFILE_IS_LINUX	1
#elif defined(EVENT__HAVE_SENDFILE) && defined(__FreeBSD__)
#define USE_SENDFILE		1
#define SENDFILE_IS_FREEBSD	1
#elif defined(EVENT__HAVE_SENDFILE) && defined(__APPLE__)
#define USE_SENDFILE		1
#define SENDFILE_IS_MACOSX	1
#elif defined(EVENT__HAVE_SENDFILE) && defined(__sun__) && defined(__svr4__)
#define USE_SENDFILE		1
#define SENDFILE_IS_SOLARIS	1
#endif

/* Mask of user-selectable callback flags. */
#define EVBUFFER_CB_USER_FLAGS	    0xffff
/* Mask of all internal-use-only flags. */
#define EVBUFFER_CB_INTERNAL_FLAGS  0xffff0000

/* Flag set if the callback is using the cb_obsolete function pointer  */
#define EVBUFFER_CB_OBSOLETE	       0x00040000

/* evbuffer_chain support */
#define CHAIN_SPACE_PTR(ch) ((ch)->buffer + (ch)->misalign + (ch)->off)
#define CHAIN_SPACE_LEN(ch) ((ch)->flags & EVBUFFER_IMMUTABLE ? \
	    0 : (ch)->buffer_len - ((ch)->misalign + (ch)->off))

#define CHAIN_PINNED(ch)  (((ch)->flags & EVBUFFER_MEM_PINNED_ANY) != 0)
#define CHAIN_PINNED_R(ch)  (((ch)->flags & EVBUFFER_MEM_PINNED_R) != 0)

/* evbuffer_ptr support */
#define PTR_NOT_FOUND(ptr) do {			\
	(ptr)->pos = -1;					\
	(ptr)->internal_.chain = NULL;		\
	(ptr)->internal_.pos_in_chain = 0;	\
} while (0)

#define EVBUFFER_MAX_READ_DEFAULT	4096

static void evbuffer_chain_align(struct evbuffer_chain *chain);
static int evbuffer_chain_should_realign(struct evbuffer_chain *chain,
    size_t datalen);
static void evbuffer_deferred_callback(struct event_callback *cb, void *arg);
static int evbuffer_ptr_memcmp(const struct evbuffer *buf,
    const struct evbuffer_ptr *pos, const char *mem, size_t len);
static struct evbuffer_chain *evbuffer_expand_singlechain(struct evbuffer *buf,
    size_t datlen);
static int evbuffer_ptr_subtract(struct evbuffer *buf, struct evbuffer_ptr *pos,
    size_t howfar);
static int evbuffer_file_segment_materialize(struct evbuffer_file_segment *seg);
static inline void evbuffer_chain_incref(struct evbuffer_chain *chain);

static struct evbuffer_chain *
evbuffer_chain_new(size_t size)
{
	struct evbuffer_chain *chain;
	size_t to_alloc;

	if (size > EVBUFFER_CHAIN_MAX - EVBUFFER_CHAIN_SIZE)
		return (NULL);

	to_alloc = size + EVBUFFER_CHAIN_SIZE;

	/* we get everything in one chunk */
	if ((chain = mm_malloc(to_alloc)) == NULL)
		return (NULL);

	memset(chain, 0, EVBUFFER_CHAIN_SIZE);

	chain->buffer_len = to_alloc - EVBUFFER_CHAIN_SIZE;

	/* this way we can manipulate the buffer to different addresses,
	 * which is required for mmap for example.
	 */
	chain->buffer = EVBUFFER_CHAIN_EXTRA(unsigned char, chain);

	chain->refcnt = 1;

	return (chain);
}

static struct evbuffer_chain *
evbuffer_chain_new_membuf(size_t size)
{
	size_t to_alloc;

	if (size > EVBUFFER_CHAIN_MAX - EVBUFFER_CHAIN_SIZE)
		return (NULL);

	size += EVBUFFER_CHAIN_SIZE;

	/* get the next largest memory that can hold the buffer */
	if (size < EVBUFFER_CHAIN_MAX / 2) {
		to_alloc = MIN_BUFFER_SIZE;
		while (to_alloc < size) {
			to_alloc <<= 1;
		}
	} else {
		to_alloc = size;
	}

	return evbuffer_chain_new(to_alloc - EVBUFFER_CHAIN_SIZE);
}

static inline void
evbuffer_chain_free(struct evbuffer_chain *chain)
{
	EVUTIL_ASSERT(chain->refcnt > 0);
	if (--chain->refcnt > 0) {
		/* chain is still referenced by other chains */
		return;
	}

	if (CHAIN_PINNED(chain)) {
		/* will get freed once no longer dangling */
		chain->refcnt++;
		chain->flags |= EVBUFFER_DANGLING;
		return;
	}

	/* safe to release chain, it's either a referencing
	 * chain or all references to it have been freed */
	if (chain->flags & EVBUFFER_REFERENCE) {
		struct evbuffer_chain_reference *info =
		    EVBUFFER_CHAIN_EXTRA(
			    struct evbuffer_chain_reference,
			    chain);
		if (info->cleanupfn)
			(*info->cleanupfn)(chain->buffer,
			    chain->buffer_len,
			    info->extra);
	}
	if (chain->flags & EVBUFFER_FILESEGMENT) {
		struct evbuffer_chain_file_segment *info =
		    EVBUFFER_CHAIN_EXTRA(
			    struct evbuffer_chain_file_segment,
			    chain);
		if (info->segment) {
#ifdef _WIN32
			if (info->segment->is_mapping)
				UnmapViewOfFile(chain->buffer);
#endif
			evbuffer_file_segment_free(info->segment);
		}
	}
	if (chain->flags & EVBUFFER_MULTICAST) {
		struct evbuffer_multicast_parent *info =
		    EVBUFFER_CHAIN_EXTRA(
			    struct evbuffer_multicast_parent,
			    chain);
		/* referencing chain is being freed, decrease
		 * refcounts of source chain and associated
		 * evbuffer (which get freed once both reach
		 * zero) */
		EVUTIL_ASSERT(info->source != NULL);
		EVUTIL_ASSERT(info->parent != NULL);
		EVBUFFER_LOCK(info->source);
		evbuffer_chain_free(info->parent);
		evbuffer_decref_and_unlock_(info->source);
	}

	mm_free(chain);
}

static void
evbuffer_free_all_chains(struct evbuffer_chain *chain)
{
	struct evbuffer_chain *next;
	for (; chain; chain = next) {
		next = chain->next;
		evbuffer_chain_free(chain);
	}
}

#ifndef NDEBUG
static int
evbuffer_chains_all_empty(struct evbuffer_chain *chain)
{
	for (; chain; chain = chain->next) {
		if (chain->off)
			return 0;
	}
	return 1;
}
#else
/* The definition is needed for EVUTIL_ASSERT, which uses sizeof to avoid
""unused variable"" warnings. */
static inline int evbuffer_chains_all_empty(struct evbuffer_chain *chain) {
	return 1;
}
#endif

/* Free all trailing chains in 'buf' that are neither pinned nor empty, prior
 * to replacing them all with a new chain.  Return a pointer to the place
 * where the new chain will go.
 *
 * Internal; requires lock.  The caller must fix up buf->last and buf->first
 * as needed; they might have been freed.
 */
static struct evbuffer_chain **
evbuffer_free_trailing_empty_chains(struct evbuffer *buf)
{
	struct evbuffer_chain **ch = buf->last_with_datap;
	/* Find the first victim chain.  It might be *last_with_datap */
	while ((*ch) && ((*ch)->off != 0 || CHAIN_PINNED(*ch)))
		ch = &(*ch)->next;
	if (*ch) {
		EVUTIL_ASSERT(evbuffer_chains_all_empty(*ch));
		evbuffer_free_all_chains(*ch);
		*ch = NULL;
	}
	return ch;
}

/* Add a single chain 'chain' to the end of 'buf', freeing trailing empty
 * chains as necessary.  Requires lock.  Does not schedule callbacks.
 */
static void
evbuffer_chain_insert(struct evbuffer *buf,
    struct evbuffer_chain *chain)
{
	ASSERT_EVBUFFER_LOCKED(buf);
	if (*buf->last_with_datap == NULL) {
		/* There are no chains data on the buffer at all. */
		EVUTIL_ASSERT(buf->last_with_datap == &buf->first);
		EVUTIL_ASSERT(buf->first == NULL);
		buf->first = buf->last = chain;
	} else {
		struct evbuffer_chain **chp;
		chp = evbuffer_free_trailing_empty_chains(buf);
		*chp = chain;
		if (chain->off)
			buf->last_with_datap = chp;
		buf->last = chain;
	}
	buf->total_len += chain->off;
}

static inline struct evbuffer_chain *
evbuffer_chain_insert_new(struct evbuffer *buf, size_t datlen)
{
	struct evbuffer_chain *chain;
	if ((chain = evbuffer_chain_new_membuf(datlen)) == NULL)
		return NULL;
	evbuffer_chain_insert(buf, chain);
	return chain;
}

void
evbuffer_chain_pin_(struct evbuffer_chain *chain, unsigned flag)
{
	EVUTIL_ASSERT((chain->flags & flag) == 0);
	chain->flags |= flag;
}

void
evbuffer_chain_unpin_(struct evbuffer_chain *chain, unsigned flag)
{
	EVUTIL_ASSERT((chain->flags & flag) != 0);
	chain->flags &= ~flag;
	if (chain->flags & EVBUFFER_DANGLING)
		evbuffer_chain_free(chain);
}

static inline void
evbuffer_chain_incref(struct evbuffer_chain *chain)
{
    ++chain->refcnt;
}

struct evbuffer *
evbuffer_new(void)
{
	struct evbuffer *buffer;

	buffer = mm_calloc(1, sizeof(struct evbuffer));
	if (buffer == NULL)
		return (NULL);

	LIST_INIT(&buffer->callbacks);
	buffer->refcnt = 1;
	buffer->last_with_datap = &buffer->first;
	buffer->max_read = EVBUFFER_MAX_READ_DEFAULT;

	return (buffer);
}

int
evbuffer_set_flags(struct evbuffer *buf, ev_uint64_t flags)
{
	EVBUFFER_LOCK(buf);
	buf->flags |= (ev_uint32_t)flags;
	EVBUFFER_UNLOCK(buf);
	return 0;
}

int
evbuffer_clear_flags(struct evbuffer *buf, ev_uint64_t flags)
{
	EVBUFFER_LOCK(buf);
	buf->flags &= ~(ev_uint32_t)flags;
	EVBUFFER_UNLOCK(buf);
	return 0;
}

void
evbuffer_incref_(struct evbuffer *buf)
{
	EVBUFFER_LOCK(buf);
	++buf->refcnt;
	EVBUFFER_UNLOCK(buf);
}

void
evbuffer_incref_and_lock_(struct evbuffer *buf)
{
	EVBUFFER_LOCK(buf);
	++buf->refcnt;
}

int
evbuffer_defer_callbacks(struct evbuffer *buffer, struct event_base *base)
{
	EVBUFFER_LOCK(buffer);
	buffer->cb_queue = base;
	buffer->deferred_cbs = 1;
	event_deferred_cb_init_(&buffer->deferred,
	    event_base_get_npriorities(base) / 2,
	    evbuffer_deferred_callback, buffer);
	EVBUFFER_UNLOCK(buffer);
	return 0;
}

int
evbuffer_enable_locking(struct evbuffer *buf, void *lock)
{
#ifdef EVENT__DISABLE_THREAD_SUPPORT
	return -1;
#else
	if (buf->lock)
		return -1;

	if (!lock) {
		EVTHREAD_ALLOC_LOCK(lock, EVTHREAD_LOCKTYPE_RECURSIVE);
		if (!lock)
			return -1;
		buf->lock = lock;
		buf->own_lock = 1;
	} else {
		buf->lock = lock;
		buf->own_lock = 0;
	}

	return 0;
#endif
}

void
evbuffer_set_parent_(struct evbuffer *buf, struct bufferevent *bev)
{
	EVBUFFER_LOCK(buf);
	buf->parent = bev;
	EVBUFFER_UNLOCK(buf);
}

static void
evbuffer_run_callbacks(struct evbuffer *buffer, int running_deferred)
{
	struct evbuffer_cb_entry *cbent, *next;
	struct evbuffer_cb_info info;
	size_t new_size;
	ev_uint32_t mask, masked_val;
	int clear = 1;

	if (running_deferred) {
		mask = EVBUFFER_CB_NODEFER|EVBUFFER_CB_ENABLED;
		masked_val = EVBUFFER_CB_ENABLED;
	} else if (buffer->deferred_cbs) {
		mask = EVBUFFER_CB_NODEFER|EVBUFFER_CB_ENABLED;
		masked_val = EVBUFFER_CB_NODEFER|EVBUFFER_CB_ENABLED;
		/* Don't zero-out n_add/n_del, since the deferred callbacks
		   will want to see them. */
		clear = 0;
	} else {
		mask = EVBUFFER_CB_ENABLED;
		masked_val = EVBUFFER_CB_ENABLED;
	}

	ASSERT_EVBUFFER_LOCKED(buffer);

	if (LIST_EMPTY(&buffer->callbacks)) {
		buffer->n_add_for_cb = buffer->n_del_for_cb = 0;
		return;
	}
	if (buffer->n_add_for_cb == 0 && buffer->n_del_for_cb == 0)
		return;

	new_size = buffer->total_len;
	info.orig_size = new_size + buffer->n_del_for_cb - buffer->n_add_for_cb;
	info.n_added = buffer->n_add_for_cb;
	info.n_deleted = buffer->n_del_for_cb;
	if (clear) {
		buffer->n_add_for_cb = 0;
		buffer->n_del_for_cb = 0;
	}
	for (cbent = LIST_FIRST(&buffer->callbacks);
	     cbent != LIST_END(&buffer->callbacks);
	     cbent = next) {
		/* Get the 'next' pointer now in case this callback decides
		 * to remove itself or something. */
		next = LIST_NEXT(cbent, next);

		if ((cbent->flags & mask) != masked_val)
			continue;

		if ((cbent->flags & EVBUFFER_CB_OBSOLETE))
			cbent->cb.cb_obsolete(buffer,
			    info.orig_size, new_size, cbent->cbarg);
		else
			cbent->cb.cb_func(buffer, &info, cbent->cbarg);
	}
}

void
evbuffer_invoke_callbacks_(struct evbuffer *buffer)
{
	if (LIST_EMPTY(&buffer->callbacks)) {
		buffer->n_add_for_cb = buffer->n_del_for_cb = 0;
		return;
	}

	if (buffer->deferred_cbs) {
		if (event_deferred_cb_schedule_(buffer->cb_queue, &buffer->deferred)) {
			evbuffer_incref_and_lock_(buffer);
			if (buffer->parent)
				bufferevent_incref_(buffer->parent);
			EVBUFFER_UNLOCK(buffer);
		}
	}

	evbuffer_run_callbacks(buffer, 0);
}

static void
evbuffer_deferred_callback(struct event_callback *cb, void *arg)
{
	struct bufferevent *parent = NULL;
	struct evbuffer *buffer = arg;

	/* XXXX It would be better to run these callbacks without holding the
	 * lock */
	EVBUFFER_LOCK(buffer);
	parent = buffer->parent;
	evbuffer_run_callbacks(buffer, 1);
	evbuffer_decref_and_unlock_(buffer);
	if (parent)
		bufferevent_decref_(parent);
}

static void
evbuffer_remove_all_callbacks(struct evbuffer *buffer)
{
	struct evbuffer_cb_entry *cbent;

	while ((cbent = LIST_FIRST(&buffer->callbacks))) {
		LIST_REMOVE(cbent, next);
		mm_free(cbent);
	}
}

void
evbuffer_decref_and_unlock_(struct evbuffer *buffer)
{
	struct evbuffer_chain *chain, *next;
	ASSERT_EVBUFFER_LOCKED(buffer);

	EVUTIL_ASSERT(buffer->refcnt > 0);

	if (--buffer->refcnt > 0) {
		EVBUFFER_UNLOCK(buffer);
		return;
	}

	for (chain = buffer->first; chain != NULL; chain = next) {
		next = chain->next;
		evbuffer_chain_free(chain);
	}
	evbuffer_remove_all_callbacks(buffer);
	if (buffer->deferred_cbs)
		event_deferred_cb_cancel_(buffer->cb_queue, &buffer->deferred);

	EVBUFFER_UNLOCK(buffer);
	if (buffer->own_lock)
		EVTHREAD_FREE_LOCK(buffer->lock, EVTHREAD_LOCKTYPE_RECURSIVE);
	mm_free(buffer);
}

void
evbuffer_free(struct evbuffer *buffer)
{
	EVBUFFER_LOCK(buffer);
	evbuffer_decref_and_unlock_(buffer);
}

int evbuffer_set_max_read(struct evbuffer *buf, size_t max)
{
	if (max > INT_MAX) {
		return -1;
	}

	EVBUFFER_LOCK(buf);
	buf->max_read = max;
	EVBUFFER_UNLOCK(buf);
	return 0;
}
size_t evbuffer_get_max_read(struct evbuffer *buf)
{
	size_t result;
	EVBUFFER_LOCK(buf);
	result = buf->max_read;
	EVBUFFER_UNLOCK(buf);
	return result;
}

void
evbuffer_lock(struct evbuffer *buf)
{
	EVBUFFER_LOCK(buf);
}

void
evbuffer_unlock(struct evbuffer *buf)
{
	EVBUFFER_UNLOCK(buf);
}

size_t
evbuffer_get_length(const struct evbuffer *buffer)
{
	size_t result;
	EVBUFFER_LOCK(buffer);
	result = buffer->total_len;
	EVBUFFER_UNLOCK(buffer);
	return result;
}

size_t
evbuffer_get_contiguous_space(const struct evbuffer *buf)
{
	struct evbuffer_chain *chain;
	size_t result;

	EVBUFFER_LOCK(buf);
	chain = buf->first;
	result = (chain != NULL ? chain->off : 0);
	EVBUFFER_UNLOCK(buf);

	return result;
}

size_t
evbuffer_add_iovec(struct evbuffer * buf, struct evbuffer_iovec * vec, int n_vec) {
	int n;
	size_t res;
	size_t to_alloc;

	EVBUFFER_LOCK(buf);

	res = to_alloc = 0;

	for (n = 0; n < n_vec; n++) {
		to_alloc += vec[n].iov_len;
	}

	if (evbuffer_expand_fast_(buf, to_alloc, 2) < 0) {
		goto done;
	}

	for (n = 0; n < n_vec; n++) {
		/* XXX each 'add' call here does a bunch of setup that's
		 * obviated by evbuffer_expand_fast_, and some cleanup that we
		 * would like to do only once.  Instead we should just extract
		 * the part of the code that's needed. */

		if (evbuffer_add(buf, vec[n].iov_base, vec[n].iov_len) < 0) {
			goto done;
		}

		res += vec[n].iov_len;
	}

done:
    EVBUFFER_UNLOCK(buf);
    return res;
}

int
evbuffer_reserve_space(struct evbuffer *buf, ev_ssize_t size,
    struct evbuffer_iovec *vec, int n_vecs)
{
	struct evbuffer_chain *chain, **chainp;
	int n = -1;

	EVBUFFER_LOCK(buf);
	if (buf->freeze_end)
		goto done;
	if (n_vecs < 1)
		goto done;
	if (n_vecs == 1) {
		if ((chain = evbuffer_expand_singlechain(buf, size)) == NULL)
			goto done;

		vec[0].iov_base = (void *)CHAIN_SPACE_PTR(chain);
		vec[0].iov_len = (size_t)CHAIN_SPACE_LEN(chain);
		EVUTIL_ASSERT(size<0 || (size_t)vec[0].iov_len >= (size_t)size);
		n = 1;
	} else {
		if (evbuffer_expand_fast_(buf, size, n_vecs)<0)
			goto done;
		n = evbuffer_read_setup_vecs_(buf, size, vec, n_vecs,
				&chainp, 0);
	}

done:
	EVBUFFER_UNLOCK(buf);
	return n;

}

static int
advance_last_with_data(struct evbuffer *buf)
{
	int n = 0;
	struct evbuffer_chain **chainp = buf->last_with_datap;

	ASSERT_EVBUFFER_LOCKED(buf);

	if (!*chainp)
		return 0;

	while ((*chainp)->next) {
		chainp = &(*chainp)->next;
		if ((*chainp)->off)
			buf->last_with_datap = chainp;
		++n;
	}
	return n;
}

int
evbuffer_commit_space(struct evbuffer *buf,
    struct evbuffer_iovec *vec, int n_vecs)
{
	struct evbuffer_chain *chain, **firstchainp, **chainp;
	int result = -1;
	size_t added = 0;
	int i;

	EVBUFFER_LOCK(buf);

	if (buf->freeze_end)
		goto done;
	if (n_vecs == 0) {
		result = 0;
		goto done;
	} else if (n_vecs == 1 &&
	    (buf->last && vec[0].iov_base == (void *)CHAIN_SPACE_PTR(buf->last))) {
		/* The user only got or used one chain; it might not
		 * be the first one with space in it. */
		if ((size_t)vec[0].iov_len > (size_t)CHAIN_SPACE_LEN(buf->last))
			goto done;
		buf->last->off += vec[0].iov_len;
		added = vec[0].iov_len;
		if (added)
			advance_last_with_data(buf);
		goto okay;
	}

	/* Advance 'firstchain' to the first chain with space in it. */
	firstchainp = buf->last_with_datap;
	if (!*firstchainp)
		goto done;
	if (CHAIN_SPACE_LEN(*firstchainp) == 0) {
		firstchainp = &(*firstchainp)->next;
	}

	chain = *firstchainp;
	/* pass 1: make sure that the pointers and lengths of vecs[] are in
	 * bounds before we try to commit anything. */
	for (i=0; i<n_vecs; ++i) {
		if (!chain)
			goto done;
		if (vec[i].iov_base != (void *)CHAIN_SPACE_PTR(chain) ||
		    (size_t)vec[i].iov_len > CHAIN_SPACE_LEN(chain))
			goto done;
		chain = chain->next;
	}
	/* pass 2: actually adjust all the chains. */
	chainp = firstchainp;
	for (i=0; i<n_vecs; ++i) {
		(*chainp)->off += vec[i].iov_len;
		added += vec[i].iov_len;
		if (vec[i].iov_len) {
			buf->last_with_datap = chainp;
		}
		chainp = &(*chainp)->next;
	}

okay:
	buf->total_len += added;
	buf->n_add_for_cb += added;
	result = 0;
	evbuffer_invoke_callbacks_(buf);

done:
	EVBUFFER_UNLOCK(buf);
	return result;
}

static inline int
HAS_PINNED_R(struct evbuffer *buf)
{
	return (buf->last && CHAIN_PINNED_R(buf->last));
}

static inline void
ZERO_CHAIN(struct evbuffer *dst)
{
	ASSERT_EVBUFFER_LOCKED(dst);
	dst->first = NULL;
	dst->last = NULL;
	dst->last_with_datap = &(dst)->first;
	dst->total_len = 0;
}

/* Prepares the contents of src to be moved to another buffer by removing
 * read-pinned chains. The first pinned chain is saved in first, and the
 * last in last. If src has no read-pinned chains, first and last are set
 * to NULL. */
static int
PRESERVE_PINNED(struct evbuffer *src, struct evbuffer_chain **first,
		struct evbuffer_chain **last)
{
	struct evbuffer_chain *chain, **pinned;

	ASSERT_EVBUFFER_LOCKED(src);

	if (!HAS_PINNED_R(src)) {
		*first = *last = NULL;
		return 0;
	}

	pinned = src->last_with_datap;
	if (!CHAIN_PINNED_R(*pinned))
		pinned = &(*pinned)->next;
	EVUTIL_ASSERT(CHAIN_PINNED_R(*pinned));
	chain = *first = *pinned;
	*last = src->last;

	/* If there's data in the first pinned chain, we need to allocate
	 * a new chain and copy the data over. */
	if (chain->off) {
		struct evbuffer_chain *tmp;

		EVUTIL_ASSERT(pinned == src->last_with_datap);
		tmp = evbuffer_chain_new_membuf(chain->off);
		if (!tmp)
			return -1;
		memcpy(tmp->buffer, chain->buffer + chain->misalign,
			chain->off);
		tmp->off = chain->off;
		*src->last_with_datap = tmp;
		src->last = tmp;
		chain->misalign += chain->off;
		chain->off = 0;
	} else {
		src->last = *src->last_with_datap;
		*pinned = NULL;
	}

	return 0;
}

static inline void
RESTORE_PINNED(struct evbuffer *src, struct evbuffer_chain *pinned,
		struct evbuffer_chain *last)
{
	ASSERT_EVBUFFER_LOCKED(src);

	if (!pinned) {
		ZERO_CHAIN(src);
		return;
	}

	src->first = pinned;
	src->last = last;
	src->last_with_datap = &src->first;
	src->total_len = 0;
}

static inline void
COPY_CHAIN(struct evbuffer *dst, struct evbuffer *src)
{
	ASSERT_EVBUFFER_LOCKED(dst);
	ASSERT_EVBUFFER_LOCKED(src);
	dst->first = src->first;
	if (src->last_with_datap == &src->first)
		dst->last_with_datap = &dst->first;
	else
		dst->last_with_datap = src->last_with_datap;
	dst->last = src->last;
	dst->total_len = src->total_len;
}

static void
APPEND_CHAIN(struct evbuffer *dst, struct evbuffer *src)
{
	struct evbuffer_chain **chp;

	ASSERT_EVBUFFER_LOCKED(dst);
	ASSERT_EVBUFFER_LOCKED(src);

	chp = evbuffer_free_trailing_empty_chains(dst);
	*chp = src->first;

	if (src->last_with_datap == &src->first)
		dst->last_with_datap = chp;
	else
		dst->last_with_datap = src->last_with_datap;
	dst->last = src->last;
	dst->total_len += src->total_len;
}

static inline void
APPEND_CHAIN_MULTICAST(struct evbuffer *dst, struct evbuffer *src)
{
	struct evbuffer_chain *tmp;
	struct evbuffer_chain *chain = src->first;
	struct evbuffer_multicast_parent *extra;

	ASSERT_EVBUFFER_LOCKED(dst);
	ASSERT_EVBUFFER_LOCKED(src);

	for (; chain; chain = chain->next) {
		if (!chain->off || chain->flags & EVBUFFER_DANGLING) {
			/* skip empty chains */
			continue;
		}

		tmp = evbuffer_chain_new(sizeof(struct evbuffer_multicast_parent));
		if (!tmp) {
			event_warn(""%s: out of memory"", __func__);
			return;
		}
		extra = EVBUFFER_CHAIN_EXTRA(struct evbuffer_multicast_parent, tmp);
		/* reference evbuffer containing source chain so it
		 * doesn't get released while the chain is still
		 * being referenced to */
		evbuffer_incref_(src);
		extra->source = src;
		/* reference source chain which now becomes immutable */
		evbuffer_chain_incref(chain);
		extra->parent = chain;
		chain->flags |= EVBUFFER_IMMUTABLE;
		tmp->buffer_len = chain->buffer_len;
		tmp->misalign = chain->misalign;
		tmp->off = chain->off;
		tmp->flags |= EVBUFFER_MULTICAST|EVBUFFER_IMMUTABLE;
		tmp->buffer = chain->buffer;
		evbuffer_chain_insert(dst, tmp);
	}
}

static void
PREPEND_CHAIN(struct evbuffer *dst, struct evbuffer *src)
{
	ASSERT_EVBUFFER_LOCKED(dst);
	ASSERT_EVBUFFER_LOCKED(src);
	src->last->next = dst->first;
	dst->first = src->first;
	dst->total_len += src->total_len;
	if (*dst->last_with_datap == NULL) {
		if (src->last_with_datap == &(src)->first)
			dst->last_with_datap = &dst->first;
		else
			dst->last_with_datap = src->last_with_datap;
	} else if (dst->last_with_datap == &dst->first) {
		dst->last_with_datap = &src->last->next;
	}
}

int
evbuffer_add_buffer(struct evbuffer *outbuf, struct evbuffer *inbuf)
{
	struct evbuffer_chain *pinned, *last;
	size_t in_total_len, out_total_len;
	int result = 0;

	EVBUFFER_LOCK2(inbuf, outbuf);
	in_total_len = inbuf->total_len;
	out_total_len = outbuf->total_len;

	if (in_total_len == 0 || outbuf == inbuf)
		goto done;

	if (outbuf->freeze_end || inbuf->freeze_start) {
		result = -1;
		goto done;
	}

	if (PRESERVE_PINNED(inbuf, &pinned, &last) < 0) {
		result = -1;
		goto done;
	}

	if (out_total_len == 0) {
		/* There might be an empty chain at the start of outbuf; free
		 * it. */
		evbuffer_free_all_chains(outbuf->first);
		COPY_CHAIN(outbuf, inbuf);
	} else {
		APPEND_CHAIN(outbuf, inbuf);
	}

	RESTORE_PINNED(inbuf, pinned, last);

	inbuf->n_del_for_cb += in_total_len;
	outbuf->n_add_for_cb += in_total_len;

	evbuffer_invoke_callbacks_(inbuf);
	evbuffer_invoke_callbacks_(outbuf);

done:
	EVBUFFER_UNLOCK2(inbuf, outbuf);
	return result;
}

int
evbuffer_add_buffer_reference(struct evbuffer *outbuf, struct evbuffer *inbuf)
{
	size_t in_total_len, out_total_len;
	struct evbuffer_chain *chain;
	int result = 0;

	EVBUFFER_LOCK2(inbuf, outbuf);
	in_total_len = inbuf->total_len;
	out_total_len = outbuf->total_len;
	chain = inbuf->first;

	if (in_total_len == 0)
		goto done;

	if (outbuf->freeze_end || outbuf == inbuf) {
		result = -1;
		goto done;
	}

	for (; chain; chain = chain->next) {
		if ((chain->flags & (EVBUFFER_FILESEGMENT|EVBUFFER_SENDFILE|EVBUFFER_MULTICAST)) != 0) {
			/* chain type can not be referenced */
			result = -1;
			goto done;
		}
	}

	if (out_total_len == 0) {
		/* There might be an empty chain at the start of outbuf; free
		 * it. */
		evbuffer_free_all_chains(outbuf->first);
	}
	APPEND_CHAIN_MULTICAST(outbuf, inbuf);

	outbuf->n_add_for_cb += in_total_len;
	evbuffer_invoke_callbacks_(outbuf);

done:
	EVBUFFER_UNLOCK2(inbuf, outbuf);
	return result;
}

int
evbuffer_prepend_buffer(struct evbuffer *outbuf, struct evbuffer *inbuf)
{
	struct evbuffer_chain *pinned, *last;
	size_t in_total_len, out_total_len;
	int result = 0;

	EVBUFFER_LOCK2(inbuf, outbuf);

	in_total_len = inbuf->total_len;
	out_total_len = outbuf->total_len;

	if (!in_total_len || inbuf == outbuf)
		goto done;

	if (outbuf->freeze_start || inbuf->freeze_start) {
		result = -1;
		goto done;
	}

	if (PRESERVE_PINNED(inbuf, &pinned, &last) < 0) {
		result = -1;
		goto done;
	}

	if (out_total_len == 0) {
		/* There might be an empty chain at the start of outbuf; free
		 * it. */
		evbuffer_free_all_chains(outbuf->first);
		COPY_CHAIN(outbuf, inbuf);
	} else {
		PREPEND_CHAIN(outbuf, inbuf);
	}

	RESTORE_PINNED(inbuf, pinned, last);

	inbuf->n_del_for_cb += in_total_len;
	outbuf->n_add_for_cb += in_total_len;

	evbuffer_invoke_callbacks_(inbuf);
	evbuffer_invoke_callbacks_(outbuf);
done:
	EVBUFFER_UNLOCK2(inbuf, outbuf);
	return result;
}

int
evbuffer_drain(struct evbuffer *buf, size_t len)
{
	struct evbuffer_chain *chain, *next;
	size_t remaining, old_len;
	int result = 0;

	EVBUFFER_LOCK(buf);
	old_len = buf->total_len;

	if (old_len == 0)
		goto done;

	if (buf->freeze_start) {
		result = -1;
		goto done;
	}

	if (len >= old_len && !HAS_PINNED_R(buf)) {
		len = old_len;
		for (chain = buf->first; chain != NULL; chain = next) {
			next = chain->next;
			evbuffer_chain_free(chain);
		}

		ZERO_CHAIN(buf);
	} else {
		if (len >= old_len)
			len = old_len;

		buf->total_len -= len;
		remaining = len;
		for (chain = buf->first;
		     remaining >= chain->off;
		     chain = next) {
			next = chain->next;
			remaining -= chain->off;

			if (chain == *buf->last_with_datap) {
				buf->last_with_datap = &buf->first;
			}
			if (&chain->next == buf->last_with_datap)
				buf->last_with_datap = &buf->first;

			if (CHAIN_PINNED_R(chain)) {
				EVUTIL_ASSERT(remaining == 0);
				chain->misalign += chain->off;
				chain->off = 0;
				break;
			} else
				evbuffer_chain_free(chain);
		}

		buf->first = chain;
		EVUTIL_ASSERT(remaining <= chain->off);
		chain->misalign += remaining;
		chain->off -= remaining;
	}

	buf->n_del_for_cb += len;
	/* Tell someone about changes in this buffer */
	evbuffer_invoke_callbacks_(buf);

done:
	EVBUFFER_UNLOCK(buf);
	return result;
}

/* Reads data from an event buffer and drains the bytes read */
int
evbuffer_remove(struct evbuffer *buf, void *data_out, size_t datlen)
{
	ev_ssize_t n;
	EVBUFFER_LOCK(buf);
	n = evbuffer_copyout_from(buf, NULL, data_out, datlen);
	if (n > 0) {
		if (evbuffer_drain(buf, n)<0)
			n = -1;
	}
	EVBUFFER_UNLOCK(buf);
	return (int)n;
}

ev_ssize_t
evbuffer_copyout(struct evbuffer *buf, void *data_out, size_t datlen)
{
	return evbuffer_copyout_from(buf, NULL, data_out, datlen);
}

ev_ssize_t
evbuffer_copyout_from(struct evbuffer *buf, const struct evbuffer_ptr *pos,
    void *data_out, size_t datlen)
{
	/*XXX fails badly on sendfile case. */
	struct evbuffer_chain *chain;
	char *data = data_out;
	size_t nread;
	ev_ssize_t result = 0;
	size_t pos_in_chain;

	EVBUFFER_LOCK(buf);

	if (pos) {
		if (datlen > (size_t)(EV_SSIZE_MAX - pos->pos)) {
			result = -1;
			goto done;
		}
		chain = pos->internal_.chain;
		pos_in_chain = pos->internal_.pos_in_chain;
		if (datlen + pos->pos > buf->total_len)
			datlen = buf->total_len - pos->pos;
	} else {
		chain = buf->first;
		pos_in_chain = 0;
		if (datlen > buf->total_len)
			datlen = buf->total_len;
	}


	if (datlen == 0)
		goto done;

	if (buf->freeze_start) {
		result = -1;
		goto done;
	}

	nread = datlen;

	while (datlen && datlen >= chain->off - pos_in_chain) {
		size_t copylen = chain->off - pos_in_chain;
		memcpy(data,
		    chain->buffer + chain->misalign + pos_in_chain,
		    copylen);
		data += copylen;
		datlen -= copylen;

		chain = chain->next;
		pos_in_chain = 0;
		EVUTIL_ASSERT(chain || datlen==0);
	}

	if (datlen) {
		EVUTIL_ASSERT(chain);
		EVUTIL_ASSERT(datlen+pos_in_chain <= chain->off);

		memcpy(data, chain->buffer + chain->misalign + pos_in_chain,
		    datlen);
	}

	result = nread;
done:
	EVBUFFER_UNLOCK(buf);
	return result;
}

/* reads data from the src buffer to the dst buffer, avoids memcpy as
 * possible. */
/*  XXXX should return ev_ssize_t */
int
evbuffer_remove_buffer(struct evbuffer *src, struct evbuffer *dst,
    size_t datlen)
{
	/*XXX We should have an option to force this to be zero-copy.*/

	/*XXX can fail badly on sendfile case. */
	struct evbuffer_chain *chain, *previous;
	size_t nread = 0;
	int result;

	EVBUFFER_LOCK2(src, dst);

	chain = previous = src->first;

	if (datlen == 0 || dst == src) {
		result = 0;
		goto done;
	}

	if (dst->freeze_end || src->freeze_start) {
		result = -1;
		goto done;
	}

	/* short-cut if there is no more data buffered */
	if (datlen >= src->total_len) {
		datlen = src->total_len;
		evbuffer_add_buffer(dst, src);
		result = (int)datlen; /*XXXX should return ev_ssize_t*/
		goto done;
	}

	/* removes chains if possible */
	while (chain->off <= datlen) {
		/* We can't remove the last with data from src unless we
		 * remove all chains, in which case we would have done the if
		 * block above */
		EVUTIL_ASSERT(chain != *src->last_with_datap);
		nread += chain->off;
		datlen -= chain->off;
		previous = chain;
		if (src->last_with_datap == &chain->next)
			src->last_with_datap = &src->first;
		chain = chain->next;
	}

	if (chain != src->first) {
		/* we can remove the chain */
		struct evbuffer_chain **chp;
		chp = evbuffer_free_trailing_empty_chains(dst);

		if (dst->first == NULL) {
			dst->first = src->first;
		} else {
			*chp = src->first;
		}
		dst->last = previous;
		previous->next = NULL;
		src->first = chain;
		advance_last_with_data(dst);

		dst->total_len += nread;
		dst->n_add_for_cb += nread;
	}

	/* we know that there is more data in the src buffer than
	 * we want to read, so we manually drain the chain */
	evbuffer_add(dst, chain->buffer + chain->misalign, datlen);
	chain->misalign += datlen;
	chain->off -= datlen;
	nread += datlen;

	/* You might think we would want to increment dst->n_add_for_cb
	 * here too.  But evbuffer_add above already took care of that.
	 */
	src->total_len -= nread;
	src->n_del_for_cb += nread;

	if (nread) {
		evbuffer_invoke_callbacks_(dst);
		evbuffer_invoke_callbacks_(src);
	}
	result = (int)nread;/*XXXX should change return type */

done:
	EVBUFFER_UNLOCK2(src, dst);
	return result;
}

unsigned char *
evbuffer_pullup(struct evbuffer *buf, ev_ssize_t size)
{
	struct evbuffer_chain *chain, *next, *tmp, *last_with_data;
	unsigned char *buffer, *result = NULL;
	ev_ssize_t remaining;
	int removed_last_with_data = 0;
	int removed_last_with_datap = 0;

	EVBUFFER_LOCK(buf);

	chain = buf->first;

	if (size < 0)
		size = buf->total_len;
	/* if size > buf->total_len, we cannot guarantee to the user that she
	 * is going to have a long enough buffer afterwards; so we return
	 * NULL */
	if (size == 0 || (size_t)size > buf->total_len)
		goto done;

	/* No need to pull up anything; the first size bytes are
	 * already here. */
	if (chain->off >= (size_t)size) {
		result = chain->buffer + chain->misalign;
		goto done;
	}

	/* Make sure that none of the chains we need to copy from is pinned. */
	remaining = size - chain->off;
	EVUTIL_ASSERT(remaining >= 0);
	for (tmp=chain->next; tmp; tmp=tmp->next) {
		if (CHAIN_PINNED(tmp))
			goto done;
		if (tmp->off >= (size_t)remaining)
			break;
		remaining -= tmp->off;
	}

	if (CHAIN_PINNED(chain)) {
		size_t old_off = chain->off;
		if (CHAIN_SPACE_LEN(chain) < size - chain->off) {
			/* not enough room at end of chunk. */
			goto done;
		}
		buffer = CHAIN_SPACE_PTR(chain);
		tmp = chain;
		tmp->off = size;
		size -= old_off;
		chain = chain->next;
	} else if (chain->buffer_len - chain->misalign >= (size_t)size) {
		/* already have enough space in the first chain */
		size_t old_off = chain->off;
		buffer = chain->buffer + chain->misalign + chain->off;
		tmp = chain;
		tmp->off = size;
		size -= old_off;
		chain = chain->next;
	} else {
		if ((tmp = evbuffer_chain_new_membuf(size)) == NULL) {
			event_warn(""%s: out of memory"", __func__);
			goto done;
		}
		buffer = tmp->buffer;
		tmp->off = size;
		buf->first = tmp;
	}

	/* TODO(niels): deal with buffers that point to NULL like sendfile */

	/* Copy and free every chunk that will be entirely pulled into tmp */
	last_with_data = *buf->last_with_datap;
	for (; chain != NULL && (size_t)size >= chain->off; chain = next) {
		next = chain->next;

		if (chain->buffer) {
			memcpy(buffer, chain->buffer + chain->misalign, chain->off);
			size -= chain->off;
			buffer += chain->off;
		}
		if (chain == last_with_data)
			removed_last_with_data = 1;
		if (&chain->next == buf->last_with_datap)
			removed_last_with_datap = 1;

		evbuffer_chain_free(chain);
	}

	if (chain != NULL) {
		memcpy(buffer, chain->buffer + chain->misalign, size);
		chain->misalign += size;
		chain->off -= size;
	} else {
		buf->last = tmp;
	}

	tmp->next = chain;

	if (removed_last_with_data) {
		buf->last_with_datap = &buf->first;
	} else if (removed_last_with_datap) {
		if (buf->first->next && buf->first->next->off)
			buf->last_with_datap = &buf->first->next;
		else
			buf->last_with_datap = &buf->first;
	}

	result = (tmp->buffer + tmp->misalign);

done:
	EVBUFFER_UNLOCK(buf);
	return result;
}

/*
 * Reads a line terminated by either '\r\n', '\n\r' or '\r' or '\n'.
 * The returned buffer needs to be freed by the called.
 */
char *
evbuffer_readline(struct evbuffer *buffer)
{
	return evbuffer_readln(buffer, NULL, EVBUFFER_EOL_ANY);
}

static inline ev_ssize_t
evbuffer_strchr(struct evbuffer_ptr *it, const char chr)
{
	struct evbuffer_chain *chain = it->internal_.chain;
	size_t i = it->internal_.pos_in_chain;
	while (chain != NULL) {
		char *buffer = (char *)chain->buffer + chain->misalign;
		char *cp = memchr(buffer+i, chr, chain->off-i);
		if (cp) {
			it->internal_.chain = chain;
			it->internal_.pos_in_chain = cp - buffer;
			it->pos += (cp - buffer - i);
			return it->pos;
		}
		it->pos += chain->off - i;
		i = 0;
		chain = chain->next;
	}

	return (-1);
}

static inline char *
find_eol_char(char *s, size_t len)
{
#define CHUNK_SZ 128
	/* Lots of benchmarking found this approach to be faster in practice
	 * than doing two memchrs over the whole buffer, doin a memchr on each
	 * char of the buffer, or trying to emulate memchr by hand. */
	char *s_end, *cr, *lf;
	s_end = s+len;
	while (s < s_end) {
		size_t chunk = (s + CHUNK_SZ < s_end) ? CHUNK_SZ : (s_end - s);
		cr = memchr(s, '\r', chunk);
		lf = memchr(s, '\n', chunk);
		if (cr) {
			if (lf && lf < cr)
				return lf;
			return cr;
		} else if (lf) {
			return lf;
		}
		s += CHUNK_SZ;
	}

	return NULL;
#undef CHUNK_SZ
}

static ev_ssize_t
evbuffer_find_eol_char(struct evbuffer_ptr *it)
{
	struct evbuffer_chain *chain = it->internal_.chain;
	size_t i = it->internal_.pos_in_chain;
	while (chain != NULL) {
		char *buffer = (char *)chain->buffer + chain->misalign;
		char *cp = find_eol_char(buffer+i, chain->off-i);
		if (cp) {
			it->internal_.chain = chain;
			it->internal_.pos_in_chain = cp - buffer;
			it->pos += (cp - buffer) - i;
			return it->pos;
		}
		it->pos += chain->off - i;
		i = 0;
		chain = chain->next;
	}

	return (-1);
}

static inline size_t
evbuffer_strspn(
	struct evbuffer_ptr *ptr, const char *chrset)
{
	size_t count = 0;
	struct evbuffer_chain *chain = ptr->internal_.chain;
	size_t i = ptr->internal_.pos_in_chain;

	if (!chain)
		return 0;

	while (1) {
		char *buffer = (char *)chain->buffer + chain->misalign;
		for (; i < chain->off; ++i) {
			const char *p = chrset;
			while (*p) {
				if (buffer[i] == *p++)
					goto next;
			}
			ptr->internal_.chain = chain;
			ptr->internal_.pos_in_chain = i;
			ptr->pos += count;
			return count;
		next:
			++count;
		}
		i = 0;

		if (! chain->next) {
			ptr->internal_.chain = chain;
			ptr->internal_.pos_in_chain = i;
			ptr->pos += count;
			return count;
		}

		chain = chain->next;
	}
}


static inline int
evbuffer_getchr(struct evbuffer_ptr *it)
{
	struct evbuffer_chain *chain = it->internal_.chain;
	size_t off = it->internal_.pos_in_chain;

	if (chain == NULL)
		return -1;

	return (unsigned char)chain->buffer[chain->misalign + off];
}

struct evbuffer_ptr
evbuffer_search_eol(struct evbuffer *buffer,
    struct evbuffer_ptr *start, size_t *eol_len_out,
    enum evbuffer_eol_style eol_style)
{
	struct evbuffer_ptr it, it2;
	size_t extra_drain = 0;
	int ok = 0;

	/* Avoid locking in trivial edge cases */
	if (start && start->internal_.chain == NULL) {
		PTR_NOT_FOUND(&it);
		if (eol_len_out)
			*eol_len_out = extra_drain;
		return it;
	}

	EVBUFFER_LOCK(buffer);

	if (start) {
		memcpy(&it, start, sizeof(it));
	} else {
		it.pos = 0;
		it.internal_.chain = buffer->first;
		it.internal_.pos_in_chain = 0;
	}

	/* the eol_style determines our first stop character and how many
	 * characters we are going to drain afterwards. */
	switch (eol_style) {
	case EVBUFFER_EOL_ANY:
		if (evbuffer_find_eol_char(&it) < 0)
			goto done;
		memcpy(&it2, &it, sizeof(it));
		extra_drain = evbuffer_strspn(&it2, ""\r\n"");
		break;
	case EVBUFFER_EOL_CRLF_STRICT: {
		it = evbuffer_search(buffer, ""\r\n"", 2, &it);
		if (it.pos < 0)
			goto done;
		extra_drain = 2;
		break;
	}
	case EVBUFFER_EOL_CRLF: {
		ev_ssize_t start_pos = it.pos;
		/* Look for a LF ... */
		if (evbuffer_strchr(&it, '\n') < 0)
			goto done;
		extra_drain = 1;
		/* ... optionally preceded by a CR. */
		if (it.pos == start_pos)
			break; /* If the first character is \n, don't back up */
		/* This potentially does an extra linear walk over the first
		 * few chains.  Probably, that's not too expensive unless you
		 * have a really pathological setup. */
		memcpy(&it2, &it, sizeof(it));
		if (evbuffer_ptr_subtract(buffer, &it2, 1)<0)
			break;
		if (evbuffer_getchr(&it2) == '\r') {
			memcpy(&it, &it2, sizeof(it));
			extra_drain = 2;
		}
		break;
	}
	case EVBUFFER_EOL_LF:
		if (evbuffer_strchr(&it, '\n') < 0)
			goto done;
		extra_drain = 1;
		break;
	case EVBUFFER_EOL_NUL:
		if (evbuffer_strchr(&it, '\0') < 0)
			goto done;
		extra_drain = 1;
		break;
	default:
		goto done;
	}

	ok = 1;
done:
	EVBUFFER_UNLOCK(buffer);

	if (!ok)
		PTR_NOT_FOUND(&it);
	if (eol_len_out)
		*eol_len_out = extra_drain;

	return it;
}

char *
evbuffer_readln(struct evbuffer *buffer, size_t *n_read_out,
		enum evbuffer_eol_style eol_style)
{
	struct evbuffer_ptr it;
	char *line;
	size_t n_to_copy=0, extra_drain=0;
	char *result = NULL;

	EVBUFFER_LOCK(buffer);

	if (buffer->freeze_start) {
		goto done;
	}

	it = evbuffer_search_eol(buffer, NULL, &extra_drain, eol_style);
	if (it.pos < 0)
		goto done;
	n_to_copy = it.pos;

	if ((line = mm_malloc(n_to_copy+1)) == NULL) {
		event_warn(""%s: out of memory"", __func__);
		goto done;
	}

	evbuffer_remove(buffer, line, n_to_copy);
	line[n_to_copy] = '\0';

	evbuffer_drain(buffer, extra_drain);
	result = line;
done:
	EVBUFFER_UNLOCK(buffer);

	if (n_read_out)
		*n_read_out = result ? n_to_copy : 0;

	return result;
}

#define EVBUFFER_CHAIN_MAX_AUTO_SIZE 4096

/* Adds data to an event buffer */

int
evbuffer_add(struct evbuffer *buf, const void *data_in, size_t datlen)
{
	struct evbuffer_chain *chain, *tmp;
	const unsigned char *data = data_in;
	size_t remain, to_alloc;
	int result = -1;

	EVBUFFER_LOCK(buf);

	if (buf->freeze_end) {
		goto done;
	}
	/* Prevent buf->total_len overflow */
	if (datlen > EV_SIZE_MAX - buf->total_len) {
		goto done;
	}

	if (*buf->last_with_datap == NULL) {
		chain = buf->last;
	} else {
		chain = *buf->last_with_datap;
	}

	/* If there are no chains allocated for this buffer, allocate one
	 * big enough to hold all the data. */
	if (chain == NULL) {
		chain = evbuffer_chain_insert_new(buf, datlen);
		if (!chain)
			goto done;
	}

	if ((chain->flags & EVBUFFER_IMMUTABLE) == 0) {
		/* Always true for mutable buffers */
		EVUTIL_ASSERT(chain->misalign >= 0 &&
		    (ev_uint64_t)chain->misalign <= EVBUFFER_CHAIN_MAX);
		remain = chain->buffer_len - (size_t)chain->misalign - chain->off;
		if (remain >= datlen) {
			/* there's enough space to hold all the data in the
			 * current last chain */
			memcpy(chain->buffer + chain->misalign + chain->off,
			    data, datlen);
			chain->off += datlen;
			buf->total_len += datlen;
			buf->n_add_for_cb += datlen;
			goto out;
		} else if (!CHAIN_PINNED(chain) &&
		    evbuffer_chain_should_realign(chain, datlen)) {
			/* we can fit the data into the misalignment */
			evbuffer_chain_align(chain);

			memcpy(chain->buffer + chain->off, data, datlen);
			chain->off += datlen;
			buf->total_len += datlen;
			buf->n_add_for_cb += datlen;
			goto out;
		}
	} else {
		/* we cannot write any data to the last chain */
		remain = 0;
	}

	/* we need to add another chain */
	to_alloc = chain->buffer_len;
	if (to_alloc <= EVBUFFER_CHAIN_MAX_AUTO_SIZE/2)
		to_alloc <<= 1;
	if (datlen > to_alloc)
		to_alloc = datlen;
	tmp = evbuffer_chain_new_membuf(to_alloc);
	if (tmp == NULL)
		goto done;

	if (remain) {
		memcpy(chain->buffer + chain->misalign + chain->off,
		    data, remain);
		chain->off += remain;
		buf->total_len += remain;
		buf->n_add_for_cb += remain;
	}

	data += remain;
	datlen -= remain;

	memcpy(tmp->buffer, data, datlen);
	tmp->off = datlen;
	evbuffer_chain_insert(buf, tmp);
	buf->n_add_for_cb += datlen;

out:
	evbuffer_invoke_callbacks_(buf);
	result = 0;
done:
	EVBUFFER_UNLOCK(buf);
	return result;
}

int
evbuffer_prepend(struct evbuffer *buf, const void *data, size_t datlen)
{
	struct evbuffer_chain *chain, *tmp;
	int result = -1;

	EVBUFFER_LOCK(buf);

	if (datlen == 0) {
		result = 0;
		goto done;
	}
	if (buf->freeze_start) {
		goto done;
	}
	if (datlen > EV_SIZE_MAX - buf->total_len) {
		goto done;
	}

	chain = buf->first;

	if (chain == NULL) {
		chain = evbuffer_chain_insert_new(buf, datlen);
		if (!chain)
			goto done;
	}

	/* we cannot touch immutable buffers */
	if ((chain->flags & EVBUFFER_IMMUTABLE) == 0) {
		/* Always true for mutable buffers */
		EVUTIL_ASSERT(chain->misalign >= 0 &&
		    (ev_uint64_t)chain->misalign <= EVBUFFER_CHAIN_MAX);

		/* If this chain is empty, we can treat it as
		 * 'empty at the beginning' rather than 'empty at the end' */
		if (chain->off == 0)
			chain->misalign = chain->buffer_len;

		if ((size_t)chain->misalign >= datlen) {
			/* we have enough space to fit everything */
			memcpy(chain->buffer + chain->misalign - datlen,
			    data, datlen);
			chain->off += datlen;
			chain->misalign -= datlen;
			buf->total_len += datlen;
			buf->n_add_for_cb += datlen;
			goto out;
		} else if (chain->misalign) {
			/* we can only fit some of the data. */
			memcpy(chain->buffer,
			    (char*)data + datlen - chain->misalign,
			    (size_t)chain->misalign);
			chain->off += (size_t)chain->misalign;
			buf->total_len += (size_t)chain->misalign;
			buf->n_add_for_cb += (size_t)chain->misalign;
			datlen -= (size_t)chain->misalign;
			chain->misalign = 0;
		}
	}

	/* we need to add another chain */
	if ((tmp = evbuffer_chain_new_membuf(datlen)) == NULL)
		goto done;
	buf->first = tmp;
	if (buf->last_with_datap == &buf->first && chain->off)
		buf->last_with_datap = &tmp->next;

	tmp->next = chain;

	tmp->off = datlen;
	EVUTIL_ASSERT(datlen <= tmp->buffer_len);
	tmp->misalign = tmp->buffer_len - datlen;

	memcpy(tmp->buffer + tmp->misalign, data, datlen);
	buf->total_len += datlen;
	buf->n_add_for_cb += datlen;

out:
	evbuffer_invoke_callbacks_(buf);
	result = 0;
done:
	EVBUFFER_UNLOCK(buf);
	return result;
}

/** Helper: realigns the memory in chain->buffer so that misalign is 0. */
static void
evbuffer_chain_align(struct evbuffer_chain *chain)
{
	EVUTIL_ASSERT(!(chain->flags & EVBUFFER_IMMUTABLE));
	EVUTIL_ASSERT(!(chain->flags & EVBUFFER_MEM_PINNED_ANY));
	memmove(chain->buffer, chain->buffer + chain->misalign, chain->off);
	chain->misalign = 0;
}

#define MAX_TO_COPY_IN_EXPAND 4096
#define MAX_TO_REALIGN_IN_EXPAND 2048

/** Helper: return true iff we should realign chain to fit datalen bytes of
    data in it. */
static int
evbuffer_chain_should_realign(struct evbuffer_chain *chain,
    size_t datlen)
{
	return chain->buffer_len - chain->off >= datlen &&
	    (chain->off < chain->buffer_len / 2) &&
	    (chain->off <= MAX_TO_REALIGN_IN_EXPAND);
}

/* Expands the available space in the event buffer to at least datlen, all in
 * a single chunk.  Return that chunk. */
static struct evbuffer_chain *
evbuffer_expand_singlechain(struct evbuffer *buf, size_t datlen)
{
	struct evbuffer_chain *chain, **chainp;
	struct evbuffer_chain *result = NULL;
	ASSERT_EVBUFFER_LOCKED(buf);

	chainp = buf->last_with_datap;

	/* XXX If *chainp is no longer writeable, but has enough space in its
	 * misalign, this might be a bad idea: we could still use *chainp, not
	 * (*chainp)->next. */
	if (*chainp && CHAIN_SPACE_LEN(*chainp) == 0)
		chainp = &(*chainp)->next;

	/* 'chain' now points to the first chain with writable space (if any)
	 * We will either use it, realign it, replace it, or resize it. */
	chain = *chainp;

	if (chain == NULL ||
	    (chain->flags & (EVBUFFER_IMMUTABLE|EVBUFFER_MEM_PINNED_ANY))) {
		/* We can't use the last_with_data chain at all.  Just add a
		 * new one that's big enough. */
		goto insert_new;
	}

	/* If we can fit all the data, then we don't have to do anything */
	if (CHAIN_SPACE_LEN(chain) >= datlen) {
		result = chain;
		goto ok;
	}

	/* If the chain is completely empty, just replace it by adding a new
	 * empty chain. */
	if (chain->off == 0) {
		goto insert_new;
	}

	/* If the misalignment plus the remaining space fulfills our data
	 * needs, we could just force an alignment to happen.  Afterwards, we
	 * have enough space.  But only do this if we're saving a lot of space
	 * and not moving too much data.  Otherwise the space savings are
	 * probably offset by the time lost in copying.
	 */
	if (evbuffer_chain_should_realign(chain, datlen)) {
		evbuffer_chain_align(chain);
		result = chain;
		goto ok;
	}

	/* At this point, we can either resize the last chunk with space in
	 * it, use the next chunk after it, or   If we add a new chunk, we waste
	 * CHAIN_SPACE_LEN(chain) bytes in the former last chunk.  If we
	 * resize, we have to copy chain->off bytes.
	 */

	/* Would expanding this chunk be affordable and worthwhile? */
	if (CHAIN_SPACE_LEN(chain) < chain->buffer_len / 8 ||
	    chain->off > MAX_TO_COPY_IN_EXPAND ||
		datlen >= (EVBUFFER_CHAIN_MAX - chain->off)) {
		/* It's not worth resizing this chain. Can the next one be
		 * used? */
		if (chain->next && CHAIN_SPACE_LEN(chain->next) >= datlen) {
			/* Yes, we can just use the next chain (which should
			 * be empty. */
			result = chain->next;
			goto ok;
		} else {
			/* No; append a new chain (which will free all
			 * terminal empty chains.) */
			goto insert_new;
		}
	} else {
		/* Okay, we're going to try to resize this chain: Not doing so
		 * would waste at least 1/8 of its current allocation, and we
		 * can do so without having to copy more than
		 * MAX_TO_COPY_IN_EXPAND bytes. */
		/* figure out how much space we need */
		size_t length = chain->off + datlen;
		struct evbuffer_chain *tmp = evbuffer_chain_new_membuf(length);
		if (tmp == NULL)
			goto err;

		/* copy the data over that we had so far */
		tmp->off = chain->off;
		memcpy(tmp->buffer, chain->buffer + chain->misalign,
		    chain->off);
		/* fix up the list */
		EVUTIL_ASSERT(*chainp == chain);
		result = *chainp = tmp;

		if (buf->last == chain)
			buf->last = tmp;

		tmp->next = chain->next;
		evbuffer_chain_free(chain);
		goto ok;
	}

insert_new:
	result = evbuffer_chain_insert_new(buf, datlen);
	if (!result)
		goto err;
ok:
	EVUTIL_ASSERT(result);
	EVUTIL_ASSERT(CHAIN_SPACE_LEN(result) >= datlen);
err:
	return result;
}

/* Make sure that datlen bytes are available for writing in the last n
 * chains.  Never copies or moves data. */
int
evbuffer_expand_fast_(struct evbuffer *buf, size_t datlen, int n)
{
	struct evbuffer_chain *chain = buf->last, *tmp, *next;
	size_t avail;
	int used;

	ASSERT_EVBUFFER_LOCKED(buf);
	EVUTIL_ASSERT(n >= 2);

	if (chain == NULL || (chain->flags & EVBUFFER_IMMUTABLE)) {
		/* There is no last chunk, or we can't touch the last chunk.
		 * Just add a new chunk. */
		chain = evbuffer_chain_insert_new(buf, datlen);
		if (chain == NULL)
			return (-1);
		else
			return (0);
	}

	used = 0; /* number of chains we're using space in. */
	avail = 0; /* how much space they have. */
	/* How many bytes can we stick at the end of buffer as it is?  Iterate
	 * over the chains at the end of the buffer, tring to see how much
	 * space we have in the first n. */
	for (chain = *buf->last_with_datap; chain; chain = chain->next) {
		if (chain->off) {
			size_t space = (size_t) CHAIN_SPACE_LEN(chain);
			EVUTIL_ASSERT(chain == *buf->last_with_datap);
			if (space) {
				avail += space;
				++used;
			}
		} else {
			/* No data in chain; realign it. */
			chain->misalign = 0;
			avail += chain->buffer_len;
			++used;
		}
		if (avail >= datlen) {
			/* There is already enough space.  Just return */
			return (0);
		}
		if (used == n)
			break;
	}

	/* There wasn't enough space in the first n chains with space in
	 * them. Either add a new chain with enough space, or replace all
	 * empty chains with one that has enough space, depending on n. */
	if (used < n) {
		/* The loop ran off the end of the chains before it hit n
		 * chains; we can add another. */
		EVUTIL_ASSERT(chain == NULL);

		tmp = evbuffer_chain_new_membuf(datlen - avail);
		if (tmp == NULL)
			return (-1);

		buf->last->next = tmp;
		buf->last = tmp;
		/* (we would only set last_with_data if we added the first
		 * chain. But if the buffer had no chains, we would have
		 * just allocated a new chain earlier) */
		return (0);
	} else {
		/* Nuke _all_ the empty chains. */
		int rmv_all = 0; /* True iff we removed last_with_data. */
		chain = *buf->last_with_datap;
		if (!chain->off) {
			EVUTIL_ASSERT(chain == buf->first);
			rmv_all = 1;
			avail = 0;
		} else {
			/* can't overflow, since only mutable chains have
			 * huge misaligns. */
			avail = (size_t) CHAIN_SPACE_LEN(chain);
			chain = chain->next;
		}


		for (; chain; chain = next) {
			next = chain->next;
			EVUTIL_ASSERT(chain->off == 0);
			evbuffer_chain_free(chain);
		}
		EVUTIL_ASSERT(datlen >= avail);
		tmp = evbuffer_chain_new_membuf(datlen - avail);
		if (tmp == NULL) {
			if (rmv_all) {
				ZERO_CHAIN(buf);
			} else {
				buf->last = *buf->last_with_datap;
				(*buf->last_with_datap)->next = NULL;
			}
			return (-1);
		}

		if (rmv_all) {
			buf->first = buf->last = tmp;
			buf->last_with_datap = &buf->first;
		} else {
			(*buf->last_with_datap)->next = tmp;
			buf->last = tmp;
		}
		return (0);
	}
}

int
evbuffer_expand(struct evbuffer *buf, size_t datlen)
{
	struct evbuffer_chain *chain;

	EVBUFFER_LOCK(buf);
	chain = evbuffer_expand_singlechain(buf, datlen);
	EVBUFFER_UNLOCK(buf);
	return chain ? 0 : -1;
}

/*
 * Reads data from a file descriptor into a buffer.
 */

#if defined(EVENT__HAVE_SYS_UIO_H) || defined(_WIN32)
#define USE_IOVEC_IMPL
#endif

#ifdef USE_IOVEC_IMPL

#ifdef EVENT__HAVE_SYS_UIO_H
/* number of iovec we use for writev, fragmentation is going to determine
 * how much we end up writing */

#define DEFAULT_WRITE_IOVEC 128

#if defined(UIO_MAXIOV) && UIO_MAXIOV < DEFAULT_WRITE_IOVEC
#define NUM_WRITE_IOVEC UIO_MAXIOV
#elif defined(IOV_MAX) && IOV_MAX < DEFAULT_WRITE_IOVEC
#define NUM_WRITE_IOVEC IOV_MAX
#else
#define NUM_WRITE_IOVEC DEFAULT_WRITE_IOVEC
#endif

#define IOV_TYPE struct iovec
#define IOV_PTR_FIELD iov_base
#define IOV_LEN_FIELD iov_len
#define IOV_LEN_TYPE size_t
#else
#define NUM_WRITE_IOVEC 16
#define IOV_TYPE WSABUF
#define IOV_PTR_FIELD buf
#define IOV_LEN_FIELD len
#define IOV_LEN_TYPE unsigned long
#endif
#endif
#define NUM_READ_IOVEC 4

/** Helper function to figure out which space to use for reading data into
    an evbuffer.  Internal use only.

    @param buf The buffer to read into
    @param howmuch How much we want to read.
    @param vecs An array of two or more iovecs or WSABUFs.
    @param n_vecs_avail The length of vecs
    @param chainp A pointer to a variable to hold the first chain we're
      reading into.
    @param exact Boolean: if true, we do not provide more than 'howmuch'
      space in the vectors, even if more space is available.
    @return The number of buffers we're using.
 */
int
evbuffer_read_setup_vecs_(struct evbuffer *buf, ev_ssize_t howmuch,
    struct evbuffer_iovec *vecs, int n_vecs_avail,
    struct evbuffer_chain ***chainp, int exact)
{
	struct evbuffer_chain *chain;
	struct evbuffer_chain **firstchainp;
	size_t so_far;
	int i;
	ASSERT_EVBUFFER_LOCKED(buf);

	if (howmuch < 0)
		return -1;

	so_far = 0;
	/* Let firstchain be the first chain with any space on it */
	firstchainp = buf->last_with_datap;
	EVUTIL_ASSERT(*firstchainp);
	if (CHAIN_SPACE_LEN(*firstchainp) == 0) {
		firstchainp = &(*firstchainp)->next;
	}

	chain = *firstchainp;
	EVUTIL_ASSERT(chain);
	for (i = 0; i < n_vecs_avail && so_far < (size_t)howmuch; ++i) {
		size_t avail = (size_t) CHAIN_SPACE_LEN(chain);
		if (avail > (howmuch - so_far) && exact)
			avail = howmuch - so_far;
		vecs[i].iov_base = (void *)CHAIN_SPACE_PTR(chain);
		vecs[i].iov_len = avail;
		so_far += avail;
		chain = chain->next;
	}

	*chainp = firstchainp;
	return i;
}

static int
get_n_bytes_readable_on_socket(evutil_socket_t fd)
{
#if defined(FIONREAD) && defined(_WIN32)
	unsigned long lng = EVBUFFER_MAX_READ_DEFAULT;
	if (ioctlsocket(fd, FIONREAD, &lng) < 0)
		return -1;
	/* Can overflow, but mostly harmlessly. XXXX */
	return (int)lng;
#elif defined(FIONREAD)
	int n = EVBUFFER_MAX_READ_DEFAULT;
	if (ioctl(fd, FIONREAD, &n) < 0)
		return -1;
	return n;
#else
	return EVBUFFER_MAX_READ_DEFAULT;
#endif
}

/* TODO(niels): should this function return ev_ssize_t and take ev_ssize_t
 * as howmuch? */
int
evbuffer_read(struct evbuffer *buf, evutil_socket_t fd, int howmuch)
{
	int n;
	int result;

#ifdef USE_IOVEC_IMPL
	struct evbuffer_chain **chainp;
	int nvecs, i, remaining;
#else
	struct evbuffer_chain *chain;
	unsigned char *p;
#endif

	EVBUFFER_LOCK(buf);

	if (buf->freeze_end) {
		result = -1;
		goto done;
	}

	n = get_n_bytes_readable_on_socket(fd);
	if (n <= 0 || n > (int)buf->max_read)
		n = (int)buf->max_read;
	if (howmuch < 0 || howmuch > n)
		howmuch = n;

#ifdef USE_IOVEC_IMPL
	/* Since we can use iovecs, we're willing to use the last
	 * NUM_READ_IOVEC chains. */
	if (evbuffer_expand_fast_(buf, howmuch, NUM_READ_IOVEC) == -1) {
		result = -1;
		goto done;
	} else {
		IOV_TYPE vecs[NUM_READ_IOVEC];
#ifdef EVBUFFER_IOVEC_IS_NATIVE_
		nvecs = evbuffer_read_setup_vecs_(buf, howmuch, vecs,
		    NUM_READ_IOVEC, &chainp, 1);
#else
		/* We aren't using the native struct iovec.  Therefore,
		   we are on win32. */
		struct evbuffer_iovec ev_vecs[NUM_READ_IOVEC];
		nvecs = evbuffer_read_setup_vecs_(buf, howmuch, ev_vecs, 2,
		    &chainp, 1);

		for (i=0; i < nvecs; ++i)
			WSABUF_FROM_EVBUFFER_IOV(&vecs[i], &ev_vecs[i]);
#endif

#ifdef _WIN32
		{
			DWORD bytesRead;
			DWORD flags=0;
			if (WSARecv(fd, vecs, nvecs, &bytesRead, &flags, NULL, NULL)) {
				/* The read failed. It might be a close,
				 * or it might be an error. */
				if (WSAGetLastError() == WSAECONNABORTED)
					n = 0;
				else
					n = -1;
			} else
				n = bytesRead;
		}
#else
		/* TODO(panjf2000): wrap it with `unlikely` as compiler hint? */
		if (nvecs == 1)
			n = read(fd, vecs[0].IOV_PTR_FIELD, vecs[0].IOV_LEN_FIELD);
		else
			n = readv(fd, vecs, nvecs);
#endif
	}

#else /*!USE_IOVEC_IMPL*/
	/* If we don't have FIONREAD, we might waste some space here */
	/* XXX we _will_ waste some space here if there is any space left
	 * over on buf->last. */
	if ((chain = evbuffer_expand_singlechain(buf, howmuch)) == NULL) {
		result = -1;
		goto done;
	}

	/* We can append new data at this point */
	p = chain->buffer + chain->misalign + chain->off;

#ifndef _WIN32
	n = read(fd, p, howmuch);
#else
	n = recv(fd, p, howmuch, 0);
#endif
#endif /* USE_IOVEC_IMPL */

	if (n == -1) {
		result = -1;
		goto done;
	}
	if (n == 0) {
		result = 0;
		goto done;
	}

#ifdef USE_IOVEC_IMPL
	remaining = n;
	for (i=0; i < nvecs; ++i) {
		/* can't overflow, since only mutable chains have
		 * huge misaligns. */
		size_t space = (size_t) CHAIN_SPACE_LEN(*chainp);
		/* XXXX This is a kludge that can waste space in perverse
		 * situations. */
		if (space > EVBUFFER_CHAIN_MAX)
			space = EVBUFFER_CHAIN_MAX;
		if ((ev_ssize_t)space < remaining) {
			(*chainp)->off += space;
			remaining -= (int)space;
		} else {
			(*chainp)->off += remaining;
			buf->last_with_datap = chainp;
			break;
		}
		chainp = &(*chainp)->next;
	}
#else
	chain->off += n;
	advance_last_with_data(buf);
#endif
	buf->total_len += n;
	buf->n_add_for_cb += n;

	/* Tell someone about changes in this buffer */
	evbuffer_invoke_callbacks_(buf);
	result = n;
done:
	EVBUFFER_UNLOCK(buf);
	return result;
}

#ifdef USE_IOVEC_IMPL
static inline int
evbuffer_write_iovec(struct evbuffer *buffer, evutil_socket_t fd,
    ev_ssize_t howmuch)
{
	IOV_TYPE iov[NUM_WRITE_IOVEC];
	struct evbuffer_chain *chain = buffer->first;
	int n, i = 0;

	if (howmuch < 0)
		return -1;

	ASSERT_EVBUFFER_LOCKED(buffer);
	/* XXX make this top out at some maximal data length?  if the
	 * buffer has (say) 1MB in it, split over 128 chains, there's
	 * no way it all gets written in one go. */
	while (chain != NULL && i < NUM_WRITE_IOVEC && howmuch) {
#ifdef USE_SENDFILE
		/* we cannot write the file info via writev */
		if (chain->flags & EVBUFFER_SENDFILE)
			break;
#endif
		iov[i].IOV_PTR_FIELD = (void *) (chain->buffer + chain->misalign);
		if ((size_t)howmuch >= chain->off) {
			/* XXXcould be problematic when windows supports mmap*/
			iov[i++].IOV_LEN_FIELD = (IOV_LEN_TYPE)chain->off;
			howmuch -= chain->off;
		} else {
			/* XXXcould be problematic when windows supports mmap*/
			iov[i++].IOV_LEN_FIELD = (IOV_LEN_TYPE)howmuch;
			break;
		}
		chain = chain->next;
	}
	if (! i)
		return 0;

#ifdef _WIN32
	{
		DWORD bytesSent;
		if (WSASend(fd, iov, i, &bytesSent, 0, NULL, NULL))
			n = -1;
		else
			n = bytesSent;
	}
#else
	/* TODO(panjf2000): wrap it with `unlikely` as compiler hint? */
	if (i == 1)
		n = write(fd, iov[0].IOV_PTR_FIELD, iov[0].IOV_LEN_FIELD);
	else
		n = writev(fd, iov, i);
#endif
	return (n);
}
#endif

#ifdef USE_SENDFILE
static inline int
evbuffer_write_sendfile(struct evbuffer *buffer, evutil_socket_t dest_fd,
    ev_ssize_t howmuch)
{
	struct evbuffer_chain *chain = buffer->first;
	struct evbuffer_chain_file_segment *info =
	    EVBUFFER_CHAIN_EXTRA(struct evbuffer_chain_file_segment,
		chain);
	const int source_fd = info->segment->fd;
#if defined(SENDFILE_IS_MACOSX) || defined(SENDFILE_IS_FREEBSD)
	int res;
	ev_off_t len = chain->off;
#elif defined(SENDFILE_IS_LINUX) || defined(SENDFILE_IS_SOLARIS)
	ev_ssize_t res;
	off_t offset = chain->misalign;
#endif

	ASSERT_EVBUFFER_LOCKED(buffer);

#if defined(SENDFILE_IS_MACOSX)
	res = sendfile(source_fd, dest_fd, chain->misalign, &len, NULL, 0);
	if (res == -1 && !EVUTIL_ERR_RW_RETRIABLE(errno))
		return (-1);

	return (len);
#elif defined(SENDFILE_IS_FREEBSD)
	res = sendfile(source_fd, dest_fd, chain->misalign, chain->off, NULL, &len, 0);
	if (res == -1 && !EVUTIL_ERR_RW_RETRIABLE(errno))
		return (-1);

	return (len);
#elif defined(SENDFILE_IS_LINUX)
	res = sendfile(dest_fd, source_fd, &offset, chain->off);
	if (res == -1 && EVUTIL_ERR_RW_RETRIABLE(errno)) {
		/* if this is EAGAIN or EINTR return 0; otherwise, -1 */
		return (0);
	}
	return (res);
#elif defined(SENDFILE_IS_SOLARIS)
	{
		const off_t offset_orig = offset;
		res = sendfile(dest_fd, source_fd, &offset, chain->off);
		if (res == -1 && EVUTIL_ERR_RW_RETRIABLE(errno)) {
			if (offset - offset_orig)
				return offset - offset_orig;
			/* if this is EAGAIN or EINTR and no bytes were
			 * written, return 0 */
			return (0);
		}
		return (res);
	}
#endif
}
#endif

int
evbuffer_write_atmost(struct evbuffer *buffer, evutil_socket_t fd,
    ev_ssize_t howmuch)
{
	int n = -1;

	EVBUFFER_LOCK(buffer);

	if (buffer->freeze_start) {
		goto done;
	}

	if (howmuch < 0 || (size_t)howmuch > buffer->total_len)
		howmuch = buffer->total_len;

	if (howmuch > 0) {
#ifdef USE_SENDFILE
		struct evbuffer_chain *chain = buffer->first;
		if (chain != NULL && (chain->flags & EVBUFFER_SENDFILE))
			n = evbuffer_write_sendfile(buffer, fd, howmuch);
		else {
#endif
#ifdef USE_IOVEC_IMPL
		n = evbuffer_write_iovec(buffer, fd, howmuch);
#elif defined(_WIN32)
		/* XXX(nickm) Don't disable this code until we know if
		 * the WSARecv code above works. */
		void *p = evbuffer_pullup(buffer, howmuch);
		EVUTIL_ASSERT(p || !howmuch);
		n = send(fd, p, howmuch, 0);
#else
		void *p = evbuffer_pullup(buffer, howmuch);
		EVUTIL_ASSERT(p || !howmuch);
		n = write(fd, p, howmuch);
#endif
#ifdef USE_SENDFILE
		}
#endif
	}

	if (n > 0)
		evbuffer_drain(buffer, n);

done:
	EVBUFFER_UNLOCK(buffer);
	return (n);
}

int
evbuffer_write(struct evbuffer *buffer, evutil_socket_t fd)
{
	return evbuffer_write_atmost(buffer, fd, -1);
}

unsigned char *
evbuffer_find(struct evbuffer *buffer, const unsigned char *what, size_t len)
{
	unsigned char *search;
	struct evbuffer_ptr ptr;

	EVBUFFER_LOCK(buffer);

	ptr = evbuffer_search(buffer, (const char *)what, len, NULL);
	if (ptr.pos < 0) {
		search = NULL;
	} else {
		search = evbuffer_pullup(buffer, ptr.pos + len);
		if (search)
			search += ptr.pos;
	}
	EVBUFFER_UNLOCK(buffer);
	return search;
}

/* Subract <b>howfar</b> from the position of <b>pos</b> within
 * <b>buf</b>. Returns 0 on success, -1 on failure.
 *
 * This isn't exposed yet, because of potential inefficiency issues.
 * Maybe it should be. */
static int
evbuffer_ptr_subtract(struct evbuffer *buf, struct evbuffer_ptr *pos,
    size_t howfar)
{
	if (pos->pos < 0)
		return -1;
	if (howfar > (size_t)pos->pos)
		return -1;
	if (pos->internal_.chain && howfar <= pos->internal_.pos_in_chain) {
		pos->internal_.pos_in_chain -= howfar;
		pos->pos -= howfar;
		return 0;
	} else {
		const size_t newpos = pos->pos - howfar;
		/* Here's the inefficient part: it walks over the
		 * chains until we hit newpos. */
		return evbuffer_ptr_set(buf, pos, newpos, EVBUFFER_PTR_SET);
	}
}

int
evbuffer_ptr_set(struct evbuffer *buf, struct evbuffer_ptr *pos,
    size_t position, enum evbuffer_ptr_how how)
{
	size_t left = position;
	struct evbuffer_chain *chain = NULL;
	int result = 0;

	EVBUFFER_LOCK(buf);

	switch (how) {
	case EVBUFFER_PTR_SET:
		chain = buf->first;
		pos->pos = position;
		position = 0;
		break;
	case EVBUFFER_PTR_ADD:
		/* this avoids iterating over all previous chains if
		   we just want to advance the position */
		if (pos->pos < 0 || EV_SIZE_MAX - position < (size_t)pos->pos) {
			EVBUFFER_UNLOCK(buf);
			return -1;
		}
		chain = pos->internal_.chain;
		pos->pos += position;
		position = pos->internal_.pos_in_chain;
		break;
	}

	EVUTIL_ASSERT(EV_SIZE_MAX - left >= position);
	while (chain && position + left >= chain->off) {
		left -= chain->off - position;
		chain = chain->next;
		position = 0;
	}
	if (chain) {
		pos->internal_.chain = chain;
		pos->internal_.pos_in_chain = position + left;
	} else if (left == 0) {
		/* The first byte in the (nonexistent) chain after the last chain */
		pos->internal_.chain = NULL;
		pos->internal_.pos_in_chain = 0;
	} else {
		PTR_NOT_FOUND(pos);
		result = -1;
	}

	EVBUFFER_UNLOCK(buf);

	return result;
}

/**
   Compare the bytes in buf at position pos to the len bytes in mem.  Return
   less than 0, 0, or greater than 0 as memcmp.
 */
static int
evbuffer_ptr_memcmp(const struct evbuffer *buf, const struct evbuffer_ptr *pos,
    const char *mem, size_t len)
{
	struct evbuffer_chain *chain;
	size_t position;
	int r;

	ASSERT_EVBUFFER_LOCKED(buf);

	if (pos->pos < 0 ||
	    EV_SIZE_MAX - len < (size_t)pos->pos ||
	    pos->pos + len > buf->total_len)
		return -1;

	chain = pos->internal_.chain;
	position = pos->internal_.pos_in_chain;
	while (len && chain) {
		size_t n_comparable;
		if (len + position > chain->off)
			n_comparable = chain->off - position;
		else
			n_comparable = len;
		r = memcmp(chain->buffer + chain->misalign + position, mem,
		    n_comparable);
		if (r)
			return r;
		mem += n_comparable;
		len -= n_comparable;
		position = 0;
		chain = chain->next;
	}

	return 0;
}

struct evbuffer_ptr
evbuffer_search(struct evbuffer *buffer, const char *what, size_t len, const struct evbuffer_ptr *start)
{
	return evbuffer_search_range(buffer, what, len, start, NULL);
}

struct evbuffer_ptr
evbuffer_search_range(struct evbuffer *buffer, const char *what, size_t len, const struct evbuffer_ptr *start, const struct evbuffer_ptr *end)
{
	struct evbuffer_ptr pos;
	struct evbuffer_chain *chain, *last_chain = NULL;
	const unsigned char *p;
	char first;

	EVBUFFER_LOCK(buffer);

	if (start) {
		memcpy(&pos, start, sizeof(pos));
		chain = pos.internal_.chain;
	} else {
		pos.pos = 0;
		chain = pos.internal_.chain = buffer->first;
		pos.internal_.pos_in_chain = 0;
	}

	if (end)
		last_chain = end->internal_.chain;

	if (!len || len > EV_SSIZE_MAX)
		goto done;

	first = what[0];

	while (chain) {
		const unsigned char *start_at =
		    chain->buffer + chain->misalign +
		    pos.internal_.pos_in_chain;
		p = memchr(start_at, first,
		    chain->off - pos.internal_.pos_in_chain);
		if (p) {
			pos.pos += p - start_at;
			pos.internal_.pos_in_chain += p - start_at;
			if (!evbuffer_ptr_memcmp(buffer, &pos, what, len)) {
				if (end && pos.pos + (ev_ssize_t)len > end->pos)
					goto not_found;
				else
					goto done;
			}
			++pos.pos;
			++pos.internal_.pos_in_chain;
			if (pos.internal_.pos_in_chain == chain->off) {
				chain = pos.internal_.chain = chain->next;
				pos.internal_.pos_in_chain = 0;
			}
		} else {
			if (chain == last_chain)
				goto not_found;
			pos.pos += chain->off - pos.internal_.pos_in_chain;
			chain = pos.internal_.chain = chain->next;
			pos.internal_.pos_in_chain = 0;
		}
	}

not_found:
	PTR_NOT_FOUND(&pos);
done:
	EVBUFFER_UNLOCK(buffer);
	return pos;
}

int
evbuffer_peek(struct evbuffer *buffer, ev_ssize_t len,
    struct evbuffer_ptr *start_at,
    struct evbuffer_iovec *vec, int n_vec)
{
	struct evbuffer_chain *chain;
	int idx = 0;
	ev_ssize_t len_so_far = 0;

	/* Avoid locking in trivial edge cases */
	if (start_at && start_at->internal_.chain == NULL)
		return 0;

	EVBUFFER_LOCK(buffer);

	if (start_at) {
		chain = start_at->internal_.chain;
		len_so_far = chain->off
		    - start_at->internal_.pos_in_chain;
		idx = 1;
		if (n_vec > 0) {
			vec[0].iov_base = (void *)(chain->buffer + chain->misalign
			    + start_at->internal_.pos_in_chain);
			vec[0].iov_len = len_so_far;
		}
		chain = chain->next;
	} else {
		chain = buffer->first;
	}

	if (n_vec == 0 && len < 0) {
		/* If no vectors are provided and they asked for ""everything"",
		 * pretend they asked for the actual available amount. */
		len = buffer->total_len;
		if (start_at) {
			len -= start_at->pos;
		}
	}

	while (chain) {
		if (len >= 0 && len_so_far >= len)
			break;
		if (idx<n_vec) {
			vec[idx].iov_base = (void *)(chain->buffer + chain->misalign);
			vec[idx].iov_len = chain->off;
		} else if (len<0) {
			break;
		}
		++idx;
		len_so_far += chain->off;
		chain = chain->next;
	}

	EVBUFFER_UNLOCK(buffer);

	return idx;
}


int
evbuffer_add_vprintf(struct evbuffer *buf, const char *fmt, va_list ap)
{
	char *buffer;
	size_t space;
	int sz, result = -1;
	va_list aq;
	struct evbuffer_chain *chain;


	EVBUFFER_LOCK(buf);

	if (buf->freeze_end) {
		goto done;
	}

	/* make sure that at least some space is available */
	if ((chain = evbuffer_expand_singlechain(buf, 64)) == NULL)
		goto done;

	for (;;) {
#if 0
		size_t used = chain->misalign + chain->off;
		buffer = (char *)chain->buffer + chain->misalign + chain->off;
		EVUTIL_ASSERT(chain->buffer_len >= used);
		space = chain->buffer_len - used;
#endif
		buffer = (char*) CHAIN_SPACE_PTR(chain);
		space = (size_t) CHAIN_SPACE_LEN(chain);

#ifndef va_copy
#define	va_copy(dst, src)	memcpy(&(dst), &(src), sizeof(va_list))
#endif
		va_copy(aq, ap);

		sz = evutil_vsnprintf(buffer, space, fmt, aq);

		va_end(aq);

		if (sz < 0)
			goto done;
		if (INT_MAX >= EVBUFFER_CHAIN_MAX &&
		    (size_t)sz >= EVBUFFER_CHAIN_MAX)
			goto done;
		if ((size_t)sz < space) {
			chain->off += sz;
			buf->total_len += sz;
			buf->n_add_for_cb += sz;

			advance_last_with_data(buf);
			evbuffer_invoke_callbacks_(buf);
			result = sz;
			goto done;
		}
		if ((chain = evbuffer_expand_singlechain(buf, sz + 1)) == NULL)
			goto done;
	}
	/* NOTREACHED */

done:
	EVBUFFER_UNLOCK(buf);
	return result;
}

int
evbuffer_add_printf(struct evbuffer *buf, const char *fmt, ...)
{
	int res = -1;
	va_list ap;

	va_start(ap, fmt);
	res = evbuffer_add_vprintf(buf, fmt, ap);
	va_end(ap);

	return (res);
}

int
evbuffer_add_reference(struct evbuffer *outbuf,
    const void *data, size_t datlen,
    evbuffer_ref_cleanup_cb cleanupfn, void *extra)
{
	return evbuffer_add_reference_with_offset(outbuf, data, /* offset= */ 0, datlen, cleanupfn, extra);
}

int
evbuffer_add_reference_with_offset(struct evbuffer *outbuf, const void *data,
	size_t offset, size_t datlen, evbuffer_ref_cleanup_cb cleanupfn,
	void *extra)
{
	struct evbuffer_chain *chain;
	struct evbuffer_chain_reference *info;
	int result = -1;

	chain = evbuffer_chain_new(sizeof(struct evbuffer_chain_reference));
	if (!chain)
		return (-1);
	chain->flags |= EVBUFFER_REFERENCE | EVBUFFER_IMMUTABLE;
	chain->buffer = (unsigned char *)data;
	chain->misalign = offset;
	chain->buffer_len = offset + datlen;
	chain->off = datlen;

	info = EVBUFFER_CHAIN_EXTRA(struct evbuffer_chain_reference, chain);
	info->cleanupfn = cleanupfn;
	info->extra = extra;

	EVBUFFER_LOCK(outbuf);
	if (outbuf->freeze_end) {
		/* don't call chain_free; we do not want to actually invoke
		 * the cleanup function */
		mm_free(chain);
		goto done;
	}
	evbuffer_chain_insert(outbuf, chain);
	outbuf->n_add_for_cb += datlen;

	evbuffer_invoke_callbacks_(outbuf);

	result = 0;
done:
	EVBUFFER_UNLOCK(outbuf);

	return result;
}

/* TODO(niels): we may want to add to automagically convert to mmap, in
 * case evbuffer_remove() or evbuffer_pullup() are being used.
 */
struct evbuffer_file_segment *
evbuffer_file_segment_new(
	int fd, ev_off_t offset, ev_off_t length, unsigned flags)
{
	struct evbuffer_file_segment *seg =
	    mm_calloc(1, sizeof(struct evbuffer_file_segment));
	if (!seg)
		return NULL;
	seg->refcnt = 1;
	seg->fd = fd;
	seg->flags = flags;
	seg->file_offset = offset;
	seg->cleanup_cb = NULL;
	seg->cleanup_cb_arg = NULL;
#ifdef _WIN32
#ifndef lseek
#define lseek _lseeki64
#endif
#ifndef fstat
#define fstat _fstat
#endif
#ifndef stat
#define stat _stat
#endif
#endif
	if (length == -1) {
		struct stat st;
		if (fstat(fd, &st) < 0)
			goto err;
		length = st.st_size;
	}
	seg->length = length;

	if (offset < 0 || length < 0 ||
	    ((ev_uint64_t)length > EVBUFFER_CHAIN_MAX) ||
	    (ev_uint64_t)offset > (ev_uint64_t)(EVBUFFER_CHAIN_MAX - length))
		goto err;

#if defined(USE_SENDFILE)
	if (!(flags & EVBUF_FS_DISABLE_SENDFILE)) {
		seg->can_sendfile = 1;
		goto done;
	}
#endif

	if (evbuffer_file_segment_materialize(seg)<0)
		goto err;

#if defined(USE_SENDFILE)
done:
#endif
	if (!(flags & EVBUF_FS_DISABLE_LOCKING)) {
		EVTHREAD_ALLOC_LOCK(seg->lock, 0);
	}
	return seg;
err:
	mm_free(seg);
	return NULL;
}

#ifdef EVENT__HAVE_MMAP
static long
get_page_size(void)
{
#ifdef SC_PAGE_SIZE
	return sysconf(SC_PAGE_SIZE);
#elif defined(_SC_PAGE_SIZE)
	return sysconf(_SC_PAGE_SIZE);
#else
	return 1;
#endif
}
#endif

/* DOCDOC */
/* Requires lock */
static int
evbuffer_file_segment_materialize(struct evbuffer_file_segment *seg)
{
#if defined(EVENT__HAVE_MMAP) || defined(_WIN32)
	const unsigned flags = seg->flags;
#endif
	const int fd = seg->fd;
	const ev_off_t length = seg->length;
	const ev_off_t offset = seg->file_offset;

	if (seg->contents || seg->is_mapping)
		return 0; /* already materialized */

#if defined(EVENT__HAVE_MMAP)
	if (!(flags & EVBUF_FS_DISABLE_MMAP)) {
		off_t offset_rounded = 0, offset_leftover = 0;
		void *mapped;
		if (offset) {
			/* mmap implementations don't generally like us
			 * to have an offset that isn't a round  */
			long page_size = get_page_size();
			if (page_size == -1)
				goto err;
			offset_leftover = offset % page_size;
			offset_rounded = offset - offset_leftover;
		}
#if defined(EVENT__HAVE_MMAP64)
		mapped = mmap64(NULL, length + offset_leftover,
#else
		mapped = mmap(NULL, length + offset_leftover,
#endif
		    PROT_READ,
#ifdef MAP_NOCACHE
		    MAP_NOCACHE | /* ??? */
#endif
#ifdef MAP_FILE
		    MAP_FILE |
#endif
		    MAP_PRIVATE,
		    fd, offset_rounded);
		if (mapped == MAP_FAILED) {
			event_warn(""%s: mmap(%d, %d, %zu) failed"",
			    __func__, fd, 0, (size_t)(offset + length));
		} else {
			seg->mapping = mapped;
			seg->contents = (char*)mapped+offset_leftover;
			seg->mmap_offset = 0;
			seg->is_mapping = 1;
			goto done;
		}
	}
#endif
#ifdef _WIN32
	if (!(flags & EVBUF_FS_DISABLE_MMAP)) {
		intptr_t h = _get_osfhandle(fd);
		HANDLE m;
		ev_uint64_t total_size = length+offset;
		if ((HANDLE)h == INVALID_HANDLE_VALUE)
			goto err;
		m = CreateFileMapping((HANDLE)h, NULL, PAGE_READONLY,
		    (total_size >> 32), total_size & 0xfffffffful,
		    NULL);
		if (m != INVALID_HANDLE_VALUE) { /* Does h leak? */
			seg->mapping_handle = m;
			seg->mmap_offset = offset;
			seg->is_mapping = 1;
			goto done;
		}
	}
#endif
	{
		ev_off_t read_so_far = 0;
		ev_ssize_t n = 0;
		char *mem;
#ifndef EVENT__HAVE_PREAD
		ev_off_t start_pos = lseek(fd, 0, SEEK_CUR);
		ev_off_t pos;
		int e;
#endif /* no pread() */
		if (!(mem = mm_malloc(length)))
			goto err;
#ifdef EVENT__HAVE_PREAD
		while (read_so_far < length) {
			n = pread(fd, mem + read_so_far, length - read_so_far,
				  offset + read_so_far);
			if (n <= 0)
				break;
			read_so_far += n;
		}
		if (n < 0 || (n == 0 && length > read_so_far)) {
			mm_free(mem);
			goto err;
		}
#else /* fallback to seek() and read() */
		if (start_pos < 0) {
			mm_free(mem);
			goto err;
		}
		if (lseek(fd, offset, SEEK_SET) < 0) {
			mm_free(mem);
			goto err;
		}
		while (read_so_far < length) {
			n = read(fd, mem+read_so_far, length-read_so_far);
			if (n <= 0)
				break;
			read_so_far += n;
		}

		e = errno;
		pos = lseek(fd, start_pos, SEEK_SET);
		if (n < 0 || (n == 0 && length > read_so_far)) {
			mm_free(mem);
			errno = e;
			goto err;
		} else if (pos < 0) {
			mm_free(mem);
			goto err;
		}
#endif /* pread */

		seg->contents = mem;
	}
#if defined(EVENT__HAVE_MMAP) || defined(_WIN32)
done:
#endif
	return 0;
err:
	return -1;
}

void evbuffer_file_segment_add_cleanup_cb(struct evbuffer_file_segment *seg,
	evbuffer_file_segment_cleanup_cb cb, void* arg)
{
	EVUTIL_ASSERT(seg->refcnt > 0);
	seg->cleanup_cb = cb;
	seg->cleanup_cb_arg = arg;
}

void
evbuffer_file_segment_free(struct evbuffer_file_segment *seg)
{
	int refcnt;
	EVLOCK_LOCK(seg->lock, 0);
	refcnt = --seg->refcnt;
	EVLOCK_UNLOCK(seg->lock, 0);
	if (refcnt > 0)
		return;
	EVUTIL_ASSERT(refcnt == 0);

	if (seg->is_mapping) {
#ifdef _WIN32
		CloseHandle(seg->mapping_handle);
#elif defined (EVENT__HAVE_MMAP)
		off_t offset_leftover;
		offset_leftover = seg->file_offset % get_page_size();
		if (munmap(seg->mapping, seg->length + offset_leftover) == -1)
			event_warn(""%s: munmap failed"", __func__);
#endif
	} else if (seg->contents) {
		mm_free(seg->contents);
	}

	if ((seg->flags & EVBUF_FS_CLOSE_ON_FREE) && seg->fd >= 0) {
		close(seg->fd);
	}

	if (seg->cleanup_cb) {
		(*seg->cleanup_cb)((struct evbuffer_file_segment const*)seg,
		    seg->flags, seg->cleanup_cb_arg);
		seg->cleanup_cb = NULL;
		seg->cleanup_cb_arg = NULL;
	}

	EVTHREAD_FREE_LOCK(seg->lock, 0);
	mm_free(seg);
}

int
evbuffer_add_file_segment(struct evbuffer *buf,
    struct evbuffer_file_segment *seg, ev_off_t offset, ev_off_t length)
{
	struct evbuffer_chain *chain;
	struct evbuffer_chain_file_segment *extra;
	int can_use_sendfile = 0;

	EVBUFFER_LOCK(buf);
	EVLOCK_LOCK(seg->lock, 0);
	if (buf->flags & EVBUFFER_FLAG_DRAINS_TO_FD) {
		can_use_sendfile = 1;
	} else {
		if (evbuffer_file_segment_materialize(seg)<0) {
			EVLOCK_UNLOCK(seg->lock, 0);
			goto err;
		}
	}
	EVLOCK_UNLOCK(seg->lock, 0);

	if (buf->freeze_end)
		goto err;

	if (length < 0) {
		if (offset > seg->length)
			goto err;
		length = seg->length - offset;
	}

	/* Can we actually add this? */
	if (offset+length > seg->length)
		goto err;

	chain = evbuffer_chain_new(sizeof(struct evbuffer_chain_file_segment));
	if (!chain)
		goto err;
	extra = EVBUFFER_CHAIN_EXTRA(struct evbuffer_chain_file_segment, chain);

	chain->flags |= EVBUFFER_IMMUTABLE|EVBUFFER_FILESEGMENT;
	if (can_use_sendfile && seg->can_sendfile) {
		chain->flags |= EVBUFFER_SENDFILE;
		chain->misalign = seg->file_offset + offset;
		chain->off = length;
		chain->buffer_len = chain->misalign + length;
	} else if (seg->is_mapping) {
#ifdef _WIN32
		ev_uint64_t total_offset = seg->mmap_offset+offset;
		ev_uint64_t offset_rounded=0, offset_remaining=0;
		LPVOID data;
		if (total_offset) {
			SYSTEM_INFO si;
			memset(&si, 0, sizeof(si)); /* cargo cult */
			GetSystemInfo(&si);
			offset_remaining = total_offset % si.dwAllocationGranularity;
			offset_rounded = total_offset - offset_remaining;
		}
		data = MapViewOfFile(
			seg->mapping_handle,
			FILE_MAP_READ,
			offset_rounded >> 32,
			offset_rounded & 0xfffffffful,
			length + offset_remaining);
		if (data == NULL) {
			mm_free(chain);
			goto err;
		}
		chain->buffer = (unsigned char*) data;
		chain->buffer_len = length+offset_remaining;
		chain->misalign = offset_remaining;
		chain->off = length;
#else
		chain->buffer = (unsigned char*)(seg->contents + offset);
		chain->buffer_len = length;
		chain->off = length;
#endif
	} else {
		chain->buffer = (unsigned char*)(seg->contents + offset);
		chain->buffer_len = length;
		chain->off = length;
	}

	EVLOCK_LOCK(seg->lock, 0);
	++seg->refcnt;
	EVLOCK_UNLOCK(seg->lock, 0);
	extra->segment = seg;
	buf->n_add_for_cb += length;
	evbuffer_chain_insert(buf, chain);

	evbuffer_invoke_callbacks_(buf);

	EVBUFFER_UNLOCK(buf);

	return 0;
err:
	EVBUFFER_UNLOCK(buf);
	evbuffer_file_segment_free(seg); /* Lowers the refcount */
	return -1;
}

int
evbuffer_add_file(struct evbuffer *buf, int fd, ev_off_t offset, ev_off_t length)
{
	struct evbuffer_file_segment *seg;
	unsigned flags = EVBUF_FS_CLOSE_ON_FREE;
	int r;

	seg = evbuffer_file_segment_new(fd, offset, length, flags);
	if (!seg)
		return -1;
	r = evbuffer_add_file_segment(buf, seg, 0, length);
	if (r == 0)
		evbuffer_file_segment_free(seg);
	return r;
}

int
evbuffer_setcb(struct evbuffer *buffer, evbuffer_cb cb, void *cbarg)
{
	EVBUFFER_LOCK(buffer);

	if (!LIST_EMPTY(&buffer->callbacks))
		evbuffer_remove_all_callbacks(buffer);

	if (cb) {
		struct evbuffer_cb_entry *ent =
		    evbuffer_add_cb(buffer, NULL, cbarg);
		if (!ent) {
			EVBUFFER_UNLOCK(buffer);
			return -1;
		}
		ent->cb.cb_obsolete = cb;
		ent->flags |= EVBUFFER_CB_OBSOLETE;
	}
	EVBUFFER_UNLOCK(buffer);
	return 0;
}

struct evbuffer_cb_entry *
evbuffer_add_cb(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg)
{
	struct evbuffer_cb_entry *e;
	if (! (e = mm_calloc(1, sizeof(struct evbuffer_cb_entry))))
		return NULL;
	EVBUFFER_LOCK(buffer);
	e->cb.cb_func = cb;
	e->cbarg = cbarg;
	e->flags = EVBUFFER_CB_ENABLED;
	LIST_INSERT_HEAD(&buffer->callbacks, e, next);
	EVBUFFER_UNLOCK(buffer);
	return e;
}

int
evbuffer_remove_cb_entry(struct evbuffer *buffer,
			 struct evbuffer_cb_entry *ent)
{
	EVBUFFER_LOCK(buffer);
	LIST_REMOVE(ent, next);
	EVBUFFER_UNLOCK(buffer);
	mm_free(ent);
	return 0;
}

int
evbuffer_remove_cb(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg)
{
	struct evbuffer_cb_entry *cbent;
	int result = -1;
	EVBUFFER_LOCK(buffer);
	LIST_FOREACH(cbent, &buffer->callbacks, next) {
		if (cb == cbent->cb.cb_func && cbarg == cbent->cbarg) {
			result = evbuffer_remove_cb_entry(buffer, cbent);
			goto done;
		}
	}
done:
	EVBUFFER_UNLOCK(buffer);
	return result;
}

int
evbuffer_cb_set_flags(struct evbuffer *buffer,
		      struct evbuffer_cb_entry *cb, ev_uint32_t flags)
{
	/* the user isn't allowed to mess with these. */
	flags &= ~EVBUFFER_CB_INTERNAL_FLAGS;
	EVBUFFER_LOCK(buffer);
	cb->flags |= flags;
	EVBUFFER_UNLOCK(buffer);
	return 0;
}

int
evbuffer_cb_clear_flags(struct evbuffer *buffer,
		      struct evbuffer_cb_entry *cb, ev_uint32_t flags)
{
	/* the user isn't allowed to mess with these. */
	flags &= ~EVBUFFER_CB_INTERNAL_FLAGS;
	EVBUFFER_LOCK(buffer);
	cb->flags &= ~flags;
	EVBUFFER_UNLOCK(buffer);
	return 0;
}

int
evbuffer_freeze(struct evbuffer *buffer, int start)
{
	EVBUFFER_LOCK(buffer);
	if (start)
		buffer->freeze_start = 1;
	else
		buffer->freeze_end = 1;
	EVBUFFER_UNLOCK(buffer);
	return 0;
}

int
evbuffer_unfreeze(struct evbuffer *buffer, int start)
{
	EVBUFFER_LOCK(buffer);
	if (start)
		buffer->freeze_start = 0;
	else
		buffer->freeze_end = 0;
	EVBUFFER_UNLOCK(buffer);
	return 0;
}

#if 0
void
evbuffer_cb_suspend(struct evbuffer *buffer, struct evbuffer_cb_entry *cb)
{
	if (!(cb->flags & EVBUFFER_CB_SUSPENDED)) {
		cb->size_before_suspend = evbuffer_get_length(buffer);
		cb->flags |= EVBUFFER_CB_SUSPENDED;
	}
}

void
evbuffer_cb_unsuspend(struct evbuffer *buffer, struct evbuffer_cb_entry *cb)
{
	if ((cb->flags & EVBUFFER_CB_SUSPENDED)) {
		unsigned call = (cb->flags & EVBUFFER_CB_CALL_ON_UNSUSPEND);
		size_t sz = cb->size_before_suspend;
		cb->flags &= ~(EVBUFFER_CB_SUSPENDED|
			       EVBUFFER_CB_CALL_ON_UNSUSPEND);
		cb->size_before_suspend = 0;
		if (call && (cb->flags & EVBUFFER_CB_ENABLED)) {
			cb->cb(buffer, sz, evbuffer_get_length(buffer), cb->cbarg);
		}
	}
}
#endif

int
evbuffer_get_callbacks_(struct evbuffer *buffer, struct event_callback **cbs,
    int max_cbs)
{
	int r = 0;
	EVBUFFER_LOCK(buffer);
	if (buffer->deferred_cbs) {
		if (max_cbs < 1) {
			r = -1;
			goto done;
		}
		cbs[0] = &buffer->deferred;
		r = 1;
	}
done:
	EVBUFFER_UNLOCK(buffer);
	return r;
}
"
./repos/libevent/bufferevent_filter.c,https://github.com/libevent/libevent,"/*
 * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
 * Copyright (c) 2002-2006 Niels Provos <provos@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include ""evconfig-private.h""

#include <sys/types.h>

#include ""event2/event-config.h""

#ifdef EVENT__HAVE_SYS_TIME_H
#include <sys/time.h>
#endif

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef EVENT__HAVE_STDARG_H
#include <stdarg.h>
#endif

#ifdef _WIN32
#include <winsock2.h>
#endif

#include ""event2/util.h""
#include ""event2/bufferevent.h""
#include ""event2/buffer.h""
#include ""event2/bufferevent_struct.h""
#include ""event2/event.h""
#include ""log-internal.h""
#include ""mm-internal.h""
#include ""bufferevent-internal.h""
#include ""util-internal.h""

/* prototypes */
static int be_filter_enable(struct bufferevent *, short);
static int be_filter_disable(struct bufferevent *, short);
static void be_filter_unlink(struct bufferevent *);
static void be_filter_destruct(struct bufferevent *);

static void be_filter_readcb(struct bufferevent *, void *);
static void be_filter_writecb(struct bufferevent *, void *);
static void be_filter_eventcb(struct bufferevent *, short, void *);
static int be_filter_flush(struct bufferevent *bufev,
    short iotype, enum bufferevent_flush_mode mode);
static int be_filter_ctrl(struct bufferevent *, enum bufferevent_ctrl_op, union bufferevent_ctrl_data *);

static void bufferevent_filtered_inbuf_cb(struct evbuffer *buf,
    const struct evbuffer_cb_info *cbinfo, void *arg);

static void bufferevent_filtered_outbuf_cb(struct evbuffer *buf,
    const struct evbuffer_cb_info *info, void *arg);

struct bufferevent_filtered {
	struct bufferevent_private bev;

	/** The bufferevent that we read/write filtered data from/to. */
	struct bufferevent *underlying;
	/** A callback on our inbuf to notice somebory removes data */
	struct evbuffer_cb_entry *inbuf_cb;
	/** A callback on our outbuf to notice when somebody adds data */
	struct evbuffer_cb_entry *outbuf_cb;
	/** True iff we have received an EOF callback from the underlying
	 * bufferevent. */
	unsigned got_eof;

	/** Function to free context when we're done. */
	void (*free_context)(void *);
	/** Input filter */
	bufferevent_filter_cb process_in;
	/** Output filter */
	bufferevent_filter_cb process_out;
	/** User-supplied argument to the filters. */
	void *context;
};

const struct bufferevent_ops bufferevent_ops_filter = {
	""filter"",
	evutil_offsetof(struct bufferevent_filtered, bev.bev),
	be_filter_enable,
	be_filter_disable,
	be_filter_unlink,
	be_filter_destruct,
	bufferevent_generic_adj_timeouts_,
	be_filter_flush,
	be_filter_ctrl,
};

/* Given a bufferevent that's really the bev filter of a bufferevent_filtered,
 * return that bufferevent_filtered. Returns NULL otherwise.*/
static inline struct bufferevent_filtered *
upcast(struct bufferevent *bev)
{
	struct bufferevent_filtered *bev_f;
	EVUTIL_ASSERT(BEV_IS_FILTER(bev));
	bev_f = (void*)( ((char*)bev) -
			 evutil_offsetof(struct bufferevent_filtered, bev.bev));
	EVUTIL_ASSERT(BEV_IS_FILTER(&bev_f->bev.bev));
	return bev_f;
}

#define downcast(bev_f) (&(bev_f)->bev.bev)

/** Return 1 iff bevf's underlying bufferevent's output buffer is at or
 * over its high watermark such that we should not write to it in a given
 * flush mode. */
static int
be_underlying_writebuf_full(struct bufferevent_filtered *bevf,
    enum bufferevent_flush_mode state)
{
	struct bufferevent *u = bevf->underlying;
	return state == BEV_NORMAL &&
	    u->wm_write.high &&
	    evbuffer_get_length(u->output) >= u->wm_write.high;
}

/** Return 1 if our input buffer is at or over its high watermark such that we
 * should not write to it in a given flush mode. */
static int
be_readbuf_full(struct bufferevent_filtered *bevf,
    enum bufferevent_flush_mode state)
{
	struct bufferevent *bufev = downcast(bevf);
	return state == BEV_NORMAL &&
	    bufev->wm_read.high &&
	    evbuffer_get_length(bufev->input) >= bufev->wm_read.high;
}


/* Filter to use when we're created with a NULL filter. */
static enum bufferevent_filter_result
be_null_filter(struct evbuffer *src, struct evbuffer *dst, ev_ssize_t lim,
	       enum bufferevent_flush_mode state, void *ctx)
{
	(void)state;
	if (evbuffer_remove_buffer(src, dst, lim) >= 0)
		return BEV_OK;
	else
		return BEV_ERROR;
}

struct bufferevent *
bufferevent_filter_new(struct bufferevent *underlying,
		       bufferevent_filter_cb input_filter,
		       bufferevent_filter_cb output_filter,
		       int options,
		       void (*free_context)(void *),
		       void *ctx)
{
	struct bufferevent_filtered *bufev_f;
	int tmp_options = options & ~BEV_OPT_THREADSAFE;

	if (!underlying)
		return NULL;

	if (!input_filter)
		input_filter = be_null_filter;
	if (!output_filter)
		output_filter = be_null_filter;

	bufev_f = mm_calloc(1, sizeof(struct bufferevent_filtered));
	if (!bufev_f)
		return NULL;

	if (bufferevent_init_common_(&bufev_f->bev, underlying->ev_base,
				    &bufferevent_ops_filter, tmp_options) < 0) {
		mm_free(bufev_f);
		return NULL;
	}
	if (options & BEV_OPT_THREADSAFE) {
		bufferevent_enable_locking_(downcast(bufev_f), NULL);
	}

	bufev_f->underlying = underlying;

	bufev_f->process_in = input_filter;
	bufev_f->process_out = output_filter;
	bufev_f->free_context = free_context;
	bufev_f->context = ctx;

	bufferevent_setcb(bufev_f->underlying,
	    be_filter_readcb, be_filter_writecb, be_filter_eventcb, bufev_f);

	bufev_f->inbuf_cb = evbuffer_add_cb(downcast(bufev_f)->input,
		bufferevent_filtered_inbuf_cb, bufev_f);
	evbuffer_cb_clear_flags(downcast(bufev_f)->input, bufev_f->inbuf_cb,
		EVBUFFER_CB_ENABLED);

	bufev_f->outbuf_cb = evbuffer_add_cb(downcast(bufev_f)->output,
	   bufferevent_filtered_outbuf_cb, bufev_f);

	bufferevent_init_generic_timeout_cbs_(downcast(bufev_f));
	bufferevent_incref_(underlying);

	bufferevent_enable(underlying, EV_READ|EV_WRITE);
	bufferevent_suspend_read_(underlying, BEV_SUSPEND_FILT_READ);

	return downcast(bufev_f);
}

static void
be_filter_unlink(struct bufferevent *bev)
{
	struct bufferevent_filtered *bevf = upcast(bev);
	if (bevf->bev.options & BEV_OPT_CLOSE_ON_FREE) {
		/* Yes, there is also a decref in bufferevent_decref_.
		 * That decref corresponds to the incref when we set
		 * underlying for the first time.  This decref is an
		 * extra one to remove the last reference.
		 */
		if (BEV_UPCAST(bevf->underlying)->refcnt < 2) {
			event_warnx(""BEV_OPT_CLOSE_ON_FREE set on an ""
			    ""bufferevent with too few references"");
		} else {
			bufferevent_free(bevf->underlying);
		}
	} else {
		if (bevf->underlying) {
			if (bevf->underlying->errorcb == be_filter_eventcb)
				bufferevent_setcb(bevf->underlying,
				    NULL, NULL, NULL, NULL);
			bufferevent_unsuspend_read_(bevf->underlying,
			    BEV_SUSPEND_FILT_READ);
		}
	}
}

static void
be_filter_destruct(struct bufferevent *bev)
{
	struct bufferevent_filtered *bevf = upcast(bev);
	if (bevf->free_context)
		bevf->free_context(bevf->context);

	if (bevf->inbuf_cb)
		evbuffer_remove_cb_entry(bev->input, bevf->inbuf_cb);

	if (bevf->outbuf_cb)
		evbuffer_remove_cb_entry(bev->output, bevf->outbuf_cb);
}

static int
be_filter_enable(struct bufferevent *bev, short event)
{
	struct bufferevent_filtered *bevf = upcast(bev);
	if (event & EV_WRITE)
		BEV_RESET_GENERIC_WRITE_TIMEOUT(bev);

	if (event & EV_READ) {
		BEV_RESET_GENERIC_READ_TIMEOUT(bev);
		bufferevent_unsuspend_read_(bevf->underlying,
		    BEV_SUSPEND_FILT_READ);
	}
	return 0;
}

static int
be_filter_disable(struct bufferevent *bev, short event)
{
	struct bufferevent_filtered *bevf = upcast(bev);
	if (event & EV_WRITE)
		BEV_DEL_GENERIC_WRITE_TIMEOUT(bev);
	if (event & EV_READ) {
		BEV_DEL_GENERIC_READ_TIMEOUT(bev);
		bufferevent_suspend_read_(bevf->underlying,
		    BEV_SUSPEND_FILT_READ);
	}
	return 0;
}

static enum bufferevent_filter_result
be_filter_process_input(struct bufferevent_filtered *bevf,
			enum bufferevent_flush_mode state,
			int *processed_out)
{
	enum bufferevent_filter_result res;
	struct bufferevent *bev = downcast(bevf);

	if (state == BEV_NORMAL) {
		/* If we're in 'normal' mode, don't urge data on the filter
		 * unless we're reading data and under our high-water mark.*/
		if (!(bev->enabled & EV_READ) ||
		    be_readbuf_full(bevf, state))
			return BEV_OK;
	}

	do {
		ev_ssize_t limit = -1;
		if (state == BEV_NORMAL && bev->wm_read.high)
			limit = bev->wm_read.high -
			    evbuffer_get_length(bev->input);

		res = bevf->process_in(bevf->underlying->input,
		    bev->input, limit, state, bevf->context);

		if (res == BEV_OK)
			*processed_out = 1;
	} while (res == BEV_OK &&
		 (bev->enabled & EV_READ) &&
		 evbuffer_get_length(bevf->underlying->input) &&
		 !be_readbuf_full(bevf, state));

	if (*processed_out)
		BEV_RESET_GENERIC_READ_TIMEOUT(bev);

	return res;
}


static enum bufferevent_filter_result
be_filter_process_output(struct bufferevent_filtered *bevf,
			 enum bufferevent_flush_mode state,
			 int *processed_out)
{
	/* Requires references and lock: might call writecb */
	enum bufferevent_filter_result res = BEV_OK;
	struct bufferevent *bufev = downcast(bevf);
	int again = 0;

	if (state == BEV_NORMAL) {
		/* If we're in 'normal' mode, don't urge data on the
		 * filter unless we're writing data, and the underlying
		 * bufferevent is accepting data, and we have data to
		 * give the filter.  If we're in 'flush' or 'finish',
		 * call the filter no matter what. */
		if (!(bufev->enabled & EV_WRITE) ||
		    be_underlying_writebuf_full(bevf, state) ||
		    !evbuffer_get_length(bufev->output))
			return BEV_OK;
	}

	/* disable the callback that calls this function
	   when the user adds to the output buffer. */
	evbuffer_cb_clear_flags(bufev->output, bevf->outbuf_cb,
	    EVBUFFER_CB_ENABLED);

	do {
		int processed = 0;
		again = 0;

		do {
			ev_ssize_t limit = -1;
			if (state == BEV_NORMAL &&
			    bevf->underlying->wm_write.high)
				limit = bevf->underlying->wm_write.high -
				    evbuffer_get_length(bevf->underlying->output);

			res = bevf->process_out(downcast(bevf)->output,
			    bevf->underlying->output,
			    limit,
			    state,
			    bevf->context);

			if (res == BEV_OK)
				processed = *processed_out = 1;
		} while (/* Stop if the filter wasn't successful...*/
			res == BEV_OK &&
			/* Or if we aren't writing any more. */
			(bufev->enabled & EV_WRITE) &&
			/* Of if we have nothing more to write and we are
			 * not flushing. */
			evbuffer_get_length(bufev->output) &&
			/* Or if we have filled the underlying output buffer. */
			!be_underlying_writebuf_full(bevf,state));

		if (processed) {
			/* call the write callback.*/
			bufferevent_trigger_nolock_(bufev, EV_WRITE, 0);

			if (res == BEV_OK &&
			    (bufev->enabled & EV_WRITE) &&
			    evbuffer_get_length(bufev->output) &&
			    !be_underlying_writebuf_full(bevf, state)) {
				again = 1;
			}
		}
	} while (again);

	/* reenable the outbuf_cb */
	evbuffer_cb_set_flags(bufev->output,bevf->outbuf_cb,
	    EVBUFFER_CB_ENABLED);

	if (*processed_out)
		BEV_RESET_GENERIC_WRITE_TIMEOUT(bufev);

	return res;
}

/* Called when the size of our outbuf changes. */
static void
bufferevent_filtered_outbuf_cb(struct evbuffer *buf,
    const struct evbuffer_cb_info *cbinfo, void *arg)
{
	struct bufferevent_filtered *bevf = arg;
	struct bufferevent *bev = downcast(bevf);

	if (cbinfo->n_added) {
		int processed_any = 0;
		/* Somebody added more data to the output buffer. Try to
		 * process it, if we should. */
		bufferevent_incref_and_lock_(bev);
		be_filter_process_output(bevf, BEV_NORMAL, &processed_any);
		bufferevent_decref_and_unlock_(bev);
	}
}

static void
be_filter_read_nolock_(struct bufferevent *underlying, void *me_)
{
	struct bufferevent_filtered *bevf = me_;
	enum bufferevent_filter_result res;
	enum bufferevent_flush_mode state;
	struct bufferevent *bufev = downcast(bevf);
	struct bufferevent_private *bufev_private = BEV_UPCAST(bufev);
	int processed_any = 0;

	// It's possible our refcount is 0 at this point if another thread free'd our filterevent
	EVUTIL_ASSERT(bufev_private->refcnt >= 0);

	// If our refcount is > 0
	if (bufev_private->refcnt > 0) {

		if (bevf->got_eof)
			state = BEV_FINISHED;
		else
			state = BEV_NORMAL;

		/* XXXX use return value */
		res = be_filter_process_input(bevf, state, &processed_any);
		(void)res;

		/* XXX This should be in process_input, not here.  There are
		 * other places that can call process-input, and they should
		 * force readcb calls as needed. */
		if (processed_any) {
			bufferevent_trigger_nolock_(bufev, EV_READ, 0);
			if (evbuffer_get_length(underlying->input) > 0 &&
				be_readbuf_full(bevf, state)) {
				/* data left in underlying buffer and filter input buffer
				 * hit its read high watermark.
				 * Schedule callback to avoid data gets stuck in underlying
				 * input buffer.
				 */
				evbuffer_cb_set_flags(bufev->input, bevf->inbuf_cb,
					EVBUFFER_CB_ENABLED);
			}
		}
	}
}

/* Called when the size of our inbuf changes. */
static void
bufferevent_filtered_inbuf_cb(struct evbuffer *buf,
    const struct evbuffer_cb_info *cbinfo, void *arg)
{
	struct bufferevent_filtered *bevf = arg;
	enum bufferevent_flush_mode state;
	struct bufferevent *bev = downcast(bevf);

	BEV_LOCK(bev);

	if (bevf->got_eof)
		state = BEV_FINISHED;
	else
		state = BEV_NORMAL;


	if (!be_readbuf_full(bevf, state)) {
		/* opportunity to read data which was left in underlying
		 * input buffer because filter input buffer hit read
		 * high watermark.
		 */
		evbuffer_cb_clear_flags(bev->input, bevf->inbuf_cb,
			EVBUFFER_CB_ENABLED);
		if (evbuffer_get_length(bevf->underlying->input) > 0)
			be_filter_read_nolock_(bevf->underlying, bevf);
	}

	BEV_UNLOCK(bev);
}

/* Called when the underlying socket has read. */
static void
be_filter_readcb(struct bufferevent *underlying, void *me_)
{
	struct bufferevent_filtered *bevf = me_;
	struct bufferevent *bev = downcast(bevf);

	BEV_LOCK(bev);

	be_filter_read_nolock_(underlying, me_);

	BEV_UNLOCK(bev);
}

/* Called when the underlying socket has drained enough that we can write to
   it. */
static void
be_filter_writecb(struct bufferevent *underlying, void *me_)
{
	struct bufferevent_filtered *bevf = me_;
	struct bufferevent *bev = downcast(bevf);
	struct bufferevent_private *bufev_private = BEV_UPCAST(bev);
	int processed_any = 0;

	BEV_LOCK(bev);

	// It's possible our refcount is 0 at this point if another thread free'd our filterevent
	EVUTIL_ASSERT(bufev_private->refcnt >= 0);

	// If our refcount is > 0
	if (bufev_private->refcnt > 0) {
		be_filter_process_output(bevf, BEV_NORMAL, &processed_any);
	}

	BEV_UNLOCK(bev);
}

/* Called when the underlying socket has given us an error */
static void
be_filter_eventcb(struct bufferevent *underlying, short what, void *me_)
{
	struct bufferevent_filtered *bevf = me_;
	struct bufferevent *bev = downcast(bevf);
	struct bufferevent_private *bufev_private = BEV_UPCAST(bev);

	BEV_LOCK(bev);

	// It's possible our refcount is 0 at this point if another thread free'd our filterevent
	EVUTIL_ASSERT(bufev_private->refcnt >= 0);

	// If our refcount is > 0
	if (bufev_private->refcnt > 0) {

		/* All we can really to is tell our own eventcb. */
		bufferevent_run_eventcb_(bev, what, 0);
	}

	BEV_UNLOCK(bev);
}

static int
be_filter_flush(struct bufferevent *bufev,
    short iotype, enum bufferevent_flush_mode mode)
{
	struct bufferevent_filtered *bevf = upcast(bufev);
	int processed_any = 0;

	bufferevent_incref_and_lock_(bufev);

	if (iotype & EV_READ) {
		be_filter_process_input(bevf, mode, &processed_any);
	}
	if (iotype & EV_WRITE) {
		be_filter_process_output(bevf, mode, &processed_any);
	}
	/* XXX check the return value? */
	/* XXX does this want to recursively call lower-level flushes? */
	bufferevent_flush(bevf->underlying, iotype, mode);

	bufferevent_decref_and_unlock_(bufev);

	return processed_any;
}

static int
be_filter_ctrl(struct bufferevent *bev, enum bufferevent_ctrl_op op,
    union bufferevent_ctrl_data *data)
{
	struct bufferevent_filtered *bevf;
	switch (op) {
	case BEV_CTRL_GET_UNDERLYING:
		bevf = upcast(bev);
		data->ptr = bevf->underlying;
		return 0;
	case BEV_CTRL_SET_FD:
	case BEV_CTRL_GET_FD:
		bevf = upcast(bev);

		if (bevf->underlying &&
			bevf->underlying->be_ops &&
			bevf->underlying->be_ops->ctrl) {
		    return (bevf->underlying->be_ops->ctrl)(bevf->underlying, op, data);
		}
		EVUTIL_FALLTHROUGH;

	case BEV_CTRL_CANCEL_ALL:
		EVUTIL_FALLTHROUGH;
	default:
		return -1;
	}

	return -1;
}
"
./repos/scrcpy/app/src/audio_player.c,https://github.com/Genymobile/scrcpy,"#include ""audio_player.h""

#include <libavcodec/avcodec.h>
#include <libavutil/opt.h>

#include ""util/log.h""

#define SC_AUDIO_PLAYER_NDEBUG // comment to debug

/**
 * Real-time audio player with configurable latency
 *
 * As input, the player regularly receives AVFrames of decoded audio samples.
 * As output, an SDL callback regularly requests audio samples to be played.
 * In the middle, an audio buffer stores the samples produced but not consumed
 * yet.
 *
 * The goal of the player is to feed the audio output with a latency as low as
 * possible while avoiding buffer underrun (i.e. not being able to provide
 * samples when requested).
 *
 * The player aims to feed the audio output with as little latency as possible
 * while avoiding buffer underrun. To achieve this, it attempts to maintain the
 * average buffering (the number of samples present in the buffer) around a
 * target value. If this target buffering is too low, then buffer underrun will
 * occur frequently. If it is too high, then latency will become unacceptable.
 * This target value is configured using the scrcpy option --audio-buffer.
 *
 * The player cannot adjust the sample input rate (it receives samples produced
 * in real-time) or the sample output rate (it must provide samples as
 * requested by the audio output callback). Therefore, it may only apply
 * compensation by resampling (converting _m_ input samples to _n_ output
 * samples).
 *
 * The compensation itself is applied by libswresample (FFmpeg). It is
 * configured using swr_set_compensation(). An important work for the player
 * is to estimate the compensation value regularly and apply it.
 *
 * The estimated buffering level is the result of averaging the ""natural""
 * buffering (samples are produced and consumed by blocks, so it must be
 * smoothed), and making instant adjustments resulting of its own actions
 * (explicit compensation and silence insertion on underflow), which are not
 * smoothed.
 *
 * Buffer underflow events can occur when packets arrive too late. In that case,
 * the player inserts silence. Once the packets finally arrive (late), one
 * strategy could be to drop the samples that were replaced by silence, in
 * order to keep a minimal latency. However, dropping samples in case of buffer
 * underflow is inadvisable, as it would temporarily increase the underflow
 * even more and cause very noticeable audio glitches.
 *
 * Therefore, the player doesn't drop any sample on underflow. The compensation
 * mechanism will absorb the delay introduced by the inserted silence.
 */

/** Downcast frame_sink to sc_audio_player */
#define DOWNCAST(SINK) container_of(SINK, struct sc_audio_player, frame_sink)

#define SC_AV_SAMPLE_FMT AV_SAMPLE_FMT_FLT
#define SC_SDL_SAMPLE_FMT AUDIO_F32

#define TO_BYTES(SAMPLES) sc_audiobuf_to_bytes(&ap->buf, (SAMPLES))
#define TO_SAMPLES(BYTES) sc_audiobuf_to_samples(&ap->buf, (BYTES))

static void SDLCALL
sc_audio_player_sdl_callback(void *userdata, uint8_t *stream, int len_int) {
    struct sc_audio_player *ap = userdata;

    // This callback is called with the lock used by SDL_LockAudioDevice()

    assert(len_int > 0);
    size_t len = len_int;
    uint32_t count = TO_SAMPLES(len);

#ifndef SC_AUDIO_PLAYER_NDEBUG
    LOGD(""[Audio] SDL callback requests %"" PRIu32 "" samples"", count);
#endif

    bool played = atomic_load_explicit(&ap->played, memory_order_relaxed);
    if (!played) {
        uint32_t buffered_samples = sc_audiobuf_can_read(&ap->buf);
        // Wait until the buffer is filled up to at least target_buffering
        // before playing
        if (buffered_samples < ap->target_buffering) {
            LOGV(""[Audio] Inserting initial buffering silence: %"" PRIu32
                 "" samples"", count);
            // Delay playback starting to reach the target buffering. Fill the
            // whole buffer with silence (len is small compared to the
            // arbitrary margin value).
            memset(stream, 0, len);
            return;
        }
    }

    uint32_t read = sc_audiobuf_read(&ap->buf, stream, count);

    if (read < count) {
        uint32_t silence = count - read;
        // Insert silence. In theory, the inserted silent samples replace the
        // missing real samples, which will arrive later, so they should be
        // dropped to keep the latency minimal. However, this would cause very
        // audible glitches, so let the clock compensation restore the target
        // latency.
        LOGD(""[Audio] Buffer underflow, inserting silence: %"" PRIu32 "" samples"",
             silence);
        memset(stream + TO_BYTES(read), 0, TO_BYTES(silence));

        bool received = atomic_load_explicit(&ap->received,
                                             memory_order_relaxed);
        if (received) {
            // Inserting additional samples immediately increases buffering
            atomic_fetch_add_explicit(&ap->underflow, silence,
                                      memory_order_relaxed);
        }
    }

    atomic_store_explicit(&ap->played, true, memory_order_relaxed);
}

static uint8_t *
sc_audio_player_get_swr_buf(struct sc_audio_player *ap, uint32_t min_samples) {
    size_t min_buf_size = TO_BYTES(min_samples);
    if (min_buf_size > ap->swr_buf_alloc_size) {
        size_t new_size = min_buf_size + 4096;
        uint8_t *buf = realloc(ap->swr_buf, new_size);
        if (!buf) {
            LOG_OOM();
            // Could not realloc to the requested size
            return NULL;
        }
        ap->swr_buf = buf;
        ap->swr_buf_alloc_size = new_size;
    }

    return ap->swr_buf;
}

static bool
sc_audio_player_frame_sink_push(struct sc_frame_sink *sink,
                                const AVFrame *frame) {
    struct sc_audio_player *ap = DOWNCAST(sink);

    SwrContext *swr_ctx = ap->swr_ctx;

    int64_t swr_delay = swr_get_delay(swr_ctx, ap->sample_rate);
    // No need to av_rescale_rnd(), input and output sample rates are the same.
    // Add more space (256) for clock compensation.
    int dst_nb_samples = swr_delay + frame->nb_samples + 256;

    uint8_t *swr_buf = sc_audio_player_get_swr_buf(ap, dst_nb_samples);
    if (!swr_buf) {
        return false;
    }

    int ret = swr_convert(swr_ctx, &swr_buf, dst_nb_samples,
                          (const uint8_t **) frame->data, frame->nb_samples);
    if (ret < 0) {
        LOGE(""Resampling failed: %d"", ret);
        return false;
    }

    // swr_convert() returns the number of samples which would have been
    // written if the buffer was big enough.
    uint32_t samples = MIN(ret, dst_nb_samples);
#ifndef SC_AUDIO_PLAYER_NDEBUG
    LOGD(""[Audio] %"" PRIu32 "" samples written to buffer"", samples);
#endif

    uint32_t cap = sc_audiobuf_capacity(&ap->buf);
    if (samples > cap) {
        // Very very unlikely: a single resampled frame should never
        // exceed the audio buffer size (or something is very wrong).
        // Ignore the first bytes in swr_buf to avoid memory corruption anyway.
        swr_buf += TO_BYTES(samples - cap);
        samples = cap;
    }

    uint32_t skipped_samples = 0;

    uint32_t written = sc_audiobuf_write(&ap->buf, swr_buf, samples);
    if (written < samples) {
        uint32_t remaining = samples - written;

        // All samples that could be written without locking have been written,
        // now we need to lock to drop/consume old samples
        SDL_LockAudioDevice(ap->device);

        // Retry with the lock
        written += sc_audiobuf_write(&ap->buf,
                                     swr_buf + TO_BYTES(written),
                                     remaining);
        if (written < samples) {
            remaining = samples - written;
            // Still insufficient, drop old samples to make space
            skipped_samples = sc_audiobuf_read(&ap->buf, NULL, remaining);
            assert(skipped_samples == remaining);

            // Now there is enough space
            uint32_t w = sc_audiobuf_write(&ap->buf,
                                           swr_buf + TO_BYTES(written),
                                           remaining);
            assert(w == remaining);
            (void) w;
        }

        SDL_UnlockAudioDevice(ap->device);
    }

    uint32_t underflow = 0;
    uint32_t max_buffered_samples;
    bool played = atomic_load_explicit(&ap->played, memory_order_relaxed);
    if (played) {
        underflow = atomic_exchange_explicit(&ap->underflow, 0,
                                             memory_order_relaxed);

        max_buffered_samples = ap->target_buffering
                               + 12 * ap->output_buffer
                               + ap->target_buffering / 10;
    } else {
        // SDL playback not started yet, do not accumulate more than
        // max_initial_buffering samples, this would cause unnecessary delay
        // (and glitches to compensate) on start.
        max_buffered_samples = ap->target_buffering + 2 * ap->output_buffer;
    }

    uint32_t can_read = sc_audiobuf_can_read(&ap->buf);
    if (can_read > max_buffered_samples) {
        uint32_t skip_samples = 0;

        SDL_LockAudioDevice(ap->device);
        can_read = sc_audiobuf_can_read(&ap->buf);
        if (can_read > max_buffered_samples) {
            skip_samples = can_read - max_buffered_samples;
            uint32_t r = sc_audiobuf_read(&ap->buf, NULL, skip_samples);
            assert(r == skip_samples);
            (void) r;
            skipped_samples += skip_samples;
        }
        SDL_UnlockAudioDevice(ap->device);

        if (skip_samples) {
            if (played) {
                LOGD(""[Audio] Buffering threshold exceeded, skipping %"" PRIu32
                     "" samples"", skip_samples);
#ifndef SC_AUDIO_PLAYER_NDEBUG
            } else {
                LOGD(""[Audio] Playback not started, skipping %"" PRIu32
                     "" samples"", skip_samples);
#endif
            }
        }
    }

    atomic_store_explicit(&ap->received, true, memory_order_relaxed);
    if (!played) {
        // Nothing more to do
        return true;
    }

    // Number of samples added (or removed, if negative) for compensation
    int32_t instant_compensation = (int32_t) written - frame->nb_samples;
    // Inserting silence instantly increases buffering
    int32_t inserted_silence = (int32_t) underflow;
    // Dropping input samples instantly decreases buffering
    int32_t dropped = (int32_t) skipped_samples;

    // The compensation must apply instantly, it must not be smoothed
    ap->avg_buffering.avg += instant_compensation + inserted_silence - dropped;
    if (ap->avg_buffering.avg < 0) {
        // Since dropping samples instantly reduces buffering, the difference
        // is applied immediately to the average value, assuming that the delay
        // between the producer and the consumer will be caught up.
        //
        // However, when this assumption is not valid, the average buffering
        // may decrease indefinitely. Prevent it to become negative to limit
        // the consequences.
        ap->avg_buffering.avg = 0;
    }

    // However, the buffering level must be smoothed
    sc_average_push(&ap->avg_buffering, can_read);

#ifndef SC_AUDIO_PLAYER_NDEBUG
    LOGD(""[Audio] can_read=%"" PRIu32 "" avg_buffering=%f"",
         can_read, sc_average_get(&ap->avg_buffering));
#endif

    ap->samples_since_resync += written;
    if (ap->samples_since_resync >= ap->sample_rate) {
        // Recompute compensation every second
        ap->samples_since_resync = 0;

        float avg = sc_average_get(&ap->avg_buffering);
        int diff = ap->target_buffering - avg;

        // Enable compensation when the difference exceeds +/- 4ms.
        // Disable compensation when the difference is lower than +/- 1ms.
        int threshold = ap->compensation != 0
                      ? ap->sample_rate     / 1000  /* 1ms */
                      : ap->sample_rate * 4 / 1000; /* 4ms */

        if (abs(diff) < threshold) {
            // Do not compensate for small values, the error is just noise
            diff = 0;
        } else if (diff < 0 && can_read < ap->target_buffering) {
            // Do not accelerate if the instant buffering level is below the
            // target, this would increase underflow
            diff = 0;
        }
        // Compensate the diff over 4 seconds (but will be recomputed after 1
        // second)
        int distance = 4 * ap->sample_rate;
        // Limit compensation rate to 2%
        int abs_max_diff = distance / 50;
        diff = CLAMP(diff, -abs_max_diff, abs_max_diff);
        LOGV(""[Audio] Buffering: target=%"" PRIu32 "" avg=%f cur=%"" PRIu32
             "" compensation=%d"", ap->target_buffering, avg, can_read, diff);

        if (diff != ap->compensation) {
            int ret = swr_set_compensation(swr_ctx, diff, distance);
            if (ret < 0) {
                LOGW(""Resampling compensation failed: %d"", ret);
                // not fatal
            } else {
                ap->compensation = diff;
            }
        }
    }

    return true;
}

static bool
sc_audio_player_frame_sink_open(struct sc_frame_sink *sink,
                                const AVCodecContext *ctx) {
    struct sc_audio_player *ap = DOWNCAST(sink);
#ifdef SCRCPY_LAVU_HAS_CHLAYOUT
    assert(ctx->ch_layout.nb_channels > 0);
    unsigned nb_channels = ctx->ch_layout.nb_channels;
#else
    int tmp = av_get_channel_layout_nb_channels(ctx->channel_layout);
    assert(tmp > 0);
    unsigned nb_channels = tmp;
#endif

    assert(ctx->sample_rate > 0);
    assert(!av_sample_fmt_is_planar(SC_AV_SAMPLE_FMT));
    int out_bytes_per_sample = av_get_bytes_per_sample(SC_AV_SAMPLE_FMT);
    assert(out_bytes_per_sample > 0);

    ap->sample_rate = ctx->sample_rate;
    ap->nb_channels = nb_channels;
    ap->out_bytes_per_sample = out_bytes_per_sample;

    ap->target_buffering = ap->target_buffering_delay * ap->sample_rate
                                                      / SC_TICK_FREQ;

    uint64_t aout_samples = ap->output_buffer_duration * ap->sample_rate
                                                       / SC_TICK_FREQ;
    assert(aout_samples <= 0xFFFF);
    ap->output_buffer = (uint16_t) aout_samples;

    SDL_AudioSpec desired = {
        .freq = ctx->sample_rate,
        .format = SC_SDL_SAMPLE_FMT,
        .channels = nb_channels,
        .samples = aout_samples,
        .callback = sc_audio_player_sdl_callback,
        .userdata = ap,
    };
    SDL_AudioSpec obtained;

    ap->device = SDL_OpenAudioDevice(NULL, 0, &desired, &obtained, 0);
    if (!ap->device) {
        LOGE(""Could not open audio device: %s"", SDL_GetError());
        return false;
    }

    SwrContext *swr_ctx = swr_alloc();
    if (!swr_ctx) {
        LOG_OOM();
        goto error_close_audio_device;
    }
    ap->swr_ctx = swr_ctx;

#ifdef SCRCPY_LAVU_HAS_CHLAYOUT
    av_opt_set_chlayout(swr_ctx, ""in_chlayout"", &ctx->ch_layout, 0);
    av_opt_set_chlayout(swr_ctx, ""out_chlayout"", &ctx->ch_layout, 0);
#else
    av_opt_set_channel_layout(swr_ctx, ""in_channel_layout"",
                              ctx->channel_layout, 0);
    av_opt_set_channel_layout(swr_ctx, ""out_channel_layout"",
                              ctx->channel_layout, 0);
#endif

    av_opt_set_int(swr_ctx, ""in_sample_rate"", ctx->sample_rate, 0);
    av_opt_set_int(swr_ctx, ""out_sample_rate"", ctx->sample_rate, 0);

    av_opt_set_sample_fmt(swr_ctx, ""in_sample_fmt"", ctx->sample_fmt, 0);
    av_opt_set_sample_fmt(swr_ctx, ""out_sample_fmt"", SC_AV_SAMPLE_FMT, 0);

    int ret = swr_init(swr_ctx);
    if (ret) {
        LOGE(""Failed to initialize the resampling context"");
        goto error_free_swr_ctx;
    }

    // Use a ring-buffer of the target buffering size plus 1 second between the
    // producer and the consumer. It's too big on purpose, to guarantee that
    // the producer and the consumer will be able to access it in parallel
    // without locking.
    uint32_t audiobuf_samples = ap->target_buffering + ap->sample_rate;

    size_t sample_size = ap->nb_channels * ap->out_bytes_per_sample;
    bool ok = sc_audiobuf_init(&ap->buf, sample_size, audiobuf_samples);
    if (!ok) {
        goto error_free_swr_ctx;
    }

    size_t initial_swr_buf_size = TO_BYTES(4096);
    ap->swr_buf = malloc(initial_swr_buf_size);
    if (!ap->swr_buf) {
        LOG_OOM();
        goto error_destroy_audiobuf;
    }
    ap->swr_buf_alloc_size = initial_swr_buf_size;

    // Samples are produced and consumed by blocks, so the buffering must be
    // smoothed to get a relatively stable value.
    sc_average_init(&ap->avg_buffering, 128);
    ap->samples_since_resync = 0;

    ap->received = false;
    atomic_init(&ap->played, false);
    atomic_init(&ap->received, false);
    atomic_init(&ap->underflow, 0);
    ap->compensation = 0;

    // The thread calling open() is the thread calling push(), which fills the
    // audio buffer consumed by the SDL audio thread.
    ok = sc_thread_set_priority(SC_THREAD_PRIORITY_TIME_CRITICAL);
    if (!ok) {
        ok = sc_thread_set_priority(SC_THREAD_PRIORITY_HIGH);
        (void) ok; // We don't care if it worked, at least we tried
    }

    SDL_PauseAudioDevice(ap->device, 0);

    return true;

error_destroy_audiobuf:
    sc_audiobuf_destroy(&ap->buf);
error_free_swr_ctx:
    swr_free(&ap->swr_ctx);
error_close_audio_device:
    SDL_CloseAudioDevice(ap->device);

    return false;
}

static void
sc_audio_player_frame_sink_close(struct sc_frame_sink *sink) {
    struct sc_audio_player *ap = DOWNCAST(sink);

    assert(ap->device);
    SDL_PauseAudioDevice(ap->device, 1);
    SDL_CloseAudioDevice(ap->device);

    free(ap->swr_buf);
    sc_audiobuf_destroy(&ap->buf);
    swr_free(&ap->swr_ctx);
}

void
sc_audio_player_init(struct sc_audio_player *ap, sc_tick target_buffering,
                     sc_tick output_buffer_duration) {
    ap->target_buffering_delay = target_buffering;
    ap->output_buffer_duration = output_buffer_duration;

    static const struct sc_frame_sink_ops ops = {
        .open = sc_audio_player_frame_sink_open,
        .close = sc_audio_player_frame_sink_close,
        .push = sc_audio_player_frame_sink_push,
    };

    ap->frame_sink.ops = &ops;
}
"
./repos/scrcpy/app/src/compat.c,https://github.com/Genymobile/scrcpy,"#include ""compat.h""

#include ""config.h""

#include <assert.h>
#ifndef HAVE_REALLOCARRAY
# include <errno.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>

#ifndef HAVE_STRDUP
char *strdup(const char *s) {
    size_t size = strlen(s) + 1;
    char *dup = malloc(size);
    if (dup) {
        memcpy(dup, s, size);
    }
    return dup;
}
#endif

#ifndef HAVE_ASPRINTF
int asprintf(char **strp, const char *fmt, ...) {
    va_list va;
    va_start(va, fmt);
    int ret = vasprintf(strp, fmt, va);
    va_end(va);
    return ret;
}
#endif

#ifndef HAVE_VASPRINTF
int vasprintf(char **strp, const char *fmt, va_list ap) {
    va_list va;
    va_copy(va, ap);
    int len = vsnprintf(NULL, 0, fmt, va);
    va_end(va);

    char *str = malloc(len + 1);
    if (!str) {
        return -1;
    }

    va_copy(va, ap);
    int len2 = vsnprintf(str, len + 1, fmt, va);
    (void) len2;
    assert(len == len2);
    va_end(va);

    *strp = str;
    return len;
}
#endif

#if !defined(HAVE_NRAND48) || !defined(HAVE_JRAND48)
#define SC_RAND48_MASK UINT64_C(0xFFFFFFFFFFFF) // 48 bits
#define SC_RAND48_A UINT64_C(0x5DEECE66D)
#define SC_RAND48_C 0xB
static inline uint64_t rand_iter48(uint64_t x) {
    assert((x & ~SC_RAND48_MASK) == 0);
    return (x * SC_RAND48_A + SC_RAND48_C) & SC_RAND48_MASK;
}

static uint64_t rand_iter48_xsubi(unsigned short xsubi[3]) {
    uint64_t x = ((uint64_t) xsubi[0] << 32)
               | ((uint64_t) xsubi[1] << 16)
               | xsubi[2];

    x = rand_iter48(x);

    xsubi[0] = (x >> 32) & 0XFFFF;
    xsubi[1] = (x >> 16) & 0XFFFF;
    xsubi[2] = x & 0XFFFF;

    return x;
}

#ifndef HAVE_NRAND48
long nrand48(unsigned short xsubi[3]) {
    // range [0, 2^31)
    return rand_iter48_xsubi(xsubi) >> 17;
}
#endif

#ifndef HAVE_JRAND48
long jrand48(unsigned short xsubi[3]) {
    // range [-2^31, 2^31)
    union {
        uint32_t u;
        int32_t i;
    } v;
    v.u = rand_iter48_xsubi(xsubi) >> 16;
    return v.i;
}
#endif
#endif

#ifndef HAVE_REALLOCARRAY
void *reallocarray(void *ptr, size_t nmemb, size_t size) {
    size_t bytes;
    if (__builtin_mul_overflow(nmemb, size, &bytes)) {
      errno = ENOMEM;
      return NULL;
    }
    return realloc(ptr, bytes);
}
#endif
"
./repos/scrcpy/app/src/clock.c,https://github.com/Genymobile/scrcpy,"#include ""clock.h""

#include <assert.h>

#include ""util/log.h""

#define SC_CLOCK_NDEBUG // comment to debug

#define SC_CLOCK_RANGE 32

void
sc_clock_init(struct sc_clock *clock) {
    clock->range = 0;
    clock->offset = 0;
}

void
sc_clock_update(struct sc_clock *clock, sc_tick system, sc_tick stream) {
    if (clock->range < SC_CLOCK_RANGE) {
        ++clock->range;
    }

    sc_tick offset = system - stream;
    clock->offset = ((clock->range - 1) * clock->offset + offset)
                  / clock->range;

#ifndef SC_CLOCK_NDEBUG
    LOGD(""Clock estimation: pts + %"" PRItick, clock->offset);
#endif
}

sc_tick
sc_clock_to_system_time(struct sc_clock *clock, sc_tick stream) {
    assert(clock->range); // sc_clock_update() must have been called
    return stream + clock->offset;
}
"
./repos/scrcpy/app/src/control_msg.c,https://github.com/Genymobile/scrcpy,"#include ""control_msg.h""

#include <assert.h>
#include <inttypes.h>
#include <stdlib.h>
#include <string.h>

#include ""util/binary.h""
#include ""util/log.h""
#include ""util/str.h""

/**
 * Map an enum value to a string based on an array, without crashing on an
 * out-of-bounds index.
 */
#define ENUM_TO_LABEL(labels, value) \
    ((size_t) (value) < ARRAY_LEN(labels) ? labels[value] : ""???"")

#define KEYEVENT_ACTION_LABEL(value) \
    ENUM_TO_LABEL(android_keyevent_action_labels, value)

#define MOTIONEVENT_ACTION_LABEL(value) \
    ENUM_TO_LABEL(android_motionevent_action_labels, value)

#define SCREEN_POWER_MODE_LABEL(value) \
    ENUM_TO_LABEL(screen_power_mode_labels, value)

static const char *const android_keyevent_action_labels[] = {
    ""down"",
    ""up"",
    ""multi"",
};

static const char *const android_motionevent_action_labels[] = {
    ""down"",
    ""up"",
    ""move"",
    ""cancel"",
    ""outside"",
    ""pointer-down"",
    ""pointer-up"",
    ""hover-move"",
    ""scroll"",
    ""hover-enter"",
    ""hover-exit"",
    ""btn-press"",
    ""btn-release"",
};

static const char *const screen_power_mode_labels[] = {
    ""off"",
    ""doze"",
    ""normal"",
    ""doze-suspend"",
    ""suspend"",
};

static const char *const copy_key_labels[] = {
    ""none"",
    ""copy"",
    ""cut"",
};

static inline const char *
get_well_known_pointer_id_name(uint64_t pointer_id) {
    switch (pointer_id) {
        case POINTER_ID_MOUSE:
            return ""mouse"";
        case POINTER_ID_GENERIC_FINGER:
            return ""finger"";
        case POINTER_ID_VIRTUAL_MOUSE:
            return ""vmouse"";
        case POINTER_ID_VIRTUAL_FINGER:
            return ""vfinger"";
        default:
            return NULL;
    }
}

static void
write_position(uint8_t *buf, const struct sc_position *position) {
    sc_write32be(&buf[0], position->point.x);
    sc_write32be(&buf[4], position->point.y);
    sc_write16be(&buf[8], position->screen_size.width);
    sc_write16be(&buf[10], position->screen_size.height);
}

// write length (4 bytes) + string (non null-terminated)
static size_t
write_string(const char *utf8, size_t max_len, uint8_t *buf) {
    size_t len = sc_str_utf8_truncation_index(utf8, max_len);
    sc_write32be(buf, len);
    memcpy(&buf[4], utf8, len);
    return 4 + len;
}

size_t
sc_control_msg_serialize(const struct sc_control_msg *msg, uint8_t *buf) {
    buf[0] = msg->type;
    switch (msg->type) {
        case SC_CONTROL_MSG_TYPE_INJECT_KEYCODE:
            buf[1] = msg->inject_keycode.action;
            sc_write32be(&buf[2], msg->inject_keycode.keycode);
            sc_write32be(&buf[6], msg->inject_keycode.repeat);
            sc_write32be(&buf[10], msg->inject_keycode.metastate);
            return 14;
        case SC_CONTROL_MSG_TYPE_INJECT_TEXT: {
            size_t len =
                write_string(msg->inject_text.text,
                             SC_CONTROL_MSG_INJECT_TEXT_MAX_LENGTH, &buf[1]);
            return 1 + len;
        }
        case SC_CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT:
            buf[1] = msg->inject_touch_event.action;
            sc_write64be(&buf[2], msg->inject_touch_event.pointer_id);
            write_position(&buf[10], &msg->inject_touch_event.position);
            uint16_t pressure =
                sc_float_to_u16fp(msg->inject_touch_event.pressure);
            sc_write16be(&buf[22], pressure);
            sc_write32be(&buf[24], msg->inject_touch_event.action_button);
            sc_write32be(&buf[28], msg->inject_touch_event.buttons);
            return 32;
        case SC_CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT:
            write_position(&buf[1], &msg->inject_scroll_event.position);
            int16_t hscroll =
                sc_float_to_i16fp(msg->inject_scroll_event.hscroll);
            int16_t vscroll =
                sc_float_to_i16fp(msg->inject_scroll_event.vscroll);
            sc_write16be(&buf[13], (uint16_t) hscroll);
            sc_write16be(&buf[15], (uint16_t) vscroll);
            sc_write32be(&buf[17], msg->inject_scroll_event.buttons);
            return 21;
        case SC_CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON:
            buf[1] = msg->inject_keycode.action;
            return 2;
        case SC_CONTROL_MSG_TYPE_GET_CLIPBOARD:
            buf[1] = msg->get_clipboard.copy_key;
            return 2;
        case SC_CONTROL_MSG_TYPE_SET_CLIPBOARD:
            sc_write64be(&buf[1], msg->set_clipboard.sequence);
            buf[9] = !!msg->set_clipboard.paste;
            size_t len = write_string(msg->set_clipboard.text,
                                      SC_CONTROL_MSG_CLIPBOARD_TEXT_MAX_LENGTH,
                                      &buf[10]);
            return 10 + len;
        case SC_CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE:
            buf[1] = msg->set_screen_power_mode.mode;
            return 2;
        case SC_CONTROL_MSG_TYPE_UHID_CREATE:
            sc_write16be(&buf[1], msg->uhid_create.id);
            sc_write16be(&buf[3], msg->uhid_create.report_desc_size);
            memcpy(&buf[5], msg->uhid_create.report_desc,
                            msg->uhid_create.report_desc_size);
            return 5 + msg->uhid_create.report_desc_size;
        case SC_CONTROL_MSG_TYPE_UHID_INPUT:
            sc_write16be(&buf[1], msg->uhid_input.id);
            sc_write16be(&buf[3], msg->uhid_input.size);
            memcpy(&buf[5], msg->uhid_input.data, msg->uhid_input.size);
            return 5 + msg->uhid_input.size;
        case SC_CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL:
        case SC_CONTROL_MSG_TYPE_EXPAND_SETTINGS_PANEL:
        case SC_CONTROL_MSG_TYPE_COLLAPSE_PANELS:
        case SC_CONTROL_MSG_TYPE_ROTATE_DEVICE:
        case SC_CONTROL_MSG_TYPE_OPEN_HARD_KEYBOARD_SETTINGS:
            // no additional data
            return 1;
        default:
            LOGW(""Unknown message type: %u"", (unsigned) msg->type);
            return 0;
    }
}

void
sc_control_msg_log(const struct sc_control_msg *msg) {
#define LOG_CMSG(fmt, ...) LOGV(""input: "" fmt, ## __VA_ARGS__)
    switch (msg->type) {
        case SC_CONTROL_MSG_TYPE_INJECT_KEYCODE:
            LOG_CMSG(""key %-4s code=%d repeat=%"" PRIu32 "" meta=%06lx"",
                     KEYEVENT_ACTION_LABEL(msg->inject_keycode.action),
                     (int) msg->inject_keycode.keycode,
                     msg->inject_keycode.repeat,
                     (long) msg->inject_keycode.metastate);
            break;
        case SC_CONTROL_MSG_TYPE_INJECT_TEXT:
            LOG_CMSG(""text \""%s\"""", msg->inject_text.text);
            break;
        case SC_CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT: {
            int action = msg->inject_touch_event.action
                       & AMOTION_EVENT_ACTION_MASK;
            uint64_t id = msg->inject_touch_event.pointer_id;
            const char *pointer_name = get_well_known_pointer_id_name(id);
            if (pointer_name) {
                // string pointer id
                LOG_CMSG(""touch [id=%s] %-4s position=%"" PRIi32 "",%"" PRIi32
                             "" pressure=%f action_button=%06lx buttons=%06lx"",
                         pointer_name,
                         MOTIONEVENT_ACTION_LABEL(action),
                         msg->inject_touch_event.position.point.x,
                         msg->inject_touch_event.position.point.y,
                         msg->inject_touch_event.pressure,
                         (long) msg->inject_touch_event.action_button,
                         (long) msg->inject_touch_event.buttons);
            } else {
                // numeric pointer id
                LOG_CMSG(""touch [id=%"" PRIu64_ ""] %-4s position=%"" PRIi32 "",%""
                             PRIi32 "" pressure=%f action_button=%06lx""
                             "" buttons=%06lx"",
                         id,
                         MOTIONEVENT_ACTION_LABEL(action),
                         msg->inject_touch_event.position.point.x,
                         msg->inject_touch_event.position.point.y,
                         msg->inject_touch_event.pressure,
                         (long) msg->inject_touch_event.action_button,
                         (long) msg->inject_touch_event.buttons);
            }
            break;
        }
        case SC_CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT:
            LOG_CMSG(""scroll position=%"" PRIi32 "",%"" PRIi32 "" hscroll=%f""
                         "" vscroll=%f buttons=%06lx"",
                     msg->inject_scroll_event.position.point.x,
                     msg->inject_scroll_event.position.point.y,
                     msg->inject_scroll_event.hscroll,
                     msg->inject_scroll_event.vscroll,
                     (long) msg->inject_scroll_event.buttons);
            break;
        case SC_CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON:
            LOG_CMSG(""back-or-screen-on %s"",
                     KEYEVENT_ACTION_LABEL(msg->inject_keycode.action));
            break;
        case SC_CONTROL_MSG_TYPE_GET_CLIPBOARD:
            LOG_CMSG(""get clipboard copy_key=%s"",
                     copy_key_labels[msg->get_clipboard.copy_key]);
            break;
        case SC_CONTROL_MSG_TYPE_SET_CLIPBOARD:
            LOG_CMSG(""clipboard %"" PRIu64_ "" %s \""%s\"""",
                     msg->set_clipboard.sequence,
                     msg->set_clipboard.paste ? ""paste"" : ""nopaste"",
                     msg->set_clipboard.text);
            break;
        case SC_CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE:
            LOG_CMSG(""power mode %s"",
                     SCREEN_POWER_MODE_LABEL(msg->set_screen_power_mode.mode));
            break;
        case SC_CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL:
            LOG_CMSG(""expand notification panel"");
            break;
        case SC_CONTROL_MSG_TYPE_EXPAND_SETTINGS_PANEL:
            LOG_CMSG(""expand settings panel"");
            break;
        case SC_CONTROL_MSG_TYPE_COLLAPSE_PANELS:
            LOG_CMSG(""collapse panels"");
            break;
        case SC_CONTROL_MSG_TYPE_ROTATE_DEVICE:
            LOG_CMSG(""rotate device"");
            break;
        case SC_CONTROL_MSG_TYPE_UHID_CREATE:
            LOG_CMSG(""UHID create [%"" PRIu16 ""] report_desc_size=%"" PRIu16,
                     msg->uhid_create.id, msg->uhid_create.report_desc_size);
            break;
        case SC_CONTROL_MSG_TYPE_UHID_INPUT: {
            char *hex = sc_str_to_hex_string(msg->uhid_input.data,
                                             msg->uhid_input.size);
            if (hex) {
                LOG_CMSG(""UHID input [%"" PRIu16 ""] %s"",
                         msg->uhid_input.id, hex);
                free(hex);
            } else {
                LOG_CMSG(""UHID input [%"" PRIu16 ""] size=%"" PRIu16,
                         msg->uhid_input.id, msg->uhid_input.size);
            }
            break;
        }
        case SC_CONTROL_MSG_TYPE_OPEN_HARD_KEYBOARD_SETTINGS:
            LOG_CMSG(""open hard keyboard settings"");
            break;
        default:
            LOG_CMSG(""unknown type: %u"", (unsigned) msg->type);
            break;
    }
}

void
sc_control_msg_destroy(struct sc_control_msg *msg) {
    switch (msg->type) {
        case SC_CONTROL_MSG_TYPE_INJECT_TEXT:
            free(msg->inject_text.text);
            break;
        case SC_CONTROL_MSG_TYPE_SET_CLIPBOARD:
            free(msg->set_clipboard.text);
            break;
        default:
            // do nothing
            break;
    }
}
"
./repos/scrcpy/app/src/cli.c,https://github.com/Genymobile/scrcpy,"#include ""cli.h""

#include <assert.h>
#include <getopt.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include ""options.h""
#include ""util/log.h""
#include ""util/net.h""
#include ""util/str.h""
#include ""util/strbuf.h""
#include ""util/term.h""

#define STR_IMPL_(x) #x
#define STR(x) STR_IMPL_(x)

enum {
    OPT_BIT_RATE = 1000,
    OPT_WINDOW_TITLE,
    OPT_PUSH_TARGET,
    OPT_ALWAYS_ON_TOP,
    OPT_CROP,
    OPT_RECORD_FORMAT,
    OPT_PREFER_TEXT,
    OPT_WINDOW_X,
    OPT_WINDOW_Y,
    OPT_WINDOW_WIDTH,
    OPT_WINDOW_HEIGHT,
    OPT_WINDOW_BORDERLESS,
    OPT_MAX_FPS,
    OPT_LOCK_VIDEO_ORIENTATION,
    OPT_DISPLAY,
    OPT_DISPLAY_ID,
    OPT_ROTATION,
    OPT_RENDER_DRIVER,
    OPT_NO_MIPMAPS,
    OPT_CODEC_OPTIONS,
    OPT_VIDEO_CODEC_OPTIONS,
    OPT_FORCE_ADB_FORWARD,
    OPT_DISABLE_SCREENSAVER,
    OPT_SHORTCUT_MOD,
    OPT_NO_KEY_REPEAT,
    OPT_FORWARD_ALL_CLICKS,
    OPT_LEGACY_PASTE,
    OPT_ENCODER,
    OPT_VIDEO_ENCODER,
    OPT_POWER_OFF_ON_CLOSE,
    OPT_V4L2_SINK,
    OPT_DISPLAY_BUFFER,
    OPT_V4L2_BUFFER,
    OPT_TUNNEL_HOST,
    OPT_TUNNEL_PORT,
    OPT_NO_CLIPBOARD_AUTOSYNC,
    OPT_TCPIP,
    OPT_RAW_KEY_EVENTS,
    OPT_NO_DOWNSIZE_ON_ERROR,
    OPT_OTG,
    OPT_NO_CLEANUP,
    OPT_PRINT_FPS,
    OPT_NO_POWER_ON,
    OPT_CODEC,
    OPT_VIDEO_CODEC,
    OPT_NO_AUDIO,
    OPT_AUDIO_BIT_RATE,
    OPT_AUDIO_CODEC,
    OPT_AUDIO_CODEC_OPTIONS,
    OPT_AUDIO_ENCODER,
    OPT_LIST_ENCODERS,
    OPT_LIST_DISPLAYS,
    OPT_REQUIRE_AUDIO,
    OPT_AUDIO_BUFFER,
    OPT_AUDIO_OUTPUT_BUFFER,
    OPT_NO_DISPLAY,
    OPT_NO_VIDEO,
    OPT_NO_AUDIO_PLAYBACK,
    OPT_NO_VIDEO_PLAYBACK,
    OPT_VIDEO_SOURCE,
    OPT_AUDIO_SOURCE,
    OPT_KILL_ADB_ON_CLOSE,
    OPT_TIME_LIMIT,
    OPT_PAUSE_ON_EXIT,
    OPT_LIST_CAMERAS,
    OPT_LIST_CAMERA_SIZES,
    OPT_CAMERA_ID,
    OPT_CAMERA_SIZE,
    OPT_CAMERA_FACING,
    OPT_CAMERA_AR,
    OPT_CAMERA_FPS,
    OPT_CAMERA_HIGH_SPEED,
    OPT_DISPLAY_ORIENTATION,
    OPT_RECORD_ORIENTATION,
    OPT_ORIENTATION,
    OPT_KEYBOARD,
    OPT_MOUSE,
    OPT_HID_KEYBOARD_DEPRECATED,
    OPT_HID_MOUSE_DEPRECATED,
};

struct sc_option {
    char shortopt;
    int longopt_id; // either shortopt or longopt_id is non-zero
    const char *longopt;
    // no argument:       argdesc == NULL && !optional_arg
    // optional argument: argdesc != NULL && optional_arg
    // required argument: argdesc != NULL && !optional_arg
    const char *argdesc;
    bool optional_arg;
    const char *text; // if NULL, the option does not appear in the help
};

#define MAX_EQUIVALENT_SHORTCUTS 3
struct sc_shortcut {
    const char *shortcuts[MAX_EQUIVALENT_SHORTCUTS + 1];
    const char *text;
};

struct sc_envvar {
    const char *name;
    const char *text;
};

struct sc_exit_status {
    unsigned value;
    const char *text;
};

struct sc_getopt_adapter {
    char *optstring;
    struct option *longopts;
};

static const struct sc_option options[] = {
    {
        .longopt_id = OPT_ALWAYS_ON_TOP,
        .longopt = ""always-on-top"",
        .text = ""Make scrcpy window always on top (above other windows)."",
    },
    {
        .longopt_id = OPT_AUDIO_BIT_RATE,
        .longopt = ""audio-bit-rate"",
        .argdesc = ""value"",
        .text = ""Encode the audio at the given bit rate, expressed in bits/s. ""
                ""Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n""
                ""Default is 128K (128000)."",
    },
    {
        .longopt_id = OPT_AUDIO_BUFFER,
        .longopt = ""audio-buffer"",
        .argdesc = ""ms"",
        .text = ""Configure the audio buffering delay (in milliseconds).\n""
                ""Lower values decrease the latency, but increase the ""
                ""likelyhood of buffer underrun (causing audio glitches).\n""
                ""Default is 50."",
    },
    {
        .longopt_id = OPT_AUDIO_CODEC,
        .longopt = ""audio-codec"",
        .argdesc = ""name"",
        .text = ""Select an audio codec (opus, aac, flac or raw).\n""
                ""Default is opus."",
    },
    {
        .longopt_id = OPT_AUDIO_CODEC_OPTIONS,
        .longopt = ""audio-codec-options"",
        .argdesc = ""key[:type]=value[,...]"",
        .text = ""Set a list of comma-separated key:type=value options for the ""
                ""device audio encoder.\n""
                ""The possible values for 'type' are 'int' (default), 'long', ""
                ""'float' and 'string'.\n""
                ""The list of possible codec options is available in the ""
                ""Android documentation: ""
                ""<https://d.android.com/reference/android/media/MediaFormat>"",
    },
    {
        .longopt_id = OPT_AUDIO_ENCODER,
        .longopt = ""audio-encoder"",
        .argdesc = ""name"",
        .text = ""Use a specific MediaCodec audio encoder (depending on the ""
                ""codec provided by --audio-codec).\n""
                ""The available encoders can be listed by --list-encoders."",
    },
    {
        .longopt_id = OPT_AUDIO_SOURCE,
        .longopt = ""audio-source"",
        .argdesc = ""source"",
        .text = ""Select the audio source (output or mic).\n""
                ""Default is output."",
    },
    {
        .longopt_id = OPT_AUDIO_OUTPUT_BUFFER,
        .longopt = ""audio-output-buffer"",
        .argdesc = ""ms"",
        .text = ""Configure the size of the SDL audio output buffer (in ""
                ""milliseconds).\n""
                ""If you get \""robotic\"" audio playback, you should test with ""
                ""a higher value (10). Do not change this setting otherwise.\n""
                ""Default is 5."",
    },
    {
        .shortopt = 'b',
        .longopt = ""video-bit-rate"",
        .argdesc = ""value"",
        .text = ""Encode the video at the given bit rate, expressed in bits/s. ""
                ""Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n""
                ""Default is 8M (8000000)."",
    },
    {
        // deprecated
        .longopt_id = OPT_BIT_RATE,
        .longopt = ""bit-rate"",
        .argdesc = ""value"",
    },
    {
        .longopt_id = OPT_CAMERA_AR,
        .longopt = ""camera-ar"",
        .argdesc = ""ar"",
        .text = ""Select the camera size by its aspect ratio (+/- 10%).\n""
                ""Possible values are \""sensor\"" (use the camera sensor aspect ""
                ""ratio), \""<num>:<den>\"" (e.g. \""4:3\"") or \""<value>\"" (e.g. ""
                ""\""1.6\"").""
    },
    {
        .longopt_id = OPT_CAMERA_ID,
        .longopt = ""camera-id"",
        .argdesc = ""id"",
        .text = ""Specify the device camera id to mirror.\n""
                ""The available camera ids can be listed by:\n""
                ""    scrcpy --list-cameras"",
    },
    {
        .longopt_id = OPT_CAMERA_FACING,
        .longopt = ""camera-facing"",
        .argdesc = ""facing"",
        .text = ""Select the device camera by its facing direction.\n""
                ""Possible values are \""front\"", \""back\"" and \""external\""."",
    },
    {
        .longopt_id = OPT_CAMERA_HIGH_SPEED,
        .longopt = ""camera-high-speed"",
        .text = ""Enable high-speed camera capture mode.\n""
                ""This mode is restricted to specific resolutions and frame ""
                ""rates, listed by --list-camera-sizes."",
    },
    {
        .longopt_id = OPT_CAMERA_SIZE,
        .longopt = ""camera-size"",
        .argdesc = ""<width>x<height>"",
        .text = ""Specify an explicit camera capture size."",
    },
    {
        .longopt_id = OPT_CAMERA_FPS,
        .longopt = ""camera-fps"",
        .argdesc = ""value"",
        .text = ""Specify the camera capture frame rate.\n""
                ""If not specified, Android's default frame rate (30 fps) is ""
                ""used."",
    },
    {
        // Not really deprecated (--codec has never been released), but without
        // declaring an explicit --codec option, getopt_long() partial matching
        // behavior would consider --codec to be equivalent to --codec-options,
        // which would be confusing.
        .longopt_id = OPT_CODEC,
        .longopt = ""codec"",
        .argdesc = ""value"",
    },
    {
        // deprecated
        .longopt_id = OPT_CODEC_OPTIONS,
        .longopt = ""codec-options"",
        .argdesc = ""key[:type]=value[,...]"",
    },
    {
        .longopt_id = OPT_CROP,
        .longopt = ""crop"",
        .argdesc = ""width:height:x:y"",
        .text = ""Crop the device screen on the server.\n""
                ""The values are expressed in the device natural orientation ""
                ""(typically, portrait for a phone, landscape for a tablet). ""
                ""Any --max-size value is computed on the cropped size."",
    },
    {
        .shortopt = 'd',
        .longopt = ""select-usb"",
        .text = ""Use USB device (if there is exactly one, like adb -d).\n""
                ""Also see -e (--select-tcpip)."",
    },
    {
        .longopt_id = OPT_DISABLE_SCREENSAVER,
        .longopt = ""disable-screensaver"",
        .text = ""Disable screensaver while scrcpy is running."",
    },
    {
        // deprecated
        .longopt_id = OPT_DISPLAY,
        .longopt = ""display"",
        .argdesc = ""id"",
    },
    {
        .longopt_id = OPT_DISPLAY_BUFFER,
        .longopt = ""display-buffer"",
        .argdesc = ""ms"",
        .text = ""Add a buffering delay (in milliseconds) before displaying. ""
                ""This increases latency to compensate for jitter.\n""
                ""Default is 0 (no buffering)."",
    },
    {
        .longopt_id = OPT_DISPLAY_ID,
        .longopt = ""display-id"",
        .argdesc = ""id"",
        .text = ""Specify the device display id to mirror.\n""
                ""The available display ids can be listed by:\n""
                ""    scrcpy --list-displays\n""
                ""Default is 0."",
    },
    {
        .longopt_id = OPT_DISPLAY_ORIENTATION,
        .longopt = ""display-orientation"",
        .argdesc = ""value"",
        .text = ""Set the initial display orientation.\n""
                ""Possible values are 0, 90, 180, 270, flip0, flip90, flip180 ""
                ""and flip270. The number represents the clockwise rotation ""
                ""in degrees; the \""flip\"" keyword applies a horizontal flip ""
                ""before the rotation.\n""
                ""Default is 0."",
    },
    {
        .shortopt = 'e',
        .longopt = ""select-tcpip"",
        .text = ""Use TCP/IP device (if there is exactly one, like adb -e).\n""
                ""Also see -d (--select-usb)."",
    },
    {
        // deprecated
        .longopt_id = OPT_ENCODER,
        .longopt = ""encoder"",
        .argdesc = ""name"",
    },
    {
        .shortopt = 'f',
        .longopt = ""fullscreen"",
        .text = ""Start in fullscreen."",
    },
    {
        .longopt_id = OPT_FORCE_ADB_FORWARD,
        .longopt = ""force-adb-forward"",
        .text = ""Do not attempt to use \""adb reverse\"" to connect to the ""
                ""device."",
    },
    {
        .longopt_id = OPT_FORWARD_ALL_CLICKS,
        .longopt = ""forward-all-clicks"",
        .text = ""By default, right-click triggers BACK (or POWER on) and ""
                ""middle-click triggers HOME. This option disables these ""
                ""shortcuts and forwards the clicks to the device instead."",
    },
    {
        .shortopt = 'h',
        .longopt = ""help"",
        .text = ""Print this help."",
    },
    {
        .shortopt = 'K',
        .text = ""Same as --keyboard=uhid."",
    },
    {
        .longopt_id = OPT_KEYBOARD,
        .longopt = ""keyboard"",
        .argdesc = ""mode"",
        .text = ""Select how to send keyboard inputs to the device.\n""
                ""Possible values are \""disabled\"", \""sdk\"", \""uhid\"" and ""
                ""\""aoa\"".\n""
                ""\""disabled\"" does not send keyboard inputs to the device.\n""
                ""\""sdk\"" uses the Android system API to deliver keyboard ""
                ""events to applications.\n""
                ""\""uhid\"" simulates a physical HID keyboard using the Linux ""
                ""UHID kernel module on the device.\n""
                ""\""aoa\"" simulates a physical keyboard using the AOAv2 ""
                ""protocol. It may only work over USB.\n""
                ""For \""uhid\"" and \""aoa\"", the keyboard layout must be ""
                ""configured (once and for all) on the device, via Settings -> ""
                ""System -> Languages and input -> Physical keyboard. This ""
                ""settings page can be started directly using the shortcut ""
                ""MOD+k (except in OTG mode) or by executing: `adb shell am ""
                ""start -a android.settings.HARD_KEYBOARD_SETTINGS`.\n""
                ""This option is only available when a HID keyboard is enabled ""
                ""(or a physical keyboard is connected).\n""
                ""Also see --mouse."",
    },
    {
        .longopt_id = OPT_KILL_ADB_ON_CLOSE,
        .longopt = ""kill-adb-on-close"",
        .text = ""Kill adb when scrcpy terminates."",
    },
    {
        // deprecated
        //.shortopt = 'K', // old, reassigned
        .longopt_id = OPT_HID_KEYBOARD_DEPRECATED,
        .longopt = ""hid-keyboard"",
    },
    {
        .longopt_id = OPT_LEGACY_PASTE,
        .longopt = ""legacy-paste"",
        .text = ""Inject computer clipboard text as a sequence of key events ""
                ""on Ctrl+v (like MOD+Shift+v).\n""
                ""This is a workaround for some devices not behaving as ""
                ""expected when setting the device clipboard programmatically."",
    },
    {
        .longopt_id = OPT_LIST_CAMERAS,
        .longopt = ""list-cameras"",
        .text = ""List device cameras."",
    },
    {
        .longopt_id = OPT_LIST_CAMERA_SIZES,
        .longopt = ""list-camera-sizes"",
        .text = ""List the valid camera capture sizes."",
    },
    {
        .longopt_id = OPT_LIST_DISPLAYS,
        .longopt = ""list-displays"",
        .text = ""List device displays."",
    },
    {
        .longopt_id = OPT_LIST_ENCODERS,
        .longopt = ""list-encoders"",
        .text = ""List video and audio encoders available on the device."",
    },
    {
        .longopt_id = OPT_LOCK_VIDEO_ORIENTATION,
        .longopt = ""lock-video-orientation"",
        .argdesc = ""value"",
        .optional_arg = true,
        .text = ""Lock capture video orientation to value.\n""
                ""Possible values are \""unlocked\"", \""initial\"" (locked to the ""
                ""initial orientation), 0, 90, 180 and 270. The values ""
                ""represent the clockwise rotation from the natural device ""
                ""orientation, in degrees.\n""
                ""Default is \""unlocked\"".\n""
                ""Passing the option without argument is equivalent to passing ""
                ""\""initial\""."",
    },
    {
        .shortopt = 'm',
        .longopt = ""max-size"",
        .argdesc = ""value"",
        .text = ""Limit both the width and height of the video to value. The ""
                ""other dimension is computed so that the device aspect-ratio ""
                ""is preserved.\n""
                ""Default is 0 (unlimited)."",
    },
    {
        // deprecated
        //.shortopt = 'M', // old, reassigned
        .longopt_id = OPT_HID_MOUSE_DEPRECATED,
        .longopt = ""hid-mouse"",
    },
    {
        .shortopt = 'M',
        .text = ""Same as --mouse=uhid."",
    },
    {
        .longopt_id = OPT_MAX_FPS,
        .longopt = ""max-fps"",
        .argdesc = ""value"",
        .text = ""Limit the frame rate of screen capture (officially supported ""
                ""since Android 10, but may work on earlier versions)."",
    },
    {
        .longopt_id = OPT_MOUSE,
        .longopt = ""mouse"",
        .argdesc = ""mode"",
        .text = ""Select how to send mouse inputs to the device.\n""
                ""Possible values are \""disabled\"", \""sdk\"", \""uhid\"" and ""
                ""\""aoa\"".\n""
                ""\""disabled\"" does not send mouse inputs to the device.\n""
                ""\""sdk\"" uses the Android system API to deliver mouse events""
                ""to applications.\n""
                ""\""uhid\"" simulates a physical HID mouse using the Linux UHID ""
                ""kernel module on the device.\n""
                ""\""aoa\"" simulates a physical mouse using the AOAv2 protocol. ""
                ""It may only work over USB.\n""
                ""In \""uhid\"" and \""aoa\"" modes, the computer mouse is captured ""
                ""to control the device directly (relative mouse mode).\n""
                ""LAlt, LSuper or RSuper toggle the capture mode, to give ""
                ""control of the mouse back to the computer.\n""
                ""Also see --keyboard."",
    },
    {
        .shortopt = 'n',
        .longopt = ""no-control"",
        .text = ""Disable device control (mirror the device in read-only)."",
    },
    {
        .shortopt = 'N',
        .longopt = ""no-playback"",
        .text = ""Disable video and audio playback on the computer (equivalent ""
                ""to --no-video-playback --no-audio-playback)."",
    },
    {
        .longopt_id = OPT_NO_AUDIO,
        .longopt = ""no-audio"",
        .text = ""Disable audio forwarding."",
    },
    {
        .longopt_id = OPT_NO_AUDIO_PLAYBACK,
        .longopt = ""no-audio-playback"",
        .text = ""Disable audio playback on the computer."",
    },
    {
        .longopt_id = OPT_NO_CLEANUP,
        .longopt = ""no-cleanup"",
        .text = ""By default, scrcpy removes the server binary from the device ""
                ""and restores the device state (show touches, stay awake and ""
                ""power mode) on exit.\n""
                ""This option disables this cleanup.""
    },
    {
        .longopt_id = OPT_NO_CLIPBOARD_AUTOSYNC,
        .longopt = ""no-clipboard-autosync"",
        .text = ""By default, scrcpy automatically synchronizes the computer ""
                ""clipboard to the device clipboard before injecting Ctrl+v, ""
                ""and the device clipboard to the computer clipboard whenever ""
                ""it changes.\n""
                ""This option disables this automatic synchronization.""
    },
    {
        .longopt_id = OPT_NO_DOWNSIZE_ON_ERROR,
        .longopt = ""no-downsize-on-error"",
        .text = ""By default, on MediaCodec error, scrcpy automatically tries ""
                ""again with a lower definition.\n""
                ""This option disables this behavior."",
    },
    {
        // deprecated
        .longopt_id = OPT_NO_DISPLAY,
        .longopt = ""no-display"",
    },
    {
        .longopt_id = OPT_NO_KEY_REPEAT,
        .longopt = ""no-key-repeat"",
        .text = ""Do not forward repeated key events when a key is held down."",
    },
    {
        .longopt_id = OPT_NO_MIPMAPS,
        .longopt = ""no-mipmaps"",
        .text = ""If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then ""
                ""mipmaps are automatically generated to improve downscaling ""
                ""quality. This option disables the generation of mipmaps."",
    },
    {
        .longopt_id = OPT_NO_POWER_ON,
        .longopt = ""no-power-on"",
        .text = ""Do not power on the device on start."",
    },
    {
        .longopt_id = OPT_NO_VIDEO,
        .longopt = ""no-video"",
        .text = ""Disable video forwarding."",
    },
    {
        .longopt_id = OPT_NO_VIDEO_PLAYBACK,
        .longopt = ""no-video-playback"",
        .text = ""Disable video playback on the computer."",
    },
    {
        .longopt_id = OPT_ORIENTATION,
        .longopt = ""orientation"",
        .argdesc = ""value"",
        .text = ""Same as --display-orientation=value ""
                ""--record-orientation=value."",
    },
    {
        .longopt_id = OPT_OTG,
        .longopt = ""otg"",
        .text = ""Run in OTG mode: simulate physical keyboard and mouse, ""
                ""as if the computer keyboard and mouse were plugged directly ""
                ""to the device via an OTG cable.\n""
                ""In this mode, adb (USB debugging) is not necessary, and ""
                ""mirroring is disabled.\n""
                ""LAlt, LSuper or RSuper toggle the mouse capture mode, to give ""
                ""control of the mouse back to the computer.\n""
                ""Keyboard and mouse may be disabled separately using""
                ""--keyboard=disabled and --mouse=disabled.\n""
                ""It may only work over USB.\n""
                ""See --keyboard and --mouse."",
    },
    {
        .shortopt = 'p',
        .longopt = ""port"",
        .argdesc = ""port[:port]"",
        .text = ""Set the TCP port (range) used by the client to listen.\n""
                ""Default is "" STR(DEFAULT_LOCAL_PORT_RANGE_FIRST) "":""
                              STR(DEFAULT_LOCAL_PORT_RANGE_LAST) ""."",
    },
    {
        .longopt_id = OPT_PAUSE_ON_EXIT,
        .longopt = ""pause-on-exit"",
        .argdesc = ""mode"",
        .optional_arg = true,
        .text = ""Configure pause on exit. Possible values are \""true\"" (always ""
                ""pause on exit), \""false\"" (never pause on exit) and ""
                ""\""if-error\"" (pause only if an error occured).\n""
                ""This is useful to prevent the terminal window from ""
                ""automatically closing, so that error messages can be read.\n""
                ""Default is \""false\"".\n""
                ""Passing the option without argument is equivalent to passing ""
                ""\""true\""."",
    },
    {
        .longopt_id = OPT_POWER_OFF_ON_CLOSE,
        .longopt = ""power-off-on-close"",
        .text = ""Turn the device screen off when closing scrcpy."",
    },
    {
        .longopt_id = OPT_PREFER_TEXT,
        .longopt = ""prefer-text"",
        .text = ""Inject alpha characters and space as text events instead of ""
                ""key events.\n""
                ""This avoids issues when combining multiple keys to enter a ""
                ""special character, but breaks the expected behavior of alpha ""
                ""keys in games (typically WASD)."",
    },
    {
        .longopt_id = OPT_PRINT_FPS,
        .longopt = ""print-fps"",
        .text = ""Start FPS counter, to print framerate logs to the console. ""
                ""It can be started or stopped at any time with MOD+i."",
    },
    {
        .longopt_id = OPT_PUSH_TARGET,
        .longopt = ""push-target"",
        .argdesc = ""path"",
        .text = ""Set the target directory for pushing files to the device by ""
                ""drag & drop. It is passed as is to \""adb push\"".\n""
                ""Default is \""/sdcard/Download/\""."",
    },
    {
        .shortopt = 'r',
        .longopt = ""record"",
        .argdesc = ""file.mp4"",
        .text = ""Record screen to file.\n""
                ""The format is determined by the --record-format option if ""
                ""set, or by the file extension."",
    },
    {
        .longopt_id = OPT_RAW_KEY_EVENTS,
        .longopt = ""raw-key-events"",
        .text = ""Inject key events for all input keys, and ignore text events.""
    },
    {
        .longopt_id = OPT_RECORD_FORMAT,
        .longopt = ""record-format"",
        .argdesc = ""format"",
        .text = ""Force recording format (mp4, mkv, m4a, mka, opus, aac, flac ""
                ""or wav)."",
    },
    {
        .longopt_id = OPT_RECORD_ORIENTATION,
        .longopt = ""record-orientation"",
        .argdesc = ""value"",
        .text = ""Set the record orientation.\n""
                ""Possible values are 0, 90, 180 and 270. The number represents ""
                ""the clockwise rotation in degrees.\n""
                ""Default is 0."",
    },
    {
        .longopt_id = OPT_RENDER_DRIVER,
        .longopt = ""render-driver"",
        .argdesc = ""name"",
        .text = ""Request SDL to use the given render driver (this is just a ""
                ""hint).\n""
                ""Supported names are currently \""direct3d\"", \""opengl\"", ""
                ""\""opengles2\"", \""opengles\"", \""metal\"" and \""software\"".\n""
                ""<https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>"",
    },
    {
        .longopt_id = OPT_REQUIRE_AUDIO,
        .longopt = ""require-audio"",
        .text = ""By default, scrcpy mirrors only the video when audio capture ""
                ""fails on the device. This option makes scrcpy fail if audio ""
                ""is enabled but does not work.""
    },
    {
        // deprecated
        .longopt_id = OPT_ROTATION,
        .longopt = ""rotation"",
        .argdesc = ""value"",
    },
    {
        .shortopt = 's',
        .longopt = ""serial"",
        .argdesc = ""serial"",
        .text = ""The device serial number. Mandatory only if several devices ""
                ""are connected to adb."",
    },
    {
        .shortopt = 'S',
        .longopt = ""turn-screen-off"",
        .text = ""Turn the device screen off immediately."",
    },
    {
        .longopt_id = OPT_SHORTCUT_MOD,
        .longopt = ""shortcut-mod"",
        .argdesc = ""key[+...][,...]"",
        .text = ""Specify the modifiers to use for scrcpy shortcuts.\n""
                ""Possible keys are \""lctrl\"", \""rctrl\"", \""lalt\"", \""ralt\"", ""
                ""\""lsuper\"" and \""rsuper\"".\n""
                ""A shortcut can consist in several keys, separated by '+'. ""
                ""Several shortcuts can be specified, separated by ','.\n""
                ""For example, to use either LCtrl+LAlt or LSuper for scrcpy ""
                ""shortcuts, pass \""lctrl+lalt,lsuper\"".\n""
                ""Default is \""lalt,lsuper\"" (left-Alt or left-Super)."",
    },
    {
        .shortopt = 't',
        .longopt = ""show-touches"",
        .text = ""Enable \""show touches\"" on start, restore the initial value ""
                ""on exit.\n""
                ""It only shows physical touches (not clicks from scrcpy)."",
    },
    {
        .longopt_id = OPT_TCPIP,
        .longopt = ""tcpip"",
        .argdesc = ""ip[:port]"",
        .optional_arg = true,
        .text = ""Configure and reconnect the device over TCP/IP.\n""
                ""If a destination address is provided, then scrcpy connects to ""
                ""this address before starting. The device must listen on the ""
                ""given TCP port (default is 5555).\n""
                ""If no destination address is provided, then scrcpy attempts ""
                ""to find the IP address of the current device (typically ""
                ""connected over USB), enables TCP/IP mode, then connects to ""
                ""this address before starting."",
    },
    {
        .longopt_id = OPT_TIME_LIMIT,
        .longopt = ""time-limit"",
        .argdesc = ""seconds"",
        .text = ""Set the maximum mirroring time, in seconds."",
    },
    {
        .longopt_id = OPT_TUNNEL_HOST,
        .longopt = ""tunnel-host"",
        .argdesc = ""ip"",
        .text = ""Set the IP address of the adb tunnel to reach the scrcpy ""
                ""server. This option automatically enables ""
                ""--force-adb-forward.\n""
                ""Default is localhost."",
    },
    {
        .longopt_id = OPT_TUNNEL_PORT,
        .longopt = ""tunnel-port"",
        .argdesc = ""port"",
        .text = ""Set the TCP port of the adb tunnel to reach the scrcpy ""
                ""server. This option automatically enables ""
                ""--force-adb-forward.\n""
                ""Default is 0 (not forced): the local port used for ""
                ""establishing the tunnel will be used."",
    },
    {
        .shortopt = 'v',
        .longopt = ""version"",
        .text = ""Print the version of scrcpy."",
    },
    {
        .shortopt = 'V',
        .longopt = ""verbosity"",
        .argdesc = ""value"",
        .text = ""Set the log level (verbose, debug, info, warn or error).\n""
#ifndef NDEBUG
                ""Default is debug."",
#else
                ""Default is info."",
#endif
    },
    {
        .longopt_id = OPT_V4L2_SINK,
        .longopt = ""v4l2-sink"",
        .argdesc = ""/dev/videoN"",
        .text = ""Output to v4l2loopback device.\n""
                ""It requires to lock the video orientation (see ""
                ""--lock-video-orientation).\n""
                ""This feature is only available on Linux."",
    },
    {
        .longopt_id = OPT_V4L2_BUFFER,
        .longopt = ""v4l2-buffer"",
        .argdesc = ""ms"",
        .text = ""Add a buffering delay (in milliseconds) before pushing ""
                ""frames. This increases latency to compensate for jitter.\n""
                ""This option is similar to --display-buffer, but specific to ""
                ""V4L2 sink.\n""
                ""Default is 0 (no buffering).\n""
                ""This option is only available on Linux."",
    },
    {
        .longopt_id = OPT_VIDEO_CODEC,
        .longopt = ""video-codec"",
        .argdesc = ""name"",
        .text = ""Select a video codec (h264, h265 or av1).\n""
                ""Default is h264."",
    },
    {
        .longopt_id = OPT_VIDEO_CODEC_OPTIONS,
        .longopt = ""video-codec-options"",
        .argdesc = ""key[:type]=value[,...]"",
        .text = ""Set a list of comma-separated key:type=value options for the ""
                ""device video encoder.\n""
                ""The possible values for 'type' are 'int' (default), 'long', ""
                ""'float' and 'string'.\n""
                ""The list of possible codec options is available in the ""
                ""Android documentation: ""
                ""<https://d.android.com/reference/android/media/MediaFormat>"",
    },
    {
        .longopt_id = OPT_VIDEO_ENCODER,
        .longopt = ""video-encoder"",
        .argdesc = ""name"",
        .text = ""Use a specific MediaCodec video encoder (depending on the ""
                ""codec provided by --video-codec).\n""
                ""The available encoders can be listed by --list-encoders."",
    },
    {
        .longopt_id = OPT_VIDEO_SOURCE,
        .longopt = ""video-source"",
        .argdesc = ""source"",
        .text = ""Select the video source (display or camera).\n""
                ""Camera mirroring requires Android 12+.\n""
                ""Default is display."",
    },
    {
        .shortopt = 'w',
        .longopt = ""stay-awake"",
        .text = ""Keep the device on while scrcpy is running, when the device ""
                ""is plugged in."",
    },
    {
        .longopt_id = OPT_WINDOW_BORDERLESS,
        .longopt = ""window-borderless"",
        .text = ""Disable window decorations (display borderless window).""
    },
    {
        .longopt_id = OPT_WINDOW_TITLE,
        .longopt = ""window-title"",
        .argdesc = ""text"",
        .text = ""Set a custom window title."",
    },
    {
        .longopt_id = OPT_WINDOW_X,
        .longopt = ""window-x"",
        .argdesc = ""value"",
        .text = ""Set the initial window horizontal position.\n""
                ""Default is \""auto\""."",
    },
    {
        .longopt_id = OPT_WINDOW_Y,
        .longopt = ""window-y"",
        .argdesc = ""value"",
        .text = ""Set the initial window vertical position.\n""
                ""Default is \""auto\""."",
    },
    {
        .longopt_id = OPT_WINDOW_WIDTH,
        .longopt = ""window-width"",
        .argdesc = ""value"",
        .text = ""Set the initial window width.\n""
                ""Default is 0 (automatic)."",
    },
    {
        .longopt_id = OPT_WINDOW_HEIGHT,
        .longopt = ""window-height"",
        .argdesc = ""value"",
        .text = ""Set the initial window height.\n""
                ""Default is 0 (automatic)."",
    },
};

static const struct sc_shortcut shortcuts[] = {
    {
        .shortcuts = { ""MOD+f"" },
        .text = ""Switch fullscreen mode"",
    },
    {
        .shortcuts = { ""MOD+Left"" },
        .text = ""Rotate display left"",
    },
    {
        .shortcuts = { ""MOD+Right"" },
        .text = ""Rotate display right"",
    },
    {
        .shortcuts = { ""MOD+Shift+Left"", ""MOD+Shift+Right"" },
        .text = ""Flip display horizontally"",
    },
    {
        .shortcuts = { ""MOD+Shift+Up"", ""MOD+Shift+Down"" },
        .text = ""Flip display vertically"",
    },
    {
        .shortcuts = { ""MOD+g"" },
        .text = ""Resize window to 1:1 (pixel-perfect)"",
    },
    {
        .shortcuts = { ""MOD+w"", ""Double-click on black borders"" },
        .text = ""Resize window to remove black borders"",
    },
    {
        .shortcuts = { ""MOD+h"", ""Middle-click"" },
        .text = ""Click on HOME"",
    },
    {
        .shortcuts = {
            ""MOD+b"",
            ""MOD+Backspace"",
            ""Right-click (when screen is on)"",
        },
        .text = ""Click on BACK"",
    },
    {
        .shortcuts = { ""MOD+s"", ""4th-click"" },
        .text = ""Click on APP_SWITCH"",
    },
    {
        .shortcuts = { ""MOD+m"" },
        .text = ""Click on MENU"",
    },
    {
        .shortcuts = { ""MOD+Up"" },
        .text = ""Click on VOLUME_UP"",
    },
    {
        .shortcuts = { ""MOD+Down"" },
        .text = ""Click on VOLUME_DOWN"",
    },
    {
        .shortcuts = { ""MOD+p"" },
        .text = ""Click on POWER (turn screen on/off)"",
    },
    {
        .shortcuts = { ""Right-click (when screen is off)"" },
        .text = ""Power on"",
    },
    {
        .shortcuts = { ""MOD+o"" },
        .text = ""Turn device screen off (keep mirroring)"",
    },
    {
        .shortcuts = { ""MOD+Shift+o"" },
        .text = ""Turn device screen on"",
    },
    {
        .shortcuts = { ""MOD+r"" },
        .text = ""Rotate device screen"",
    },
    {
        .shortcuts = { ""MOD+n"", ""5th-click"" },
        .text = ""Expand notification panel"",
    },
    {
        .shortcuts = { ""MOD+Shift+n"" },
        .text = ""Collapse notification panel"",
    },
    {
        .shortcuts = { ""MOD+c"" },
        .text = ""Copy to clipboard (inject COPY keycode, Android >= 7 only)"",
    },
    {
        .shortcuts = { ""MOD+x"" },
        .text = ""Cut to clipboard (inject CUT keycode, Android >= 7 only)"",
    },
    {
        .shortcuts = { ""MOD+v"" },
        .text = ""Copy computer clipboard to device, then paste (inject PASTE ""
                ""keycode, Android >= 7 only)"",
    },
    {
        .shortcuts = { ""MOD+Shift+v"" },
        .text = ""Inject computer clipboard text as a sequence of key events"",
    },
    {
        .shortcuts = { ""MOD+k"" },
        .text = ""Open keyboard settings on the device (for HID keyboard only)"",
    },
    {
        .shortcuts = { ""MOD+i"" },
        .text = ""Enable/disable FPS counter (print frames/second in logs)"",
    },
    {
        .shortcuts = { ""Ctrl+click-and-move"" },
        .text = ""Pinch-to-zoom and rotate from the center of the screen"",
    },
    {
        .shortcuts = { ""Shift+click-and-move"" },
        .text = ""Tilt (slide vertically with two fingers)"",
    },
    {
        .shortcuts = { ""Drag & drop APK file"" },
        .text = ""Install APK from computer"",
    },
    {
        .shortcuts = { ""Drag & drop non-APK file"" },
        .text = ""Push file to device (see --push-target)"",
    },
};

static const struct sc_envvar envvars[] = {
    {
        .name = ""ADB"",
        .text = ""Path to adb executable"",
    },
    {
        .name = ""ANDROID_SERIAL"",
        .text = ""Device serial to use if no selector (-s, -d, -e or ""
                ""--tcpip=<addr>) is specified"",
    },
    {
        .name = ""SCRCPY_ICON_PATH"",
        .text = ""Path to the program icon"",
    },
    {
        .name = ""SCRCPY_SERVER_PATH"",
        .text = ""Path to the server binary"",
    },
};

static const struct sc_exit_status exit_statuses[] = {
    {
        .value = 0,
        .text = ""Normal program termination"",
    },
    {
        .value = 1,
        .text = ""Start failure"",
    },
    {
        .value = 2,
        .text = ""Device disconnected while running"",
    },
};

static char *
sc_getopt_adapter_create_optstring(void) {
    struct sc_strbuf buf;
    if (!sc_strbuf_init(&buf, 64)) {
        return false;
    }

    for (size_t i = 0; i < ARRAY_LEN(options); ++i) {
        const struct sc_option *opt = &options[i];
        if (opt->shortopt) {
            if (!sc_strbuf_append_char(&buf, opt->shortopt)) {
                goto error;
            }
            // If there is an argument, add ':'
            if (opt->argdesc) {
                if (!sc_strbuf_append_char(&buf, ':')) {
                    goto error;
                }
                // If the argument is optional, add another ':'
                if (opt->optional_arg && !sc_strbuf_append_char(&buf, ':')) {
                    goto error;
                }
            }
        }
    }

    return buf.s;

error:
    free(buf.s);
    return NULL;
}

static struct option *
sc_getopt_adapter_create_longopts(void) {
    struct option *longopts =
        malloc((ARRAY_LEN(options) + 1) * sizeof(*longopts));
    if (!longopts) {
        LOG_OOM();
        return NULL;
    }

    size_t out_idx = 0;
    for (size_t i = 0; i < ARRAY_LEN(options); ++i) {
        const struct sc_option *in = &options[i];

        // If longopt_id is set, then longopt must be set
        assert(!in->longopt_id || in->longopt);

        if (!in->longopt) {
            // The longopts array must only contain long options
            continue;
        }
        struct option *out = &longopts[out_idx++];

        out->name = in->longopt;

        if (!in->argdesc) {
            assert(!in->optional_arg);
            out->has_arg = no_argument;
        } else if (in->optional_arg) {
            out->has_arg = optional_argument;
        } else {
            out->has_arg = required_argument;
        }

        out->flag = NULL;

        // Either shortopt or longopt_id is set, but not both
        assert(!!in->shortopt ^ !!in->longopt_id);
        out->val = in->shortopt ? in->shortopt : in->longopt_id;
    }

    // The array must be terminated by a NULL item
    longopts[out_idx] = (struct option) {0};

    return longopts;
}

static bool
sc_getopt_adapter_init(struct sc_getopt_adapter *adapter) {
    adapter->optstring = sc_getopt_adapter_create_optstring();
    if (!adapter->optstring) {
        return false;
    }

    adapter->longopts = sc_getopt_adapter_create_longopts();
    if (!adapter->longopts) {
        free(adapter->optstring);
        return false;
    }

    return true;
}

static void
sc_getopt_adapter_destroy(struct sc_getopt_adapter *adapter) {
    free(adapter->optstring);
    free(adapter->longopts);
}

static void
print_option_usage_header(const struct sc_option *opt) {
    struct sc_strbuf buf;
    if (!sc_strbuf_init(&buf, 64)) {
        goto error;
    }

    bool ok = true;
    (void) ok; // only used for assertions

    if (opt->shortopt) {
        ok = sc_strbuf_append_char(&buf, '-');
        assert(ok);

        ok = sc_strbuf_append_char(&buf, opt->shortopt);
        assert(ok);

        if (opt->longopt) {
            ok = sc_strbuf_append_staticstr(&buf, "", "");
            assert(ok);
        }
    }

    if (opt->longopt) {
        ok = sc_strbuf_append_staticstr(&buf, ""--"");
        assert(ok);

        if (!sc_strbuf_append_str(&buf, opt->longopt)) {
            goto error;
        }
    }

    if (opt->argdesc) {
        if (opt->optional_arg && !sc_strbuf_append_char(&buf, '[')) {
            goto error;
        }

        if (!sc_strbuf_append_char(&buf, '=')) {
            goto error;
        }

        if (!sc_strbuf_append_str(&buf, opt->argdesc)) {
            goto error;
        }

        if (opt->optional_arg && !sc_strbuf_append_char(&buf, ']')) {
            goto error;
        }
    }

    printf(""\n    %s\n"", buf.s);
    free(buf.s);
    return;

error:
    printf(""<ERROR>\n"");
}

static void
print_option_usage(const struct sc_option *opt, unsigned cols) {
    assert(cols > 8); // sc_str_wrap_lines() requires indent < columns

    if (!opt->text) {
        // Option not documented in help (for example because it is deprecated)
        return;
    }

    print_option_usage_header(opt);

    char *text = sc_str_wrap_lines(opt->text, cols, 8);
    if (!text) {
        printf(""<ERROR>\n"");
        return;
    }

    printf(""%s\n"", text);
    free(text);
}

static void
print_shortcuts_intro(unsigned cols) {
    char *intro = sc_str_wrap_lines(
        ""In the following list, MOD is the shortcut modifier. By default, it's ""
        ""(left) Alt or (left) Super, but it can be configured by ""
        ""--shortcut-mod (see above)."", cols, 4);
    if (!intro) {
        printf(""<ERROR>\n"");
        return;
    }

    printf(""\n%s\n"", intro);
    free(intro);
}

static void
print_shortcut(const struct sc_shortcut *shortcut, unsigned cols) {
    assert(cols > 8); // sc_str_wrap_lines() requires indent < columns
    assert(shortcut->shortcuts[0]); // At least one shortcut
    assert(shortcut->text);

    printf(""\n"");

    unsigned i = 0;
    while (shortcut->shortcuts[i]) {
        printf(""    %s\n"", shortcut->shortcuts[i]);
        ++i;
    }

    char *text = sc_str_wrap_lines(shortcut->text, cols, 8);
    if (!text) {
        printf(""<ERROR>\n"");
        return;
    }

    printf(""%s\n"", text);
    free(text);
}

static void
print_envvar(const struct sc_envvar *envvar, unsigned cols) {
    assert(cols > 8); // sc_str_wrap_lines() requires indent < columns
    assert(envvar->name);
    assert(envvar->text);

    printf(""\n    %s\n"", envvar->name);
    char *text = sc_str_wrap_lines(envvar->text, cols, 8);
    if (!text) {
        printf(""<ERROR>\n"");
        return;
    }

    printf(""%s\n"", text);
    free(text);
}

static void
print_exit_status(const struct sc_exit_status *status, unsigned cols) {
    assert(cols > 8); // sc_str_wrap_lines() requires indent < columns
    assert(status->text);

    // The text starts at 9: 4 ident spaces, 3 chars for numeric value, 2 spaces
    char *text = sc_str_wrap_lines(status->text, cols, 9);
    if (!text) {
        printf(""<ERROR>\n"");
        return;
    }

    assert(strlen(text) >= 9); // Contains at least the initial identation

    // text + 9 to remove the initial indentation
    printf(""    %3d  %s\n"", status->value, text + 9);
    free(text);
}

void
scrcpy_print_usage(const char *arg0) {
#define SC_TERM_COLS_DEFAULT 80
    unsigned cols;

    if (!isatty(STDERR_FILENO)) {
        // Not a tty
        cols = SC_TERM_COLS_DEFAULT;
    } else {
        bool ok = sc_term_get_size(NULL, &cols);
        if (!ok) {
            // Could not get the terminal size
            cols = SC_TERM_COLS_DEFAULT;
        }
        if (cols < 20) {
            // Do not accept a too small value
            cols = 20;
        }
    }

    printf(""Usage: %s [options]\n\n""
            ""Options:\n"", arg0);
    for (size_t i = 0; i < ARRAY_LEN(options); ++i) {
        print_option_usage(&options[i], cols);
    }

    // Print shortcuts section
    printf(""\nShortcuts:\n"");
    print_shortcuts_intro(cols);
    for (size_t i = 0; i < ARRAY_LEN(shortcuts); ++i) {
        print_shortcut(&shortcuts[i], cols);
    }

    // Print environment variables section
    printf(""\nEnvironment variables:\n"");
    for (size_t i = 0; i < ARRAY_LEN(envvars); ++i) {
        print_envvar(&envvars[i], cols);
    }

    printf(""\nExit status:\n\n"");
    for (size_t i = 0; i < ARRAY_LEN(exit_statuses); ++i) {
        print_exit_status(&exit_statuses[i], cols);
    }
}

static bool
parse_integer_arg(const char *s, long *out, bool accept_suffix, long min,
                  long max, const char *name) {
    long value;
    bool ok;
    if (accept_suffix) {
        ok = sc_str_parse_integer_with_suffix(s, &value);
    } else {
        ok = sc_str_parse_integer(s, &value);
    }
    if (!ok) {
        LOGE(""Could not parse %s: %s"", name, s);
        return false;
    }

    if (value < min || value > max) {
        LOGE(""Could not parse %s: value (%ld) out-of-range (%ld; %ld)"",
             name, value, min, max);
        return false;
    }

    *out = value;
    return true;
}

static size_t
parse_integers_arg(const char *s, const char sep, size_t max_items, long *out,
                   long min, long max, const char *name) {
    size_t count = sc_str_parse_integers(s, sep, max_items, out);
    if (!count) {
        LOGE(""Could not parse %s: %s"", name, s);
        return 0;
    }

    for (size_t i = 0; i < count; ++i) {
        long value = out[i];
        if (value < min || value > max) {
            LOGE(""Could not parse %s: value (%ld) out-of-range (%ld; %ld)"",
                 name, value, min, max);
            return 0;
        }
    }

    return count;
}

static bool
parse_bit_rate(const char *s, uint32_t *bit_rate) {
    long value;
    // long may be 32 bits (it is the case on mingw), so do not use more than
    // 31 bits (long is signed)
    bool ok = parse_integer_arg(s, &value, true, 0, 0x7FFFFFFF, ""bit-rate"");
    if (!ok) {
        return false;
    }

    *bit_rate = (uint32_t) value;
    return true;
}

static bool
parse_max_size(const char *s, uint16_t *max_size) {
    long value;
    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF, ""max size"");
    if (!ok) {
        return false;
    }

    *max_size = (uint16_t) value;
    return true;
}

static bool
parse_max_fps(const char *s, uint16_t *max_fps) {
    long value;
    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF, ""max fps"");
    if (!ok) {
        return false;
    }

    *max_fps = (uint16_t) value;
    return true;
}

static bool
parse_buffering_time(const char *s, sc_tick *tick) {
    long value;
    // In practice, buffering time should not exceed a few seconds.
    // Limit it to some arbitrary value (1 hour) to prevent 32-bit overflow
    // when multiplied by the audio sample size and the number of samples per
    // millisecond.
    bool ok = parse_integer_arg(s, &value, false, 0, 60 * 60 * 1000,
                                ""buffering time"");
    if (!ok) {
        return false;
    }

    *tick = SC_TICK_FROM_MS(value);
    return true;
}

static bool
parse_audio_output_buffer(const char *s, sc_tick *tick) {
    long value;
    bool ok = parse_integer_arg(s, &value, false, 0, 1000,
                                ""audio output buffer"");
    if (!ok) {
        return false;
    }

    *tick = SC_TICK_FROM_MS(value);
    return true;
}

static bool
parse_lock_video_orientation(const char *s,
                             enum sc_lock_video_orientation *lock_mode) {
    if (!s || !strcmp(s, ""initial"")) {
        // Without argument, lock the initial orientation
        *lock_mode = SC_LOCK_VIDEO_ORIENTATION_INITIAL;
        return true;
    }

    if (!strcmp(s, ""unlocked"")) {
        *lock_mode = SC_LOCK_VIDEO_ORIENTATION_UNLOCKED;
        return true;
    }

    if (!strcmp(s, ""0"")) {
        *lock_mode = SC_LOCK_VIDEO_ORIENTATION_0;
        return true;
    }

    if (!strcmp(s, ""90"")) {
        *lock_mode = SC_LOCK_VIDEO_ORIENTATION_90;
        return true;
    }

    if (!strcmp(s, ""180"")) {
        *lock_mode = SC_LOCK_VIDEO_ORIENTATION_180;
        return true;
    }

    if (!strcmp(s, ""270"")) {
        *lock_mode = SC_LOCK_VIDEO_ORIENTATION_270;
        return true;
    }

    if (!strcmp(s, ""1"")) {
        LOGW(""--lock-video-orientation=1 is deprecated, use ""
             ""--lock-video-orientation=270 instead."");
        *lock_mode = SC_LOCK_VIDEO_ORIENTATION_270;
        return true;
    }

    if (!strcmp(s, ""2"")) {
        LOGW(""--lock-video-orientation=2 is deprecated, use ""
             ""--lock-video-orientation=180 instead."");
        *lock_mode = SC_LOCK_VIDEO_ORIENTATION_180;
        return true;
    }

    if (!strcmp(s, ""3"")) {
        LOGW(""--lock-video-orientation=3 is deprecated, use ""
             ""--lock-video-orientation=90 instead."");
        *lock_mode = SC_LOCK_VIDEO_ORIENTATION_90;
        return true;
    }

    LOGE(""Unsupported --lock-video-orientation value: %s (expected initial, ""
         ""unlocked, 0, 90, 180 or 270)."", s);
    return false;
}

static bool
parse_rotation(const char *s, uint8_t *rotation) {
    long value;
    bool ok = parse_integer_arg(s, &value, false, 0, 3, ""rotation"");
    if (!ok) {
        return false;
    }

    *rotation = (uint8_t) value;
    return true;
}

static bool
parse_orientation(const char *s, enum sc_orientation *orientation) {
    if (!strcmp(s, ""0"")) {
        *orientation = SC_ORIENTATION_0;
        return true;
    }
    if (!strcmp(s, ""90"")) {
        *orientation = SC_ORIENTATION_90;
        return true;
    }
    if (!strcmp(s, ""180"")) {
        *orientation = SC_ORIENTATION_180;
        return true;
    }
    if (!strcmp(s, ""270"")) {
        *orientation = SC_ORIENTATION_270;
        return true;
    }
    if (!strcmp(s, ""flip0"")) {
        *orientation = SC_ORIENTATION_FLIP_0;
        return true;
    }
    if (!strcmp(s, ""flip90"")) {
        *orientation = SC_ORIENTATION_FLIP_90;
        return true;
    }
    if (!strcmp(s, ""flip180"")) {
        *orientation = SC_ORIENTATION_FLIP_180;
        return true;
    }
    if (!strcmp(s, ""flip270"")) {
        *orientation = SC_ORIENTATION_FLIP_270;
        return true;
    }
    LOGE(""Unsupported orientation: %s (expected 0, 90, 180, 270, flip0, ""
         ""flip90, flip180 or flip270)"", optarg);
    return false;
}

static bool
parse_window_position(const char *s, int16_t *position) {
    // special value for ""auto""
    static_assert(SC_WINDOW_POSITION_UNDEFINED == -0x8000, ""unexpected value"");

    if (!strcmp(s, ""auto"")) {
        *position = SC_WINDOW_POSITION_UNDEFINED;
        return true;
    }

    long value;
    bool ok = parse_integer_arg(s, &value, false, -0x7FFF, 0x7FFF,
                                ""window position"");
    if (!ok) {
        return false;
    }

    *position = (int16_t) value;
    return true;
}

static bool
parse_window_dimension(const char *s, uint16_t *dimension) {
    long value;
    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF,
                                ""window dimension"");
    if (!ok) {
        return false;
    }

    *dimension = (uint16_t) value;
    return true;
}

static bool
parse_port_range(const char *s, struct sc_port_range *port_range) {
    long values[2];
    size_t count = parse_integers_arg(s, ':', 2, values, 0, 0xFFFF, ""port"");
    if (!count) {
        return false;
    }

    uint16_t v0 = (uint16_t) values[0];
    if (count == 1) {
        port_range->first = v0;
        port_range->last = v0;
        return true;
    }

    assert(count == 2);
    uint16_t v1 = (uint16_t) values[1];
    if (v0 < v1) {
        port_range->first = v0;
        port_range->last = v1;
    } else {
        port_range->first = v1;
        port_range->last = v0;
    }

    return true;
}

static bool
parse_display_id(const char *s, uint32_t *display_id) {
    long value;
    bool ok = parse_integer_arg(s, &value, false, 0, 0x7FFFFFFF, ""display id"");
    if (!ok) {
        return false;
    }

    *display_id = (uint32_t) value;
    return true;
}

static bool
parse_log_level(const char *s, enum sc_log_level *log_level) {
    if (!strcmp(s, ""verbose"")) {
        *log_level = SC_LOG_LEVEL_VERBOSE;
        return true;
    }

    if (!strcmp(s, ""debug"")) {
        *log_level = SC_LOG_LEVEL_DEBUG;
        return true;
    }

    if (!strcmp(s, ""info"")) {
        *log_level = SC_LOG_LEVEL_INFO;
        return true;
    }

    if (!strcmp(s, ""warn"")) {
        *log_level = SC_LOG_LEVEL_WARN;
        return true;
    }

    if (!strcmp(s, ""error"")) {
        *log_level = SC_LOG_LEVEL_ERROR;
        return true;
    }

    LOGE(""Could not parse log level: %s"", s);
    return false;
}

// item is a list of mod keys separated by '+' (e.g. ""lctrl+lalt"")
// returns a bitwise-or of SC_SHORTCUT_MOD_* constants (or 0 on error)
static unsigned
parse_shortcut_mods_item(const char *item, size_t len) {
    unsigned mod = 0;

    for (;;) {
        char *plus = strchr(item, '+');
        // strchr() does not consider the ""len"" parameter, to it could find an
        // occurrence too far in the string (there is no strnchr())
        bool has_plus = plus && plus < item + len;

        assert(!has_plus || plus > item);
        size_t key_len = has_plus ? (size_t) (plus - item) : len;

#define STREQ(literal, s, len) \
    ((sizeof(literal)-1 == len) && !memcmp(literal, s, len))

        if (STREQ(""lctrl"", item, key_len)) {
            mod |= SC_SHORTCUT_MOD_LCTRL;
        } else if (STREQ(""rctrl"", item, key_len)) {
            mod |= SC_SHORTCUT_MOD_RCTRL;
        } else if (STREQ(""lalt"", item, key_len)) {
            mod |= SC_SHORTCUT_MOD_LALT;
        } else if (STREQ(""ralt"", item, key_len)) {
            mod |= SC_SHORTCUT_MOD_RALT;
        } else if (STREQ(""lsuper"", item, key_len)) {
            mod |= SC_SHORTCUT_MOD_LSUPER;
        } else if (STREQ(""rsuper"", item, key_len)) {
            mod |= SC_SHORTCUT_MOD_RSUPER;
        } else {
            LOGE(""Unknown modifier key: %.*s ""
                 ""(must be one of: lctrl, rctrl, lalt, ralt, lsuper, rsuper)"",
                 (int) key_len, item);
            return 0;
        }
#undef STREQ

        if (!has_plus) {
            break;
        }

        item = plus + 1;
        assert(len >= key_len + 1);
        len -= key_len + 1;
    }

    return mod;
}

static bool
parse_shortcut_mods(const char *s, struct sc_shortcut_mods *mods) {
    unsigned count = 0;
    unsigned current = 0;

    // LCtrl+LAlt or RCtrl or LCtrl+RSuper: ""lctrl+lalt,rctrl,lctrl+rsuper""

    for (;;) {
        char *comma = strchr(s, ',');
        if (comma && count == SC_MAX_SHORTCUT_MODS - 1) {
            assert(count < SC_MAX_SHORTCUT_MODS);
            LOGW(""Too many shortcut modifiers alternatives"");
            return false;
        }

        assert(!comma || comma > s);
        size_t limit = comma ? (size_t) (comma - s) : strlen(s);

        unsigned mod = parse_shortcut_mods_item(s, limit);
        if (!mod) {
            LOGE(""Invalid modifier keys: %.*s"", (int) limit, s);
            return false;
        }

        mods->data[current++] = mod;
        ++count;

        if (!comma) {
            break;
        }

        s = comma + 1;
    }

    mods->count = count;

    return true;
}

#ifdef SC_TEST
// expose the function to unit-tests
bool
sc_parse_shortcut_mods(const char *s, struct sc_shortcut_mods *mods) {
    return parse_shortcut_mods(s, mods);
}
#endif

static enum sc_record_format
get_record_format(const char *name) {
    if (!strcmp(name, ""mp4"")) {
        return SC_RECORD_FORMAT_MP4;
    }
    if (!strcmp(name, ""mkv"")) {
        return SC_RECORD_FORMAT_MKV;
    }
    if (!strcmp(name, ""m4a"")) {
        return SC_RECORD_FORMAT_M4A;
    }
    if (!strcmp(name, ""mka"")) {
        return SC_RECORD_FORMAT_MKA;
    }
    if (!strcmp(name, ""opus"")) {
        return SC_RECORD_FORMAT_OPUS;
    }
    if (!strcmp(name, ""aac"")) {
        return SC_RECORD_FORMAT_AAC;
    }
    if (!strcmp(name, ""flac"")) {
        return SC_RECORD_FORMAT_FLAC;
    }
    if (!strcmp(name, ""wav"")) {
        return SC_RECORD_FORMAT_WAV;
    }
    return 0;
}

static bool
parse_record_format(const char *optarg, enum sc_record_format *format) {
    enum sc_record_format fmt = get_record_format(optarg);
    if (!fmt) {
        LOGE(""Unsupported record format: %s (expected mp4, mkv, m4a, mka, ""
             ""opus, aac, flac or wav)"", optarg);
        return false;
    }

    *format = fmt;
    return true;
}

static bool
parse_ip(const char *optarg, uint32_t *ipv4) {
    return net_parse_ipv4(optarg, ipv4);
}

static bool
parse_port(const char *optarg, uint16_t *port) {
    long value;
    if (!parse_integer_arg(optarg, &value, false, 0, 0xFFFF, ""port"")) {
        return false;
    }
    *port = (uint16_t) value;
    return true;
}

static enum sc_record_format
guess_record_format(const char *filename) {
    const char *dot = strrchr(filename, '.');
    if (!dot) {
        return 0;
    }

    const char *ext = dot + 1;
    return get_record_format(ext);
}

static bool
parse_video_codec(const char *optarg, enum sc_codec *codec) {
    if (!strcmp(optarg, ""h264"")) {
        *codec = SC_CODEC_H264;
        return true;
    }
    if (!strcmp(optarg, ""h265"")) {
        *codec = SC_CODEC_H265;
        return true;
    }
    if (!strcmp(optarg, ""av1"")) {
        *codec = SC_CODEC_AV1;
        return true;
    }
    LOGE(""Unsupported video codec: %s (expected h264, h265 or av1)"", optarg);
    return false;
}

static bool
parse_audio_codec(const char *optarg, enum sc_codec *codec) {
    if (!strcmp(optarg, ""opus"")) {
        *codec = SC_CODEC_OPUS;
        return true;
    }
    if (!strcmp(optarg, ""aac"")) {
        *codec = SC_CODEC_AAC;
        return true;
    }
    if (!strcmp(optarg, ""flac"")) {
        *codec = SC_CODEC_FLAC;
        return true;
    }
    if (!strcmp(optarg, ""raw"")) {
        *codec = SC_CODEC_RAW;
        return true;
    }
    LOGE(""Unsupported audio codec: %s (expected opus, aac, flac or raw)"",
         optarg);
    return false;
}

static bool
parse_video_source(const char *optarg, enum sc_video_source *source) {
    if (!strcmp(optarg, ""display"")) {
        *source = SC_VIDEO_SOURCE_DISPLAY;
        return true;
    }

    if (!strcmp(optarg, ""camera"")) {
        *source = SC_VIDEO_SOURCE_CAMERA;
        return true;
    }

    LOGE(""Unsupported video source: %s (expected display or camera)"", optarg);
    return false;
}

static bool
parse_audio_source(const char *optarg, enum sc_audio_source *source) {
    if (!strcmp(optarg, ""mic"")) {
        *source = SC_AUDIO_SOURCE_MIC;
        return true;
    }

    if (!strcmp(optarg, ""output"")) {
        *source = SC_AUDIO_SOURCE_OUTPUT;
        return true;
    }

    LOGE(""Unsupported audio source: %s (expected output or mic)"", optarg);
    return false;
}

static bool
parse_camera_facing(const char *optarg, enum sc_camera_facing *facing) {
    if (!strcmp(optarg, ""front"")) {
        *facing = SC_CAMERA_FACING_FRONT;
        return true;
    }

    if (!strcmp(optarg, ""back"")) {
        *facing = SC_CAMERA_FACING_BACK;
        return true;
    }

    if (!strcmp(optarg, ""external"")) {
        *facing = SC_CAMERA_FACING_EXTERNAL;
        return true;
    }

    if (*optarg == '\0') {
        // Empty string is a valid value (equivalent to not passing the option)
        *facing = SC_CAMERA_FACING_ANY;
        return true;
    }

    LOGE(""Unsupported camera facing: %s (expected front, back or external)"",
         optarg);
    return false;
}

static bool
parse_camera_fps(const char *s, uint16_t *camera_fps) {
    long value;
    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF, ""camera fps"");
    if (!ok) {
        return false;
    }

    *camera_fps = (uint16_t) value;
    return true;
}

static bool
parse_keyboard(const char *optarg, enum sc_keyboard_input_mode *mode) {
    if (!strcmp(optarg, ""disabled"")) {
        *mode = SC_KEYBOARD_INPUT_MODE_DISABLED;
        return true;
    }

    if (!strcmp(optarg, ""sdk"")) {
        *mode = SC_KEYBOARD_INPUT_MODE_SDK;
        return true;
    }

    if (!strcmp(optarg, ""uhid"")) {
        *mode = SC_KEYBOARD_INPUT_MODE_UHID;
        return true;
    }

    if (!strcmp(optarg, ""aoa"")) {
#ifdef HAVE_USB
        *mode = SC_KEYBOARD_INPUT_MODE_AOA;
        return true;
#else
        LOGE(""--keyboard=aoa is disabled."");
        return false;
#endif
    }

    LOGE(""Unsupported keyboard: %s (expected disabled, sdk, uhid and aoa)"",
         optarg);
    return false;
}

static bool
parse_mouse(const char *optarg, enum sc_mouse_input_mode *mode) {
    if (!strcmp(optarg, ""disabled"")) {
        *mode = SC_MOUSE_INPUT_MODE_DISABLED;
        return true;
    }

    if (!strcmp(optarg, ""sdk"")) {
        *mode = SC_MOUSE_INPUT_MODE_SDK;
        return true;
    }

    if (!strcmp(optarg, ""uhid"")) {
        *mode = SC_MOUSE_INPUT_MODE_UHID;
        return true;
    }

    if (!strcmp(optarg, ""aoa"")) {
#ifdef HAVE_USB
        *mode = SC_MOUSE_INPUT_MODE_AOA;
        return true;
#else
        LOGE(""--mouse=aoa is disabled."");
        return false;
#endif
    }

    LOGE(""Unsupported mouse: %s (expected disabled, sdk, uhid or aoa)"", optarg);
    return false;
}

static bool
parse_time_limit(const char *s, sc_tick *tick) {
    long value;
    bool ok = parse_integer_arg(s, &value, false, 0, 0x7FFFFFFF, ""time limit"");
    if (!ok) {
        return false;
    }

    *tick = SC_TICK_FROM_SEC(value);
    return true;
}

static bool
parse_pause_on_exit(const char *s, enum sc_pause_on_exit *pause_on_exit) {
    if (!s || !strcmp(s, ""true"")) {
        *pause_on_exit = SC_PAUSE_ON_EXIT_TRUE;
        return true;
    }

    if (!strcmp(s, ""false"")) {
        *pause_on_exit = SC_PAUSE_ON_EXIT_FALSE;
        return true;
    }

    if (!strcmp(s, ""if-error"")) {
        *pause_on_exit = SC_PAUSE_ON_EXIT_IF_ERROR;
        return true;
    }

    LOGE(""Unsupported pause on exit mode: %s ""
         ""(expected true, false or if-error)"", optarg);
    return false;

}

static bool
parse_args_with_getopt(struct scrcpy_cli_args *args, int argc, char *argv[],
                       const char *optstring, const struct option *longopts) {
    struct scrcpy_options *opts = &args->opts;

    optind = 0; // reset to start from the first argument in tests

    int c;
    while ((c = getopt_long(argc, argv, optstring, longopts, NULL)) != -1) {
        switch (c) {
            case OPT_BIT_RATE:
                LOGE(""--bit-rate has been removed, ""
                     ""use --video-bit-rate or --audio-bit-rate."");
                return false;
            case 'b':
                if (!parse_bit_rate(optarg, &opts->video_bit_rate)) {
                    return false;
                }
                break;
            case OPT_AUDIO_BIT_RATE:
                if (!parse_bit_rate(optarg, &opts->audio_bit_rate)) {
                    return false;
                }
                break;
            case OPT_CROP:
                opts->crop = optarg;
                break;
            case OPT_DISPLAY:
                LOGW(""--display is deprecated, use --display-id instead."");
                // fall through
            case OPT_DISPLAY_ID:
                if (!parse_display_id(optarg, &opts->display_id)) {
                    return false;
                }
                break;
            case 'd':
                opts->select_usb = true;
                break;
            case 'e':
                opts->select_tcpip = true;
                break;
            case 'f':
                opts->fullscreen = true;
                break;
            case OPT_RECORD_FORMAT:
                if (!parse_record_format(optarg, &opts->record_format)) {
                    return false;
                }
                break;
            case 'h':
                args->help = true;
                break;
            case 'K':
                opts->keyboard_input_mode = SC_KEYBOARD_INPUT_MODE_UHID;
                break;
            case OPT_KEYBOARD:
                if (!parse_keyboard(optarg, &opts->keyboard_input_mode)) {
                    return false;
                }
                break;
            case OPT_HID_KEYBOARD_DEPRECATED:
                LOGE(""--hid-keyboard has been removed, use --keyboard=aoa or ""
                     ""--keyboard=uhid instead."");
                return false;
            case OPT_MAX_FPS:
                if (!parse_max_fps(optarg, &opts->max_fps)) {
                    return false;
                }
                break;
            case 'm':
                if (!parse_max_size(optarg, &opts->max_size)) {
                    return false;
                }
                break;
            case 'M':
                opts->mouse_input_mode = SC_MOUSE_INPUT_MODE_UHID;
                break;
            case OPT_MOUSE:
                if (!parse_mouse(optarg, &opts->mouse_input_mode)) {
                    return false;
                }
                break;
            case OPT_HID_MOUSE_DEPRECATED:
                LOGE(""--hid-mouse has been removed, use --mouse=aoa or ""
                     ""--mouse=uhid instead."");
                return false;
            case OPT_LOCK_VIDEO_ORIENTATION:
                if (!parse_lock_video_orientation(optarg,
                        &opts->lock_video_orientation)) {
                    return false;
                }
                break;
            case OPT_TUNNEL_HOST:
                if (!parse_ip(optarg, &opts->tunnel_host)) {
                    return false;
                }
                break;
            case OPT_TUNNEL_PORT:
                if (!parse_port(optarg, &opts->tunnel_port)) {
                    return false;
                }
                break;
            case 'n':
                opts->control = false;
                break;
            case OPT_NO_DISPLAY:
                LOGW(""--no-display is deprecated, use --no-playback instead."");
                // fall through
            case 'N':
                opts->video_playback = false;
                opts->audio_playback = false;
                break;
            case OPT_NO_VIDEO_PLAYBACK:
                opts->video_playback = false;
                break;
            case OPT_NO_AUDIO_PLAYBACK:
                opts->audio_playback = false;
                break;
            case 'p':
                if (!parse_port_range(optarg, &opts->port_range)) {
                    return false;
                }
                break;
            case 'r':
                opts->record_filename = optarg;
                break;
            case 's':
                opts->serial = optarg;
                break;
            case 'S':
                opts->turn_screen_off = true;
                break;
            case 't':
                opts->show_touches = true;
                break;
            case OPT_ALWAYS_ON_TOP:
                opts->always_on_top = true;
                break;
            case 'v':
                args->version = true;
                break;
            case 'V':
                if (!parse_log_level(optarg, &opts->log_level)) {
                    return false;
                }
                break;
            case 'w':
                opts->stay_awake = true;
                break;
            case OPT_WINDOW_TITLE:
                opts->window_title = optarg;
                break;
            case OPT_WINDOW_X:
                if (!parse_window_position(optarg, &opts->window_x)) {
                    return false;
                }
                break;
            case OPT_WINDOW_Y:
                if (!parse_window_position(optarg, &opts->window_y)) {
                    return false;
                }
                break;
            case OPT_WINDOW_WIDTH:
                if (!parse_window_dimension(optarg, &opts->window_width)) {
                    return false;
                }
                break;
            case OPT_WINDOW_HEIGHT:
                if (!parse_window_dimension(optarg, &opts->window_height)) {
                    return false;
                }
                break;
            case OPT_WINDOW_BORDERLESS:
                opts->window_borderless = true;
                break;
            case OPT_PUSH_TARGET:
                opts->push_target = optarg;
                break;
            case OPT_PREFER_TEXT:
                if (opts->key_inject_mode != SC_KEY_INJECT_MODE_MIXED) {
                    LOGE(""--prefer-text is incompatible with --raw-key-events"");
                    return false;
                }
                opts->key_inject_mode = SC_KEY_INJECT_MODE_TEXT;
                break;
            case OPT_RAW_KEY_EVENTS:
                if (opts->key_inject_mode != SC_KEY_INJECT_MODE_MIXED) {
                    LOGE(""--prefer-text is incompatible with --raw-key-events"");
                    return false;
                }
                opts->key_inject_mode = SC_KEY_INJECT_MODE_RAW;
                break;
            case OPT_ROTATION:
                LOGW(""--rotation is deprecated, use --display-orientation ""
                     ""instead."");
                uint8_t rotation;
                if (!parse_rotation(optarg, &rotation)) {
                    return false;
                }
                assert(rotation <= 3);
                switch (rotation) {
                    case 0:
                        opts->display_orientation = SC_ORIENTATION_0;
                        break;
                    case 1:
                        // rotation 1 was 90° counterclockwise, but orientation
                        // is expressed clockwise
                        opts->display_orientation = SC_ORIENTATION_270;
                        break;
                    case 2:
                        opts->display_orientation = SC_ORIENTATION_180;
                        break;
                    case 3:
                        // rotation 3 was 270° counterclockwise, but orientation
                        // is expressed clockwise
                        opts->display_orientation = SC_ORIENTATION_90;
                        break;
                }
                break;
            case OPT_DISPLAY_ORIENTATION:
                if (!parse_orientation(optarg, &opts->display_orientation)) {
                    return false;
                }
                break;
            case OPT_RECORD_ORIENTATION:
                if (!parse_orientation(optarg, &opts->record_orientation)) {
                    return false;
                }
                break;
            case OPT_ORIENTATION: {
                enum sc_orientation orientation;
                if (!parse_orientation(optarg, &orientation)) {
                    return false;
                }
                opts->display_orientation = orientation;
                opts->record_orientation = orientation;
                break;
            }
            case OPT_RENDER_DRIVER:
                opts->render_driver = optarg;
                break;
            case OPT_NO_MIPMAPS:
                opts->mipmaps = false;
                break;
            case OPT_NO_KEY_REPEAT:
                opts->forward_key_repeat = false;
                break;
            case OPT_CODEC_OPTIONS:
                LOGE(""--codec-options has been removed, ""
                     ""use --video-codec-options or --audio-codec-options."");
                return false;
            case OPT_VIDEO_CODEC_OPTIONS:
                opts->video_codec_options = optarg;
                break;
            case OPT_AUDIO_CODEC_OPTIONS:
                opts->audio_codec_options = optarg;
                break;
            case OPT_ENCODER:
                LOGE(""--encoder has been removed, ""
                     ""use --video-encoder or --audio-encoder."");
                return false;
            case OPT_VIDEO_ENCODER:
                opts->video_encoder = optarg;
                break;
            case OPT_AUDIO_ENCODER:
                opts->audio_encoder = optarg;
                break;
            case OPT_FORCE_ADB_FORWARD:
                opts->force_adb_forward = true;
                break;
            case OPT_DISABLE_SCREENSAVER:
                opts->disable_screensaver = true;
                break;
            case OPT_SHORTCUT_MOD:
                if (!parse_shortcut_mods(optarg, &opts->shortcut_mods)) {
                    return false;
                }
                break;
            case OPT_FORWARD_ALL_CLICKS:
                opts->forward_all_clicks = true;
                break;
            case OPT_LEGACY_PASTE:
                opts->legacy_paste = true;
                break;
            case OPT_POWER_OFF_ON_CLOSE:
                opts->power_off_on_close = true;
                break;
            case OPT_DISPLAY_BUFFER:
                if (!parse_buffering_time(optarg, &opts->display_buffer)) {
                    return false;
                }
                break;
            case OPT_NO_CLIPBOARD_AUTOSYNC:
                opts->clipboard_autosync = false;
                break;
            case OPT_TCPIP:
                opts->tcpip = true;
                opts->tcpip_dst = optarg;
                break;
            case OPT_NO_DOWNSIZE_ON_ERROR:
                opts->downsize_on_error = false;
                break;
            case OPT_NO_VIDEO:
                opts->video = false;
                break;
            case OPT_NO_AUDIO:
                opts->audio = false;
                break;
            case OPT_NO_CLEANUP:
                opts->cleanup = false;
                break;
            case OPT_NO_POWER_ON:
                opts->power_on = false;
                break;
            case OPT_PRINT_FPS:
                opts->start_fps_counter = true;
                break;
            case OPT_CODEC:
                LOGE(""--codec has been removed, ""
                     ""use --video-codec or --audio-codec."");
                return false;
            case OPT_VIDEO_CODEC:
                if (!parse_video_codec(optarg, &opts->video_codec)) {
                    return false;
                }
                break;
            case OPT_AUDIO_CODEC:
                if (!parse_audio_codec(optarg, &opts->audio_codec)) {
                    return false;
                }
                break;
            case OPT_OTG:
#ifdef HAVE_USB
                opts->otg = true;
                break;
#else
                LOGE(""OTG mode (--otg) is disabled."");
                return false;
#endif
            case OPT_V4L2_SINK:
#ifdef HAVE_V4L2
                opts->v4l2_device = optarg;
                break;
#else
                LOGE(""V4L2 (--v4l2-sink) is disabled (or unsupported on this ""
                     ""platform)."");
                return false;
#endif
            case OPT_V4L2_BUFFER:
#ifdef HAVE_V4L2
                if (!parse_buffering_time(optarg, &opts->v4l2_buffer)) {
                    return false;
                }
                break;
#else
                LOGE(""V4L2 (--v4l2-buffer) is disabled (or unsupported on this ""
                     ""platform)."");
                return false;
#endif
            case OPT_LIST_ENCODERS:
                opts->list |= SC_OPTION_LIST_ENCODERS;
                break;
            case OPT_LIST_DISPLAYS:
                opts->list |= SC_OPTION_LIST_DISPLAYS;
                break;
            case OPT_LIST_CAMERAS:
                opts->list |= SC_OPTION_LIST_CAMERAS;
                break;
            case OPT_LIST_CAMERA_SIZES:
                opts->list |= SC_OPTION_LIST_CAMERA_SIZES;
                break;
            case OPT_REQUIRE_AUDIO:
                opts->require_audio = true;
                break;
            case OPT_AUDIO_BUFFER:
                if (!parse_buffering_time(optarg, &opts->audio_buffer)) {
                    return false;
                }
                break;
            case OPT_AUDIO_OUTPUT_BUFFER:
                if (!parse_audio_output_buffer(optarg,
                                               &opts->audio_output_buffer)) {
                    return false;
                }
                break;
            case OPT_VIDEO_SOURCE:
                if (!parse_video_source(optarg, &opts->video_source)) {
                    return false;
                }
                break;
            case OPT_AUDIO_SOURCE:
                if (!parse_audio_source(optarg, &opts->audio_source)) {
                    return false;
                }
                break;
            case OPT_KILL_ADB_ON_CLOSE:
                opts->kill_adb_on_close = true;
                break;
            case OPT_TIME_LIMIT:
                if (!parse_time_limit(optarg, &opts->time_limit)) {
                    return false;
                }
                break;
            case OPT_PAUSE_ON_EXIT:
                if (!parse_pause_on_exit(optarg, &args->pause_on_exit)) {
                    return false;
                }
                break;
            case OPT_CAMERA_AR:
                opts->camera_ar = optarg;
                break;
            case OPT_CAMERA_ID:
                opts->camera_id = optarg;
                break;
            case OPT_CAMERA_SIZE:
                opts->camera_size = optarg;
                break;
            case OPT_CAMERA_FACING:
                if (!parse_camera_facing(optarg, &opts->camera_facing)) {
                    return false;
                }
                break;
            case OPT_CAMERA_FPS:
                if (!parse_camera_fps(optarg, &opts->camera_fps)) {
                    return false;
                }
                break;
            case OPT_CAMERA_HIGH_SPEED:
                opts->camera_high_speed = true;
                break;
            default:
                // getopt prints the error message on stderr
                return false;
        }
    }

    int index = optind;
    if (index < argc) {
        LOGE(""Unexpected additional argument: %s"", argv[index]);
        return false;
    }

    // If a TCP/IP address is provided, then tcpip must be enabled
    assert(opts->tcpip || !opts->tcpip_dst);

    unsigned selectors = !!opts->serial
                       + !!opts->tcpip_dst
                       + opts->select_tcpip
                       + opts->select_usb;
    if (selectors > 1) {
        LOGE(""At most one device selector option may be passed, among:\n""
             ""  --serial (-s)\n""
             ""  --select-usb (-d)\n""
             ""  --select-tcpip (-e)\n""
             ""  --tcpip=<addr> (with an argument)"");
        return false;
    }

    bool otg = false;
    bool v4l2 = false;
#ifdef HAVE_USB
    otg = opts->otg;
#endif
#ifdef HAVE_V4L2
    v4l2 = !!opts->v4l2_device;
#endif

    if (!opts->video) {
        opts->video_playback = false;
        // Do not power on the device on start if video capture is disabled
        opts->power_on = false;
    }

    if (!opts->audio) {
        opts->audio_playback = false;
    }

    if (opts->video && !opts->video_playback && !opts->record_filename
            && !v4l2) {
        LOGI(""No video playback, no recording, no V4L2 sink: video disabled"");
        opts->video = false;
    }

    if (opts->audio && !opts->audio_playback && !opts->record_filename) {
        LOGI(""No audio playback, no recording: audio disabled"");
        opts->audio = false;
    }

    if (!opts->video && !opts->audio && !otg) {
        LOGE(""No video, no audio, no OTG: nothing to do"");
        return false;
    }

    if (!opts->video && !otg) {
        // If video is disabled, then scrcpy must exit on audio failure.
        opts->require_audio = true;
    }

    if (opts->audio_playback && opts->audio_buffer == -1) {
        if (opts->audio_codec == SC_CODEC_FLAC) {
            // Use 50 ms audio buffer by default, but use a higher value for FLAC,
            // which is not low latency (the default encoder produces blocks of
            // 4096 samples, which represent ~85.333ms).
            LOGI(""FLAC audio: audio buffer increased to 120 ms (use ""
                 ""--audio-buffer to set a custom value)"");
            opts->audio_buffer = SC_TICK_FROM_MS(120);
        } else {
            opts->audio_buffer = SC_TICK_FROM_MS(50);
        }
    }

#ifdef HAVE_V4L2
    if (v4l2) {
        if (opts->lock_video_orientation ==
                SC_LOCK_VIDEO_ORIENTATION_UNLOCKED) {
            LOGI(""Video orientation is locked for v4l2 sink. ""
                 ""See --lock-video-orientation."");
            opts->lock_video_orientation = SC_LOCK_VIDEO_ORIENTATION_INITIAL;
        }

        // V4L2 could not handle size change.
        // Do not log because downsizing on error is the default behavior,
        // not an explicit request from the user.
        opts->downsize_on_error = false;
    }

    if (opts->v4l2_buffer && !opts->v4l2_device) {
        LOGE(""V4L2 buffer value without V4L2 sink\n"");
        return false;
    }
#endif

    if (opts->keyboard_input_mode == SC_KEYBOARD_INPUT_MODE_AUTO) {
        opts->keyboard_input_mode = otg ? SC_KEYBOARD_INPUT_MODE_AOA
                                        : SC_KEYBOARD_INPUT_MODE_SDK;
    }
    if (opts->mouse_input_mode == SC_MOUSE_INPUT_MODE_AUTO) {
        opts->mouse_input_mode = otg ? SC_MOUSE_INPUT_MODE_AOA
                                     : SC_MOUSE_INPUT_MODE_SDK;
    }

    if (otg) {
        enum sc_keyboard_input_mode kmode = opts->keyboard_input_mode;
        if (kmode != SC_KEYBOARD_INPUT_MODE_AOA
                && kmode != SC_KEYBOARD_INPUT_MODE_DISABLED) {
            LOGE(""In OTG mode, --keyboard only supports aoa or disabled."");
            return false;
        }

        enum sc_mouse_input_mode mmode = opts->mouse_input_mode;
        if (mmode != SC_MOUSE_INPUT_MODE_AOA
                && mmode != SC_MOUSE_INPUT_MODE_DISABLED) {
            LOGE(""In OTG mode, --mouse only supports aoa or disabled."");
            return false;
        }

        if (kmode == SC_KEYBOARD_INPUT_MODE_DISABLED
                && mmode == SC_MOUSE_INPUT_MODE_DISABLED) {
            LOGE(""Could not disable both keyboard and mouse in OTG mode."");
            return false;
        }
    }

    if (opts->keyboard_input_mode != SC_KEYBOARD_INPUT_MODE_SDK) {
        if (opts->key_inject_mode == SC_KEY_INJECT_MODE_TEXT) {
            LOGE(""--prefer-text is specific to --keyboard=sdk"");
            return false;
        }

        if (opts->key_inject_mode == SC_KEY_INJECT_MODE_RAW) {
            LOGE(""--raw-key-events is specific to --keyboard=sdk"");
            return false;
        }

        if (!opts->forward_key_repeat) {
            LOGE(""--no-key-repeat is specific to --keyboard=sdk"");
            return false;
        }
    }

    if ((opts->tunnel_host || opts->tunnel_port) && !opts->force_adb_forward) {
        LOGI(""Tunnel host/port is set, ""
             ""--force-adb-forward automatically enabled."");
        opts->force_adb_forward = true;
    }

    if (opts->video_source == SC_VIDEO_SOURCE_CAMERA) {
        if (opts->display_id) {
            LOGE(""--display-id is only available with --video-source=display"");
            return false;
        }

        if (opts->camera_id && opts->camera_facing != SC_CAMERA_FACING_ANY) {
            LOGE(""Could not specify both --camera-id and --camera-facing"");
            return false;
        }

        if (opts->camera_size) {
            if (opts->max_size) {
                LOGE(""Could not specify both --camera-size and -m/--max-size"");
                return false;
            }

            if (opts->camera_ar) {
                LOGE(""Could not specify both --camera-size and --camera-ar"");
                return false;
            }
        }

        if (opts->camera_high_speed && !opts->camera_fps) {
            LOGE(""--camera-high-speed requires an explicit --camera-fps value"");
            return false;
        }

        if (opts->control) {
            LOGI(""Camera video source: control disabled"");
            opts->control = false;
        }
    } else if (opts->camera_id
            || opts->camera_ar
            || opts->camera_facing != SC_CAMERA_FACING_ANY
            || opts->camera_fps
            || opts->camera_high_speed
            || opts->camera_size) {
        LOGE(""Camera options are only available with --video-source=camera"");
        return false;
    }

    if (opts->audio && opts->audio_source == SC_AUDIO_SOURCE_AUTO) {
        // Select the audio source according to the video source
        if (opts->video_source == SC_VIDEO_SOURCE_DISPLAY) {
            opts->audio_source = SC_AUDIO_SOURCE_OUTPUT;
        } else {
            opts->audio_source = SC_AUDIO_SOURCE_MIC;
            LOGI(""Camera video source: microphone audio source selected"");
        }
    }

    if (opts->record_format && !opts->record_filename) {
        LOGE(""Record format specified without recording"");
        return false;
    }

    if (opts->record_filename) {
        if (!opts->record_format) {
            opts->record_format = guess_record_format(opts->record_filename);
            if (!opts->record_format) {
                LOGE(""No format specified for \""%s\"" ""
                     ""(try with --record-format=mkv)"",
                     opts->record_filename);
                return false;
            }
        }

        if (opts->record_orientation != SC_ORIENTATION_0) {
            if (sc_orientation_is_mirror(opts->record_orientation)) {
                LOGE(""Record orientation only supports rotation, not ""
                     ""flipping: %s"",
                     sc_orientation_get_name(opts->record_orientation));
                return false;
            }
        }

        if (opts->video
                && sc_record_format_is_audio_only(opts->record_format)) {
            LOGE(""Audio container does not support video stream"");
            return false;
        }

        if (opts->record_format == SC_RECORD_FORMAT_OPUS
                && opts->audio_codec != SC_CODEC_OPUS) {
            LOGE(""Recording to OPUS file requires an OPUS audio stream ""
                 ""(try with --audio-codec=opus)"");
            return false;
        }

        if (opts->record_format == SC_RECORD_FORMAT_AAC
                && opts->audio_codec != SC_CODEC_AAC) {
            LOGE(""Recording to AAC file requires an AAC audio stream ""
                 ""(try with --audio-codec=aac)"");
            return false;
        }
        if (opts->record_format == SC_RECORD_FORMAT_FLAC
                && opts->audio_codec != SC_CODEC_FLAC) {
            LOGE(""Recording to FLAC file requires a FLAC audio stream ""
                 ""(try with --audio-codec=flac)"");
            return false;
        }

        if (opts->record_format == SC_RECORD_FORMAT_WAV
                && opts->audio_codec != SC_CODEC_RAW) {
            LOGE(""Recording to WAV file requires a RAW audio stream ""
                 ""(try with --audio-codec=raw)"");
            return false;
        }

        if ((opts->record_format == SC_RECORD_FORMAT_MP4 ||
             opts->record_format == SC_RECORD_FORMAT_M4A)
                && opts->audio_codec == SC_CODEC_RAW) {
            LOGE(""Recording to MP4 container does not support RAW audio"");
            return false;
        }
    }

    if (opts->audio_codec == SC_CODEC_FLAC && opts->audio_bit_rate) {
        LOGW(""--audio-bit-rate is ignored for FLAC audio codec"");
    }

    if (opts->audio_codec == SC_CODEC_RAW) {
        if (opts->audio_bit_rate) {
            LOGW(""--audio-bit-rate is ignored for raw audio codec"");
        }
        if (opts->audio_codec_options) {
            LOGW(""--audio-codec-options is ignored for raw audio codec"");
        }
        if (opts->audio_encoder) {
            LOGW(""--audio-encoder is ignored for raw audio codec"");
        }
    }

    if (!opts->control) {
        if (opts->turn_screen_off) {
            LOGE(""Could not request to turn screen off if control is disabled"");
            return false;
        }
        if (opts->stay_awake) {
            LOGE(""Could not request to stay awake if control is disabled"");
            return false;
        }
        if (opts->show_touches) {
            LOGE(""Could not request to show touches if control is disabled"");
            return false;
        }
        if (opts->power_off_on_close) {
            LOGE(""Could not request power off on close if control is disabled"");
            return false;
        }
    }

# ifdef _WIN32
    if (!otg && (opts->keyboard_input_mode == SC_KEYBOARD_INPUT_MODE_AOA
                || opts->mouse_input_mode == SC_MOUSE_INPUT_MODE_AOA)) {
        LOGE(""On Windows, it is not possible to open a USB device already open ""
             ""by another process (like adb)."");
        LOGE(""Therefore, --keyboard=aoa and --mouse=aoa may only work in OTG""
             ""mode (--otg)."");
        return false;
    }
# endif

    if (otg) {
        // OTG mode is compatible with only very few options.
        // Only report obvious errors.
        if (opts->record_filename) {
            LOGE(""OTG mode: could not record"");
            return false;
        }
        if (opts->turn_screen_off) {
            LOGE(""OTG mode: could not turn screen off"");
            return false;
        }
        if (opts->stay_awake) {
            LOGE(""OTG mode: could not stay awake"");
            return false;
        }
        if (opts->show_touches) {
            LOGE(""OTG mode: could not request to show touches"");
            return false;
        }
        if (opts->power_off_on_close) {
            LOGE(""OTG mode: could not request power off on close"");
            return false;
        }
        if (opts->display_id) {
            LOGE(""OTG mode: could not select display"");
            return false;
        }
        if (v4l2) {
            LOGE(""OTG mode: could not sink to V4L2 device"");
            return false;
        }
    }

    return true;
}

static enum sc_pause_on_exit
sc_get_pause_on_exit(int argc, char *argv[]) {
    // Read arguments backwards so that the last --pause-on-exit is considered
    // (same behavior as getopt())
    for (int i = argc - 1; i >= 1; --i) {
        const char *arg = argv[i];
        // Starts with ""--pause-on-exit""
        if (!strncmp(""--pause-on-exit"", arg, 15)) {
            if (arg[15] == '\0') {
                // No argument
                return SC_PAUSE_ON_EXIT_TRUE;
            }
            if (arg[15] != '=') {
                // Invalid parameter, ignore
                return SC_PAUSE_ON_EXIT_FALSE;
            }
            const char *value = &arg[16];
            if (!strcmp(value, ""true"")) {
                return SC_PAUSE_ON_EXIT_TRUE;
            }
            if (!strcmp(value, ""if-error"")) {
                return SC_PAUSE_ON_EXIT_IF_ERROR;
            }
            // Set to false, inclusing when the value is invalid
            return SC_PAUSE_ON_EXIT_FALSE;
        }
    }

    return SC_PAUSE_ON_EXIT_FALSE;
}

bool
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {
    struct sc_getopt_adapter adapter;
    if (!sc_getopt_adapter_init(&adapter)) {
        LOGW(""Could not create getopt adapter"");
        return false;
    }

    bool ret = parse_args_with_getopt(args, argc, argv, adapter.optstring,
                                      adapter.longopts);

    sc_getopt_adapter_destroy(&adapter);

    if (!ret && args->pause_on_exit == SC_PAUSE_ON_EXIT_FALSE) {
        // Check if ""--pause-on-exit"" is present in the arguments list, because
        // it must be taken into account even if command line parsing failed
        args->pause_on_exit = sc_get_pause_on_exit(argc, argv);
    }

    return ret;
}
"
./repos/Ventoy/VBLADE/vblade-master/aoe.c,https://github.com/ventoy/Ventoy,"// aoe.c: the ATA over Ethernet virtual EtherDrive (R) blade
#define _GNU_SOURCE
#include ""config.h""
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <netinet/in.h>
#include ""dat.h""
#include ""fns.h""

enum {
	Nmasks= 32,
	Nsrr= 256,
	Alen= 6,
};

uchar masks[Nmasks*Alen];
int nmasks;
uchar srr[Nsrr*Alen];
int nsrr;
char config[Nconfig];
int nconfig = 0;
int maxscnt = 2;
char *ifname;
int bufcnt = Bufcount;

#ifndef O_BINARY
#define O_BINARY 0
#endif

typedef unsigned long long u64_t;
typedef unsigned int    u32_t;

#pragma pack(4)
typedef struct ventoy_img_chunk
{
    u32_t img_start_sector; // sector size: 2KB
    u32_t img_end_sector;   // included

    u64_t disk_start_sector; // in disk_sector_size
    u64_t disk_end_sector;   // included
}ventoy_img_chunk;

typedef struct ventoy_disk_map
{
    u64_t img_start_sector;
    u64_t img_end_sector;
    u64_t disk_start_sector;
    u64_t disk_end_sector;
}ventoy_disk_map;
#pragma pack()

static int verbose = 0;
static u64_t g_iso_file_size = 0;
static int g_img_map_num = 0;
static ventoy_disk_map *g_img_map = NULL;

static ventoy_disk_map * vtoydm_get_img_map_data(const char *img_map_file, int *plen)
{
    int i;
    int len;
    int rc = 1;
    u64_t sector_num;
    FILE *fp = NULL;
    ventoy_img_chunk *chunk = NULL;
    ventoy_disk_map *map = NULL;
    
    fp = fopen(img_map_file, ""rb"");
    if (NULL == fp)
    {
        fprintf(stderr, ""Failed to open file %s\n"", img_map_file);
        return NULL;
    }

    fseek(fp, 0, SEEK_END);
    len = (int)ftell(fp);
    fseek(fp, 0, SEEK_SET);

    chunk = (ventoy_img_chunk *)malloc(len);
    if (NULL == chunk)
    {
        fprintf(stderr, ""Failed to malloc memory len:%d\n"", len);
        goto end;
    }

    if (fread(chunk, 1, len, fp) != len)
    {
        fprintf(stderr, ""Failed to read file\n"");
        goto end;
    }

    if (len % sizeof(ventoy_img_chunk))
    {
        fprintf(stderr, ""image map file size %d is not aligned with %d\n"", 
                len, (int)sizeof(ventoy_img_chunk));
        goto end;
    }

    map = (ventoy_disk_map *)malloc((len / sizeof(ventoy_img_chunk)) * sizeof(ventoy_disk_map));
    if (NULL == map)
    {
        fprintf(stderr, ""Failed to malloc memory\n"");
        goto end;
    }
    
    for (i = 0; i < len / sizeof(ventoy_img_chunk); i++)
    {
        sector_num = chunk[i].img_end_sector - chunk[i].img_start_sector + 1;
        g_iso_file_size += sector_num * 2048;
        
        map[i].img_start_sector = chunk[i].img_start_sector << 2;
        map[i].img_end_sector = (chunk[i].img_end_sector << 2) + 3;
        map[i].disk_start_sector = chunk[i].disk_start_sector;
        map[i].disk_end_sector = chunk[i].disk_end_sector;
    }

    rc = 0;
end:
    fclose(fp);

    if (chunk)
    {
        free(chunk);
        chunk = NULL;
    }

    *plen = len;
    return map;
}

static void parse_img_chunk(const char *img_map_file)
{
    int len;

    g_img_map = vtoydm_get_img_map_data(img_map_file, &len);
    if (g_img_map)
    {
        g_img_map_num = len / sizeof(ventoy_img_chunk);
    }
}

static u64_t get_disk_sector(u64_t lba)
{
    int i;
    ventoy_disk_map *cur = g_img_map;
    
    for (i = 0; i < g_img_map_num; i++, cur++)
    {
        if (lba >= cur->img_start_sector && lba <= cur->img_end_sector)
        {
            return (lba - cur->img_start_sector) + cur->disk_start_sector;
        }
    }

    return 0;
}

int getsec(int fd, uchar *place, vlong lba, int nsec)
{
    int i;
    int count = 0;
    u64_t last_sector;
    u64_t sector;

    count = 1;
    last_sector = get_disk_sector((u64_t)lba);
    
    for (i = 1; i < nsec; i++)
    {
        sector = get_disk_sector((u64_t)(lba + i));
        if (sector == (last_sector + count))
        {
            count++;
        }
        else
        {
            lseek(fd, last_sector * 512, SEEK_SET);
            read(fd, place, count * 512);

            last_sector = sector;
            count = 1;
        }
    }

    lseek(fd, last_sector * 512, SEEK_SET);
    read(fd, place, count * 512);

	return nsec * 512;
}
// read only
int putsec(int fd, uchar *place, vlong lba, int nsec)
{
    return nsec * 512;
}


void
aoead(int fd)	// advertise the virtual blade
{
	uchar buf[2000];
	Conf *p;
	int i;

	p = (Conf *)buf;
	memset(p, 0, sizeof *p);
	memset(p->h.dst, 0xff, 6);
	memmove(p->h.src, mac, 6);
	p->h.type = htons(0x88a2);
	p->h.flags = Resp;
	p->h.maj = htons(shelf);
	p->h.min = slot;
	p->h.cmd = Config;
	p->bufcnt = htons(bufcnt);
	p->scnt = maxscnt = (getmtu(sfd, ifname) - sizeof (Ata)) / 512;
	p->firmware = htons(FWV);
	p->vercmd = 0x10 | Qread;
	memcpy(p->data, config, nconfig);
	p->len = htons(nconfig);
	if (nmasks == 0)
	if (putpkt(fd, buf, sizeof *p - sizeof p->data + nconfig) == -1) {
		perror(""putpkt aoe id"");
		return;
	}
	for (i=0; i<nmasks; i++) {
		memcpy(p->h.dst, &masks[i*Alen], Alen);
		if (putpkt(fd, buf, sizeof *p - sizeof p->data + nconfig) == -1)
			perror(""putpkt aoe id"");
	}
}

int
isbcast(uchar *ea)
{
	uchar *b = (uchar *)""\377\377\377\377\377\377"";

	return memcmp(ea, b, 6) == 0;
}

long long
getlba(uchar *p)
{
	vlong v;
	int i;

	v = 0;
	for (i = 0; i < 6; i++)
		v |= (vlong)(*p++) << i * 8;
	return v;
}

int
aoeata(Ata *p, int pktlen)	// do ATA reqeust
{
	Ataregs r;
	int len = 60;
	int n;

	r.lba = getlba(p->lba);
	r.sectors = p->sectors;
	r.feature = p->err;
	r.cmd = p->cmd;
	if (r.cmd != 0xec)
	if (!rrok(p->h.src)) {
		p->h.flags |= Error;
		p->h.error = Res;
		return len;
	}
	if (atacmd(&r, (uchar *)(p+1), maxscnt*512, pktlen - sizeof(*p)) < 0) {
		p->h.flags |= Error;
		p->h.error = BadArg;
		return len;
	}
	if (!(p->aflag & Write))
	if ((n = p->sectors)) {
		n -= r.sectors;
		len = sizeof (Ata) + (n*512);
	}
	p->sectors = r.sectors;
	p->err = r.err;
	p->cmd = r.status;
	return len;
}

#define QCMD(x) ((x)->vercmd & 0xf)

// yes, this makes unnecessary copies.

int
confcmd(Conf *p, int payload)	// process conf request
{
	int len;

	len = ntohs(p->len);
	if (QCMD(p) != Qread)
	if (len > Nconfig || len > payload)
		return 0;	// if you can't play nice ...
	switch (QCMD(p)) {
	case Qtest:
		if (len != nconfig)
			return 0;
		// fall thru
	case Qprefix:
		if (len > nconfig)
			return 0;
		if (memcmp(config, p->data, len))
			return 0;
		// fall thru
	case Qread:
		break;
	case Qset:
		if (nconfig)
		if (nconfig != len || memcmp(config, p->data, len)) {
			p->h.flags |= Error;
			p->h.error = ConfigErr;
			break;
		}
		// fall thru
	case Qfset:
		nconfig = len;
		memcpy(config, p->data, nconfig);
		break;
	default:
		p->h.flags |= Error;
		p->h.error = BadArg;
	}
	memmove(p->data, config, nconfig);
	p->len = htons(nconfig);
	p->bufcnt = htons(bufcnt);
	p->scnt = maxscnt = (getmtu(sfd, ifname) - sizeof (Ata)) / 512;
	p->firmware = htons(FWV);
	p->vercmd = 0x10 | QCMD(p);	// aoe v.1
	return nconfig + sizeof *p - sizeof p->data;
}

static int
aoesrr(Aoesrr *sh, int len)
{
	uchar *m, *e;
	int n;

	e = (uchar *) sh + len;
	m = (uchar *) sh + Nsrrhdr;
	switch (sh->rcmd) {
	default:
e:		sh->h.error = BadArg;
		sh->h.flags |= Error;
		break;
	case 1:	// set
		if (!rrok(sh->h.src)) {
			sh->h.error = Res;
			sh->h.flags |= Error;
			break;
		}
	case 2:	// force set
		n = sh->nmacs * 6;
		if (e < m + n)
			goto e;
		nsrr = sh->nmacs;
		memmove(srr, m, n);
	case 0:	// read
		break;
	}
	sh->nmacs = nsrr;
	n = nsrr * 6;
	memmove(m, srr, n);
	return Nsrrhdr + n;
}

static int
addmask(uchar *ea)
{

	uchar *p, *e;

	p = masks;
	e = p + nmasks;
	for (; p<e; p += 6)
		if (!memcmp(p, ea, 6))
			return 2;
	if (nmasks >= Nmasks)
		return 0;
	memmove(p, ea, 6);
	nmasks++;
	return 1;
}

static void
rmmask(uchar *ea)
{
	uchar *p, *e;

	p = masks;
	e = p + nmasks;
	for (; p<e; p+=6)
		if (!memcmp(p, ea, 6)) {
			memmove(p, p+6, e-p-6);
			nmasks--;
			return;
		}
}

static int
aoemask(Aoemask *mh, int len)
{
	Mdir *md, *mdi, *mde;
	int i, n;

	n = 0;
	md = mdi = (Mdir *) ((uchar *)mh + Nmaskhdr);
	switch (mh->cmd) {
	case Medit:
		mde = md + mh->nmacs;
		for (; md<mde; md++) {
			switch (md->cmd) {
			case MDdel:
				rmmask(md->mac);
				continue;
			case MDadd:
				if (addmask(md->mac))
					continue;
				mh->merror = MEfull;
				mh->nmacs = md - mdi;
				goto e;
			case MDnop:
				continue;
			default:
				mh->merror = MEbaddir;
				mh->nmacs = md - mdi;
				goto e;
			}
		}
		// success.  fall thru to return list
	case Mread:
		md = mdi;
		for (i=0; i<nmasks; i++) {
			md->res = md->cmd = 0;
			memmove(md->mac, &masks[i*6], 6);
			md++;
		}
		mh->merror = 0;
		mh->nmacs = nmasks;
		n = sizeof *md * nmasks;
		break;
	default:
		mh->h.flags |= Error;
		mh->h.error = BadArg;
	}
e:	return n + Nmaskhdr;
}

void
doaoe(Aoehdr *p, int n)
{
	int len;

	switch (p->cmd) {
	case ATAcmd:
		if (n < Natahdr)
			return;
		len = aoeata((Ata*)p, n);
		break;
	case Config:
		if (n < Ncfghdr)
			return;
		len = confcmd((Conf *)p, n);
		break;
	case Mask:
		if (n < Nmaskhdr)
			return;
		len = aoemask((Aoemask *)p, n);
		break;
	case Resrel:
		if (n < Nsrrhdr)
			return;
		len = aoesrr((Aoesrr *)p, n);
		break;
	default:
		p->error = BadCmd;
		p->flags |= Error;
		len = n;
		break;
	}
	if (len <= 0)
		return;
	memmove(p->dst, p->src, 6);
	memmove(p->src, mac, 6);
	p->maj = htons(shelf);
	p->min = slot;
	p->flags |= Resp;
	if (putpkt(sfd, (uchar *) p, len) == -1) {
		perror(""write to network"");
		exit(1);
	}
}

void
aoe(void)
{
	Aoehdr *p;
	uchar *buf;
	int n, sh;
	long pagesz;
	enum { bufsz = 1<<16, };

	if ((pagesz = sysconf(_SC_PAGESIZE)) < 0) {
		perror(""sysconf"");
		exit(1);
	}        
	if ((buf = malloc(bufsz + pagesz)) == NULL) {
		perror(""malloc"");
		exit(1);
	}
	n = (size_t) buf + sizeof(Ata);
	if (n & (pagesz - 1))
		buf += pagesz - (n & (pagesz - 1));

	aoead(sfd);

	for (;;) {
		n = getpkt(sfd, buf, bufsz);
		if (n < 0) {
			perror(""read network"");
			exit(1);
		}
		if (n < sizeof(Aoehdr))
			continue;
		p = (Aoehdr *) buf;
		if (ntohs(p->type) != 0x88a2)
			continue;
		if (p->flags & Resp)
			continue;
		sh = ntohs(p->maj);
		if (sh != shelf && sh != (ushort)~0)
			continue;
		if (p->min != slot && p->min != (uchar)~0)
			continue;
		if (nmasks && !maskok(p->src))
			continue;
		doaoe(p, n);
	}
}

void
usage(void)
{
	fprintf(stderr, ""usage: %s [-b bufcnt] [-o offset] [-l length] [-d ] [-s] [-r] [ -m mac[,mac...] ] shelf slot netif filename\n"", 
		progname);
	exit(1);
}

/* parseether from plan 9 */
int
parseether(uchar *to, char *from)
{
	char nip[4];
	char *p;
	int i;

	p = from;
	for(i = 0; i < 6; i++){
		if(*p == 0)
			return -1;
		nip[0] = *p++;
		if(*p == 0)
			return -1;
		nip[1] = *p++;
		nip[2] = 0;
		to[i] = strtoul(nip, 0, 16);
		if(*p == ':')
			p++;
	}
	return 0;
}

void
setmask(char *ml)
{
	char *p;
	int n;

	for (; ml; ml=p) {
		p = strchr(ml, ',');
		if (p)
			*p++ = '\0';
		n = parseether(&masks[nmasks*Alen], ml);
		if (n < 0)
			fprintf(stderr, ""ignoring mask %s, parseether failure\n"", ml);
		else
			nmasks++;
	}
}

int
maskok(uchar *ea)
{
	int i, ok = 0;

	for (i=0; !ok && i<nmasks; i++)
		ok = memcmp(ea, &masks[i*Alen], Alen) == 0;
	return ok;
}

int
rrok(uchar *ea)
{
	int i, ok = 0;

	if (nsrr == 0)
		return 1;
	for (i=0; !ok && i<nsrr; i++)
		ok = memcmp(ea, &srr[i*Alen], Alen) == 0;
	return ok;
}

void
setserial(int sh, int sl)
{
	char h[32];

	h[0] = 0;
	gethostname(h, sizeof h);
	snprintf(serial, Nserial, ""%d.%d:%.*s"", sh, sl, (int) sizeof h, h);
}

int
main(int argc, char **argv)
{
	int ch, omode = 0, readonly = 0;
	vlong length = 0;
	char *end;
    char filepath[300] = {0};

    /* Avoid to be killed by systemd */
    if (access(""/etc/initrd-release"", F_OK) >= 0)
	{		
		argv[0][0] = '@';
	}

	bufcnt = Bufcount;
	offset = 0;
	setbuf(stdin, NULL);
	progname = *argv;
	while ((ch = getopt(argc, argv, ""b:dsrm:f:tv::o:l:"")) != -1) {
		switch (ch) {
		case 'b':
			bufcnt = atoi(optarg);
			break;
		case 'd':
#ifdef O_DIRECT
			omode |= O_DIRECT;
#endif
			break;
		case 's':
			omode |= O_SYNC;
			break;
		case 'r':
			readonly = 1;
			break;
		case 'm':
			setmask(optarg);
			break;
        case 't':
            return 0;
        case 'v':
            verbose = 1;
            break;
        case 'f':
            strncpy(filepath, optarg, sizeof(filepath) - 1);
            break;
		case 'o':
			offset = strtoll(optarg, &end, 0);
			if (end == optarg || offset < 0)
				usage();
			break;
		case 'l':
			length = strtoll(optarg, &end, 0);
			if (end == optarg || length < 1)
				usage();
			break;
		case '?':
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;
	if (argc != 4 || bufcnt <= 0)
		usage();
	omode |= readonly ? O_RDONLY : O_RDWR;
    parse_img_chunk(filepath);
	bfd = open(argv[3], omode);
	if (bfd == -1) {
		perror(""open"");
		exit(1);
	}
	shelf = atoi(argv[0]);
	slot = atoi(argv[1]);
	setserial(shelf, slot);
	size = g_iso_file_size; //getsize(bfd);
	size /= 512;
	if (size <= offset) {
                if (offset)
                        fprintf(stderr,
                                ""Offset %lld too large for %lld-sector export\n"",
                                offset,
                                size);
                else
                        fputs(""0-sector file size is too small\n"", stderr);
		exit(1);
	}
	size -= offset;
	if (length) {
		if (length > size) {
			fprintf(stderr, ""Length %llu too big - exceeds size of file!\n"", offset);
			exit(1);
		}
		size = length;
	}
	ifname = argv[2];
	sfd = dial(ifname, bufcnt);
	if (sfd < 0)
		return 1;
	getea(sfd, ifname, mac);

    if (verbose) {
        printf(""pid %ld: e%d.%d, %lld sectors %s\n"",
		    (long) getpid(), shelf, slot, size,
		    readonly ? ""O_RDONLY"" : ""O_RDWR"");
    }
    
	fflush(stdout);
	atainit();
	aoe();
	return 0;
}

"
./repos/Ventoy/VBLADE/vblade-master/bpf.c,https://github.com/ventoy/Ventoy,"// bpf.c: bpf packet filter for linux/freebsd

#include ""config.h""
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include ""dat.h""
#include ""fns.h""

struct bpf_insn {
	ushort code;
	uchar jt;
	uchar jf;
	u_int32_t k;
};

struct bpf_program {
	uint bf_len;
	struct bpf_insn *bf_insns;
};

/* instruction classes */
#define		BPF_CLASS(code) ((code) & 0x07)
#define		BPF_LD		0x00
#define		BPF_LDX		0x01
#define		BPF_ST		0x02
#define		BPF_STX		0x03
#define		BPF_ALU		0x04
#define		BPF_JMP		0x05
#define		BPF_RET		0x06
#define		BPF_MISC	0x07

/* ld/ldx fields */
#define		BPF_SIZE(code)	((code) & 0x18)
#define		BPF_W		0x00
#define		BPF_H		0x08
#define		BPF_B		0x10
#define		BPF_MODE(code)	((code) & 0xe0)
#define		BPF_IMM 	0x00
#define		BPF_ABS		0x20
#define		BPF_IND		0x40
#define		BPF_MEM		0x60
#define		BPF_LEN		0x80
#define		BPF_MSH		0xa0

/* alu/jmp fields */
#define		BPF_OP(code)	((code) & 0xf0)
#define		BPF_ADD		0x00
#define		BPF_SUB		0x10
#define		BPF_MUL		0x20
#define		BPF_DIV		0x30
#define		BPF_OR		0x40
#define		BPF_AND		0x50
#define		BPF_LSH		0x60
#define		BPF_RSH		0x70
#define		BPF_NEG		0x80
#define		BPF_JA		0x00
#define		BPF_JEQ		0x10
#define		BPF_JGT		0x20
#define		BPF_JGE		0x30
#define		BPF_JSET	0x40
#define		BPF_SRC(code)	((code) & 0x08)
#define		BPF_K		0x00
#define		BPF_X		0x08

/* ret - BPF_K and BPF_X also apply */
#define		BPF_RVAL(code)	((code) & 0x18)
#define		BPF_A		0x10

/* misc */
#define		BPF_MISCOP(code) ((code) & 0xf8)
#define		BPF_TAX		0x00
#define		BPF_TXA		0x80

/* macros for insn array initializers */
#define BPF_STMT(code, k) { (ushort)(code), 0, 0, k }
#define BPF_JUMP(code, k, jt, jf) { (ushort)(code), jt, jf, k }

void *
create_bpf_program(int shelf, int slot)
{
	struct bpf_program *bpf_program;
	struct bpf_insn insns[] = {
		/* CHECKTYPE: Load the type into register */
		BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 12),
		/* Does it match AoE Type (0x88a2)? No, goto INVALID */
		BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x88a2, 0, 10),
		/* Load the flags into register */
		BPF_STMT(BPF_LD+BPF_B+BPF_ABS, 14),
		/* Check to see if the Resp flag is set */
		BPF_STMT(BPF_ALU+BPF_AND+BPF_K, Resp),
		/* Yes, goto INVALID */
		BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0, 0, 7),
		/* CHECKSHELF: Load the shelf number into register */
		BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 16),
		/* Does it match shelf number? Yes, goto CHECKSLOT */
		BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, shelf, 1, 0),
		/* Does it match broadcast? No, goto INVALID */
		BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0xffff, 0, 4),
		/* CHECKSLOT: Load the slot number into register */
		BPF_STMT(BPF_LD+BPF_B+BPF_ABS, 18),
		/* Does it match shelf number? Yes, goto VALID */
		BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, slot, 1, 0),
		/* Does it match broadcast? No, goto INVALID */
		BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0xff, 0, 1),
		/* VALID: return -1 (allow the packet to be read) */
		BPF_STMT(BPF_RET+BPF_K, -1),
		/* INVALID: return 0 (ignore the packet) */
		BPF_STMT(BPF_RET+BPF_K, 0),
	};
	if ((bpf_program = malloc(sizeof(struct bpf_program))) == NULL
	    || (bpf_program->bf_insns = malloc(sizeof(insns))) == NULL) {
		perror(""malloc"");
		exit(1);
	}
	bpf_program->bf_len = sizeof(insns)/sizeof(struct bpf_insn);
	memcpy(bpf_program->bf_insns, insns, sizeof(insns));
	return (void *)bpf_program;
}

void
free_bpf_program(void *bpf_program)
{
	free(((struct bpf_program *) bpf_program)->bf_insns);
	free(bpf_program);
}
"
./repos/Ventoy/VBLADE/vblade-master/freebsd.c,https://github.com/ventoy/Ventoy,"/*
 * Copyright (c) 2005, Stacey Son <sson (at) verio (dot) net>
 * All rights reserved.
 */

// freebsd.c: low level access routines for FreeBSD
#include ""config.h""
#include <sys/types.h>
#include <sys/socket.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/time.h>

#include <netinet/in.h>
#include <net/ethernet.h>
#include <net/bpf.h>
#include <net/if.h>
#include <net/if_arp.h>
#include <net/if_dl.h>
#include <net/route.h>

#include <sys/ioctl.h>
#include <sys/types.h>
#include <net/if.h>
#include <sys/stat.h>
#include <sys/disk.h>
#include <sys/select.h>
#include <sys/sysctl.h>

#include <fcntl.h>
#include <errno.h>

#include ""dat.h""
#include ""fns.h""

#define BPF_DEV ""/dev/bpf0""

/* Packet buffer for getpkt() */
static uchar *pktbuf = NULL;
static int pktbufsz = 0;

int
dial(char *eth, int bufcnt)
{
	char m;
	int fd = -1;
	struct bpf_version bv;
	u_int v;
	unsigned bufsize, linktype;
	char device[sizeof BPF_DEV];
	struct ifreq ifr;

	struct bpf_program *bpf_program = create_bpf_program(shelf, slot);
	
	strncpy(device, BPF_DEV, sizeof BPF_DEV);

	/* find a bpf device we can use, check /dev/bpf[0-9] */
	for (m = '0'; m <= '9'; m++) {
		device[sizeof(BPF_DEV)-2] = m;

		if ((fd = open(device, O_RDWR)) > 0)
			break;
	}

	if (fd < 0) {
		perror(""open"");
		return -1;
	}

	if (ioctl(fd, BIOCVERSION, &bv) < 0) {
		perror(""BIOCVERSION"");
		goto bad;
	}

	if (bv.bv_major != BPF_MAJOR_VERSION ||
	    bv.bv_minor < BPF_MINOR_VERSION) {
		fprintf(stderr,
			""kernel bpf filter out of date\n"");
		goto bad;
	}

	/*
	 * Try finding a good size for the buffer; 65536 may be too
	 * big, so keep cutting it in half until we find a size
	 * that works, or run out of sizes to try.
	 *
	 */
	for (v = 65536; v != 0; v >>= 1) {
		(void) ioctl(fd, BIOCSBLEN, (caddr_t)&v);

		(void)strncpy(ifr.ifr_name, eth,
			sizeof(ifr.ifr_name));
		if (ioctl(fd, BIOCSETIF, (caddr_t)&ifr) >= 0)
			break;  /* that size worked; we're done */

		if (errno != ENOBUFS) {
			fprintf(stderr, ""BIOCSETIF: %s: %s\n"",
					eth, strerror(errno));
			goto bad;
		}
	}
	if (v == 0) {
		fprintf(stderr, 
			""BIOCSBLEN: %s: No buffer size worked\n"", eth);
		goto bad;
	}

	/* Allocate memory for the packet buffer */
	pktbufsz = v;
	if ((pktbuf = malloc(pktbufsz)) == NULL) {
		perror(""malloc"");
		goto bad;
	}

	/* Don't wait for buffer to be full or timeout */
	v = 1;
	if (ioctl(fd, BIOCIMMEDIATE, &v) < 0) {
		perror(""BIOCIMMEDIATE"");
		goto bad;
	}

	/* Only read incoming packets */
	v = 0;
	if (ioctl(fd, BIOCSSEESENT, &v) < 0) {
		perror(""BIOCSSEESENT"");
		goto bad;
	}

	/* Don't complete ethernet hdr */
	v = 1;
	if (ioctl(fd, BIOCSHDRCMPLT, &v) < 0) {
		perror(""BIOCSHDRCMPLT"");
		goto bad;
	}

	/* Get the data link layer type. */
	if (ioctl(fd, BIOCGDLT, (caddr_t)&v) < 0) {
		perror(""BIOCGDLT"");
		goto bad;
	}
	linktype = v;

	/* Get the filter buf size */
	if (ioctl(fd, BIOCGBLEN, (caddr_t)&v) < 0) {
		perror(""BIOCGBLEN"");
		goto bad;
	}
	bufsize = v;

	if (ioctl(fd, BIOCSETF, (caddr_t)bpf_program) < 0) {
		perror(""BIOSETF"");
		goto bad;
	} 

	free_bpf_program(bpf_program);
	return(fd);

bad:
	free_bpf_program(bpf_program);
	close(fd);
	return(-1);
}

int
getea(int s, char *eth, uchar *ea)
{
	int mib[6];
	size_t len;
	char *buf, *next, *end;
	struct if_msghdr *ifm;
	struct sockaddr_dl *sdl;
	

	mib[0] = CTL_NET; 	mib[1] = AF_ROUTE;
	mib[2] = 0; 		mib[3] = AF_LINK;
	mib[4] = NET_RT_IFLIST;	mib[5] = 0;

	if (sysctl(mib, 6, NULL, &len, NULL, 0) < 0) {
		return (-1);
	}

	if (!(buf = (char *) malloc(len))) {
		return (-1);
	}
	
	if (sysctl(mib, 6, buf, &len, NULL, 0) < 0) {
		free(buf);
		return (-1);
	}
	end = buf + len;

	for (next = buf; next < end; next += ifm->ifm_msglen) {
		ifm = (struct if_msghdr *)next;
		if (ifm->ifm_type == RTM_IFINFO) {
			sdl = (struct sockaddr_dl *)(ifm + 1);
			if (strncmp(&sdl->sdl_data[0], eth, 
					sdl->sdl_nlen) == 0) {
				memcpy(ea, LLADDR(sdl), ETHER_ADDR_LEN);
				break;
			}

		}

	}

	free(buf);
	return(0);
}


#if 0
int
getsec(int fd, uchar *place, vlong lba, int nsec)
{
	return pread(fd, place, nsec * 512, lba * 512);
}

int
putsec(int fd, uchar *place, vlong lba, int nsec)
{
	return pwrite(fd, place, nsec * 512, lba * 512);
}
#endif

static int pktn = 0;
static uchar *pktbp = NULL;

int
getpkt(int fd, uchar *buf, int sz)
{
	register struct bpf_hdr *bh;
	register int pktlen, retlen;
	
	if (pktn <= 0) { 
		if ((pktn = read(fd, pktbuf, pktbufsz)) < 0) {
			perror(""read"");
			exit(1);
		}
		pktbp = pktbuf;
	}

	bh = (struct bpf_hdr *) pktbp;
	retlen = (int) bh->bh_caplen;
	/* This memcpy() is currently needed */ 
	memcpy(buf, (void *)(pktbp + bh->bh_hdrlen),
		retlen > sz ? sz : retlen);
	pktlen = bh->bh_hdrlen + bh->bh_caplen; 
	
	pktbp = pktbp + BPF_WORDALIGN(pktlen);
	pktn  -= (int) BPF_WORDALIGN(pktlen);

	return retlen; 
}

int
putpkt(int fd, uchar *buf, int sz)
{
	return write(fd, buf, sz);
}

int
getmtu(int fd, char *name)
{
	struct ifreq xx;
	int s, n, p;

	s = socket(AF_INET, SOCK_RAW, 0);
	if (s == -1) {
		perror(""Can't get mtu"");
		return 1500;
	}
	xx.ifr_addr.sa_family = AF_INET;
	snprintf(xx.ifr_name, sizeof xx.ifr_name, ""%s"", name);
	n = ioctl(s, SIOCGIFMTU, &xx);
	if (n == -1) {
		perror(""Can't get mtu"");
		return 1500;
	}
	close(s);
	// FreeBSD bpf writes are capped at one PAGESIZE'd mbuf. As such we must
	// limit our sector count. See FreeBSD PR 205164, OpenAoE/vblade #7.
	p = getpagesize();
	if (xx.ifr_mtu > p) {
		return p;
	}
	return xx.ifr_mtu;
}

vlong
getsize(int fd)
{
	off_t media_size;
	vlong size;
	struct stat s;
	int n;

	// Try getting disklabel from block dev
	if ((n = ioctl(fd, DIOCGMEDIASIZE, &media_size)) != -1) {
		size = media_size;
	} else {
		// must not be a block special dev
		if (fstat(fd, &s) == -1) {
			perror(""getsize"");
			exit(1);
		}
		size = s.st_size;
	}
	printf(""ioctl returned %d\n"", n);
	printf(""%lld bytes\n"", size);
	return size;
}
"
./repos/Ventoy/VBLADE/vblade-master/ata.c,https://github.com/ventoy/Ventoy,"// ata.c:  ATA simulator for vblade
#include ""config.h""
#include <string.h>
#include <stdio.h>
#include <sys/types.h>
#include ""dat.h""
#include ""fns.h""

enum {
	// err bits
	UNC =	1<<6,
	MC =	1<<5,
	IDNF =	1<<4,
	MCR =	1<<3,
	ABRT = 	1<<2,
	NM =	1<<1,

	// status bits
	BSY =	1<<7,
	DRDY =	1<<6,
	DF =	1<<5,
	DRQ =	1<<3,
	ERR =	1<<0,
};

static ushort ident[256];

static void
setfld(ushort *a, int idx, int len, char *str)	// set field in ident
{
	uchar *p;

	p = (uchar *)(a+idx);
	while (len > 0) {
		if (*str == 0)
			p[1] = ' ';
		else
			p[1] = *str++;
		if (*str == 0)
			p[0] = ' ';
		else
			p[0] = *str++;
		p += 2;
		len -= 2;
	}
}

static void
setlba28(ushort *ident, vlong lba)
{
	uchar *cp;

	cp = (uchar *) &ident[60];
	*cp++ = lba;
	*cp++ = lba >>= 8;
	*cp++ = lba >>= 8;
	*cp++ = (lba >>= 8) & 0xf;
}

static void
setlba48(ushort *ident, vlong lba)
{
	uchar *cp;

	cp = (uchar *) &ident[100];
	*cp++ = lba;
	*cp++ = lba >>= 8;
	*cp++ = lba >>= 8;
	*cp++ = lba >>= 8;
	*cp++ = lba >>= 8;
	*cp++ = lba >>= 8;
}

static void
setushort(ushort *a, int i, ushort n)
{
	uchar *p;

	p = (uchar *)(a+i);
	*p++ = n & 0xff;
	*p++ = n >> 8;
}

void
atainit(void)
{
	char buf[64];

	setushort(ident, 47, 0x8000);
	setushort(ident, 49, 0x0200);
	setushort(ident, 50, 0x4000);
	setushort(ident, 83, 0x5400);
	setushort(ident, 84, 0x4000);
	setushort(ident, 86, 0x1400);
	setushort(ident, 87, 0x4000);
	setushort(ident, 93, 0x400b);
	setfld(ident, 27, 40, ""Coraid EtherDrive vblade"");
	sprintf(buf, ""V%d"", VBLADE_VERSION);
	setfld(ident, 23, 8, buf);
	setfld(ident, 10, 20, serial);
}


/* The ATA spec is weird in that you specify the device size as number
 * of sectors and then address the sectors with an offset.  That means
 * with LBA 28 you shouldn't see an LBA of all ones.  Still, we don't
 * check for that.
 */
int
atacmd(Ataregs *p, uchar *dp, int ndp, int payload) // do the ata cmd
{
	vlong lba;
	ushort *ip;
	int n;
	enum { MAXLBA28SIZE = 0x0fffffff };
	extern int maxscnt;

	p->status = 0;
	switch (p->cmd) {
	default:
		p->status = DRDY | ERR;
		p->err = ABRT;
		return 0;
	case 0xe7:		// flush cache
		return 0;
	case 0xec:		// identify device
		if (p->sectors != 1 || ndp < 512)
			return -1;
		memmove(dp, ident, 512);
		ip = (ushort *)dp;
		if (size & ~MAXLBA28SIZE)
			setlba28(ip, MAXLBA28SIZE);
		else
			setlba28(ip, size);
		setlba48(ip, size);
		p->err = 0;
		p->status = DRDY;
		p->sectors = 0;
		return 0;
	case 0xe5:		// check power mode
		p->err = 0;
		p->sectors = 0xff; // the device is active or idle
		p->status = DRDY;
		return 0;
	case 0x20:		// read sectors
	case 0x30:		// write sectors
		lba = p->lba & MAXLBA28SIZE;
		break;
	case 0x24:		// read sectors ext
	case 0x34:		// write sectors ext
		lba = p->lba & 0x0000ffffffffffffLL;	// full 48
		break;
	}

	// we ought not be here unless we are a read/write

	if (p->sectors > maxscnt || p->sectors*512 > ndp)
		return -1;

	if (lba + p->sectors > size) {
		p->err = IDNF;
		p->status = DRDY | ERR;
		p->lba = lba;
		return 0;
	}
	if (p->cmd == 0x20 || p->cmd == 0x24)
		n = getsec(bfd, dp, lba+offset, p->sectors);
	else {
		// packet should be big enough to contain the data
		if (payload < 512 * p->sectors)
			return -1;
		n = putsec(bfd, dp, lba+offset, p->sectors);
	}
	n /= 512;
	if (n != p->sectors) {
		p->err = ABRT;
		p->status = ERR;
	} else
		p->err = 0;
	p->status |= DRDY;
	p->lba += n;
	p->sectors -= n;
	return 0;
}

"
./repos/Ventoy/VBLADE/vblade-master/linux.c,https://github.com/ventoy/Ventoy,"// linux.c: low level access routines for Linux
#define _GNU_SOURCE
#include ""config.h""
#include <sys/socket.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/time.h>
#include <features.h>    /* for the glibc version number */
#if __GLIBC__ >= 2 && __GLIBC_MINOR >= 1
#include <netpacket/packet.h>
#include <net/ethernet.h>     /* the L2 protocols */
#else
#include <asm/types.h>
#include <linux/if_packet.h>
#include <linux/if_ether.h>   /* The L2 protocols */
#endif

#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <net/if.h>
#include <netinet/in.h>
#include <linux/fs.h>
#include <sys/stat.h>

#include ""dat.h""
#include ""fns.h""

int	getindx(int, char *);
int	getea(int, char *, uchar *);



int
dial(char *eth, int bufcnt)		// get us a raw connection to an interface
{
	int i, n, s;
	struct sockaddr_ll sa;
	enum { aoe_type = 0x88a2 };

	memset(&sa, 0, sizeof sa);
	s = socket(PF_PACKET, SOCK_RAW, htons(aoe_type));
	if (s == -1) {
		perror(""got bad socket"");
		return -1;
	}
	i = getindx(s, eth);
	if (i < 0) {
		perror(eth);
		return -1;
	}
	sa.sll_family = AF_PACKET;
	sa.sll_protocol = htons(0x88a2);
	sa.sll_ifindex = i;
	n = bind(s, (struct sockaddr *)&sa, sizeof sa);
	if (n == -1) {
		perror(""bind funky"");
		return -1;
	}

	struct bpf_program {
		ulong bf_len;
		void *bf_insns;
	} *bpf_program = create_bpf_program(shelf, slot);
	setsockopt(s, SOL_SOCKET, SO_ATTACH_FILTER, bpf_program, sizeof(*bpf_program));
	free_bpf_program(bpf_program);

	n = bufcnt * getmtu(s, eth);
	if (setsockopt(s, SOL_SOCKET, SO_SNDBUF, &n, sizeof(n)) < 0)
		perror(""setsockopt SOL_SOCKET, SO_SNDBUF"");
	if (setsockopt(s, SOL_SOCKET, SO_RCVBUF, &n, sizeof(n)) < 0)
		perror(""setsockopt SOL_SOCKET, SO_RCVBUF"");

	return s;
}

int
getindx(int s, char *name)	// return the index of device 'name'
{
	struct ifreq xx;
	int n;

	snprintf(xx.ifr_name, sizeof xx.ifr_name, ""%s"", name);
	n = ioctl(s, SIOCGIFINDEX, &xx);
	if (n == -1)
		return -1;
	return xx.ifr_ifindex;
}

int
getea(int s, char *name, uchar *ea)
{
	struct ifreq xx;
	int n;

        snprintf(xx.ifr_name, sizeof xx.ifr_name, ""%s"", name);
	n = ioctl(s, SIOCGIFHWADDR, &xx);
	if (n == -1) {
		perror(""Can't get hw addr"");
		return 0;
	}
	memmove(ea, xx.ifr_hwaddr.sa_data, 6);
	return 1;
}

int
getmtu(int s, char *name)
{
	struct ifreq xx;
	int n;

	snprintf(xx.ifr_name, sizeof xx.ifr_name, ""%s"", name);
	n = ioctl(s, SIOCGIFMTU, &xx);
	if (n == -1) {
		perror(""Can't get mtu"");
		return 1500;
	}
	return xx.ifr_mtu;
}

#if 0
int
getsec(int fd, uchar *place, vlong lba, int nsec)
{
	return pread(fd, place, nsec * 512, lba * 512);
}

int
putsec(int fd, uchar *place, vlong lba, int nsec)
{
	return pwrite(fd, place, nsec * 512, lba * 512);
}
#endif

int
getpkt(int fd, uchar *buf, int sz)
{
	return read(fd, buf, sz);
}

int
putpkt(int fd, uchar *buf, int sz)
{
	return write(fd, buf, sz);
}

vlong
getsize(int fd)
{
	vlong size;
	struct stat s;
	int n;

	n = ioctl(fd, BLKGETSIZE64, &size);
	if (n == -1) {	// must not be a block special
		n = fstat(fd, &s);
		if (n == -1) {
			perror(""getsize"");
			exit(1);
		}
		size = s.st_size;
	}
	return size;
}
"
./repos/mpv/demux/cache.c,https://github.com/mpv-player/mpv.git,"/*
 * This file is part of mpv.
 *
 * mpv is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * mpv is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#include ""cache.h""
#include ""common/msg.h""
#include ""common/av_common.h""
#include ""demux.h""
#include ""misc/io_utils.h""
#include ""options/path.h""
#include ""options/m_config.h""
#include ""options/m_option.h""
#include ""osdep/io.h""

struct demux_cache_opts {
    char *cache_dir;
    int unlink_files;
};

#define OPT_BASE_STRUCT struct demux_cache_opts

const struct m_sub_options demux_cache_conf = {
    .opts = (const struct m_option[]){
        {""demuxer-cache-dir"", OPT_STRING(cache_dir), .flags = M_OPT_FILE},
        {""demuxer-cache-unlink-files"", OPT_CHOICE(unlink_files,
            {""immediate"", 2}, {""whendone"", 1}, {""no"", 0}),
        },
        {""cache-dir"", OPT_REPLACED(""demuxer-cache-dir"")},
        {""cache-unlink-files"", OPT_REPLACED(""demuxer-cache-unlink-files"")},
        {0}
    },
    .size = sizeof(struct demux_cache_opts),
    .defaults = &(const struct demux_cache_opts){
        .unlink_files = 2,
    },
};

struct demux_cache {
    struct mp_log *log;
    struct demux_cache_opts *opts;

    char *filename;
    bool need_unlink;
    int fd;
    int64_t file_pos;
    uint64_t file_size;
};

struct pkt_header {
    uint32_t data_len;
    uint32_t av_flags;
    uint32_t num_sd;
};

struct sd_header {
    uint32_t av_type;
    uint32_t len;
};

static void cache_destroy(void *p)
{
    struct demux_cache *cache = p;

    if (cache->fd >= 0)
        close(cache->fd);

    if (cache->need_unlink && cache->opts->unlink_files >= 1) {
        if (unlink(cache->filename))
            MP_ERR(cache, ""Failed to delete cache temporary file.\n"");
    }
}

// Create a cache. This also initializes the cache file from the options. The
// log parameter must stay valid until demux_cache is destroyed.
// Free with talloc_free().
struct demux_cache *demux_cache_create(struct mpv_global *global,
                                       struct mp_log *log)
{
    struct demux_cache *cache = talloc_zero(NULL, struct demux_cache);
    talloc_set_destructor(cache, cache_destroy);
    cache->opts = mp_get_config_group(cache, global, &demux_cache_conf);
    cache->log = log;
    cache->fd = -1;

    char *cache_dir = cache->opts->cache_dir;
    if (cache_dir && cache_dir[0]) {
        cache_dir = mp_get_user_path(NULL, global, cache_dir);
    } else {
        cache_dir = mp_find_user_file(NULL, global, ""cache"", """");
    }

    if (!cache_dir || !cache_dir[0])
        goto fail;

    mp_mkdirp(cache_dir);
    cache->filename = mp_path_join(cache, cache_dir, ""mpv-cache-XXXXXX.dat"");
    cache->fd = mp_mkostemps(cache->filename, 4, O_CLOEXEC);
    if (cache->fd < 0) {
        MP_ERR(cache, ""Failed to create cache temporary file.\n"");
        goto fail;
    }
    cache->need_unlink = true;
    if (cache->opts->unlink_files >= 2) {
        if (unlink(cache->filename)) {
            MP_ERR(cache, ""Failed to unlink cache temporary file after creation.\n"");
        } else {
            cache->need_unlink = false;
        }
    }

    return cache;
fail:
    talloc_free(cache);
    return NULL;
}

uint64_t demux_cache_get_size(struct demux_cache *cache)
{
    return cache->file_size;
}

static bool do_seek(struct demux_cache *cache, uint64_t pos)
{
    if (cache->file_pos == pos)
        return true;

    off_t res = lseek(cache->fd, pos, SEEK_SET);

    if (res == (off_t)-1) {
        MP_ERR(cache, ""Failed to seek in cache file.\n"");
        cache->file_pos = -1;
    } else {
        cache->file_pos = res;
    }

    return cache->file_pos >= 0;
}

static bool write_raw(struct demux_cache *cache, void *ptr, size_t len)
{
    ssize_t res = write(cache->fd, ptr, len);

    if (res < 0) {
        MP_ERR(cache, ""Failed to write to cache file: %s\n"", mp_strerror(errno));
        return false;
    }

    cache->file_pos += res;
    cache->file_size = MPMAX(cache->file_size, cache->file_pos);

    // Should never happen, unless the disk is full, or someone succeeded to
    // trick us to write into a pipe or a socket.
    if (res != len) {
        MP_ERR(cache, ""Could not write all data.\n"");
        return false;
    }

    return true;
}

static bool read_raw(struct demux_cache *cache, void *ptr, size_t len)
{
    ssize_t res = read(cache->fd, ptr, len);

    if (res < 0) {
        MP_ERR(cache, ""Failed to read cache file: %s\n"", mp_strerror(errno));
        return false;
    }

    cache->file_pos += res;

    // Should never happen, unless the file was cut short, or someone succeeded
    // to rick us to write into a pipe or a socket.
    if (res != len) {
        MP_ERR(cache, ""Could not read all data.\n"");
        return false;
    }

    return true;
}

// Serialize a packet to the cache file. Returns the packet position, which can
// be passed to demux_cache_read() to read the packet again.
// Returns a negative value on errors, i.e. writing the file failed.
int64_t demux_cache_write(struct demux_cache *cache, struct demux_packet *dp)
{
    assert(dp->avpacket);

    // AV_PKT_FLAG_TRUSTED usually means there are embedded pointers and such
    // in the packet data. The pointer will become invalid if the packet is
    // unreferenced.
    if (dp->avpacket->flags & AV_PKT_FLAG_TRUSTED) {
        MP_ERR(cache, ""Cannot serialize this packet to cache file.\n"");
        return -1;
    }

    assert(!dp->is_cached);
    assert(dp->len <= INT32_MAX);
    assert(dp->avpacket->flags >= 0 && dp->avpacket->flags <= INT32_MAX);
    assert(dp->avpacket->side_data_elems >= 0 &&
           dp->avpacket->side_data_elems <= INT32_MAX);

    if (!do_seek(cache, cache->file_size))
        return -1;

    uint64_t pos = cache->file_pos;

    struct pkt_header hd = {
        .data_len  = dp->len,
        .av_flags = dp->avpacket->flags,
        .num_sd = dp->avpacket->side_data_elems,
    };

    if (!write_raw(cache, &hd, sizeof(hd)))
        goto fail;

    if (!write_raw(cache, dp->buffer, dp->len))
        goto fail;

    // The handling of FFmpeg side data requires an extra long comment to
    // explain why this code is fragile and insane.
    // FFmpeg packet side data is per-packet out of band data, that contains
    // further information for the decoder (extra metadata and such), which is
    // not part of the codec itself and thus isn't contained in the packet
    // payload. All types use a flat byte array. The format of this byte array
    // is non-standard and FFmpeg-specific, and depends on the side data type
    // field. The side data type is of course a FFmpeg ABI artifact.
    // In some cases, the format is described as fixed byte layout. In others,
    // it contains a struct, i.e. is bound to FFmpeg ABI. Some newer types make
    // the format explicitly internal (and _not_ part of the ABI), and you need
    // to use separate accessors to turn it into complex data structures.
    // As of now, FFmpeg fortunately adheres to the idea that side data can not
    // contain embedded pointers (due to API rules, but also because they forgot
    // adding a refcount field, and can't change this until they break ABI).
    // We rely on this. We hope that FFmpeg won't silently change their
    // semantics, and add refcounting and embedded pointers. This way we can
    // for example dump the data in a disk cache, even though we can't use the
    // data from another process or if this process is restarted (unless we're
    // absolutely sure the FFmpeg internals didn't change). The data has to be
    // treated as a memory dump.
    for (int n = 0; n < dp->avpacket->side_data_elems; n++) {
        AVPacketSideData *sd = &dp->avpacket->side_data[n];

        assert(sd->size <= INT32_MAX);
        assert(sd->type >= 0 && sd->type <= INT32_MAX);

        struct sd_header sd_hd = {
            .av_type = sd->type,
            .len = sd->size,
        };

        if (!write_raw(cache, &sd_hd, sizeof(sd_hd)))
            goto fail;
        if (!write_raw(cache, sd->data, sd->size))
            goto fail;
    }

    return pos;

fail:
    // Reset file_size (try not to append crap forever).
    do_seek(cache, pos);
    cache->file_size = cache->file_pos;
    return -1;
}

struct demux_packet *demux_cache_read(struct demux_cache *cache, uint64_t pos)
{
    if (!do_seek(cache, pos))
        return NULL;

    struct pkt_header hd;

    if (!read_raw(cache, &hd, sizeof(hd)))
        return NULL;

    struct demux_packet *dp = new_demux_packet(hd.data_len);
    if (!dp)
        goto fail;

    if (!read_raw(cache, dp->buffer, dp->len))
        goto fail;

    dp->avpacket->flags = hd.av_flags;

    for (uint32_t n = 0; n < hd.num_sd; n++) {
        struct sd_header sd_hd;

        if (!read_raw(cache, &sd_hd, sizeof(sd_hd)))
            goto fail;

        if (sd_hd.len > INT_MAX)
            goto fail;

        uint8_t *sd = av_packet_new_side_data(dp->avpacket, sd_hd.av_type,
                                              sd_hd.len);
        if (!sd)
            goto fail;

        if (!read_raw(cache, sd, sd_hd.len))
            goto fail;
    }

    return dp;

fail:
    talloc_free(dp);
    return NULL;
}
"
./repos/mpv/demux/demux_cue.c,https://github.com/mpv-player/mpv.git,"/*
 * Original author: Uoti Urpala
 *
 * This file is part of mpv.
 *
 * mpv is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * mpv is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <dirent.h>
#include <inttypes.h>

#include ""osdep/io.h""

#include ""mpv_talloc.h""

#include ""misc/bstr.h""
#include ""misc/charset_conv.h""
#include ""common/msg.h""
#include ""demux/demux.h""
#include ""options/m_config.h""
#include ""options/m_option.h""
#include ""options/path.h""
#include ""common/common.h""
#include ""stream/stream.h""
#include ""timeline.h""

#include ""cue.h""

#define PROBE_SIZE 512

const struct m_sub_options demux_cue_conf = {
        .opts = (const m_option_t[]) {
            {""codepage"", OPT_REPLACED(""metadata-codepage"")},
            {0}
        },
};

struct priv {
    struct cue_file *f;
};

static void add_source(struct timeline *tl, struct demuxer *d)
{
    MP_TARRAY_APPEND(tl, tl->sources, tl->num_sources, d);
}

static bool try_open(struct timeline *tl, char *filename)
{
    struct bstr bfilename = bstr0(filename);
    // Avoid trying to open itself or another .cue file. Best would be
    // to check the result of demuxer auto-detection, but the demuxer
    // API doesn't allow this without opening a full demuxer.
    if (bstr_case_endswith(bfilename, bstr0("".cue""))
        || bstrcasecmp(bstr0(tl->demuxer->filename), bfilename) == 0)
        return false;

    struct demuxer_params p = {
        .stream_flags = tl->stream_origin,
    };

    struct demuxer *d = demux_open_url(filename, &p, tl->cancel, tl->global);
    // Since .bin files are raw PCM data with no headers, we have to explicitly
    // open them. Also, try to avoid to open files that are most likely not .bin
    // files, as that would only play noise. Checking the file extension is
    // fragile, but it's about the only way we have.
    // TODO: maybe also could check if the .bin file is a multiple of the Audio
    //       CD sector size (2352 bytes)
    if (!d && bstr_case_endswith(bfilename, bstr0("".bin""))) {
        MP_WARN(tl, ""CUE: Opening as BIN file!\n"");
        p.force_format = ""rawaudio"";
        d = demux_open_url(filename, &p, tl->cancel, tl->global);
    }
    if (d) {
        add_source(tl, d);
        return true;
    }
    MP_ERR(tl, ""Could not open source '%s'!\n"", filename);
    return false;
}

static bool open_source(struct timeline *tl, char *filename)
{
    void *ctx = talloc_new(NULL);
    bool res = false;

    struct bstr dirname = mp_dirname(tl->demuxer->filename);

    struct bstr base_filename = bstr0(mp_basename(filename));
    if (!base_filename.len) {
        MP_WARN(tl, ""CUE: Invalid audio filename in .cue file!\n"");
    } else {
        char *fullname = mp_path_join_bstr(ctx, dirname, base_filename);
        if (try_open(tl, fullname)) {
            res = true;
            goto out;
        }
    }

    // Try an audio file with the same name as the .cue file (but different
    // extension).
    // Rationale: this situation happens easily if the audio file or both files
    // are renamed.

    struct bstr cuefile =
        bstr_strip_ext(bstr0(mp_basename(tl->demuxer->filename)));

    DIR *d = opendir(bstrdup0(ctx, dirname));
    if (!d)
        goto out;
    struct dirent *de;
    while ((de = readdir(d))) {
        char *dename0 = de->d_name;
        struct bstr dename = bstr0(dename0);
        if (bstr_case_startswith(dename, cuefile)) {
            MP_WARN(tl, ""CUE: No useful audio filename ""
                    ""in .cue file found, trying with '%s' instead!\n"",
                    dename0);
            if (try_open(tl, mp_path_join_bstr(ctx, dirname, dename))) {
                res = true;
                break;
            }
        }
    }
    closedir(d);

out:
    talloc_free(ctx);
    if (!res)
        MP_ERR(tl, ""CUE: Could not open audio file!\n"");
    return res;
}

static void build_timeline(struct timeline *tl)
{
    struct priv *p = tl->demuxer->priv;

    void *ctx = talloc_new(NULL);

    add_source(tl, tl->demuxer);

    struct cue_track *tracks = NULL;
    size_t track_count = 0;

    for (size_t n = 0; n < p->f->num_tracks; n++) {
        struct cue_track *track = &p->f->tracks[n];
        if (track->filename) {
            MP_TARRAY_APPEND(ctx, tracks, track_count, *track);
        } else {
            MP_WARN(tl->demuxer, ""No file specified for track entry %zd. ""
                    ""It will be removed\n"", n + 1);
        }
    }

    if (track_count == 0) {
        MP_ERR(tl, ""CUE: no tracks found!\n"");
        goto out;
    }

    // Remove duplicate file entries. This might be too sophisticated, since
    // CUE files usually use either separate files for every single track, or
    // only one file for all tracks.

    char **files = 0;
    size_t file_count = 0;

    for (size_t n = 0; n < track_count; n++) {
        struct cue_track *track = &tracks[n];
        track->source = -1;
        for (size_t file = 0; file < file_count; file++) {
            if (strcmp(files[file], track->filename) == 0) {
                track->source = file;
                break;
            }
        }
        if (track->source == -1) {
            file_count++;
            files = talloc_realloc(ctx, files, char *, file_count);
            files[file_count - 1] = track->filename;
            track->source = file_count - 1;
        }
    }

    for (size_t i = 0; i < file_count; i++) {
        if (!open_source(tl, files[i]))
            goto out;
    }

    struct timeline_part *timeline = talloc_array_ptrtype(tl, timeline,
                                                          track_count + 1);
    struct demux_chapter *chapters = talloc_array_ptrtype(tl, chapters,
                                                          track_count);
    double starttime = 0;
    for (int i = 0; i < track_count; i++) {
        struct demuxer *source = tl->sources[1 + tracks[i].source];
        double duration;
        if (i + 1 < track_count && tracks[i].source == tracks[i + 1].source) {
            duration = tracks[i + 1].start - tracks[i].start;
        } else {
            duration = source->duration;
            // Two cases: 1) last track of a single-file cue, or 2) any track of
            // a multi-file cue. We need to do this for 1) only because the
            // timeline needs to be terminated with the length of the last
            // track.
            duration -= tracks[i].start;
        }
        if (duration < 0) {
            MP_WARN(tl, ""CUE: Can't get duration of source file!\n"");
            // xxx: do something more reasonable
            duration = 0.0;
        }
        timeline[i] = (struct timeline_part) {
            .start = starttime,
            .end = starttime + duration,
            .source_start = tracks[i].start,
            .source = source,
        };
        chapters[i] = (struct demux_chapter) {
            .pts = timeline[i].start,
            .metadata = mp_tags_dup(tl, tracks[i].tags),
        };
        starttime = timeline[i].end;
    }

    struct timeline_par *par = talloc_ptrtype(tl, par);
    *par = (struct timeline_par){
        .parts = timeline,
        .num_parts = track_count,
        .track_layout = timeline[0].source,
    };

    tl->chapters = chapters;
    tl->num_chapters = track_count;
    MP_TARRAY_APPEND(tl, tl->pars, tl->num_pars, par);
    tl->meta = par->track_layout;
    tl->format = ""cue"";

out:
    talloc_free(ctx);
}

static int try_open_file(struct demuxer *demuxer, enum demux_check check)
{
    if (!demuxer->access_references)
        return -1;

    struct stream *s = demuxer->stream;
    if (check >= DEMUX_CHECK_UNSAFE) {
        char probe[PROBE_SIZE];
        int len = stream_read_peek(s, probe, sizeof(probe));
        if (len < 1 || !mp_probe_cue((bstr){probe, len}))
            return -1;
    }
    struct priv *p = talloc_zero(demuxer, struct priv);
    demuxer->priv = p;
    demuxer->fully_read = true;
    bstr data = stream_read_complete(s, p, 1000000);
    if (data.start == NULL)
        return -1;

    struct demux_opts *opts = mp_get_config_group(p, demuxer->global, &demux_conf);
    const char *charset = mp_charset_guess(p, demuxer->log, data, opts->meta_cp, 0);
    if (charset && !mp_charset_is_utf8(charset)) {
        MP_INFO(demuxer, ""Using CUE charset: %s\n"", charset);
        bstr utf8 = mp_iconv_to_utf8(demuxer->log, data, charset, MP_ICONV_VERBOSE);
        if (utf8.start && utf8.start != data.start) {
            ta_steal(data.start, utf8.start);
            data = utf8;
        }
    }
    talloc_free(opts);

    p->f = mp_parse_cue(data);
    talloc_steal(p, p->f);
    if (!p->f) {
        MP_ERR(demuxer, ""error parsing input file!\n"");
        return -1;
    }

    demux_close_stream(demuxer);

    mp_tags_merge(demuxer->metadata, p->f->tags);
    return 0;
}

const struct demuxer_desc demuxer_desc_cue = {
    .name = ""cue"",
    .desc = ""CUE sheet"",
    .open = try_open_file,
    .load_timeline = build_timeline,
};
"
./repos/mpv/demux/demux_disc.c,https://github.com/mpv-player/mpv.git,"/*
 * This file is part of mpv.
 *
 * mpv is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * mpv is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <string.h>
#include <math.h>
#include <assert.h>

#include ""common/common.h""
#include ""common/msg.h""

#include ""stream/stream.h""
#include ""video/mp_image.h""
#include ""demux.h""
#include ""stheader.h""

#include ""video/csputils.h""

struct priv {
    struct demuxer *slave;
    // streams[slave_stream_index] == our_stream
    struct sh_stream **streams;
    int num_streams;
    // This contains each DVD sub stream, or NULL. Needed because DVD packets
    // can come arbitrarily late in the MPEG stream, so the slave demuxer
    // might add the streams only later.
    struct sh_stream *dvd_subs[32];
    // Used to rewrite the raw MPEG timestamps to playback time.
    double base_time;   // playback display start time of current segment
    double base_dts;    // packet DTS that maps to base_time
    double last_dts;    // DTS of previously demuxed packet
    bool seek_reinit;   // needs reinit after seek

    bool is_dvd, is_cdda;
};

// If the timestamp difference between subsequent packets is this big, assume
// a reset. It should be big enough to account for 1. low video framerates and
// large audio frames, and 2. bad interleaving.
#define DTS_RESET_THRESHOLD 5.0

static void reselect_streams(demuxer_t *demuxer)
{
    struct priv *p = demuxer->priv;
    int num_slave = demux_get_num_stream(p->slave);
    for (int n = 0; n < MPMIN(num_slave, p->num_streams); n++) {
        if (p->streams[n]) {
            demuxer_select_track(p->slave, demux_get_stream(p->slave, n),
                MP_NOPTS_VALUE, demux_stream_is_selected(p->streams[n]));
        }
    }
}

static void get_disc_lang(struct stream *stream, struct sh_stream *sh, bool dvd)
{
    struct stream_lang_req req = {.type = sh->type, .id = sh->demuxer_id};
    if (dvd && sh->type == STREAM_SUB)
        req.id = req.id & 0x1F; // mpeg ID to index
    stream_control(stream, STREAM_CTRL_GET_LANG, &req);
    if (req.name[0])
        sh->lang = talloc_strdup(sh, req.name);
}

static void add_dvd_streams(demuxer_t *demuxer)
{
    struct priv *p = demuxer->priv;
    struct stream *stream = demuxer->stream;
    if (!p->is_dvd)
        return;
    struct stream_dvd_info_req info;
    if (stream_control(stream, STREAM_CTRL_GET_DVD_INFO, &info) > 0) {
        for (int n = 0; n < MPMIN(32, info.num_subs); n++) {
            struct sh_stream *sh = demux_alloc_sh_stream(STREAM_SUB);
            sh->demuxer_id = n + 0x20;
            sh->codec->codec = ""dvd_subtitle"";
            get_disc_lang(stream, sh, true);
            // p->streams _must_ match with p->slave->streams, so we can't add
            // it yet - it has to be done when the real stream appears, which
            // could be right on start, or any time later.
            p->dvd_subs[n] = sh;

            // emulate the extradata
            struct mp_csp_params csp = MP_CSP_PARAMS_DEFAULTS;
            struct pl_transform3x3 cmatrix;
            mp_get_csp_matrix(&csp, &cmatrix);

            char *s = talloc_strdup(sh, """");
            s = talloc_asprintf_append(s, ""palette: "");
            for (int i = 0; i < 16; i++) {
                int color = info.palette[i];
                int y[3] = {(color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff};
                int c[3];
                mp_map_fixp_color(&cmatrix, 8, y, 8, c);
                color = (c[2] << 16) | (c[1] << 8) | c[0];

                if (i != 0)
                    s = talloc_asprintf_append(s, "", "");
                s = talloc_asprintf_append(s, ""%06x"", color);
            }
            s = talloc_asprintf_append(s, ""\n"");

            sh->codec->extradata = s;
            sh->codec->extradata_size = strlen(s);

            demux_add_sh_stream(demuxer, sh);
        }
    }
}

static void add_streams(demuxer_t *demuxer)
{
    struct priv *p = demuxer->priv;

    for (int n = p->num_streams; n < demux_get_num_stream(p->slave); n++) {
        struct sh_stream *src = demux_get_stream(p->slave, n);
        if (src->type == STREAM_SUB) {
            struct sh_stream *sub = NULL;
            if (src->demuxer_id >= 0x20 && src->demuxer_id <= 0x3F)
                sub = p->dvd_subs[src->demuxer_id - 0x20];
            if (sub) {
                assert(p->num_streams == n); // directly mapped
                MP_TARRAY_APPEND(p, p->streams, p->num_streams, sub);
                continue;
            }
        }
        struct sh_stream *sh = demux_alloc_sh_stream(src->type);
        assert(p->num_streams == n); // directly mapped
        MP_TARRAY_APPEND(p, p->streams, p->num_streams, sh);
        // Copy all stream fields that might be relevant
        *sh->codec = *src->codec;
        sh->demuxer_id = src->demuxer_id;
        if (src->type == STREAM_VIDEO) {
            double ar;
            if (stream_control(demuxer->stream, STREAM_CTRL_GET_ASPECT_RATIO, &ar)
                                == STREAM_OK)
            {
                struct mp_image_params f = {.w = src->codec->disp_w,
                                            .h = src->codec->disp_h};
                mp_image_params_set_dsize(&f, 1728 * ar, 1728);
                sh->codec->par_w = f.p_w;
                sh->codec->par_h = f.p_h;
            }
        }
        get_disc_lang(demuxer->stream, sh, p->is_dvd);
        demux_add_sh_stream(demuxer, sh);
    }
    reselect_streams(demuxer);
}

static void d_seek(demuxer_t *demuxer, double seek_pts, int flags)
{
    struct priv *p = demuxer->priv;

    if (p->is_cdda) {
        demux_seek(p->slave, seek_pts, flags);
        return;
    }

    if (flags & SEEK_FACTOR) {
        double tmp = 0;
        stream_control(demuxer->stream, STREAM_CTRL_GET_TIME_LENGTH, &tmp);
        seek_pts *= tmp;
    }

    MP_VERBOSE(demuxer, ""seek to: %f\n"", seek_pts);

    // Supposed to induce a seek reset. Does it even work? I don't know.
    // It will log some bogus error messages, since the demuxer will try a
    // low level seek, which will obviously not work. But it will probably
    // clear its internal buffers.
    demux_seek(p->slave, 0, SEEK_FACTOR | SEEK_FORCE);
    stream_drop_buffers(demuxer->stream);

    double seek_arg[] = {seek_pts, flags};
    stream_control(demuxer->stream, STREAM_CTRL_SEEK_TO_TIME, seek_arg);

    p->seek_reinit = true;
}

static void reset_pts(demuxer_t *demuxer)
{
    struct priv *p = demuxer->priv;

    double base;
    if (stream_control(demuxer->stream, STREAM_CTRL_GET_CURRENT_TIME, &base) < 1)
        base = 0;

    MP_VERBOSE(demuxer, ""reset to time: %f\n"", base);

    p->base_dts = p->last_dts = MP_NOPTS_VALUE;
    p->base_time = base;
    p->seek_reinit = false;
}

static bool d_read_packet(struct demuxer *demuxer, struct demux_packet **out_pkt)
{
    struct priv *p = demuxer->priv;

    struct demux_packet *pkt = demux_read_any_packet(p->slave);
    if (!pkt)
        return false;

    demux_update(p->slave, MP_NOPTS_VALUE);

    if (p->seek_reinit)
        reset_pts(demuxer);

    add_streams(demuxer);
    if (pkt->stream >= p->num_streams) { // out of memory?
        talloc_free(pkt);
        return true;
    }

    struct sh_stream *sh = p->streams[pkt->stream];
    if (!demux_stream_is_selected(sh)) {
        talloc_free(pkt);
        return true;
    }

    pkt->stream = sh->index;

    if (p->is_cdda) {
        *out_pkt = pkt;
        return true;
    }

    MP_TRACE(demuxer, ""ipts: %d %f %f\n"", sh->type, pkt->pts, pkt->dts);

    if (sh->type == STREAM_SUB) {
        if (p->base_dts == MP_NOPTS_VALUE)
            MP_WARN(demuxer, ""subtitle packet along PTS reset\n"");
    } else if (pkt->dts != MP_NOPTS_VALUE) {
        // Use the very first DTS to rebase the start time of the MPEG stream
        // to the playback time.
        if (p->base_dts == MP_NOPTS_VALUE)
            p->base_dts = pkt->dts;

        if (p->last_dts == MP_NOPTS_VALUE)
            p->last_dts = pkt->dts;

        if (fabs(p->last_dts - pkt->dts) >= DTS_RESET_THRESHOLD) {
            MP_WARN(demuxer, ""PTS discontinuity: %f->%f\n"", p->last_dts, pkt->dts);
            p->base_time += p->last_dts - p->base_dts;
            p->base_dts = pkt->dts - pkt->duration;
        }
        p->last_dts = pkt->dts;
    }

    if (p->base_dts != MP_NOPTS_VALUE) {
        double delta = -p->base_dts + p->base_time;
        if (pkt->pts != MP_NOPTS_VALUE)
            pkt->pts += delta;
        if (pkt->dts != MP_NOPTS_VALUE)
            pkt->dts += delta;
    }

    MP_TRACE(demuxer, ""opts: %d %f %f\n"", sh->type, pkt->pts, pkt->dts);

    *out_pkt = pkt;
    return 1;
}

static void add_stream_chapters(struct demuxer *demuxer)
{
    int num = 0;
    if (stream_control(demuxer->stream, STREAM_CTRL_GET_NUM_CHAPTERS, &num) < 1)
        return;
    for (int n = 0; n < num; n++) {
        double p = n;
        if (stream_control(demuxer->stream, STREAM_CTRL_GET_CHAPTER_TIME, &p) < 1)
            continue;
        demuxer_add_chapter(demuxer, """", p, 0);
    }
}

static int d_open(demuxer_t *demuxer, enum demux_check check)
{
    struct priv *p = demuxer->priv = talloc_zero(demuxer, struct priv);

    if (check != DEMUX_CHECK_FORCE)
        return -1;

    struct demuxer_params params = {
        .force_format = ""+lavf"",
        .external_stream = demuxer->stream,
        .stream_flags = demuxer->stream_origin,
    };

    struct stream *cur = demuxer->stream;
    const char *sname = """";
    if (cur->info)
        sname = cur->info->name;

    p->is_cdda = strcmp(sname, ""cdda"") == 0;
    p->is_dvd = strcmp(sname, ""dvd"") == 0 ||
                strcmp(sname, ""ifo"") == 0 ||
                strcmp(sname, ""dvdnav"") == 0 ||
                strcmp(sname, ""ifo_dvdnav"") == 0;

    if (p->is_cdda)
        params.force_format = ""+rawaudio"";

    char *t = NULL;
    stream_control(demuxer->stream, STREAM_CTRL_GET_DISC_NAME, &t);
    if (t) {
        mp_tags_set_str(demuxer->metadata, ""TITLE"", t);
        talloc_free(t);
    }

    // Initialize the playback time. We need to read _some_ data to get the
    // correct stream-layer time (at least with libdvdnav).
    stream_read_peek(demuxer->stream, &(char){0}, 1);
    reset_pts(demuxer);

    p->slave = demux_open_url(""-"", &params, demuxer->cancel, demuxer->global);
    if (!p->slave)
        return -1;

    // Can be seekable even if the stream isn't.
    demuxer->seekable = true;

    add_dvd_streams(demuxer);
    add_streams(demuxer);
    add_stream_chapters(demuxer);

    double len;
    if (stream_control(demuxer->stream, STREAM_CTRL_GET_TIME_LENGTH, &len) >= 1)
        demuxer->duration = len;

    return 0;
}

static void d_close(demuxer_t *demuxer)
{
    struct priv *p = demuxer->priv;
    demux_free(p->slave);
}

const demuxer_desc_t demuxer_desc_disc = {
    .name = ""disc"",
    .desc = ""CD/DVD/BD wrapper"",
    .read_packet = d_read_packet,
    .open = d_open,
    .close = d_close,
    .seek = d_seek,
    .switched_tracks = reselect_streams,
};
"
./repos/mpv/demux/cue.c,https://github.com/mpv-player/mpv.git,"/*
 * This file is part of mpv.
 *
 * mpv is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * mpv is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <inttypes.h>

#include ""mpv_talloc.h""

#include ""misc/bstr.h""
#include ""common/common.h""
#include ""common/tags.h""

#include ""cue.h""

#define SECS_PER_CUE_FRAME (1.0/75.0)

enum cue_command {
    CUE_ERROR = -1,     // not a valid CUE command, or an unknown extension
    CUE_EMPTY,          // line with whitespace only
    CUE_UNUSED,         // valid CUE command, but ignored by this code
    CUE_FILE,
    CUE_TRACK,
    CUE_INDEX,
    CUE_TITLE,
    CUE_PERFORMER,
};

static const struct {
    enum cue_command command;
    const char *text;
} cue_command_strings[] = {
    { CUE_FILE, ""FILE"" },
    { CUE_TRACK, ""TRACK"" },
    { CUE_INDEX, ""INDEX"" },
    { CUE_TITLE, ""TITLE"" },
    { CUE_UNUSED, ""CATALOG"" },
    { CUE_UNUSED, ""CDTEXTFILE"" },
    { CUE_UNUSED, ""FLAGS"" },
    { CUE_UNUSED, ""ISRC"" },
    { CUE_PERFORMER, ""PERFORMER"" },
    { CUE_UNUSED, ""POSTGAP"" },
    { CUE_UNUSED, ""PREGAP"" },
    { CUE_UNUSED, ""REM"" },
    { CUE_UNUSED, ""SONGWRITER"" },
    { CUE_UNUSED, ""MESSAGE"" },
    { -1 },
};

static const uint8_t spaces[] = {' ', '\f', '\n', '\r', '\t', '\v', 0xA0};

static struct bstr lstrip_whitespace(struct bstr data)
{
    while (data.len) {
        bstr rest = data;
        int code = bstr_decode_utf8(data, &rest);
        if (code < 0) {
            // Tolerate Latin1 => probing works (which doesn't convert charsets).
            code = data.start[0];
            rest.start += 1;
            rest.len -= 1;
        }
        for (size_t n = 0; n < MP_ARRAY_SIZE(spaces); n++) {
            if (spaces[n] == code) {
                data = rest;
                goto next;
            }
        }
        break;
    next: ;
    }
    return data;
}

static enum cue_command read_cmd(struct bstr *data, struct bstr *out_params)
{
    struct bstr line = bstr_strip_linebreaks(bstr_getline(*data, data));
    line = lstrip_whitespace(line);
    if (line.len == 0)
        return CUE_EMPTY;
    for (int n = 0; cue_command_strings[n].command != -1; n++) {
        struct bstr name = bstr0(cue_command_strings[n].text);
        if (bstr_case_startswith(line, name)) {
            struct bstr rest = bstr_cut(line, name.len);
            struct bstr par = lstrip_whitespace(rest);
            if (rest.len && par.len == rest.len)
                continue;
            if (out_params)
                *out_params = par;
            return cue_command_strings[n].command;
        }
    }
    return CUE_ERROR;
}

static bool eat_char(struct bstr *data, char ch)
{
    if (data->len && data->start[0] == ch) {
        *data = bstr_cut(*data, 1);
        return true;
    } else {
        return false;
    }
}

static char *read_quoted(void *talloc_ctx, struct bstr *data)
{
    *data = lstrip_whitespace(*data);
    if (!eat_char(data, '""'))
        return NULL;
    int end = bstrchr(*data, '""');
    if (end < 0)
        return NULL;
    struct bstr res = bstr_splice(*data, 0, end);
    *data = bstr_cut(*data, end + 1);
    return bstrto0(talloc_ctx, res);
}

static struct bstr strip_quotes(struct bstr data)
{
    bstr s = data;
    if (bstr_eatstart0(&s, ""\"""") && bstr_eatend0(&s, ""\""""))
        return s;
    return data;
}

// Read an unsigned decimal integer.
// Optionally check if it is 2 digit.
// Return -1 on failure.
static int read_int(struct bstr *data, bool two_digit)
{
    *data = lstrip_whitespace(*data);
    if (data->len && data->start[0] == '-')
        return -1;
    struct bstr s = *data;
    int res = (int)bstrtoll(s, &s, 10);
    if (data->len == s.len || (two_digit && data->len - s.len > 2))
        return -1;
    *data = s;
    return res;
}

static double read_time(struct bstr *data)
{
    struct bstr s = *data;
    bool ok = true;
    double t1 = read_int(&s, false);
    ok = eat_char(&s, ':') && ok;
    double t2 = read_int(&s, true);
    ok = eat_char(&s, ':') && ok;
    double t3 = read_int(&s, true);
    ok = ok && t1 >= 0 && t2 >= 0 && t3 >= 0;
    return ok ? t1 * 60.0 + t2 + t3 * SECS_PER_CUE_FRAME : 0;
}

static struct bstr skip_utf8_bom(struct bstr data)
{
    return bstr_startswith0(data, ""\xEF\xBB\xBF"") ? bstr_cut(data, 3) : data;
}

// Check if the text in data is most likely CUE data. This is used by the
// demuxer code to check the file type.
// data is the start of the probed file, possibly cut off at a random point.
bool mp_probe_cue(struct bstr data)
{
    bool valid = false;
    data = skip_utf8_bom(data);
    for (;;) {
        enum cue_command cmd = read_cmd(&data, NULL);
        // End reached. Since the line was most likely cut off, don't use the
        // result of the last parsing call.
        if (data.len == 0)
            break;
        if (cmd == CUE_ERROR)
            return false;
        if (cmd != CUE_EMPTY)
            valid = true;
    }
    return valid;
}

struct cue_file *mp_parse_cue(struct bstr data)
{
    struct cue_file *f = talloc_zero(NULL, struct cue_file);
    f->tags = talloc_zero(f, struct mp_tags);

    data = skip_utf8_bom(data);

    char *filename = NULL;
    // Global metadata, and copied into new tracks.
    struct cue_track proto_track = {0};
    struct cue_track *cur_track = NULL;

    while (data.len) {
        struct bstr param;
        int cmd = read_cmd(&data, &param);
        switch (cmd) {
        case CUE_ERROR:
            talloc_free(f);
            return NULL;
        case CUE_TRACK: {
            MP_TARRAY_GROW(f, f->tracks, f->num_tracks);
            f->num_tracks += 1;
            cur_track = &f->tracks[f->num_tracks - 1];
            *cur_track = proto_track;
            cur_track->tags = talloc_zero(f, struct mp_tags);
            break;
        }
        case CUE_TITLE:
        case CUE_PERFORMER: {
            static const char *metanames[] = {
                [CUE_TITLE] = ""title"",
                [CUE_PERFORMER] = ""performer"",
            };
            struct mp_tags *tags = cur_track ? cur_track->tags : f->tags;
            mp_tags_set_bstr(tags, bstr0(metanames[cmd]), strip_quotes(param));
            break;
        }
        case CUE_INDEX: {
            int type = read_int(&param, true);
            double time = read_time(&param);
            if (cur_track) {
                if (type == 1) {
                    cur_track->start = time;
                    cur_track->filename = filename;
                } else if (type == 0) {
                    cur_track->pregap_start = time;
                }
            }
            break;
        }
        case CUE_FILE:
            // NOTE: FILE comes before TRACK, so don't use cur_track->filename
            filename = read_quoted(f, &param);
            break;
        }
    }

    return f;
}

int mp_check_embedded_cue(struct cue_file *f)
{
    char *fn0 = f->tracks[0].filename;
    for (int n = 1; n < f->num_tracks; n++) {
        char *fn = f->tracks[n].filename;
        // both filenames have the same address (including NULL)
        if (fn0 == fn)
            continue;
        // only one filename is NULL, or the strings don't match
        if (!fn0 || !fn || strcmp(fn0, fn) != 0)
            return -1;
    }
    return 0;
}
"
./repos/mpv/demux/codec_tags.c,https://github.com/mpv-player/mpv.git,"/*
 * This file is part of mpv.
 *
 * mpv is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * mpv is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <libavformat/avformat.h>
#include <libavcodec/avcodec.h>
#include <libavutil/common.h>
#include <libavutil/intreadwrite.h>

#include ""codec_tags.h""
#include ""stheader.h""
#include ""common/av_common.h""

static const char *lookup_tag(int type, uint32_t tag)
{
    const struct AVCodecTag *av_tags[3] = {0};
    switch (type) {
    case STREAM_VIDEO: {
        av_tags[0] = avformat_get_riff_video_tags();
        av_tags[1] = avformat_get_mov_video_tags();
        break;
    }
    case STREAM_AUDIO: {
        av_tags[0] = avformat_get_riff_audio_tags();
        av_tags[1] = avformat_get_mov_audio_tags();
        break;
    }
    }

    int id = av_codec_get_id(av_tags, tag);
    return id == AV_CODEC_ID_NONE ? NULL : mp_codec_from_av_codec_id(id);
}


/*
 * As seen in the following page:
 *
 * <https://web.archive.org/web/20220406060153/
 * http://dream.cs.bath.ac.uk/researchdev/wave-ex/bformat.html>
 *
 * Note that the GUID struct in the above citation has its
 * integers encoded in little-endian format, which means that
 * the unsigned short and unsigned long entries need to be
 * byte-flipped for this encoding.
 *
 * In theory only the first element of this array should be used,
 * however some encoders incorrectly encoded the GUID byte-for-byte
 * and thus the second one exists as a fallback.
 */
static const unsigned char guid_ext_base[][16] = {
    // MEDIASUBTYPE_BASE_GUID
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
     0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71},
     // SUBTYPE_AMBISONIC_B_FORMAT_PCM
    {0x01, 0x00, 0x00, 0x00, 0x21, 0x07, 0xD3, 0x11,
     0x86, 0x44, 0xC8, 0xC1, 0xCA, 0x00, 0x00, 0x00}
};

struct mp_waveformatex_guid {
    const char *codec;
    const unsigned char guid[16];
};

static const struct mp_waveformatex_guid guid_ext_other[] = {
    {""ac3"",
        {0x2C, 0x80, 0x6D, 0xE0, 0x46, 0xDB, 0xCF, 0x11,
         0xB4, 0xD1, 0x00, 0x80, 0x5F, 0x6C, 0xBB, 0xEA}},
    {""adpcm_agm"",
        {0x82, 0xEC, 0x1F, 0x6A, 0xCA, 0xDB, 0x19, 0x45,
         0xBD, 0xE7, 0x56, 0xD3, 0xB3, 0xEF, 0x98, 0x1D}},
    {""atrac3p"",
        {0xBF, 0xAA, 0x23, 0xE9, 0x58, 0xCB, 0x71, 0x44,
         0xA1, 0x19, 0xFF, 0xFA, 0x01, 0xE4, 0xCE, 0x62}},
    {""atrac9"",
        {0xD2, 0x42, 0xE1, 0x47, 0xBA, 0x36, 0x8D, 0x4D,
         0x88, 0xFC, 0x61, 0x65, 0x4F, 0x8C, 0x83, 0x6C}},
    {""dfpwm"",
        {0x3A, 0xC1, 0xFA, 0x38, 0x81, 0x1D, 0x43, 0x61,
         0xA4, 0x0D, 0xCE, 0x53, 0xCA, 0x60, 0x7C, 0xD1}},
    {""eac3"",
        {0xAF, 0x87, 0xFB, 0xA7, 0x02, 0x2D, 0xFB, 0x42,
         0xA4, 0xD4, 0x05, 0xCD, 0x93, 0x84, 0x3B, 0xDD}},
    {""mp2"",
        {0x2B, 0x80, 0x6D, 0xE0, 0x46, 0xDB, 0xCF, 0x11,
         0xB4, 0xD1, 0x00, 0x80, 0x5F, 0x6C, 0xBB, 0xEA}}
};

static void map_audio_pcm_tag(struct mp_codec_params *c)
{
    // MS PCM, Extended
    if (c->codec_tag == 0xfffe && c->extradata_size >= 22) {
        // WAVEFORMATEXTENSIBLE.wBitsPerSample
        int bits_per_sample = AV_RL16(c->extradata);
        if (bits_per_sample)
            c->bits_per_coded_sample = bits_per_sample;

        // WAVEFORMATEXTENSIBLE.dwChannelMask
        uint64_t chmask = AV_RL32(c->extradata + 2);
        struct mp_chmap chmap;
        mp_chmap_from_waveext(&chmap, chmask);
        if (c->channels.num == chmap.num)
            c->channels = chmap;

        // WAVEFORMATEXTENSIBLE.SubFormat
        unsigned char *subformat = c->extradata + 6;
        for (int i = 0; i < MP_ARRAY_SIZE(guid_ext_base); i++) {
            if (memcmp(subformat + 4, guid_ext_base[i] + 4, 12) == 0) {
                c->codec_tag = AV_RL32(subformat);
                c->codec = lookup_tag(c->type, c->codec_tag);
                break;
            }
        }

        // extra subformat, not a base one
        if (c->codec_tag == 0xfffe) {
            for (int i = 0; i < MP_ARRAY_SIZE(guid_ext_other); i++) {
                if (memcmp(subformat, &guid_ext_other[i].guid, 16) == 0) {
                    c->codec = guid_ext_other[i].codec;
                    c->codec_tag = mp_codec_to_av_codec_id(c->codec);
                    break;
                }
            }
        }

        // Compressed formats might use this.
        c->extradata += 22;
        c->extradata_size -= 22;
    }

    int bits = c->bits_per_coded_sample;
    if (!bits)
        return;

    int bytes = (bits + 7) / 8;
    switch (c->codec_tag) {
    case 0x0:       // Microsoft PCM
    case 0x1:
        if (bytes >= 1 && bytes <= 4)
            mp_set_pcm_codec(c, bytes > 1, false, bytes * 8, false);
        break;
    case 0x3:       // IEEE float
        mp_set_pcm_codec(c, true, true, bits == 64 ? 64 : 32, false);
        break;
    }
}

void mp_set_codec_from_tag(struct mp_codec_params *c)
{
    c->codec = lookup_tag(c->type, c->codec_tag);
    if (c->type == STREAM_AUDIO)
        map_audio_pcm_tag(c);
}

void mp_set_pcm_codec(struct mp_codec_params *c, bool sign, bool is_float,
                      int bits, bool is_be)
{
    // This uses libavcodec pcm codec names, e.g. ""pcm_u16le"".
    char codec[64] = ""pcm_"";
    if (is_float) {
        mp_snprintf_cat(codec, sizeof(codec), ""f"");
    } else {
        mp_snprintf_cat(codec, sizeof(codec), sign ? ""s"" : ""u"");
    }
    mp_snprintf_cat(codec, sizeof(codec), ""%d"", bits);
    if (bits != 8)
        mp_snprintf_cat(codec, sizeof(codec), is_be ? ""be"" : ""le"");
    c->codec = talloc_strdup(c, codec);
}

static const char *const mimetype_to_codec[][2] = {
    {""image/apng"",      ""apng""},
    {""image/avif"",      ""av1""},
    {""image/bmp"",       ""bmp""},
    {""image/gif"",       ""gif""},
    {""image/jpeg"",      ""mjpeg""},
    {""image/jxl"",       ""jpegxl""},
    {""image/png"",       ""png""},
    {""image/tiff"",      ""tiff""},
    {""image/webp"",      ""webp""},
    {0}
};

const char *mp_map_mimetype_to_video_codec(const char *mimetype)
{
    if (mimetype) {
        for (int n = 0; mimetype_to_codec[n][0]; n++) {
            if (strcasecmp(mimetype_to_codec[n][0], mimetype) == 0)
                return mimetype_to_codec[n][1];
        }
    }
    return NULL;
}
"
./repos/tmux/alerts.c,https://github.com/tmux/tmux.git,"/* $OpenBSD$ */

/*
 * Copyright (c) 2015 Nicholas Marriott <nicholas.marriott@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <stdlib.h>

#include ""tmux.h""

static int	alerts_fired;

static void	alerts_timer(int, short, void *);
static int	alerts_enabled(struct window *, int);
static void	alerts_callback(int, short, void *);
static void	alerts_reset(struct window *);

static int	alerts_action_applies(struct winlink *, const char *);
static int	alerts_check_all(struct window *);
static int	alerts_check_bell(struct window *);
static int	alerts_check_activity(struct window *);
static int	alerts_check_silence(struct window *);
static void	alerts_set_message(struct winlink *, const char *,
		    const char *);

static TAILQ_HEAD(, window) alerts_list = TAILQ_HEAD_INITIALIZER(alerts_list);

static void
alerts_timer(__unused int fd, __unused short events, void *arg)
{
	struct window	*w = arg;

	log_debug(""@%u alerts timer expired"", w->id);
	alerts_queue(w, WINDOW_SILENCE);
}

static void
alerts_callback(__unused int fd, __unused short events, __unused void *arg)
{
	struct window	*w, *w1;
	int		 alerts;

	TAILQ_FOREACH_SAFE(w, &alerts_list, alerts_entry, w1) {
		alerts = alerts_check_all(w);
		log_debug(""@%u alerts check, alerts %#x"", w->id, alerts);

		w->alerts_queued = 0;
		TAILQ_REMOVE(&alerts_list, w, alerts_entry);

		w->flags &= ~WINDOW_ALERTFLAGS;
		window_remove_ref(w, __func__);
	}
	alerts_fired = 0;
}

static int
alerts_action_applies(struct winlink *wl, const char *name)
{
	int	action;

	/*
	 * {bell,activity,silence}-action determines when to alert: none means
	 * nothing happens, current means only do something for the current
	 * window and other means only for windows other than the current.
	 */

	action = options_get_number(wl->session->options, name);
	if (action == ALERT_ANY)
		return (1);
	if (action == ALERT_CURRENT)
		return (wl == wl->session->curw);
	if (action == ALERT_OTHER)
		return (wl != wl->session->curw);
	return (0);
}

static int
alerts_check_all(struct window *w)
{
	int	alerts;

	alerts	= alerts_check_bell(w);
	alerts |= alerts_check_activity(w);
	alerts |= alerts_check_silence(w);
	return (alerts);
}

void
alerts_check_session(struct session *s)
{
	struct winlink	*wl;

	RB_FOREACH(wl, winlinks, &s->windows)
		alerts_check_all(wl->window);
}

static int
alerts_enabled(struct window *w, int flags)
{
	if (flags & WINDOW_BELL) {
		if (options_get_number(w->options, ""monitor-bell""))
			return (1);
	}
	if (flags & WINDOW_ACTIVITY) {
		if (options_get_number(w->options, ""monitor-activity""))
			return (1);
	}
	if (flags & WINDOW_SILENCE) {
		if (options_get_number(w->options, ""monitor-silence"") != 0)
			return (1);
	}
	return (0);
}

void
alerts_reset_all(void)
{
	struct window	*w;

	RB_FOREACH(w, windows, &windows)
		alerts_reset(w);
}

static void
alerts_reset(struct window *w)
{
	struct timeval	tv;

	if (!event_initialized(&w->alerts_timer))
		evtimer_set(&w->alerts_timer, alerts_timer, w);

	w->flags &= ~WINDOW_SILENCE;
	event_del(&w->alerts_timer);

	timerclear(&tv);
	tv.tv_sec = options_get_number(w->options, ""monitor-silence"");

	log_debug(""@%u alerts timer reset %u"", w->id, (u_int)tv.tv_sec);
	if (tv.tv_sec != 0)
		event_add(&w->alerts_timer, &tv);
}

void
alerts_queue(struct window *w, int flags)
{
	alerts_reset(w);

	if ((w->flags & flags) != flags) {
		w->flags |= flags;
		log_debug(""@%u alerts flags added %#x"", w->id, flags);
	}

	if (alerts_enabled(w, flags)) {
		if (!w->alerts_queued) {
			w->alerts_queued = 1;
			TAILQ_INSERT_TAIL(&alerts_list, w, alerts_entry);
			window_add_ref(w, __func__);
		}

		if (!alerts_fired) {
			log_debug(""alerts check queued (by @%u)"", w->id);
			event_once(-1, EV_TIMEOUT, alerts_callback, NULL, NULL);
			alerts_fired = 1;
		}
	}
}

static int
alerts_check_bell(struct window *w)
{
	struct winlink	*wl;
	struct session	*s;

	if (~w->flags & WINDOW_BELL)
		return (0);
	if (!options_get_number(w->options, ""monitor-bell""))
		return (0);

	TAILQ_FOREACH(wl, &w->winlinks, wentry)
		wl->session->flags &= ~SESSION_ALERTED;

	TAILQ_FOREACH(wl, &w->winlinks, wentry) {
		/*
		 * Bells are allowed even if there is an existing bell (so do
		 * not check WINLINK_BELL).
		 */
		s = wl->session;
		if (s->curw != wl || s->attached == 0) {
			wl->flags |= WINLINK_BELL;
			server_status_session(s);
		}
		if (!alerts_action_applies(wl, ""bell-action""))
			continue;
		notify_winlink(""alert-bell"", wl);

		if (s->flags & SESSION_ALERTED)
			continue;
		s->flags |= SESSION_ALERTED;

		alerts_set_message(wl, ""Bell"", ""visual-bell"");
	}

	return (WINDOW_BELL);
}

static int
alerts_check_activity(struct window *w)
{
	struct winlink	*wl;
	struct session	*s;

	if (~w->flags & WINDOW_ACTIVITY)
		return (0);
	if (!options_get_number(w->options, ""monitor-activity""))
		return (0);

	TAILQ_FOREACH(wl, &w->winlinks, wentry)
		wl->session->flags &= ~SESSION_ALERTED;

	TAILQ_FOREACH(wl, &w->winlinks, wentry) {
		if (wl->flags & WINLINK_ACTIVITY)
			continue;
		s = wl->session;
		if (s->curw != wl || s->attached == 0) {
			wl->flags |= WINLINK_ACTIVITY;
			server_status_session(s);
		}
		if (!alerts_action_applies(wl, ""activity-action""))
			continue;
		notify_winlink(""alert-activity"", wl);

		if (s->flags & SESSION_ALERTED)
			continue;
		s->flags |= SESSION_ALERTED;

		alerts_set_message(wl, ""Activity"", ""visual-activity"");
	}

	return (WINDOW_ACTIVITY);
}

static int
alerts_check_silence(struct window *w)
{
	struct winlink	*wl;
	struct session	*s;

	if (~w->flags & WINDOW_SILENCE)
		return (0);
	if (options_get_number(w->options, ""monitor-silence"") == 0)
		return (0);

	TAILQ_FOREACH(wl, &w->winlinks, wentry)
		wl->session->flags &= ~SESSION_ALERTED;

	TAILQ_FOREACH(wl, &w->winlinks, wentry) {
		if (wl->flags & WINLINK_SILENCE)
			continue;
		s = wl->session;
		if (s->curw != wl || s->attached == 0) {
			wl->flags |= WINLINK_SILENCE;
			server_status_session(s);
		}
		if (!alerts_action_applies(wl, ""silence-action""))
			continue;
		notify_winlink(""alert-silence"", wl);

		if (s->flags & SESSION_ALERTED)
			continue;
		s->flags |= SESSION_ALERTED;

		alerts_set_message(wl, ""Silence"", ""visual-silence"");
	}

	return (WINDOW_SILENCE);
}

static void
alerts_set_message(struct winlink *wl, const char *type, const char *option)
{
	struct client	*c;
	int		 visual;

	/*
	 * We have found an alert (bell, activity or silence), so we need to
	 * pass it on to the user. For each client attached to this session,
	 * decide whether a bell, message or both is needed.
	 *
	 * If visual-{bell,activity,silence} is on, then a message is
	 * substituted for a bell; if it is off, a bell is sent as normal; both
	 * mean both a bell and message is sent.
	 */

	visual = options_get_number(wl->session->options, option);
	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session != wl->session || c->flags & CLIENT_CONTROL)
			continue;

		if (visual == VISUAL_OFF || visual == VISUAL_BOTH)
			tty_putcode(&c->tty, TTYC_BEL);
		if (visual == VISUAL_OFF)
			continue;
		if (c->session->curw == wl) {
			status_message_set(c, -1, 1, 0, ""%s in current window"",
			    type);
		} else {
			status_message_set(c, -1, 1, 0, ""%s in window %d"", type,
			    wl->idx);
		}
	}
}
"
./repos/tmux/arguments.c,https://github.com/tmux/tmux.git,"/* $OpenBSD$ */

/*
 * Copyright (c) 2010 Nicholas Marriott <nicholas.marriott@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include ""tmux.h""

/*
 * Manipulate command arguments.
 */

/* List of argument values. */
TAILQ_HEAD(args_values, args_value);

/* Single arguments flag. */
struct args_entry {
	u_char			 flag;
	struct args_values	 values;
	u_int			 count;

	int			 flags;
#define ARGS_ENTRY_OPTIONAL_VALUE 0x1

	RB_ENTRY(args_entry)	 entry;
};

/* Parsed argument flags and values. */
struct args {
	struct args_tree	 tree;
	u_int			 count;
	struct args_value	*values;
};

/* Prepared command state. */
struct args_command_state {
	struct cmd_list		*cmdlist;
	char			*cmd;
	struct cmd_parse_input	 pi;
};

static struct args_entry	*args_find(struct args *, u_char);

static int	args_cmp(struct args_entry *, struct args_entry *);
RB_GENERATE_STATIC(args_tree, args_entry, entry, args_cmp);

/* Arguments tree comparison function. */
static int
args_cmp(struct args_entry *a1, struct args_entry *a2)
{
	return (a1->flag - a2->flag);
}

/* Find a flag in the arguments tree. */
static struct args_entry *
args_find(struct args *args, u_char flag)
{
	struct args_entry	entry;

	entry.flag = flag;
	return (RB_FIND(args_tree, &args->tree, &entry));
}

/* Copy value. */
static void
args_copy_value(struct args_value *to, struct args_value *from)
{
	to->type = from->type;
	switch (from->type) {
	case ARGS_NONE:
		break;
	case ARGS_COMMANDS:
		to->cmdlist = from->cmdlist;
		to->cmdlist->references++;
		break;
	case ARGS_STRING:
		to->string = xstrdup(from->string);
		break;
	}
}

/* Type to string. */
static const char *
args_type_to_string (enum args_type type)
{
	switch (type)
	{
	case ARGS_NONE:
		return ""NONE"";
	case ARGS_STRING:
		return ""STRING"";
	case ARGS_COMMANDS:
		return ""COMMANDS"";
	}
	return ""INVALID"";
}

/* Get value as string. */
static const char *
args_value_as_string(struct args_value *value)
{
	switch (value->type) {
	case ARGS_NONE:
		return ("""");
	case ARGS_COMMANDS:
		if (value->cached == NULL)
			value->cached = cmd_list_print(value->cmdlist, 0);
		return (value->cached);
	case ARGS_STRING:
		return (value->string);
	}
	fatalx(""unexpected argument type"");
}

/* Create an empty arguments set. */
struct args *
args_create(void)
{
	struct args	 *args;

	args = xcalloc(1, sizeof *args);
	RB_INIT(&args->tree);
	return (args);
}

/* Parse a single flag. */
static int
args_parse_flag_argument(struct args_value *values, u_int count, char **cause,
    struct args *args, u_int *i, const char *string, int flag,
    int optional_argument)
{
	struct args_value	*argument, *new;
	const char		*s;

	new = xcalloc(1, sizeof *new);
	if (*string != '\0') {
		new->type = ARGS_STRING;
		new->string = xstrdup(string);
		goto out;
	}

	if (*i == count)
		argument = NULL;
	else {
		argument = &values[*i];
		if (argument->type != ARGS_STRING) {
			xasprintf(cause, ""-%c argument must be a string"", flag);
			return (-1);
		}
	}
	if (argument == NULL) {
		if (optional_argument) {
			log_debug(""%s: -%c (optional)"", __func__, flag);
			args_set(args, flag, NULL, ARGS_ENTRY_OPTIONAL_VALUE);
			return (0); /* either - or end */
		}
		xasprintf(cause, ""-%c expects an argument"", flag);
		return (-1);
	}
	args_copy_value(new, argument);
	(*i)++;

out:
	s = args_value_as_string(new);
	log_debug(""%s: -%c = %s"", __func__, flag, s);
	args_set(args, flag, new, 0);
	return (0);
}

/* Parse flags argument. */
static int
args_parse_flags(const struct args_parse *parse, struct args_value *values,
    u_int count, char **cause, struct args *args, u_int *i)
{
	struct args_value	*value;
	u_char			 flag;
	const char		*found, *string;
	int			 optional_argument;

	value = &values[*i];
	if (value->type != ARGS_STRING)
		return (1);

	string = value->string;
	log_debug(""%s: next %s"", __func__, string);
	if (*string++ != '-' || *string == '\0')
		return (1);
	(*i)++;
	if (string[0] == '-' && string[1] == '\0')
		return (1);

	for (;;) {
		flag = *string++;
		if (flag == '\0')
			return (0);
		if (flag == '?')
			return (-1);
		if (!isalnum(flag)) {
			xasprintf(cause, ""invalid flag -%c"", flag);
			return (-1);
		}

		found = strchr(parse->template, flag);
		if (found == NULL) {
			xasprintf(cause, ""unknown flag -%c"", flag);
			return (-1);
		}
		if (found[1] != ':') {
			log_debug(""%s: -%c"", __func__, flag);
			args_set(args, flag, NULL, 0);
			continue;
		}
		optional_argument = (found[2] == ':');
		return (args_parse_flag_argument(values, count, cause, args, i,
		    string, flag, optional_argument));
	}
}

/* Parse arguments into a new argument set. */
struct args *
args_parse(const struct args_parse *parse, struct args_value *values,
    u_int count, char **cause)
{
	struct args		*args;
	u_int			 i;
	enum args_parse_type	 type;
	struct args_value	*value, *new;
	const char		*s;
	int			 stop;

	if (count == 0)
		return (args_create());

	args = args_create();
	for (i = 1; i < count; /* nothing */) {
		stop = args_parse_flags(parse, values, count, cause, args, &i);
		if (stop == -1) {
			args_free(args);
			return (NULL);
		}
		if (stop == 1)
			break;
	}
	log_debug(""%s: flags end at %u of %u"", __func__, i, count);
	if (i != count) {
		for (/* nothing */; i < count; i++) {
			value = &values[i];

			s = args_value_as_string(value);
			log_debug(""%s: %u = %s (type %s)"", __func__, i, s,
			    args_type_to_string (value->type));

			if (parse->cb != NULL) {
				type = parse->cb(args, args->count, cause);
				if (type == ARGS_PARSE_INVALID) {
					args_free(args);
					return (NULL);
				}
			} else
				type = ARGS_PARSE_STRING;

			args->values = xrecallocarray(args->values,
			    args->count, args->count + 1, sizeof *args->values);
			new = &args->values[args->count++];

			switch (type) {
			case ARGS_PARSE_INVALID:
				fatalx(""unexpected argument type"");
			case ARGS_PARSE_STRING:
				if (value->type != ARGS_STRING) {
					xasprintf(cause,
					    ""argument %u must be \""string\"""",
					    args->count);
					args_free(args);
					return (NULL);
				}
				args_copy_value(new, value);
				break;
			case ARGS_PARSE_COMMANDS_OR_STRING:
				args_copy_value(new, value);
				break;
			case ARGS_PARSE_COMMANDS:
				if (value->type != ARGS_COMMANDS) {
					xasprintf(cause,
					    ""argument %u must be { commands }"",
					    args->count);
					args_free(args);
					return (NULL);
				}
				args_copy_value(new, value);
				break;
			}
		}
	}

	if (parse->lower != -1 && args->count < (u_int)parse->lower) {
		xasprintf(cause,
		    ""too few arguments (need at least %u)"",
		    parse->lower);
		args_free(args);
		return (NULL);
	}
	if (parse->upper != -1 && args->count > (u_int)parse->upper) {
		xasprintf(cause,
		    ""too many arguments (need at most %u)"",
		    parse->upper);
		args_free(args);
		return (NULL);
	}
	return (args);
}

/* Copy and expand a value. */
static void
args_copy_copy_value(struct args_value *to, struct args_value *from, int argc,
    char **argv)
{
	char	*s, *expanded;
	int	 i;

	to->type = from->type;
	switch (from->type) {
	case ARGS_NONE:
		break;
	case ARGS_STRING:
		expanded = xstrdup(from->string);
		for (i = 0; i < argc; i++) {
			s = cmd_template_replace(expanded, argv[i], i + 1);
			free(expanded);
			expanded = s;
		}
		to->string = expanded;
		break;
	case ARGS_COMMANDS:
		to->cmdlist = cmd_list_copy(from->cmdlist, argc, argv);
		break;
	}
}

/* Copy an arguments set. */
struct args *
args_copy(struct args *args, int argc, char **argv)
{
	struct args		*new_args;
	struct args_entry	*entry;
	struct args_value	*value, *new_value;
	u_int			 i;

	cmd_log_argv(argc, argv, ""%s"", __func__);

	new_args = args_create();
	RB_FOREACH(entry, args_tree, &args->tree) {
		if (TAILQ_EMPTY(&entry->values)) {
			for (i = 0; i < entry->count; i++)
				args_set(new_args, entry->flag, NULL, 0);
			continue;
		}
		TAILQ_FOREACH(value, &entry->values, entry) {
			new_value = xcalloc(1, sizeof *new_value);
			args_copy_copy_value(new_value, value, argc, argv);
			args_set(new_args, entry->flag, new_value, 0);
		}
	}
	if (args->count == 0)
		return (new_args);
	new_args->count = args->count;
	new_args->values = xcalloc(args->count, sizeof *new_args->values);
	for (i = 0; i < args->count; i++) {
		new_value = &new_args->values[i];
		args_copy_copy_value(new_value, &args->values[i], argc, argv);
	}
	return (new_args);
}

/* Free a value. */
void
args_free_value(struct args_value *value)
{
	switch (value->type) {
	case ARGS_NONE:
		break;
	case ARGS_STRING:
		free(value->string);
		break;
	case ARGS_COMMANDS:
		cmd_list_free(value->cmdlist);
		break;
	}
	free(value->cached);
}

/* Free values. */
void
args_free_values(struct args_value *values, u_int count)
{
	u_int	i;

	for (i = 0; i < count; i++)
		args_free_value(&values[i]);
}

/* Free an arguments set. */
void
args_free(struct args *args)
{
	struct args_entry	*entry;
	struct args_entry	*entry1;
	struct args_value	*value;
	struct args_value	*value1;

	args_free_values(args->values, args->count);
	free(args->values);

	RB_FOREACH_SAFE(entry, args_tree, &args->tree, entry1) {
		RB_REMOVE(args_tree, &args->tree, entry);
		TAILQ_FOREACH_SAFE(value, &entry->values, entry, value1) {
			TAILQ_REMOVE(&entry->values, value, entry);
			args_free_value(value);
			free(value);
		}
		free(entry);
	}

	free(args);
}

/* Convert arguments to vector. */
void
args_to_vector(struct args *args, int *argc, char ***argv)
{
	char	*s;
	u_int	 i;

	*argc = 0;
	*argv = NULL;

	for (i = 0; i < args->count; i++) {
		switch (args->values[i].type) {
		case ARGS_NONE:
			break;
		case ARGS_STRING:
			cmd_append_argv(argc, argv, args->values[i].string);
			break;
		case ARGS_COMMANDS:
			s = cmd_list_print(args->values[i].cmdlist, 0);
			cmd_append_argv(argc, argv, s);
			free(s);
			break;
		}
	}
}

/* Convert arguments from vector. */
struct args_value *
args_from_vector(int argc, char **argv)
{
	struct args_value	*values;
	int			 i;

	values = xcalloc(argc, sizeof *values);
	for (i = 0; i < argc; i++) {
		values[i].type = ARGS_STRING;
		values[i].string = xstrdup(argv[i]);
	}
	return (values);
}

/* Add to string. */
static void printflike(3, 4)
args_print_add(char **buf, size_t *len, const char *fmt, ...)
{
	va_list	 ap;
	char	*s;
	size_t	 slen;

	va_start(ap, fmt);
	slen = xvasprintf(&s, fmt, ap);
	va_end(ap);

	*len += slen;
	*buf = xrealloc(*buf, *len);

	strlcat(*buf, s, *len);
	free(s);
}

/* Add value to string. */
static void
args_print_add_value(char **buf, size_t *len, struct args_value *value)
{
	char	*expanded = NULL;

	if (**buf != '\0')
		args_print_add(buf, len, "" "");

	switch (value->type) {
	case ARGS_NONE:
		break;
	case ARGS_COMMANDS:
		expanded = cmd_list_print(value->cmdlist, 0);
		args_print_add(buf, len, ""{ %s }"", expanded);
		break;
	case ARGS_STRING:
		expanded = args_escape(value->string);
		args_print_add(buf, len, ""%s"", expanded);
		break;
	}
	free(expanded);
}

/* Print a set of arguments. */
char *
args_print(struct args *args)
{
	size_t			 len;
	char			*buf;
	u_int			 i, j;
	struct args_entry	*entry;
	struct args_entry	*last = NULL;
	struct args_value	*value;

	len = 1;
	buf = xcalloc(1, len);

	/* Process the flags first. */
	RB_FOREACH(entry, args_tree, &args->tree) {
		if (entry->flags & ARGS_ENTRY_OPTIONAL_VALUE)
			continue;
		if (!TAILQ_EMPTY(&entry->values))
			continue;

		if (*buf == '\0')
			args_print_add(&buf, &len, ""-"");
		for (j = 0; j < entry->count; j++)
			args_print_add(&buf, &len, ""%c"", entry->flag);
	}

	/* Then the flags with arguments. */
	RB_FOREACH(entry, args_tree, &args->tree) {
		if (entry->flags & ARGS_ENTRY_OPTIONAL_VALUE) {
			if (*buf != '\0')
				args_print_add(&buf, &len, "" -%c"", entry->flag);
			else
				args_print_add(&buf, &len, ""-%c"", entry->flag);
			last = entry;
			continue;
		}
		if (TAILQ_EMPTY(&entry->values))
			continue;
		TAILQ_FOREACH(value, &entry->values, entry) {
			if (*buf != '\0')
				args_print_add(&buf, &len, "" -%c"", entry->flag);
			else
				args_print_add(&buf, &len, ""-%c"", entry->flag);
			args_print_add_value(&buf, &len, value);
		}
		last = entry;
	}
	if (last && (last->flags & ARGS_ENTRY_OPTIONAL_VALUE))
		args_print_add(&buf, &len, "" --"");

	/* And finally the argument vector. */
	for (i = 0; i < args->count; i++)
		args_print_add_value(&buf, &len, &args->values[i]);

	return (buf);
}

/* Escape an argument. */
char *
args_escape(const char *s)
{
	static const char	 dquoted[] = "" #';${}%"";
	static const char	 squoted[] = "" \"""";
	char			*escaped, *result;
	int			 flags, quotes = 0;

	if (*s == '\0') {
		xasprintf(&result, ""''"");
		return (result);
	}
	if (s[strcspn(s, dquoted)] != '\0')
		quotes = '""';
	else if (s[strcspn(s, squoted)] != '\0')
		quotes = '\'';

	if (s[0] != ' ' &&
	    s[1] == '\0' &&
	    (quotes != 0 || s[0] == '~')) {
		xasprintf(&escaped, ""\\%c"", s[0]);
		return (escaped);
	}

	flags = VIS_OCTAL|VIS_CSTYLE|VIS_TAB|VIS_NL;
	if (quotes == '""')
		flags |= VIS_DQ;
	utf8_stravis(&escaped, s, flags);

	if (quotes == '\'')
		xasprintf(&result, ""'%s'"", escaped);
	else if (quotes == '""') {
		if (*escaped == '~')
			xasprintf(&result, ""\""\\%s\"""", escaped);
		else
			xasprintf(&result, ""\""%s\"""", escaped);
	} else {
		if (*escaped == '~')
			xasprintf(&result, ""\\%s"", escaped);
		else
			result = xstrdup(escaped);
	}
	free(escaped);
	return (result);
}

/* Return if an argument is present. */
int
args_has(struct args *args, u_char flag)
{
	struct args_entry	*entry;

	entry = args_find(args, flag);
	if (entry == NULL)
		return (0);
	return (entry->count);
}

/* Set argument value in the arguments tree. */
void
args_set(struct args *args, u_char flag, struct args_value *value, int flags)
{
	struct args_entry	*entry;

	entry = args_find(args, flag);
	if (entry == NULL) {
		entry = xcalloc(1, sizeof *entry);
		entry->flag = flag;
		entry->count = 1;
		entry->flags = flags;
		TAILQ_INIT(&entry->values);
		RB_INSERT(args_tree, &args->tree, entry);
	} else
		entry->count++;
	if (value != NULL && value->type != ARGS_NONE)
		TAILQ_INSERT_TAIL(&entry->values, value, entry);
}

/* Get argument value. Will be NULL if it isn't present. */
const char *
args_get(struct args *args, u_char flag)
{
	struct args_entry	*entry;

	if ((entry = args_find(args, flag)) == NULL)
		return (NULL);
	if (TAILQ_EMPTY(&entry->values))
		return (NULL);
	return (TAILQ_LAST(&entry->values, args_values)->string);
}

/* Get first argument. */
u_char
args_first(struct args *args, struct args_entry **entry)
{
	*entry = RB_MIN(args_tree, &args->tree);
	if (*entry == NULL)
		return (0);
	return ((*entry)->flag);
}

/* Get next argument. */
u_char
args_next(struct args_entry **entry)
{
	*entry = RB_NEXT(args_tree, &args->tree, *entry);
	if (*entry == NULL)
		return (0);
	return ((*entry)->flag);
}

/* Get argument count. */
u_int
args_count(struct args *args)
{
	return (args->count);
}

/* Get argument values. */
struct args_value *
args_values(struct args *args)
{
	return (args->values);
}

/* Get argument value. */
struct args_value *
args_value(struct args *args, u_int idx)
{
	if (idx >= args->count)
		return (NULL);
	return (&args->values[idx]);
}

/* Return argument as string. */
const char *
args_string(struct args *args, u_int idx)
{
	if (idx >= args->count)
		return (NULL);
	return (args_value_as_string(&args->values[idx]));
}

/* Make a command now. */
struct cmd_list *
args_make_commands_now(struct cmd *self, struct cmdq_item *item, u_int idx,
    int expand)
{
	struct args_command_state	*state;
	char				*error;
	struct cmd_list			*cmdlist;

	state = args_make_commands_prepare(self, item, idx, NULL, 0, expand);
	cmdlist = args_make_commands(state, 0, NULL, &error);
	if (cmdlist == NULL) {
		cmdq_error(item, ""%s"", error);
		free(error);
	}
	else
		cmdlist->references++;
	args_make_commands_free(state);
	return (cmdlist);
}

/* Save bits to make a command later. */
struct args_command_state *
args_make_commands_prepare(struct cmd *self, struct cmdq_item *item, u_int idx,
    const char *default_command, int wait, int expand)
{
	struct args			*args = cmd_get_args(self);
	struct cmd_find_state		*target = cmdq_get_target(item);
	struct client			*tc = cmdq_get_target_client(item);
	struct args_value		*value;
	struct args_command_state	*state;
	const char			*cmd;
	const char			*file;

	state = xcalloc(1, sizeof *state);

	if (idx < args->count) {
		value = &args->values[idx];
		if (value->type == ARGS_COMMANDS) {
			state->cmdlist = value->cmdlist;
			state->cmdlist->references++;
			return (state);
		}
		cmd = value->string;
	} else {
		if (default_command == NULL)
			fatalx(""argument out of range"");
		cmd = default_command;
	}


	if (expand)
		state->cmd = format_single_from_target(item, cmd);
	else
		state->cmd = xstrdup(cmd);
	log_debug(""%s: %s"", __func__, state->cmd);

	if (wait)
		state->pi.item = item;
	cmd_get_source(self, &file, &state->pi.line);
	if (file != NULL)
		state->pi.file = xstrdup(file);
	state->pi.c = tc;
	if (state->pi.c != NULL)
		state->pi.c->references++;
	cmd_find_copy_state(&state->pi.fs, target);

	return (state);
}

/* Return argument as command. */
struct cmd_list *
args_make_commands(struct args_command_state *state, int argc, char **argv,
    char **error)
{
	struct cmd_parse_result	*pr;
	char			*cmd, *new_cmd;
	int			 i;

	if (state->cmdlist != NULL) {
		if (argc == 0)
			return (state->cmdlist);
		return (cmd_list_copy(state->cmdlist, argc, argv));
	}

	cmd = xstrdup(state->cmd);
	log_debug(""%s: %s"", __func__, cmd);
	cmd_log_argv(argc, argv, __func__);
	for (i = 0; i < argc; i++) {
		new_cmd = cmd_template_replace(cmd, argv[i], i + 1);
		log_debug(""%s: %%%u %s: %s"", __func__, i + 1, argv[i], new_cmd);
		free(cmd);
		cmd = new_cmd;
	}
	log_debug(""%s: %s"", __func__, cmd);

	pr = cmd_parse_from_string(cmd, &state->pi);
	free(cmd);
	switch (pr->status) {
	case CMD_PARSE_ERROR:
		*error = pr->error;
		return (NULL);
	case CMD_PARSE_SUCCESS:
		return (pr->cmdlist);
	}
	fatalx(""invalid parse return state"");
}

/* Free commands state. */
void
args_make_commands_free(struct args_command_state *state)
{
	if (state->cmdlist != NULL)
		cmd_list_free(state->cmdlist);
	if (state->pi.c != NULL)
		server_client_unref(state->pi.c);
	free((void *)state->pi.file);
	free(state->cmd);
	free(state);
}

/* Get prepared command. */
char *
args_make_commands_get_command(struct args_command_state *state)
{
	struct cmd	*first;
	int		 n;
	char		*s;

	if (state->cmdlist != NULL) {
		first = cmd_list_first(state->cmdlist);
		if (first == NULL)
			return (xstrdup(""""));
		return (xstrdup(cmd_get_entry(first)->name));
	}
	n = strcspn(state->cmd, "" ,"");
	xasprintf(&s, ""%.*s"", n, state->cmd);
	return (s);
}

/* Get first value in argument. */
struct args_value *
args_first_value(struct args *args, u_char flag)
{
	struct args_entry	*entry;

	if ((entry = args_find(args, flag)) == NULL)
		return (NULL);
	return (TAILQ_FIRST(&entry->values));
}

/* Get next value in argument. */
struct args_value *
args_next_value(struct args_value *value)
{
	return (TAILQ_NEXT(value, entry));
}

/* Convert an argument value to a number. */
long long
args_strtonum(struct args *args, u_char flag, long long minval,
    long long maxval, char **cause)
{
	const char		*errstr;
	long long		 ll;
	struct args_entry	*entry;
	struct args_value	*value;

	if ((entry = args_find(args, flag)) == NULL) {
		*cause = xstrdup(""missing"");
		return (0);
	}
	value = TAILQ_LAST(&entry->values, args_values);
	if (value == NULL ||
	    value->type != ARGS_STRING ||
	    value->string == NULL) {
		*cause = xstrdup(""missing"");
		return (0);
	}

	ll = strtonum(value->string, minval, maxval, &errstr);
	if (errstr != NULL) {
		*cause = xstrdup(errstr);
		return (0);
	}

	*cause = NULL;
	return (ll);
}

/* Convert an argument value to a number, and expand formats. */
long long
args_strtonum_and_expand(struct args *args, u_char flag, long long minval,
    long long maxval, struct cmdq_item *item, char **cause)
{
	const char		*errstr;
	char			*formatted;
	long long		 ll;
	struct args_entry	*entry;
	struct args_value	*value;

	if ((entry = args_find(args, flag)) == NULL) {
		*cause = xstrdup(""missing"");
		return (0);
	}
	value = TAILQ_LAST(&entry->values, args_values);
	if (value == NULL ||
	    value->type != ARGS_STRING ||
	    value->string == NULL) {
		*cause = xstrdup(""missing"");
		return (0);
	}

	formatted = format_single_from_target(item, value->string);
	ll = strtonum(formatted, minval, maxval, &errstr);
	free(formatted);
	if (errstr != NULL) {
		*cause = xstrdup(errstr);
		return (0);
	}

	*cause = NULL;
	return (ll);
}

/* Convert an argument to a number which may be a percentage. */
long long
args_percentage(struct args *args, u_char flag, long long minval,
    long long maxval, long long curval, char **cause)
{
	const char		*value;
	struct args_entry	*entry;

	if ((entry = args_find(args, flag)) == NULL) {
		*cause = xstrdup(""missing"");
		return (0);
	}
	if (TAILQ_EMPTY(&entry->values)) {
		*cause = xstrdup(""empty"");
		return (0);
	}
	value = TAILQ_LAST(&entry->values, args_values)->string;
	return (args_string_percentage(value, minval, maxval, curval, cause));
}

/* Convert a string to a number which may be a percentage. */
long long
args_string_percentage(const char *value, long long minval, long long maxval,
    long long curval, char **cause)
{
	const char	*errstr;
	long long	 ll;
	size_t		 valuelen = strlen(value);
	char		*copy;

	if (valuelen == 0) {
		*cause = xstrdup(""empty"");
		return (0);
	}
	if (value[valuelen - 1] == '%') {
		copy = xstrdup(value);
		copy[valuelen - 1] = '\0';

		ll = strtonum(copy, 0, 100, &errstr);
		free(copy);
		if (errstr != NULL) {
			*cause = xstrdup(errstr);
			return (0);
		}
		ll = (curval * ll) / 100;
		if (ll < minval) {
			*cause = xstrdup(""too small"");
			return (0);
		}
		if (ll > maxval) {
			*cause = xstrdup(""too large"");
			return (0);
		}
	} else {
		ll = strtonum(value, minval, maxval, &errstr);
		if (errstr != NULL) {
			*cause = xstrdup(errstr);
			return (0);
		}
	}

	*cause = NULL;
	return (ll);
}

/*
 * Convert an argument to a number which may be a percentage, and expand
 * formats.
 */
long long
args_percentage_and_expand(struct args *args, u_char flag, long long minval,
    long long maxval, long long curval, struct cmdq_item *item, char **cause)
{
	const char		*value;
	struct args_entry	*entry;

	if ((entry = args_find(args, flag)) == NULL) {
		*cause = xstrdup(""missing"");
		return (0);
	}
	if (TAILQ_EMPTY(&entry->values)) {
		*cause = xstrdup(""empty"");
		return (0);
	}
	value = TAILQ_LAST(&entry->values, args_values)->string;
	return (args_string_percentage_and_expand(value, minval, maxval, curval,
		    item, cause));
}

/*
 * Convert a string to a number which may be a percentage, and expand formats.
 */
long long
args_string_percentage_and_expand(const char *value, long long minval,
    long long maxval, long long curval, struct cmdq_item *item, char **cause)
{
	const char	*errstr;
	long long	 ll;
	size_t		 valuelen = strlen(value);
	char		*copy, *f;

	if (value[valuelen - 1] == '%') {
		copy = xstrdup(value);
		copy[valuelen - 1] = '\0';

		f = format_single_from_target(item, copy);
		ll = strtonum(f, 0, 100, &errstr);
		free(f);
		free(copy);
		if (errstr != NULL) {
			*cause = xstrdup(errstr);
			return (0);
		}
		ll = (curval * ll) / 100;
		if (ll < minval) {
			*cause = xstrdup(""too small"");
			return (0);
		}
		if (ll > maxval) {
			*cause = xstrdup(""too large"");
			return (0);
		}
	} else {
		f = format_single_from_target(item, value);
		ll = strtonum(f, minval, maxval, &errstr);
		free(f);
		if (errstr != NULL) {
			*cause = xstrdup(errstr);
			return (0);
		}
	}

	*cause = NULL;
	return (ll);
}
"
./repos/tmux/cfg.c,https://github.com/tmux/tmux.git,"/* $OpenBSD$ */

/*
 * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <ctype.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include ""tmux.h""

struct client		 *cfg_client;
int			  cfg_finished;
static char		**cfg_causes;
static u_int		  cfg_ncauses;
static struct cmdq_item	 *cfg_item;

int                       cfg_quiet = 1;
char                    **cfg_files;
u_int                     cfg_nfiles;

static enum cmd_retval
cfg_client_done(__unused struct cmdq_item *item, __unused void *data)
{
	if (!cfg_finished)
		return (CMD_RETURN_WAIT);
	return (CMD_RETURN_NORMAL);
}

static enum cmd_retval
cfg_done(__unused struct cmdq_item *item, __unused void *data)
{
	if (cfg_finished)
		return (CMD_RETURN_NORMAL);
	cfg_finished = 1;

	cfg_show_causes(NULL);

	if (cfg_item != NULL)
		cmdq_continue(cfg_item);

	status_prompt_load_history();

	return (CMD_RETURN_NORMAL);
}

void
start_cfg(void)
{
	struct client	 *c;
	u_int		  i;
	int		  flags = 0;

	/*
	 * Configuration files are loaded without a client, so commands are run
	 * in the global queue with item->client NULL.
	 *
	 * However, we must block the initial client (but just the initial
	 * client) so that its command runs after the configuration is loaded.
	 * Because start_cfg() is called so early, we can be sure the client's
	 * command queue is currently empty and our callback will be at the
	 * front - we need to get in before MSG_COMMAND.
	 */
	cfg_client = c = TAILQ_FIRST(&clients);
	if (c != NULL) {
		cfg_item = cmdq_get_callback(cfg_client_done, NULL);
		cmdq_append(c, cfg_item);
	}

	if (cfg_quiet)
		flags = CMD_PARSE_QUIET;
	for (i = 0; i < cfg_nfiles; i++)
		load_cfg(cfg_files[i], c, NULL, NULL, flags, NULL);

	cmdq_append(NULL, cmdq_get_callback(cfg_done, NULL));
}

int
load_cfg(const char *path, struct client *c, struct cmdq_item *item,
    struct cmd_find_state *current, int flags, struct cmdq_item **new_item)
{
	FILE			*f;
	struct cmd_parse_input	 pi;
	struct cmd_parse_result	*pr;
	struct cmdq_item	*new_item0;
	struct cmdq_state	*state;

	if (new_item != NULL)
		*new_item = NULL;

	log_debug(""loading %s"", path);
	if ((f = fopen(path, ""rb"")) == NULL) {
		if (errno == ENOENT && (flags & CMD_PARSE_QUIET))
			return (0);
		cfg_add_cause(""%s: %s"", path, strerror(errno));
		return (-1);
	}

	memset(&pi, 0, sizeof pi);
	pi.flags = flags;
	pi.file = path;
	pi.line = 1;
	pi.item = item;
	pi.c = c;

	pr = cmd_parse_from_file(f, &pi);
	fclose(f);
	if (pr->status == CMD_PARSE_ERROR) {
		cfg_add_cause(""%s"", pr->error);
		free(pr->error);
		return (-1);
	}
	if (flags & CMD_PARSE_PARSEONLY) {
		cmd_list_free(pr->cmdlist);
		return (0);
	}

	if (item != NULL)
		state = cmdq_copy_state(cmdq_get_state(item), current);
	else
		state = cmdq_new_state(NULL, NULL, 0);
	cmdq_add_format(state, ""current_file"", ""%s"", pi.file);

	new_item0 = cmdq_get_command(pr->cmdlist, state);
	if (item != NULL)
		new_item0 = cmdq_insert_after(item, new_item0);
	else
		new_item0 = cmdq_append(NULL, new_item0);
	cmd_list_free(pr->cmdlist);
	cmdq_free_state(state);

	if (new_item != NULL)
		*new_item = new_item0;
	return (0);
}

int
load_cfg_from_buffer(const void *buf, size_t len, const char *path,
    struct client *c, struct cmdq_item *item, struct cmd_find_state *current,
    int flags, struct cmdq_item **new_item)
{
	struct cmd_parse_input	 pi;
	struct cmd_parse_result	*pr;
	struct cmdq_item	*new_item0;
	struct cmdq_state	*state;

	if (new_item != NULL)
		*new_item = NULL;

	log_debug(""loading %s"", path);

	memset(&pi, 0, sizeof pi);
	pi.flags = flags;
	pi.file = path;
	pi.line = 1;
	pi.item = item;
	pi.c = c;

	pr = cmd_parse_from_buffer(buf, len, &pi);
	if (pr->status == CMD_PARSE_ERROR) {
		cfg_add_cause(""%s"", pr->error);
		free(pr->error);
		return (-1);
	}
	if (flags & CMD_PARSE_PARSEONLY) {
		cmd_list_free(pr->cmdlist);
		return (0);
	}

	if (item != NULL)
		state = cmdq_copy_state(cmdq_get_state(item), current);
	else
		state = cmdq_new_state(NULL, NULL, 0);
	cmdq_add_format(state, ""current_file"", ""%s"", pi.file);

	new_item0 = cmdq_get_command(pr->cmdlist, state);
	if (item != NULL)
		new_item0 = cmdq_insert_after(item, new_item0);
	else
		new_item0 = cmdq_append(NULL, new_item0);
	cmd_list_free(pr->cmdlist);
	cmdq_free_state(state);

	if (new_item != NULL)
		*new_item = new_item0;
	return (0);
}

void
cfg_add_cause(const char *fmt, ...)
{
	va_list	 ap;
	char	*msg;

	va_start(ap, fmt);
	xvasprintf(&msg, fmt, ap);
	va_end(ap);

	cfg_ncauses++;
	cfg_causes = xreallocarray(cfg_causes, cfg_ncauses, sizeof *cfg_causes);
	cfg_causes[cfg_ncauses - 1] = msg;
}

void
cfg_print_causes(struct cmdq_item *item)
{
	u_int	 i;

	for (i = 0; i < cfg_ncauses; i++) {
		cmdq_print(item, ""%s"", cfg_causes[i]);
		free(cfg_causes[i]);
	}

	free(cfg_causes);
	cfg_causes = NULL;
	cfg_ncauses = 0;
}

void
cfg_show_causes(struct session *s)
{
	struct client			*c = TAILQ_FIRST(&clients);
	struct window_pane		*wp;
	struct window_mode_entry	*wme;
	u_int				 i;

	if (cfg_ncauses == 0)
		return;

	if (c != NULL && (c->flags & CLIENT_CONTROL)) {
		for (i = 0; i < cfg_ncauses; i++) {
			control_write(c, ""%%config-error %s"", cfg_causes[i]);
			free(cfg_causes[i]);
		}
		goto out;
	}

	if (s == NULL) {
		if (c != NULL && c->session != NULL)
			s = c->session;
		else
			s = RB_MIN(sessions, &sessions);
	}
	if (s == NULL || s->attached == 0) /* wait for an attached session */
		return;
	wp = s->curw->window->active;

	wme = TAILQ_FIRST(&wp->modes);
	if (wme == NULL || wme->mode != &window_view_mode)
		window_pane_set_mode(wp, NULL, &window_view_mode, NULL, NULL);
	for (i = 0; i < cfg_ncauses; i++) {
		window_copy_add(wp, 0, ""%s"", cfg_causes[i]);
		free(cfg_causes[i]);
	}

out:
	free(cfg_causes);
	cfg_causes = NULL;
	cfg_ncauses = 0;
}
"
./repos/tmux/attributes.c,https://github.com/tmux/tmux.git,"/* $OpenBSD$ */

/*
 * Copyright (c) 2009 Joshua Elsasser <josh@elsasser.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <string.h>

#include ""tmux.h""

const char *
attributes_tostring(int attr)
{
	static char	buf[512];
	size_t		len;

	if (attr == 0)
		return (""none"");

	len = xsnprintf(buf, sizeof buf, ""%s%s%s%s%s%s%s%s%s%s%s%s%s%s"",
	    (attr & GRID_ATTR_CHARSET) ? ""acs,"" : """",
	    (attr & GRID_ATTR_BRIGHT) ? ""bright,"" : """",
	    (attr & GRID_ATTR_DIM) ? ""dim,"" : """",
	    (attr & GRID_ATTR_UNDERSCORE) ? ""underscore,"" : """",
	    (attr & GRID_ATTR_BLINK)? ""blink,"" : """",
	    (attr & GRID_ATTR_REVERSE) ? ""reverse,"" : """",
	    (attr & GRID_ATTR_HIDDEN) ? ""hidden,"" : """",
	    (attr & GRID_ATTR_ITALICS) ? ""italics,"" : """",
	    (attr & GRID_ATTR_STRIKETHROUGH) ? ""strikethrough,"" : """",
	    (attr & GRID_ATTR_UNDERSCORE_2) ? ""double-underscore,"" : """",
	    (attr & GRID_ATTR_UNDERSCORE_3) ? ""curly-underscore,"" : """",
	    (attr & GRID_ATTR_UNDERSCORE_4) ? ""dotted-underscore,"" : """",
	    (attr & GRID_ATTR_UNDERSCORE_5) ? ""dashed-underscore,"" : """",
	    (attr & GRID_ATTR_OVERLINE) ? ""overline,"" : """");
	if (len > 0)
		buf[len - 1] = '\0';

	return (buf);
}

int
attributes_fromstring(const char *str)
{
	const char	delimiters[] = "" ,|"";
	int		attr;
	size_t		end;
	u_int		i;
	struct {
		const char	*name;
		int		 attr;
	} table[] = {
		{ ""acs"", GRID_ATTR_CHARSET },
		{ ""bright"", GRID_ATTR_BRIGHT },
		{ ""bold"", GRID_ATTR_BRIGHT },
		{ ""dim"", GRID_ATTR_DIM },
		{ ""underscore"", GRID_ATTR_UNDERSCORE },
		{ ""blink"", GRID_ATTR_BLINK },
		{ ""reverse"", GRID_ATTR_REVERSE },
		{ ""hidden"", GRID_ATTR_HIDDEN },
		{ ""italics"", GRID_ATTR_ITALICS },
		{ ""strikethrough"", GRID_ATTR_STRIKETHROUGH },
		{ ""double-underscore"", GRID_ATTR_UNDERSCORE_2 },
		{ ""curly-underscore"", GRID_ATTR_UNDERSCORE_3 },
		{ ""dotted-underscore"", GRID_ATTR_UNDERSCORE_4 },
		{ ""dashed-underscore"", GRID_ATTR_UNDERSCORE_5 },
		{ ""overline"", GRID_ATTR_OVERLINE }
	};

	if (*str == '\0' || strcspn(str, delimiters) == 0)
		return (-1);
	if (strchr(delimiters, str[strlen(str) - 1]) != NULL)
		return (-1);

	if (strcasecmp(str, ""default"") == 0 || strcasecmp(str, ""none"") == 0)
		return (0);

	attr = 0;
	do {
		end = strcspn(str, delimiters);
		for (i = 0; i < nitems(table); i++) {
			if (end != strlen(table[i].name))
				continue;
			if (strncasecmp(str, table[i].name, end) == 0) {
				attr |= table[i].attr;
				break;
			}
		}
		if (i == nitems(table))
			return (-1);
		str += end + strspn(str + end, delimiters);
	} while (*str != '\0');

	return (attr);
}
"
./repos/tmux/client.c,https://github.com/tmux/tmux.git,"/* $OpenBSD$ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/un.h>
#include <sys/wait.h>
#include <sys/file.h>

#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include ""tmux.h""

static struct tmuxproc	*client_proc;
static struct tmuxpeer	*client_peer;
static uint64_t		 client_flags;
static int		 client_suspended;
static enum {
	CLIENT_EXIT_NONE,
	CLIENT_EXIT_DETACHED,
	CLIENT_EXIT_DETACHED_HUP,
	CLIENT_EXIT_LOST_TTY,
	CLIENT_EXIT_TERMINATED,
	CLIENT_EXIT_LOST_SERVER,
	CLIENT_EXIT_EXITED,
	CLIENT_EXIT_SERVER_EXITED,
	CLIENT_EXIT_MESSAGE_PROVIDED
} client_exitreason = CLIENT_EXIT_NONE;
static int		 client_exitflag;
static int		 client_exitval;
static enum msgtype	 client_exittype;
static const char	*client_exitsession;
static char		*client_exitmessage;
static const char	*client_execshell;
static const char	*client_execcmd;
static int		 client_attached;
static struct client_files client_files = RB_INITIALIZER(&client_files);

static __dead void	 client_exec(const char *,const char *);
static int		 client_get_lock(char *);
static int		 client_connect(struct event_base *, const char *,
			     uint64_t);
static void		 client_send_identify(const char *, const char *,
			     char **, u_int, const char *, int);
static void		 client_signal(int);
static void		 client_dispatch(struct imsg *, void *);
static void		 client_dispatch_attached(struct imsg *);
static void		 client_dispatch_wait(struct imsg *);
static const char	*client_exit_message(void);

/*
 * Get server create lock. If already held then server start is happening in
 * another client, so block until the lock is released and return -2 to
 * retry. Return -1 on failure to continue and start the server anyway.
 */
static int
client_get_lock(char *lockfile)
{
	int lockfd;

	log_debug(""lock file is %s"", lockfile);

	if ((lockfd = open(lockfile, O_WRONLY|O_CREAT, 0600)) == -1) {
		log_debug(""open failed: %s"", strerror(errno));
		return (-1);
	}

	if (flock(lockfd, LOCK_EX|LOCK_NB) == -1) {
		log_debug(""flock failed: %s"", strerror(errno));
		if (errno != EAGAIN)
			return (lockfd);
		while (flock(lockfd, LOCK_EX) == -1 && errno == EINTR)
			/* nothing */;
		close(lockfd);
		return (-2);
	}
	log_debug(""flock succeeded"");

	return (lockfd);
}

/* Connect client to server. */
static int
client_connect(struct event_base *base, const char *path, uint64_t flags)
{
	struct sockaddr_un	sa;
	size_t			size;
	int			fd, lockfd = -1, locked = 0;
	char		       *lockfile = NULL;

	memset(&sa, 0, sizeof sa);
	sa.sun_family = AF_UNIX;
	size = strlcpy(sa.sun_path, path, sizeof sa.sun_path);
	if (size >= sizeof sa.sun_path) {
		errno = ENAMETOOLONG;
		return (-1);
	}
	log_debug(""socket is %s"", path);

retry:
	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		return (-1);

	log_debug(""trying connect"");
	if (connect(fd, (struct sockaddr *)&sa, sizeof sa) == -1) {
		log_debug(""connect failed: %s"", strerror(errno));
		if (errno != ECONNREFUSED && errno != ENOENT)
			goto failed;
		if (flags & CLIENT_NOSTARTSERVER)
			goto failed;
		if (~flags & CLIENT_STARTSERVER)
			goto failed;
		close(fd);

		if (!locked) {
			xasprintf(&lockfile, ""%s.lock"", path);
			if ((lockfd = client_get_lock(lockfile)) < 0) {
				log_debug(""didn't get lock (%d)"", lockfd);

				free(lockfile);
				lockfile = NULL;

				if (lockfd == -2)
					goto retry;
			}
			log_debug(""got lock (%d)"", lockfd);

			/*
			 * Always retry at least once, even if we got the lock,
			 * because another client could have taken the lock,
			 * started the server and released the lock between our
			 * connect() and flock().
			 */
			locked = 1;
			goto retry;
		}

		if (lockfd >= 0 && unlink(path) != 0 && errno != ENOENT) {
			free(lockfile);
			close(lockfd);
			return (-1);
		}
		fd = server_start(client_proc, flags, base, lockfd, lockfile);
	}

	if (locked && lockfd >= 0) {
		free(lockfile);
		close(lockfd);
	}
	setblocking(fd, 0);
	return (fd);

failed:
	if (locked) {
		free(lockfile);
		close(lockfd);
	}
	close(fd);
	return (-1);
}

/* Get exit string from reason number. */
const char *
client_exit_message(void)
{
	static char msg[256];

	switch (client_exitreason) {
	case CLIENT_EXIT_NONE:
		break;
	case CLIENT_EXIT_DETACHED:
		if (client_exitsession != NULL) {
			xsnprintf(msg, sizeof msg, ""detached ""
			    ""(from session %s)"", client_exitsession);
			return (msg);
		}
		return (""detached"");
	case CLIENT_EXIT_DETACHED_HUP:
		if (client_exitsession != NULL) {
			xsnprintf(msg, sizeof msg, ""detached and SIGHUP ""
			    ""(from session %s)"", client_exitsession);
			return (msg);
		}
		return (""detached and SIGHUP"");
	case CLIENT_EXIT_LOST_TTY:
		return (""lost tty"");
	case CLIENT_EXIT_TERMINATED:
		return (""terminated"");
	case CLIENT_EXIT_LOST_SERVER:
		return (""server exited unexpectedly"");
	case CLIENT_EXIT_EXITED:
		return (""exited"");
	case CLIENT_EXIT_SERVER_EXITED:
		return (""server exited"");
	case CLIENT_EXIT_MESSAGE_PROVIDED:
		return (client_exitmessage);
	}
	return (""unknown reason"");
}

/* Exit if all streams flushed. */
static void
client_exit(void)
{
	if (!file_write_left(&client_files))
		proc_exit(client_proc);
}

/* Client main loop. */
int
client_main(struct event_base *base, int argc, char **argv, uint64_t flags,
    int feat)
{
	struct cmd_parse_result	*pr;
	struct msg_command	*data;
	int			 fd, i;
	const char		*ttynam, *termname, *cwd;
	pid_t			 ppid;
	enum msgtype		 msg;
	struct termios		 tio, saved_tio;
	size_t			 size, linesize = 0;
	ssize_t			 linelen;
	char			*line = NULL, **caps = NULL, *cause;
	u_int			 ncaps = 0;
	struct args_value	*values;

	/* Set up the initial command. */
	if (shell_command != NULL) {
		msg = MSG_SHELL;
		flags |= CLIENT_STARTSERVER;
	} else if (argc == 0) {
		msg = MSG_COMMAND;
		flags |= CLIENT_STARTSERVER;
	} else {
		msg = MSG_COMMAND;

		/*
		 * It's annoying parsing the command string twice (in client
		 * and later in server) but it is necessary to get the start
		 * server flag.
		 */
		values = args_from_vector(argc, argv);
		pr = cmd_parse_from_arguments(values, argc, NULL);
		if (pr->status == CMD_PARSE_SUCCESS) {
			if (cmd_list_any_have(pr->cmdlist, CMD_STARTSERVER))
				flags |= CLIENT_STARTSERVER;
			cmd_list_free(pr->cmdlist);
		} else
			free(pr->error);
		args_free_values(values, argc);
		free(values);
	}

	/* Create client process structure (starts logging). */
	client_proc = proc_start(""client"");
	proc_set_signals(client_proc, client_signal);

	/* Save the flags. */
	client_flags = flags;
	log_debug(""flags are %#llx"", (unsigned long long)client_flags);

	/* Initialize the client socket and start the server. */
#ifdef HAVE_SYSTEMD
	if (systemd_activated()) {
		/* socket-based activation, do not even try to be a client. */
		fd = server_start(client_proc, flags, base, 0, NULL);
	} else
#endif
	fd = client_connect(base, socket_path, client_flags);
	if (fd == -1) {
		if (errno == ECONNREFUSED) {
			fprintf(stderr, ""no server running on %s\n"",
			    socket_path);
		} else {
			fprintf(stderr, ""error connecting to %s (%s)\n"",
			    socket_path, strerror(errno));
		}
		return (1);
	}
	client_peer = proc_add_peer(client_proc, fd, client_dispatch, NULL);

	/* Save these before pledge(). */
	if ((cwd = find_cwd()) == NULL && (cwd = find_home()) == NULL)
		cwd = ""/"";
	if ((ttynam = ttyname(STDIN_FILENO)) == NULL)
		ttynam = """";
	if ((termname = getenv(""TERM"")) == NULL)
		termname = """";

	/*
	 * Drop privileges for client. ""proc exec"" is needed for -c and for
	 * locking (which uses system(3)).
	 *
	 * ""tty"" is needed to restore termios(4) and also for some reason -CC
	 * does not work properly without it (input is not recognised).
	 *
	 * ""sendfd"" is dropped later in client_dispatch_wait().
	 */
	if (pledge(
	    ""stdio rpath wpath cpath unix sendfd proc exec tty"",
	    NULL) != 0)
		fatal(""pledge failed"");

	/* Load terminfo entry if any. */
	if (isatty(STDIN_FILENO) &&
	    *termname != '\0' &&
	    tty_term_read_list(termname, STDIN_FILENO, &caps, &ncaps,
	    &cause) != 0) {
		fprintf(stderr, ""%s\n"", cause);
		free(cause);
		return (1);
	}

	/* Free stuff that is not used in the client. */
	if (ptm_fd != -1)
		close(ptm_fd);
	options_free(global_options);
	options_free(global_s_options);
	options_free(global_w_options);
	environ_free(global_environ);

	/* Set up control mode. */
	if (client_flags & CLIENT_CONTROLCONTROL) {
		if (tcgetattr(STDIN_FILENO, &saved_tio) != 0) {
			fprintf(stderr, ""tcgetattr failed: %s\n"",
			    strerror(errno));
			return (1);
		}
		cfmakeraw(&tio);
		tio.c_iflag = ICRNL|IXANY;
		tio.c_oflag = OPOST|ONLCR;
#ifdef NOKERNINFO
		tio.c_lflag = NOKERNINFO;
#endif
		tio.c_cflag = CREAD|CS8|HUPCL;
		tio.c_cc[VMIN] = 1;
		tio.c_cc[VTIME] = 0;
		cfsetispeed(&tio, cfgetispeed(&saved_tio));
		cfsetospeed(&tio, cfgetospeed(&saved_tio));
		tcsetattr(STDIN_FILENO, TCSANOW, &tio);
	}

	/* Send identify messages. */
	client_send_identify(ttynam, termname, caps, ncaps, cwd, feat);
	tty_term_free_list(caps, ncaps);
	proc_flush_peer(client_peer);

	/* Send first command. */
	if (msg == MSG_COMMAND) {
		/* How big is the command? */
		size = 0;
		for (i = 0; i < argc; i++)
			size += strlen(argv[i]) + 1;
		if (size > MAX_IMSGSIZE - (sizeof *data)) {
			fprintf(stderr, ""command too long\n"");
			return (1);
		}
		data = xmalloc((sizeof *data) + size);

		/* Prepare command for server. */
		data->argc = argc;
		if (cmd_pack_argv(argc, argv, (char *)(data + 1), size) != 0) {
			fprintf(stderr, ""command too long\n"");
			free(data);
			return (1);
		}
		size += sizeof *data;

		/* Send the command. */
		if (proc_send(client_peer, msg, -1, data, size) != 0) {
			fprintf(stderr, ""failed to send command\n"");
			free(data);
			return (1);
		}
		free(data);
	} else if (msg == MSG_SHELL)
		proc_send(client_peer, msg, -1, NULL, 0);

	/* Start main loop. */
	proc_loop(client_proc, NULL);

	/* Run command if user requested exec, instead of exiting. */
	if (client_exittype == MSG_EXEC) {
		if (client_flags & CLIENT_CONTROLCONTROL)
			tcsetattr(STDOUT_FILENO, TCSAFLUSH, &saved_tio);
		client_exec(client_execshell, client_execcmd);
	}

	/* Restore streams to blocking. */
	setblocking(STDIN_FILENO, 1);
	setblocking(STDOUT_FILENO, 1);
	setblocking(STDERR_FILENO, 1);

	/* Print the exit message, if any, and exit. */
	if (client_attached) {
		if (client_exitreason != CLIENT_EXIT_NONE)
			printf(""[%s]\n"", client_exit_message());

		ppid = getppid();
		if (client_exittype == MSG_DETACHKILL && ppid > 1)
			kill(ppid, SIGHUP);
	} else if (client_flags & CLIENT_CONTROL) {
		if (client_exitreason != CLIENT_EXIT_NONE)
			printf(""%%exit %s\n"", client_exit_message());
		else
			printf(""%%exit\n"");
		fflush(stdout);
		if (client_flags & CLIENT_CONTROL_WAITEXIT) {
			setvbuf(stdin, NULL, _IOLBF, 0);
			for (;;) {
				linelen = getline(&line, &linesize, stdin);
				if (linelen <= 1)
					break;
			}
			free(line);
		}
		if (client_flags & CLIENT_CONTROLCONTROL) {
			printf(""\033\\"");
			fflush(stdout);
			tcsetattr(STDOUT_FILENO, TCSAFLUSH, &saved_tio);
		}
	} else if (client_exitreason != CLIENT_EXIT_NONE)
		fprintf(stderr, ""%s\n"", client_exit_message());
	return (client_exitval);
}

/* Send identify messages to server. */
static void
client_send_identify(const char *ttynam, const char *termname, char **caps,
    u_int ncaps, const char *cwd, int feat)
{
	char	**ss;
	size_t	  sslen;
	int	  fd, flags = client_flags;
	pid_t	  pid;
	u_int	  i;

	proc_send(client_peer, MSG_IDENTIFY_FLAGS, -1, &flags, sizeof flags);
	proc_send(client_peer, MSG_IDENTIFY_LONGFLAGS, -1, &client_flags,
	    sizeof client_flags);

	proc_send(client_peer, MSG_IDENTIFY_TERM, -1, termname,
	    strlen(termname) + 1);
	proc_send(client_peer, MSG_IDENTIFY_FEATURES, -1, &feat, sizeof feat);

	proc_send(client_peer, MSG_IDENTIFY_TTYNAME, -1, ttynam,
	    strlen(ttynam) + 1);
	proc_send(client_peer, MSG_IDENTIFY_CWD, -1, cwd, strlen(cwd) + 1);

	for (i = 0; i < ncaps; i++) {
		proc_send(client_peer, MSG_IDENTIFY_TERMINFO, -1,
		    caps[i], strlen(caps[i]) + 1);
	}

	if ((fd = dup(STDIN_FILENO)) == -1)
		fatal(""dup failed"");
	proc_send(client_peer, MSG_IDENTIFY_STDIN, fd, NULL, 0);
	if ((fd = dup(STDOUT_FILENO)) == -1)
		fatal(""dup failed"");
	proc_send(client_peer, MSG_IDENTIFY_STDOUT, fd, NULL, 0);

	pid = getpid();
	proc_send(client_peer, MSG_IDENTIFY_CLIENTPID, -1, &pid, sizeof pid);

	for (ss = environ; *ss != NULL; ss++) {
		sslen = strlen(*ss) + 1;
		if (sslen > MAX_IMSGSIZE - IMSG_HEADER_SIZE)
			continue;
		proc_send(client_peer, MSG_IDENTIFY_ENVIRON, -1, *ss, sslen);
	}

	proc_send(client_peer, MSG_IDENTIFY_DONE, -1, NULL, 0);
}

/* Run command in shell; used for -c. */
static __dead void
client_exec(const char *shell, const char *shellcmd)
{
	const char	*name, *ptr;
	char		*argv0;

	log_debug(""shell %s, command %s"", shell, shellcmd);

	ptr = strrchr(shell, '/');
	if (ptr != NULL && *(ptr + 1) != '\0')
		name = ptr + 1;
	else
		name = shell;
	if (client_flags & CLIENT_LOGIN)
		xasprintf(&argv0, ""-%s"", name);
	else
		xasprintf(&argv0, ""%s"", name);
	setenv(""SHELL"", shell, 1);

	proc_clear_signals(client_proc, 1);

	setblocking(STDIN_FILENO, 1);
	setblocking(STDOUT_FILENO, 1);
	setblocking(STDERR_FILENO, 1);
	closefrom(STDERR_FILENO + 1);

	execl(shell, argv0, ""-c"", shellcmd, (char *) NULL);
	fatal(""execl failed"");
}

/* Callback to handle signals in the client. */
static void
client_signal(int sig)
{
	struct sigaction sigact;
	int		 status;
	pid_t		 pid;

	log_debug(""%s: %s"", __func__, strsignal(sig));
	if (sig == SIGCHLD) {
		for (;;) {
			pid = waitpid(WAIT_ANY, &status, WNOHANG);
			if (pid == 0)
				break;
			if (pid == -1) {
				if (errno == ECHILD)
					break;
				log_debug(""waitpid failed: %s"",
				    strerror(errno));
			}
		}
	} else if (!client_attached) {
		if (sig == SIGTERM || sig == SIGHUP)
			proc_exit(client_proc);
	} else {
		switch (sig) {
		case SIGHUP:
			client_exitreason = CLIENT_EXIT_LOST_TTY;
			client_exitval = 1;
			proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
			break;
		case SIGTERM:
			if (!client_suspended)
				client_exitreason = CLIENT_EXIT_TERMINATED;
			client_exitval = 1;
			proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
			break;
		case SIGWINCH:
			proc_send(client_peer, MSG_RESIZE, -1, NULL, 0);
			break;
		case SIGCONT:
			memset(&sigact, 0, sizeof sigact);
			sigemptyset(&sigact.sa_mask);
			sigact.sa_flags = SA_RESTART;
			sigact.sa_handler = SIG_IGN;
			if (sigaction(SIGTSTP, &sigact, NULL) != 0)
				fatal(""sigaction failed"");
			proc_send(client_peer, MSG_WAKEUP, -1, NULL, 0);
			client_suspended = 0;
			break;
		}
	}
}

/* Callback for file write error or close. */
static void
client_file_check_cb(__unused struct client *c, __unused const char *path,
    __unused int error, __unused int closed, __unused struct evbuffer *buffer,
    __unused void *data)
{
	if (client_exitflag)
		client_exit();
}

/* Callback for client read events. */
static void
client_dispatch(struct imsg *imsg, __unused void *arg)
{
	if (imsg == NULL) {
		if (!client_exitflag) {
			client_exitreason = CLIENT_EXIT_LOST_SERVER;
			client_exitval = 1;
		}
		proc_exit(client_proc);
		return;
	}

	if (client_attached)
		client_dispatch_attached(imsg);
	else
		client_dispatch_wait(imsg);
}

/* Process an exit message. */
static void
client_dispatch_exit_message(char *data, size_t datalen)
{
	int	retval;

	if (datalen < sizeof retval && datalen != 0)
		fatalx(""bad MSG_EXIT size"");

	if (datalen >= sizeof retval) {
		memcpy(&retval, data, sizeof retval);
		client_exitval = retval;
	}

	if (datalen > sizeof retval) {
		datalen -= sizeof retval;
		data += sizeof retval;

		client_exitmessage = xmalloc(datalen);
		memcpy(client_exitmessage, data, datalen);
		client_exitmessage[datalen - 1] = '\0';

		client_exitreason = CLIENT_EXIT_MESSAGE_PROVIDED;
	}
}

/* Dispatch imsgs when in wait state (before MSG_READY). */
static void
client_dispatch_wait(struct imsg *imsg)
{
	char		*data;
	ssize_t		 datalen;
	static int	 pledge_applied;

	/*
	 * ""sendfd"" is no longer required once all of the identify messages
	 * have been sent. We know the server won't send us anything until that
	 * point (because we don't ask it to), so we can drop ""sendfd"" once we
	 * get the first message from the server.
	 */
	if (!pledge_applied) {
		if (pledge(
		    ""stdio rpath wpath cpath unix proc exec tty"",
		    NULL) != 0)
			fatal(""pledge failed"");
		pledge_applied = 1;
	}

	data = imsg->data;
	datalen = imsg->hdr.len - IMSG_HEADER_SIZE;

	switch (imsg->hdr.type) {
	case MSG_EXIT:
	case MSG_SHUTDOWN:
		client_dispatch_exit_message(data, datalen);
		client_exitflag = 1;
		client_exit();
		break;
	case MSG_READY:
		if (datalen != 0)
			fatalx(""bad MSG_READY size"");

		client_attached = 1;
		proc_send(client_peer, MSG_RESIZE, -1, NULL, 0);
		break;
	case MSG_VERSION:
		if (datalen != 0)
			fatalx(""bad MSG_VERSION size"");

		fprintf(stderr, ""protocol version mismatch ""
		    ""(client %d, server %u)\n"", PROTOCOL_VERSION,
		    imsg->hdr.peerid & 0xff);
		client_exitval = 1;
		proc_exit(client_proc);
		break;
	case MSG_FLAGS:
		if (datalen != sizeof client_flags)
			fatalx(""bad MSG_FLAGS string"");

		memcpy(&client_flags, data, sizeof client_flags);
		log_debug(""new flags are %#llx"",
		    (unsigned long long)client_flags);
		break;
	case MSG_SHELL:
		if (datalen == 0 || data[datalen - 1] != '\0')
			fatalx(""bad MSG_SHELL string"");

		client_exec(data, shell_command);
		/* NOTREACHED */
	case MSG_DETACH:
	case MSG_DETACHKILL:
		proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
		break;
	case MSG_EXITED:
		proc_exit(client_proc);
		break;
	case MSG_READ_OPEN:
		file_read_open(&client_files, client_peer, imsg, 1,
		    !(client_flags & CLIENT_CONTROL), client_file_check_cb,
		    NULL);
		break;
	case MSG_READ_CANCEL:
		file_read_cancel(&client_files, imsg);
		break;
	case MSG_WRITE_OPEN:
		file_write_open(&client_files, client_peer, imsg, 1,
		    !(client_flags & CLIENT_CONTROL), client_file_check_cb,
		    NULL);
		break;
	case MSG_WRITE:
		file_write_data(&client_files, imsg);
		break;
	case MSG_WRITE_CLOSE:
		file_write_close(&client_files, imsg);
		break;
	case MSG_OLDSTDERR:
	case MSG_OLDSTDIN:
	case MSG_OLDSTDOUT:
		fprintf(stderr, ""server version is too old for client\n"");
		proc_exit(client_proc);
		break;
	}
}

/* Dispatch imsgs in attached state (after MSG_READY). */
static void
client_dispatch_attached(struct imsg *imsg)
{
	struct sigaction	 sigact;
	char			*data;
	ssize_t			 datalen;

	data = imsg->data;
	datalen = imsg->hdr.len - IMSG_HEADER_SIZE;

	switch (imsg->hdr.type) {
	case MSG_FLAGS:
		if (datalen != sizeof client_flags)
			fatalx(""bad MSG_FLAGS string"");

		memcpy(&client_flags, data, sizeof client_flags);
		log_debug(""new flags are %#llx"",
		    (unsigned long long)client_flags);
		break;
	case MSG_DETACH:
	case MSG_DETACHKILL:
		if (datalen == 0 || data[datalen - 1] != '\0')
			fatalx(""bad MSG_DETACH string"");

		client_exitsession = xstrdup(data);
		client_exittype = imsg->hdr.type;
		if (imsg->hdr.type == MSG_DETACHKILL)
			client_exitreason = CLIENT_EXIT_DETACHED_HUP;
		else
			client_exitreason = CLIENT_EXIT_DETACHED;
		proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
		break;
	case MSG_EXEC:
		if (datalen == 0 || data[datalen - 1] != '\0' ||
		    strlen(data) + 1 == (size_t)datalen)
			fatalx(""bad MSG_EXEC string"");
		client_execcmd = xstrdup(data);
		client_execshell = xstrdup(data + strlen(data) + 1);

		client_exittype = imsg->hdr.type;
		proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
		break;
	case MSG_EXIT:
		client_dispatch_exit_message(data, datalen);
		if (client_exitreason == CLIENT_EXIT_NONE)
			client_exitreason = CLIENT_EXIT_EXITED;
		proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
		break;
	case MSG_EXITED:
		if (datalen != 0)
			fatalx(""bad MSG_EXITED size"");

		proc_exit(client_proc);
		break;
	case MSG_SHUTDOWN:
		if (datalen != 0)
			fatalx(""bad MSG_SHUTDOWN size"");

		proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
		client_exitreason = CLIENT_EXIT_SERVER_EXITED;
		client_exitval = 1;
		break;
	case MSG_SUSPEND:
		if (datalen != 0)
			fatalx(""bad MSG_SUSPEND size"");

		memset(&sigact, 0, sizeof sigact);
		sigemptyset(&sigact.sa_mask);
		sigact.sa_flags = SA_RESTART;
		sigact.sa_handler = SIG_DFL;
		if (sigaction(SIGTSTP, &sigact, NULL) != 0)
			fatal(""sigaction failed"");
		client_suspended = 1;
		kill(getpid(), SIGTSTP);
		break;
	case MSG_LOCK:
		if (datalen == 0 || data[datalen - 1] != '\0')
			fatalx(""bad MSG_LOCK string"");

		system(data);
		proc_send(client_peer, MSG_UNLOCK, -1, NULL, 0);
		break;
	}
}
"
./repos/twemproxy/src/nc_array.c,https://github.com/twitter/twemproxy,"/*
 * twemproxy - A fast and lightweight proxy for memcached protocol.
 * Copyright (C) 2011 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stdlib.h>

#include <nc_core.h>

struct array *
array_create(uint32_t n, size_t size)
{
    struct array *a;

    ASSERT(n != 0 && size != 0);

    a = nc_alloc(sizeof(*a));
    if (a == NULL) {
        return NULL;
    }

    a->elem = nc_alloc(n * size);
    if (a->elem == NULL) {
        nc_free(a);
        return NULL;
    }

    a->nelem = 0;
    a->size = size;
    a->nalloc = n;

    return a;
}

void
array_destroy(struct array *a)
{
    array_deinit(a);
    nc_free(a);
}

rstatus_t
array_init(struct array *a, uint32_t n, size_t size)
{
    ASSERT(n != 0 && size != 0);

    a->elem = nc_alloc(n * size);
    if (a->elem == NULL) {
        return NC_ENOMEM;
    }

    a->nelem = 0;
    a->size = size;
    a->nalloc = n;

    return NC_OK;
}

void
array_deinit(struct array *a)
{
    ASSERT(a->nelem == 0);

    if (a->elem != NULL) {
        nc_free(a->elem);
    }
}

uint32_t
array_idx(const struct array *a, const void *elem)
{
    const uint8_t *p, *q;
    uint32_t off, idx;

    ASSERT(elem >= a->elem);

    p = a->elem;
    q = elem;
    off = (uint32_t)(q - p);

    ASSERT(off % (uint32_t)a->size == 0);

    idx = off / (uint32_t)a->size;

    return idx;
}

void *
array_push(struct array *a)
{
    void *elem, *new;
    size_t size;

    if (a->nelem == a->nalloc) {

        /* the array is full; allocate new array */
        size = a->size * a->nalloc;
        new = nc_realloc(a->elem, 2 * size);
        if (new == NULL) {
            return NULL;
        }

        a->elem = new;
        a->nalloc *= 2;
    }

    elem = (uint8_t *)a->elem + a->size * a->nelem;
    a->nelem++;

    return elem;
}

void *
array_pop(struct array *a)
{
    void *elem;

    ASSERT(a->nelem != 0);

    a->nelem--;
    elem = (uint8_t *)a->elem + a->size * a->nelem;

    return elem;
}

void *
array_get(const struct array *a, uint32_t idx)
{
    void *elem;

    ASSERT(a->nelem != 0);
    ASSERT(idx < a->nelem);

    elem = (uint8_t *)a->elem + (a->size * idx);

    return elem;
}

void *
array_top(const struct array *a)
{
    ASSERT(a->nelem != 0);

    return array_get(a, a->nelem - 1);
}

void
array_swap(struct array *a, struct array *b)
{
    struct array tmp;

    tmp = *a;
    *a = *b;
    *b = tmp;
}

/*
 * Sort nelem elements of the array in ascending order based on the
 * compare comparator.
 */
void
array_sort(struct array *a, array_compare_t compare)
{
    ASSERT(a->nelem != 0);

    qsort(a->elem, a->nelem, a->size, compare);
}

/*
 * Calls the func once for each element in the array as long as func returns
 * success. On failure short-circuits and returns the error status.
 */
rstatus_t
array_each(const struct array *a, array_each_t func, void *data)
{
    uint32_t i, nelem;

    ASSERT(array_n(a) != 0);
    ASSERT(func != NULL);

    for (i = 0, nelem = array_n(a); i < nelem; i++) {
        void *elem = array_get(a, i);
        rstatus_t status;

        status = func(elem, data);
        if (status != NC_OK) {
            return status;
        }
    }

    return NC_OK;
}
"
./repos/twemproxy/src/nc_conf.c,https://github.com/twitter/twemproxy,"/*
 * twemproxy - A fast and lightweight proxy for memcached protocol.
 * Copyright (C) 2011 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <nc_core.h>
#include <nc_conf.h>
#include <nc_server.h>
#include <proto/nc_proto.h>

#define DEFINE_ACTION(_hash, _name) string(#_name),
static const struct string hash_strings[] = {
    HASH_CODEC( DEFINE_ACTION )
    null_string
};
#undef DEFINE_ACTION

#define DEFINE_ACTION(_hash, _name) hash_##_name,
static const hash_t hash_algos[] = {
    HASH_CODEC( DEFINE_ACTION )
    NULL
};
#undef DEFINE_ACTION

#define DEFINE_ACTION(_dist, _name) string(#_name),
static const struct string dist_strings[] = {
    DIST_CODEC( DEFINE_ACTION )
    null_string
};
#undef DEFINE_ACTION

static const struct command conf_commands[] = {
    { string(""listen""),
      conf_set_listen,
      offsetof(struct conf_pool, listen) },

    { string(""hash""),
      conf_set_hash,
      offsetof(struct conf_pool, hash) },

    { string(""hash_tag""),
      conf_set_hashtag,
      offsetof(struct conf_pool, hash_tag) },

    { string(""distribution""),
      conf_set_distribution,
      offsetof(struct conf_pool, distribution) },

    { string(""timeout""),
      conf_set_num,
      offsetof(struct conf_pool, timeout) },

    { string(""backlog""),
      conf_set_num,
      offsetof(struct conf_pool, backlog) },

    { string(""client_connections""),
      conf_set_num,
      offsetof(struct conf_pool, client_connections) },

    { string(""redis""),
      conf_set_bool,
      offsetof(struct conf_pool, redis) },

    { string(""tcpkeepalive""),
      conf_set_bool,
      offsetof(struct conf_pool, tcpkeepalive) },

    { string(""reuseport""),
      conf_set_bool,
      offsetof(struct conf_pool, reuseport) },

    { string(""redis_auth""),
      conf_set_string,
      offsetof(struct conf_pool, redis_auth) },

    { string(""redis_db""),
      conf_set_num,
      offsetof(struct conf_pool, redis_db) },

    { string(""preconnect""),
      conf_set_bool,
      offsetof(struct conf_pool, preconnect) },

    { string(""auto_eject_hosts""),
      conf_set_bool,
      offsetof(struct conf_pool, auto_eject_hosts) },

    { string(""server_connections""),
      conf_set_num,
      offsetof(struct conf_pool, server_connections) },

    { string(""server_retry_timeout""),
      conf_set_num,
      offsetof(struct conf_pool, server_retry_timeout) },

    { string(""server_failure_limit""),
      conf_set_num,
      offsetof(struct conf_pool, server_failure_limit) },

    { string(""servers""),
      conf_add_server,
      offsetof(struct conf_pool, server) },

    null_command
};

static const struct string true_str = string(""true"");
static const struct string false_str = string(""false"");

static void
conf_server_init(struct conf_server *cs)
{
    string_init(&cs->pname);
    string_init(&cs->name);
    string_init(&cs->addrstr);
    cs->port = 0;
    cs->weight = 0;

    memset(&cs->info, 0, sizeof(cs->info));

    cs->valid = 0;

    log_debug(LOG_VVERB, ""init conf server %p"", cs);
}

static void
conf_server_deinit(struct conf_server *cs)
{
    string_deinit(&cs->pname);
    string_deinit(&cs->name);
    string_deinit(&cs->addrstr);
    cs->valid = 0;
    log_debug(LOG_VVERB, ""deinit conf server %p"", cs);
}

rstatus_t
conf_server_each_transform(void *elem, void *data)
{
    struct conf_server *cs = elem;
    struct array *server = data;
    struct server *s;

    ASSERT(cs->valid);

    s = array_push(server);
    ASSERT(s != NULL);

    s->idx = array_idx(server, s);
    s->owner = NULL;

    s->pname = cs->pname;
    s->name = cs->name;
    s->addrstr = cs->addrstr;
    s->port = (uint16_t)cs->port;
    s->weight = (uint32_t)cs->weight;

    nc_memcpy(&s->info, &cs->info, sizeof(cs->info));

    s->ns_conn_q = 0;
    TAILQ_INIT(&s->s_conn_q);

    s->next_retry = 0LL;
    s->failure_count = 0;

    log_debug(LOG_VERB, ""transform to server %""PRIu32"" '%.*s'"",
              s->idx, s->pname.len, s->pname.data);

    return NC_OK;
}

static rstatus_t
conf_pool_init(struct conf_pool *cp, const struct string *name)
{
    rstatus_t status;

    string_init(&cp->name);

    string_init(&cp->listen.pname);
    string_init(&cp->listen.name);
    string_init(&cp->redis_auth);
    cp->listen.port = 0;
    memset(&cp->listen.info, 0, sizeof(cp->listen.info));
    cp->listen.valid = 0;

    cp->hash = CONF_UNSET_HASH;
    string_init(&cp->hash_tag);
    cp->distribution = CONF_UNSET_DIST;

    cp->timeout = CONF_UNSET_NUM;
    cp->backlog = CONF_UNSET_NUM;

    cp->client_connections = CONF_UNSET_NUM;

    cp->redis = CONF_UNSET_NUM;
    cp->tcpkeepalive = CONF_UNSET_NUM;
    cp->reuseport = CONF_UNSET_NUM;
    cp->redis_db = CONF_UNSET_NUM;
    cp->preconnect = CONF_UNSET_NUM;
    cp->auto_eject_hosts = CONF_UNSET_NUM;
    cp->server_connections = CONF_UNSET_NUM;
    cp->server_retry_timeout = CONF_UNSET_NUM;
    cp->server_failure_limit = CONF_UNSET_NUM;

    array_null(&cp->server);

    cp->valid = 0;

    status = string_duplicate(&cp->name, name);
    if (status != NC_OK) {
        return status;
    }

    status = array_init(&cp->server, CONF_DEFAULT_SERVERS,
                        sizeof(struct conf_server));
    if (status != NC_OK) {
        string_deinit(&cp->name);
        return status;
    }

    log_debug(LOG_VVERB, ""init conf pool %p, '%.*s'"", cp, name->len, name->data);

    return NC_OK;
}

static void
conf_pool_deinit(struct conf_pool *cp)
{
    string_deinit(&cp->name);

    string_deinit(&cp->listen.pname);
    string_deinit(&cp->listen.name);

    if (cp->redis_auth.len > 0) {
        string_deinit(&cp->redis_auth);
    }

    while (array_n(&cp->server) != 0) {
        conf_server_deinit(array_pop(&cp->server));
    }
    array_deinit(&cp->server);

    log_debug(LOG_VVERB, ""deinit conf pool %p"", cp);
}

rstatus_t
conf_pool_each_transform(void *elem, void *data)
{
    rstatus_t status;
    struct conf_pool *cp = elem;
    struct array *server_pool = data;
    struct server_pool *sp;

    ASSERT(cp->valid);

    sp = array_push(server_pool);
    ASSERT(sp != NULL);

    sp->idx = array_idx(server_pool, sp);
    sp->ctx = NULL;

    sp->p_conn = NULL;
    sp->nc_conn_q = 0;
    TAILQ_INIT(&sp->c_conn_q);

    array_null(&sp->server);
    sp->ncontinuum = 0;
    sp->nserver_continuum = 0;
    sp->continuum = NULL;
    sp->nlive_server = 0;
    sp->next_rebuild = 0LL;

    sp->name = cp->name;
    sp->addrstr = cp->listen.pname;
    sp->port = (uint16_t)cp->listen.port;

    nc_memcpy(&sp->info, &cp->listen.info, sizeof(cp->listen.info));
    sp->perm = cp->listen.perm;

    sp->key_hash_type = cp->hash;
    sp->key_hash = hash_algos[cp->hash];
    sp->dist_type = cp->distribution;
    sp->hash_tag = cp->hash_tag;

    sp->tcpkeepalive = cp->tcpkeepalive ? 1 : 0;
    sp->reuseport = cp->reuseport ? 1 : 0;

    sp->redis = cp->redis ? 1 : 0;
    sp->timeout = cp->timeout;
    sp->backlog = cp->backlog;
    sp->redis_db = cp->redis_db;

    sp->redis_auth = cp->redis_auth;
    sp->require_auth = cp->redis_auth.len > 0 ? 1 : 0;

    sp->client_connections = (uint32_t)cp->client_connections;
    sp->server_connections = (uint32_t)cp->server_connections;
    sp->server_retry_timeout = (int64_t)cp->server_retry_timeout * 1000LL;
    sp->server_failure_limit = (uint32_t)cp->server_failure_limit;
    sp->auto_eject_hosts = cp->auto_eject_hosts ? 1 : 0;
    sp->preconnect = cp->preconnect ? 1 : 0;

    status = server_init(&sp->server, &cp->server, sp);
    if (status != NC_OK) {
        return status;
    }

    log_debug(LOG_VERB, ""transform to pool %""PRIu32"" '%.*s'"", sp->idx,
              sp->name.len, sp->name.data);

    return NC_OK;
}

static void
conf_dump(const struct conf *cf)
{
    uint32_t i, j, npool, nserver;
    struct conf_pool *cp;
    struct string *s;

    npool = array_n(&cf->pool);
    if (npool == 0) {
        return;
    }

    log_debug(LOG_VVERB, ""%""PRIu32"" pools in configuration file '%s'"", npool,
              cf->fname);

    for (i = 0; i < npool; i++) {
        cp = array_get(&cf->pool, i);

        log_debug(LOG_VVERB, ""%.*s"", cp->name.len, cp->name.data);
        log_debug(LOG_VVERB, ""  listen: %.*s"",
                  cp->listen.pname.len, cp->listen.pname.data);
        log_debug(LOG_VVERB, ""  timeout: %d"", cp->timeout);
        log_debug(LOG_VVERB, ""  backlog: %d"", cp->backlog);
        log_debug(LOG_VVERB, ""  hash: %d"", cp->hash);
        log_debug(LOG_VVERB, ""  hash_tag: \""%.*s\"""", cp->hash_tag.len,
                  cp->hash_tag.data);
        log_debug(LOG_VVERB, ""  distribution: %d"", cp->distribution);
        log_debug(LOG_VVERB, ""  client_connections: %d"",
                  cp->client_connections);
        log_debug(LOG_VVERB, ""  redis: %d"", cp->redis);
        log_debug(LOG_VVERB, ""  preconnect: %d"", cp->preconnect);
        log_debug(LOG_VVERB, ""  auto_eject_hosts: %d"", cp->auto_eject_hosts);
        log_debug(LOG_VVERB, ""  server_connections: %d"",
                  cp->server_connections);
        log_debug(LOG_VVERB, ""  server_retry_timeout: %d"",
                  cp->server_retry_timeout);
        log_debug(LOG_VVERB, ""  server_failure_limit: %d"",
                  cp->server_failure_limit);

        nserver = array_n(&cp->server);
        log_debug(LOG_VVERB, ""  servers: %""PRIu32"""", nserver);

        for (j = 0; j < nserver; j++) {
            s = array_get(&cp->server, j);
            log_debug(LOG_VVERB, ""    %.*s"", s->len, s->data);
        }
    }
}

static rstatus_t
conf_yaml_init(struct conf *cf)
{
    int rv;

    ASSERT(!cf->valid_parser);

    rv = fseek(cf->fh, 0L, SEEK_SET);
    if (rv < 0) {
        log_error(""conf: failed to seek to the beginning of file '%s': %s"",
                  cf->fname, strerror(errno));
        return NC_ERROR;
    }

    rv = yaml_parser_initialize(&cf->parser);
    if (!rv) {
        log_error(""conf: failed (err %d) to initialize yaml parser"",
                  cf->parser.error);
        return NC_ERROR;
    }

    yaml_parser_set_input_file(&cf->parser, cf->fh);
    cf->valid_parser = 1;

    return NC_OK;
}

static void
conf_yaml_deinit(struct conf *cf)
{
    if (cf->valid_parser) {
        yaml_parser_delete(&cf->parser);
        cf->valid_parser = 0;
    }
}

static rstatus_t
conf_token_next(struct conf *cf)
{
    int rv;

    ASSERT(cf->valid_parser && !cf->valid_token);

    rv = yaml_parser_scan(&cf->parser, &cf->token);
    if (!rv) {
        log_error(""conf: failed (err %d) to scan next token"", cf->parser.error);
        return NC_ERROR;
    }
    cf->valid_token = 1;

    return NC_OK;
}

static void
conf_token_done(struct conf *cf)
{
    ASSERT(cf->valid_parser);

    if (cf->valid_token) {
        yaml_token_delete(&cf->token);
        cf->valid_token = 0;
    }
}

static rstatus_t
conf_event_next(struct conf *cf)
{
    int rv;

    ASSERT(cf->valid_parser && !cf->valid_event);

    rv = yaml_parser_parse(&cf->parser, &cf->event);
    if (!rv) {
        log_error(""conf: failed (err %d) to get next event"", cf->parser.error);
        return NC_ERROR;
    }
    cf->valid_event = 1;

    return NC_OK;
}

static void
conf_event_done(struct conf *cf)
{
    if (cf->valid_event) {
        yaml_event_delete(&cf->event);
        cf->valid_event = 0;
    }
}

static rstatus_t
conf_push_scalar(struct conf *cf)
{
    rstatus_t status;
    struct string *value;
    uint8_t *scalar;
    uint32_t scalar_len;

    scalar = cf->event.data.scalar.value;
    scalar_len = (uint32_t)cf->event.data.scalar.length;
    if (scalar_len == 0) {
        return NC_ERROR;
    }

    log_debug(LOG_VVERB, ""push '%.*s'"", scalar_len, scalar);

    value = array_push(&cf->arg);
    if (value == NULL) {
        return NC_ENOMEM;
    }
    string_init(value);

    status = string_copy(value, scalar, scalar_len);
    if (status != NC_OK) {
        array_pop(&cf->arg);
        return status;
    }

    return NC_OK;
}

static void
conf_pop_scalar(struct conf *cf)
{
    struct string *value;

    value = array_pop(&cf->arg);
    log_debug(LOG_VVERB, ""pop '%.*s'"", value->len, value->data);
    string_deinit(value);
}

static rstatus_t
conf_handler(struct conf *cf, void *data)
{
    const struct command *cmd;
    struct string *key, *value;
    uint32_t narg;

    if (array_n(&cf->arg) == 1) {
        value = array_top(&cf->arg);
        log_debug(LOG_VVERB, ""conf handler on '%.*s'"", value->len, value->data);
        return conf_pool_init(data, value);
    }

    narg = array_n(&cf->arg);
    value = array_get(&cf->arg, narg - 1);
    key = array_get(&cf->arg, narg - 2);

    log_debug(LOG_VVERB, ""conf handler on %.*s: %.*s"", key->len, key->data,
              value->len, value->data);

    for (cmd = conf_commands; cmd->name.len != 0; cmd++) {
        const char *rv;

        if (string_compare(key, &cmd->name) != 0) {
            continue;
        }

        rv = cmd->set(cf, cmd, data);
        if (rv != CONF_OK) {
            log_error(""conf: directive \""%.*s\"" %s"", key->len, key->data, rv);
            return NC_ERROR;
        }

        return NC_OK;
    }

    log_error(""conf: directive \""%.*s\"" is unknown"", key->len, key->data);

    return NC_ERROR;
}

static rstatus_t
conf_begin_parse(struct conf *cf)
{
    rstatus_t status;
    bool done;

    ASSERT(cf->sound && !cf->parsed);
    ASSERT(cf->depth == 0);

    status = conf_yaml_init(cf);
    if (status != NC_OK) {
        return status;
    }

    done = false;
    do {
        status = conf_event_next(cf);
        if (status != NC_OK) {
            return status;
        }

        log_debug(LOG_VVERB, ""next begin event %d"", cf->event.type);

        switch (cf->event.type) {
        case YAML_STREAM_START_EVENT:
        case YAML_DOCUMENT_START_EVENT:
            break;

        case YAML_MAPPING_START_EVENT:
            ASSERT(cf->depth < CONF_MAX_DEPTH);
            cf->depth++;
            done = true;
            break;

        default:
            NOT_REACHED();
        }

        conf_event_done(cf);

    } while (!done);

    return NC_OK;
}

static rstatus_t
conf_end_parse(struct conf *cf)
{
    rstatus_t status;
    bool done;

    ASSERT(cf->sound && !cf->parsed);
    ASSERT(cf->depth == 0);

    done = false;
    do {
        status = conf_event_next(cf);
        if (status != NC_OK) {
            return status;
        }

        log_debug(LOG_VVERB, ""next end event %d"", cf->event.type);

        switch (cf->event.type) {
        case YAML_STREAM_END_EVENT:
            done = true;
            break;

        case YAML_DOCUMENT_END_EVENT:
            break;

        default:
            NOT_REACHED();
        }

        conf_event_done(cf);
    } while (!done);

    conf_yaml_deinit(cf);

    return NC_OK;
}

static rstatus_t
conf_parse_core(struct conf *cf, void *data)
{
    rstatus_t status;
    bool done, leaf, new_pool;

    ASSERT(cf->sound);

    status = conf_event_next(cf);
    if (status != NC_OK) {
        return status;
    }

    log_debug(LOG_VVERB, ""next event %d depth %""PRIu32"" seq %d"", cf->event.type,
              cf->depth, cf->seq);

    done = false;
    leaf = false;
    new_pool = false;

    switch (cf->event.type) {
    case YAML_MAPPING_END_EVENT:
        cf->depth--;
        if (cf->depth == 1) {
            conf_pop_scalar(cf);
        } else if (cf->depth == 0) {
            done = true;
        }
        break;

    case YAML_MAPPING_START_EVENT:
        cf->depth++;
        break;

    case YAML_SEQUENCE_START_EVENT:
        cf->seq = 1;
        break;

    case YAML_SEQUENCE_END_EVENT:
        conf_pop_scalar(cf);
        cf->seq = 0;
        break;

    case YAML_SCALAR_EVENT:
        status = conf_push_scalar(cf);
        if (status != NC_OK) {
            break;
        }

        /* take appropriate action */
        if (cf->seq) {
            /* for a sequence, leaf is at CONF_MAX_DEPTH */
            ASSERT(cf->depth == CONF_MAX_DEPTH);
            leaf = true;
        } else if (cf->depth == CONF_ROOT_DEPTH) {
            /* create new conf_pool */
            data = array_push(&cf->pool);
            if (data == NULL) {
                status = NC_ENOMEM;
                break;
           }
           new_pool = true;
        } else if (array_n(&cf->arg) == cf->depth + 1) {
            /* for {key: value}, leaf is at CONF_MAX_DEPTH */
            ASSERT(cf->depth == CONF_MAX_DEPTH);
            leaf = true;
        }
        break;

    default:
        NOT_REACHED();
        break;
    }

    conf_event_done(cf);

    if (status != NC_OK) {
        return status;
    }

    if (done) {
        /* terminating condition */
        return NC_OK;
    }

    if (leaf || new_pool) {
        status = conf_handler(cf, data);

        if (leaf) {
            conf_pop_scalar(cf);
            if (!cf->seq) {
                conf_pop_scalar(cf);
            }
        }

        if (status != NC_OK) {
            return status;
        }
    }

    return conf_parse_core(cf, data);
}

static rstatus_t
conf_parse(struct conf *cf)
{
    rstatus_t status;

    ASSERT(cf->sound && !cf->parsed);
    ASSERT(array_n(&cf->arg) == 0);

    status = conf_begin_parse(cf);
    if (status != NC_OK) {
        return status;
    }

    status = conf_parse_core(cf, NULL);
    if (status != NC_OK) {
        return status;
    }

    status = conf_end_parse(cf);
    if (status != NC_OK) {
        return status;
    }

    cf->parsed = 1;

    return NC_OK;
}

static struct conf *
conf_open(const char *filename)
{
    rstatus_t status;
    struct conf *cf;
    FILE *fh;

    fh = fopen(filename, ""r"");
    if (fh == NULL) {
        log_error(""conf: failed to open configuration '%s': %s"", filename,
                  strerror(errno));
        return NULL;
    }

    cf = nc_alloc(sizeof(*cf));
    if (cf == NULL) {
        fclose(fh);
        return NULL;
    }

    status = array_init(&cf->arg, CONF_DEFAULT_ARGS, sizeof(struct string));
    if (status != NC_OK) {
        nc_free(cf);
        fclose(fh);
        return NULL;
    }

    status = array_init(&cf->pool, CONF_DEFAULT_POOL, sizeof(struct conf_pool));
    if (status != NC_OK) {
        array_deinit(&cf->arg);
        nc_free(cf);
        fclose(fh);
        return NULL;
    }

    cf->fname = filename;
    cf->fh = fh;
    cf->depth = 0;
    /* parser, event, and token are initialized later */
    cf->seq = 0;
    cf->valid_parser = 0;
    cf->valid_event = 0;
    cf->valid_token = 0;
    cf->sound = 0;
    cf->parsed = 0;
    cf->valid = 0;

    log_debug(LOG_VVERB, ""opened conf '%s'"", filename);

    return cf;
}

static rstatus_t
conf_validate_document(struct conf *cf)
{
    rstatus_t status;
    uint32_t count;
    bool done;

    status = conf_yaml_init(cf);
    if (status != NC_OK) {
        return status;
    }

    count = 0;
    done = false;
    do {
        yaml_document_t document;
        yaml_node_t *node;
        int rv;

        rv = yaml_parser_load(&cf->parser, &document);
        if (!rv) {
            log_error(""conf: failed (err %d) to get the next yaml document"",
                      cf->parser.error);
            conf_yaml_deinit(cf);
            return NC_ERROR;
        }

        node = yaml_document_get_root_node(&document);
        if (node == NULL) {
            done = true;
        } else {
            count++;
        }

        yaml_document_delete(&document);
    } while (!done);

    conf_yaml_deinit(cf);

    if (count != 1) {
        log_error(""conf: '%s' must contain only 1 document; found %""PRIu32"" ""
                  ""documents"", cf->fname, count);
        return NC_ERROR;
    }

    return NC_OK;
}

static rstatus_t
conf_validate_tokens(struct conf *cf)
{
    rstatus_t status;
    bool done, error;
    int type;

    status = conf_yaml_init(cf);
    if (status != NC_OK) {
        return status;
    }

    done = false;
    error = false;
    do {
        status = conf_token_next(cf);
        if (status != NC_OK) {
            return status;
        }
        type = cf->token.type;

        switch (type) {
        case YAML_NO_TOKEN:
            error = true;
            log_error(""conf: no token (%d) is disallowed"", type);
            break;

        case YAML_VERSION_DIRECTIVE_TOKEN:
            error = true;
            log_error(""conf: version directive token (%d) is disallowed"", type);
            break;

        case YAML_TAG_DIRECTIVE_TOKEN:
            error = true;
            log_error(""conf: tag directive token (%d) is disallowed"", type);
            break;

        case YAML_DOCUMENT_START_TOKEN:
            error = true;
            log_error(""conf: document start token (%d) is disallowed"", type);
            break;

        case YAML_DOCUMENT_END_TOKEN:
            error = true;
            log_error(""conf: document end token (%d) is disallowed"", type);
            break;

        case YAML_FLOW_SEQUENCE_START_TOKEN:
            error = true;
            log_error(""conf: flow sequence start token (%d) is disallowed"", type);
            break;

        case YAML_FLOW_SEQUENCE_END_TOKEN:
            error = true;
            log_error(""conf: flow sequence end token (%d) is disallowed"", type);
            break;

        case YAML_FLOW_MAPPING_START_TOKEN:
            error = true;
            log_error(""conf: flow mapping start token (%d) is disallowed"", type);
            break;

        case YAML_FLOW_MAPPING_END_TOKEN:
            error = true;
            log_error(""conf: flow mapping end token (%d) is disallowed"", type);
            break;

        case YAML_FLOW_ENTRY_TOKEN:
            error = true;
            log_error(""conf: flow entry token (%d) is disallowed"", type);
            break;

        case YAML_ALIAS_TOKEN:
            error = true;
            log_error(""conf: alias token (%d) is disallowed"", type);
            break;

        case YAML_ANCHOR_TOKEN:
            error = true;
            log_error(""conf: anchor token (%d) is disallowed"", type);
            break;

        case YAML_TAG_TOKEN:
            error = true;
            log_error(""conf: tag token (%d) is disallowed"", type);
            break;

        case YAML_BLOCK_SEQUENCE_START_TOKEN:
        case YAML_BLOCK_MAPPING_START_TOKEN:
        case YAML_BLOCK_END_TOKEN:
        case YAML_BLOCK_ENTRY_TOKEN:
            break;

        case YAML_KEY_TOKEN:
        case YAML_VALUE_TOKEN:
        case YAML_SCALAR_TOKEN:
            break;

        case YAML_STREAM_START_TOKEN:
            break;

        case YAML_STREAM_END_TOKEN:
            done = true;
            log_debug(LOG_VVERB, ""conf '%s' has valid tokens"", cf->fname);
            break;

        default:
            error = true;
            log_error(""conf: unknown token (%d) is disallowed"", type);
            break;
        }

        conf_token_done(cf);
    } while (!done && !error);

    conf_yaml_deinit(cf);

    return !error ? NC_OK : NC_ERROR;
}

static rstatus_t
conf_validate_structure(struct conf *cf)
{
    rstatus_t status;
    int type, depth;
    uint32_t i, count[CONF_MAX_DEPTH + 1];
    bool done, error, seq;

    status = conf_yaml_init(cf);
    if (status != NC_OK) {
        return status;
    }

    done = false;
    error = false;
    seq = false;
    depth = 0;
    for (i = 0; i < CONF_MAX_DEPTH + 1; i++) {
        count[i] = 0;
    }

    /*
     * Validate that the configuration conforms roughly to the following
     * yaml tree structure:
     *
     * keyx:
     *   key1: value1
     *   key2: value2
     *   seq:
     *     - elem1
     *     - elem2
     *     - elem3
     *   key3: value3
     *
     * keyy:
     *   key1: value1
     *   key2: value2
     *   seq:
     *     - elem1
     *     - elem2
     *     - elem3
     *   key3: value3
     */
    do {
        status = conf_event_next(cf);
        if (status != NC_OK) {
            return status;
        }

        type = cf->event.type;

        log_debug(LOG_VVERB, ""next event %d depth %d seq %d"", type, depth, seq);

        switch (type) {
        case YAML_STREAM_START_EVENT:
        case YAML_DOCUMENT_START_EVENT:
            break;

        case YAML_DOCUMENT_END_EVENT:
            break;

        case YAML_STREAM_END_EVENT:
            done = true;
            break;

        case YAML_MAPPING_START_EVENT:
            if (depth == CONF_ROOT_DEPTH && count[depth] != 1) {
                error = true;
                log_error(""conf: '%s' has more than one \""key:value\"" at depth""
                          "" %d"", cf->fname, depth);
            } else if (depth >= CONF_MAX_DEPTH) {
                error = true;
                log_error(""conf: '%s' has a depth greater than %d"", cf->fname,
                          CONF_MAX_DEPTH);
            }
            depth++;
            break;

        case YAML_MAPPING_END_EVENT:
            if (depth == CONF_MAX_DEPTH) {
                if (seq) {
                    seq = false;
                } else {
                    error = true;
                    log_error(""conf: '%s' missing sequence directive at depth ""
                              ""%d"", cf->fname, depth);
                }
            }
            depth--;
            count[depth] = 0;
            break;

        case YAML_SEQUENCE_START_EVENT:
            if (seq) {
                error = true;
                log_error(""conf: '%s' has more than one sequence directive"",
                          cf->fname);
            } else if (depth != CONF_MAX_DEPTH) {
                error = true;
                log_error(""conf: '%s' has sequence at depth %d instead of %d"",
                          cf->fname, depth, CONF_MAX_DEPTH);
            } else if (count[depth] != 1) {
                error = true;
                log_error(""conf: '%s' has invalid \""key:value\"" at depth %d"",
                          cf->fname, depth);
            }
            seq = true;
            break;

        case YAML_SEQUENCE_END_EVENT:
            ASSERT(depth == CONF_MAX_DEPTH);
            count[depth] = 0;
            break;

        case YAML_SCALAR_EVENT:
            if (depth == 0) {
                error = true;
                log_error(""conf: '%s' has invalid empty \""key:\"" at depth %d"",
                          cf->fname, depth);
            } else if (depth == CONF_ROOT_DEPTH && count[depth] != 0) {
                error = true;
                log_error(""conf: '%s' has invalid mapping \""key:\"" at depth %d"",
                          cf->fname, depth);
            } else if (depth == CONF_MAX_DEPTH && count[depth] == 2) {
                /* found a ""key: value"", resetting! */
                count[depth] = 0;
            }
            count[depth]++;
            break;

        default:
            NOT_REACHED();
        }

        conf_event_done(cf);
    } while (!done && !error);

    conf_yaml_deinit(cf);

    return !error ? NC_OK : NC_ERROR;
}

static rstatus_t
conf_pre_validate(struct conf *cf)
{
    rstatus_t status;

    status = conf_validate_document(cf);
    if (status != NC_OK) {
        return status;
    }

    status = conf_validate_tokens(cf);
    if (status != NC_OK) {
        return status;
    }

    status = conf_validate_structure(cf);
    if (status != NC_OK) {
        return status;
    }

    cf->sound = 1;

    return NC_OK;
}

static int
conf_server_name_cmp(const void *t1, const void *t2)
{
    const struct conf_server *s1 = t1, *s2 = t2;

    return string_compare(&s1->name, &s2->name);
}

static int
conf_pool_name_cmp(const void *t1, const void *t2)
{
    const struct conf_pool *p1 = t1, *p2 = t2;

    return string_compare(&p1->name, &p2->name);
}

static int
conf_pool_listen_cmp(const void *t1, const void *t2)
{
    const struct conf_pool *p1 = t1, *p2 = t2;

    return string_compare(&p1->listen.pname, &p2->listen.pname);
}

static rstatus_t
conf_validate_server(struct conf *cf, struct conf_pool *cp)
{
    uint32_t i, nserver;
    bool valid;

    nserver = array_n(&cp->server);
    if (nserver == 0) {
        log_error(""conf: pool '%.*s' has no servers"", cp->name.len,
                  cp->name.data);
        return NC_ERROR;
    }

    /*
     * Disallow duplicate servers - servers with identical ""host:port:weight""
     * or ""name"" combination are considered as duplicates. When server name
     * is configured, we only check for duplicate ""name"" and not for duplicate
     * ""host:port:weight""
     */
    array_sort(&cp->server, conf_server_name_cmp);
    for (valid = true, i = 0; i < nserver - 1; i++) {
        struct conf_server *cs1, *cs2;

        cs1 = array_get(&cp->server, i);
        cs2 = array_get(&cp->server, i + 1);

        if (string_compare(&cs1->name, &cs2->name) == 0) {
            log_error(""conf: pool '%.*s' has servers with same name '%.*s'"",
                      cp->name.len, cp->name.data, cs1->name.len,
                      cs1->name.data);
            valid = false;
            break;
        }
    }
    if (!valid) {
        return NC_ERROR;
    }

    return NC_OK;
}

static rstatus_t
conf_validate_pool(struct conf *cf, struct conf_pool *cp)
{
    rstatus_t status;

    ASSERT(!cp->valid);
    ASSERT(!string_empty(&cp->name));

    if (!cp->listen.valid) {
        log_error(""conf: directive \""listen:\"" is missing"");
        return NC_ERROR;
    }

    /* set default values for unset directives */

    if (cp->distribution == CONF_UNSET_DIST) {
        cp->distribution = CONF_DEFAULT_DIST;
    }

    if (cp->hash == CONF_UNSET_HASH) {
        cp->hash = CONF_DEFAULT_HASH;
    }

    if (cp->timeout == CONF_UNSET_NUM) {
        cp->timeout = CONF_DEFAULT_TIMEOUT;
    }

    if (cp->backlog == CONF_UNSET_NUM) {
        cp->backlog = CONF_DEFAULT_LISTEN_BACKLOG;
    }

    cp->client_connections = CONF_DEFAULT_CLIENT_CONNECTIONS;

    if (cp->redis == CONF_UNSET_NUM) {
        cp->redis = CONF_DEFAULT_REDIS;
    }

    if (cp->tcpkeepalive == CONF_UNSET_NUM) {
        cp->tcpkeepalive = CONF_DEFAULT_TCPKEEPALIVE;
    }

    if (cp->reuseport == CONF_UNSET_NUM) {
	cp->reuseport = CONF_DEFAULT_REUSEPORT;
    }

    if (cp->redis_db == CONF_UNSET_NUM) {
        cp->redis_db = CONF_DEFAULT_REDIS_DB;
    }

    if (cp->preconnect == CONF_UNSET_NUM) {
        cp->preconnect = CONF_DEFAULT_PRECONNECT;
    }

    if (cp->auto_eject_hosts == CONF_UNSET_NUM) {
        cp->auto_eject_hosts = CONF_DEFAULT_AUTO_EJECT_HOSTS;
    }

    if (cp->server_connections == CONF_UNSET_NUM) {
        cp->server_connections = CONF_DEFAULT_SERVER_CONNECTIONS;
    } else if (cp->server_connections == 0) {
        log_error(""conf: directive \""server_connections:\"" cannot be 0"");
        return NC_ERROR;
    }

    if (cp->server_retry_timeout == CONF_UNSET_NUM) {
        cp->server_retry_timeout = CONF_DEFAULT_SERVER_RETRY_TIMEOUT;
    }

    if (cp->server_failure_limit == CONF_UNSET_NUM) {
        cp->server_failure_limit = CONF_DEFAULT_SERVER_FAILURE_LIMIT;
    }

    if (!cp->redis && cp->redis_auth.len > 0) {
        log_error(""conf: directive \""redis_auth:\"" is only valid for a redis pool"");
        return NC_ERROR;
    }

    status = conf_validate_server(cf, cp);
    if (status != NC_OK) {
        return status;
    }

    cp->valid = 1;

    return NC_OK;
}

static rstatus_t
conf_post_validate(struct conf *cf)
{
    rstatus_t status;
    uint32_t i, npool;
    bool valid;

    ASSERT(cf->sound && cf->parsed);
    ASSERT(!cf->valid);

    npool = array_n(&cf->pool);
    if (npool == 0) {
        log_error(""conf: '%s' has no pools"", cf->fname);
        return NC_ERROR;
    }

    /* validate pool */
    for (i = 0; i < npool; i++) {
        struct conf_pool *cp = array_get(&cf->pool, i);

        status = conf_validate_pool(cf, cp);
        if (status != NC_OK) {
            return status;
        }
    }

    /* disallow pools with duplicate listen: key values */
    array_sort(&cf->pool, conf_pool_listen_cmp);
    for (valid = true, i = 0; i < npool - 1; i++) {
        struct conf_pool *p1, *p2;

        p1 = array_get(&cf->pool, i);
        p2 = array_get(&cf->pool, i + 1);

        if (string_compare(&p1->listen.pname, &p2->listen.pname) == 0) {
            log_error(""conf: pools '%.*s' and '%.*s' have the same listen ""
                      ""address '%.*s'"", p1->name.len, p1->name.data,
                      p2->name.len, p2->name.data, p1->listen.pname.len,
                      p1->listen.pname.data);
            valid = false;
            break;
        }
    }
    if (!valid) {
        return NC_ERROR;
    }

    /* disallow pools with duplicate names */
    array_sort(&cf->pool, conf_pool_name_cmp);
    for (valid = true, i = 0; i < npool - 1; i++) {
        struct conf_pool *p1, *p2;

        p1 = array_get(&cf->pool, i);
        p2 = array_get(&cf->pool, i + 1);

        if (string_compare(&p1->name, &p2->name) == 0) {
            log_error(""conf: '%s' has pools with same name %.*s'"", cf->fname,
                      p1->name.len, p1->name.data);
            valid = false;
            break;
        }
    }
    if (!valid) {
        return NC_ERROR;
    }

    return NC_OK;
}

struct conf *
conf_create(const char *filename)
{
    rstatus_t status;
    struct conf *cf;

    cf = conf_open(filename);
    if (cf == NULL) {
        return NULL;
    }

    /* validate configuration file before parsing */
    status = conf_pre_validate(cf);
    if (status != NC_OK) {
        goto error;
    }

    /* parse the configuration file */
    status = conf_parse(cf);
    if (status != NC_OK) {
        goto error;
    }

    /* validate parsed configuration */
    status = conf_post_validate(cf);
    if (status != NC_OK) {
        goto error;
    }

    conf_dump(cf);

    fclose(cf->fh);
    cf->fh = NULL;

    return cf;

error:
    log_stderr(""nutcracker: configuration file '%s' syntax is invalid"",
               filename);
    fclose(cf->fh);
    cf->fh = NULL;
    conf_destroy(cf);
    return NULL;
}

void
conf_destroy(struct conf *cf)
{
    while (array_n(&cf->arg) != 0) {
        conf_pop_scalar(cf);
    }
    array_deinit(&cf->arg);

    while (array_n(&cf->pool) != 0) {
        conf_pool_deinit(array_pop(&cf->pool));
    }
    array_deinit(&cf->pool);

    nc_free(cf);
}

const char *
conf_set_string(struct conf *cf, const struct command *cmd, void *conf)
{
    rstatus_t status;
    uint8_t *p;
    struct string *field;
    const struct string *value;

    p = conf;
    field = (struct string *)(p + cmd->offset);

    if (field->data != CONF_UNSET_PTR) {
        return ""is a duplicate"";
    }

    value = array_top(&cf->arg);

    status = string_duplicate(field, value);
    if (status != NC_OK) {
        return CONF_ERROR;
    }

    return CONF_OK;
}

const char *
conf_set_listen(struct conf *cf, const struct command *cmd, void *conf)
{
    rstatus_t status;
    struct string *value;
    struct conf_listen *field;
    uint8_t *p, *name;
    uint32_t namelen;

    p = conf;
    field = (struct conf_listen *)(p + cmd->offset);

    if (field->valid == 1) {
        return ""is a duplicate"";
    }

    value = array_top(&cf->arg);

    status = string_duplicate(&field->pname, value);
    if (status != NC_OK) {
        return CONF_ERROR;
    }

    if (value->data[0] == '/') {
        uint8_t *q, *start, *perm;

        /* parse ""socket_path permissions"" from the end */
        p = value->data + value->len -1;
        start = value->data;
        q = nc_strrchr(p, start, ' ');
        if (q == NULL) {
            /* no permissions field, so use defaults */
            name = value->data;
            namelen = value->len;
            field->perm = (mode_t)0;
        } else {
            perm = q + 1;

            p = q - 1;
            name = start;
            namelen = (uint32_t)(p - start + 1);

            errno = 0;
            field->perm = (mode_t)strtol((char *)perm, NULL, 8);
            if (errno || field->perm > 0777) {
                return ""has an invalid file permission in \""socket_path permission\"" format string"";
            }
        }
    } else {
        uint8_t *q, *start, *port;
        uint32_t portlen;

        /* parse ""hostname:port"" from the end */
        p = value->data + value->len - 1;
        start = value->data;
        q = nc_strrchr(p, start, ':');
        if (q == NULL) {
            return ""has an invalid \""hostname:port\"" format string"";
        }

        port = q + 1;
        portlen = (uint32_t)(p - port + 1);

        p = q - 1;

        name = start;
        namelen = (uint32_t)(p - start + 1);

        field->port = nc_atoi(port, portlen);
        if (field->port < 0 || !nc_valid_port(field->port)) {
            return ""has an invalid port in \""hostname:port\"" format string"";
        }
    }

    status = string_copy(&field->name, name, namelen);
    if (status != NC_OK) {
        return CONF_ERROR;
    }

    status = nc_resolve(&field->name, field->port, &field->info);
    if (status != NC_OK) {
        return CONF_ERROR;
    }

    field->valid = 1;

    return CONF_OK;
}

const char *
conf_add_server(struct conf *cf, const struct command *cmd, void *conf)
{
    rstatus_t status;
    struct array *a;
    struct string *value;
    struct conf_server *field;
    uint8_t *p, *q, *start;
    uint8_t *pname, *addr, *port, *weight, *name;
    uint32_t k, delimlen, pnamelen, addrlen, portlen, weightlen, namelen;
    const char *const delim = "" ::"";

    p = conf;
    a = (struct array *)(p + cmd->offset);

    field = array_push(a);
    if (field == NULL) {
        return CONF_ERROR;
    }

    conf_server_init(field);

    value = array_top(&cf->arg);

    /* parse ""hostname:port:weight [name]"" or ""/path/unix_socket:weight [name]"" from the end */
    p = value->data + value->len - 1;
    start = value->data;
    addr = NULL;
    addrlen = 0;
    weight = NULL;
    weightlen = 0;
    port = NULL;
    portlen = 0;
    name = NULL;
    namelen = 0;

    delimlen = value->data[0] == '/' ? 2 : 3;

    for (k = 0; k < sizeof(delim); k++) {
        q = nc_strrchr(p, start, delim[k]);
        if (q == NULL) {
            if (k == 0) {
                /*
                 * name in ""hostname:port:weight [name]"" format string is
                 * optional
                 */
                continue;
            }
            break;
        }

        switch (k) {
        case 0:
            name = q + 1;
            namelen = (uint32_t)(p - name + 1);
            break;

        case 1:
            weight = q + 1;
            weightlen = (uint32_t)(p - weight + 1);
            break;

        case 2:
            port = q + 1;
            portlen = (uint32_t)(p - port + 1);
            break;

        default:
            NOT_REACHED();
        }

        p = q - 1;
    }

    if (k != delimlen) {
        return ""has an invalid \""hostname:port:weight [name]\""or \""/path/unix_socket:weight [name]\"" format string"";
    }

    pname = value->data;
    pnamelen = namelen > 0 ? value->len - (namelen + 1) : value->len;
    status = string_copy(&field->pname, pname, pnamelen);
    if (status != NC_OK) {
        array_pop(a);
        return CONF_ERROR;
    }

    addr = start;
    addrlen = (uint32_t)(p - start + 1);

    field->weight = nc_atoi(weight, weightlen);
    if (field->weight < 0) {
        return ""has an invalid weight in \""hostname:port:weight [name]\"" format string"";
    } else if (field->weight == 0) {
        return ""has a zero weight in \""hostname:port:weight [name]\"" format string"";
    }

    if (value->data[0] != '/') {
        field->port = nc_atoi(port, portlen);
        if (field->port < 0 || !nc_valid_port(field->port)) {
            return ""has an invalid port in \""hostname:port:weight [name]\"" format string"";
        }
    }

    if (name == NULL) {
        /*
         * To maintain backward compatibility with libmemcached, we don't
         * include the port as the part of the input string to the consistent
         * hashing algorithm, when it is equal to 11211.
         */
        if (field->port == CONF_DEFAULT_KETAMA_PORT) {
            name = addr;
            namelen = addrlen;
        } else {
            name = addr;
            namelen = addrlen + 1 + portlen;
        }
    }

    status = string_copy(&field->name, name, namelen);
    if (status != NC_OK) {
        return CONF_ERROR;
    }

    status = string_copy(&field->addrstr, addr, addrlen);
    if (status != NC_OK) {
        return CONF_ERROR;
    }

    /*
     * The address resolution of the backend server hostname is lazy.
     * The resolution occurs when a new connection to the server is
     * created, which could either be the first time or every time
     * the server gets re-added to the pool after an auto ejection
     */

    field->valid = 1;

    return CONF_OK;
}

const char *
conf_set_num(struct conf *cf, const struct command *cmd, void *conf)
{
    uint8_t *p;
    int num, *np;
    const struct string *value;

    p = conf;
    np = (int *)(p + cmd->offset);

    if (*np != CONF_UNSET_NUM) {
        return ""is a duplicate"";
    }

    value = array_top(&cf->arg);

    num = nc_atoi(value->data, value->len);
    if (num < 0) {
        return ""is not a number"";
    }

    *np = num;

    return CONF_OK;
}

const char *
conf_set_bool(struct conf *cf, const struct command *cmd, void *conf)
{
    uint8_t *p;
    int *bp;
    const struct string *value;

    p = conf;
    bp = (int *)(p + cmd->offset);

    if (*bp != CONF_UNSET_NUM) {
        return ""is a duplicate"";
    }

    value = array_top(&cf->arg);

    if (string_compare(value, &true_str) == 0) {
        *bp = 1;
    } else if (string_compare(value, &false_str) == 0) {
        *bp = 0;
    } else {
        return ""is not \""true\"" or \""false\"""";
    }

    return CONF_OK;
}

const char *
conf_set_hash(struct conf *cf, const struct command *cmd, void *conf)
{
    uint8_t *p;
    hash_type_t *hp;
    const struct string *value, *hash;

    p = conf;
    hp = (hash_type_t *)(p + cmd->offset);

    if (*hp != CONF_UNSET_HASH) {
        return ""is a duplicate"";
    }

    value = array_top(&cf->arg);

    for (hash = hash_strings; hash->len != 0; hash++) {
        if (string_compare(value, hash) != 0) {
            continue;
        }

        *hp = (hash_type_t)(hash - hash_strings);

        return CONF_OK;
    }

    return ""is not a valid hash"";
}

const char *
conf_set_distribution(struct conf *cf, const struct command *cmd, void *conf)
{
    uint8_t *p;
    dist_type_t *dp;
    const struct string *value, *dist;

    p = conf;
    dp = (dist_type_t *)(p + cmd->offset);

    if (*dp != CONF_UNSET_DIST) {
        return ""is a duplicate"";
    }

    value = array_top(&cf->arg);

    for (dist = dist_strings; dist->len != 0; dist++) {
        if (string_compare(value, dist) != 0) {
            continue;
        }

        *dp = (dist_type_t)(dist - dist_strings);

        return CONF_OK;
    }

    return ""is not a valid distribution"";
}

const char *
conf_set_hashtag(struct conf *cf, const struct command *cmd, void *conf)
{
    rstatus_t status;
    uint8_t *p;
    struct string *field;
    const struct string *value;

    p = conf;
    field = (struct string *)(p + cmd->offset);

    if (field->data != CONF_UNSET_PTR) {
        return ""is a duplicate"";
    }

    value = array_top(&cf->arg);

    if (value->len != 2) {
        return ""is not a valid hash tag string with two characters"";
    }

    status = string_duplicate(field, value);
    if (status != NC_OK) {
        return CONF_ERROR;
    }

    return CONF_OK;
}
"
./repos/twemproxy/src/nc_client.c,https://github.com/twitter/twemproxy,"/*
 * twemproxy - A fast and lightweight proxy for memcached protocol.
 * Copyright (C) 2011 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <nc_core.h>
#include <nc_server.h>
#include <nc_client.h>

void
client_ref(struct conn *conn, void *owner)
{
    struct server_pool *pool = owner;

    ASSERT(conn->client && !conn->proxy);
    ASSERT(conn->owner == NULL);

    /*
     * We use null pointer as the sockaddr argument in the accept() call as
     * we are not interested in the address of the peer for the accepted
     * connection
     */
    conn->family = 0;
    conn->addrlen = 0;
    conn->addr = NULL;

    pool->nc_conn_q++;
    TAILQ_INSERT_TAIL(&pool->c_conn_q, conn, conn_tqe);

    /* owner of the client connection is the server pool */
    conn->owner = owner;

    log_debug(LOG_VVERB, ""ref conn %p owner %p into pool '%.*s'"", conn, pool,
              pool->name.len, pool->name.data);
}

void
client_unref(struct conn *conn)
{
    struct server_pool *pool;

    ASSERT(conn->client && !conn->proxy);
    ASSERT(conn->owner != NULL);

    pool = conn->owner;
    conn->owner = NULL;

    ASSERT(pool->nc_conn_q != 0);
    pool->nc_conn_q--;
    TAILQ_REMOVE(&pool->c_conn_q, conn, conn_tqe);

    log_debug(LOG_VVERB, ""unref conn %p owner %p from pool '%.*s'"", conn,
              pool, pool->name.len, pool->name.data);
}

bool
client_active(const struct conn *conn)
{
    ASSERT(conn->client && !conn->proxy);

    ASSERT(TAILQ_EMPTY(&conn->imsg_q));

    if (!TAILQ_EMPTY(&conn->omsg_q)) {
        log_debug(LOG_VVERB, ""c %d is active"", conn->sd);
        return true;
    }

    if (conn->rmsg != NULL) {
        log_debug(LOG_VVERB, ""c %d is active"", conn->sd);
        return true;
    }

    if (conn->smsg != NULL) {
        log_debug(LOG_VVERB, ""c %d is active"", conn->sd);
        return true;
    }

    log_debug(LOG_VVERB, ""c %d is inactive"", conn->sd);

    return false;
}

static void
client_close_stats(struct context *ctx, struct server_pool *pool, err_t err,
                   unsigned eof)
{
    stats_pool_decr(ctx, pool, client_connections);

    if (eof) {
        stats_pool_incr(ctx, pool, client_eof);
        return;
    }

    switch (err) {
    case EPIPE:
    case ETIMEDOUT:
    case ECONNRESET:
    case ECONNABORTED:
    case ENOTCONN:
    case ENETDOWN:
    case ENETUNREACH:
    case EHOSTDOWN:
    case EHOSTUNREACH:
    default:
        stats_pool_incr(ctx, pool, client_err);
        break;
    }
}

void
client_close(struct context *ctx, struct conn *conn)
{
    rstatus_t status;
    struct msg *msg, *nmsg; /* current and next message */

    ASSERT(conn->client && !conn->proxy);

    client_close_stats(ctx, conn->owner, conn->err, conn->eof);

    if (conn->sd < 0) {
        conn->unref(conn);
        conn_put(conn);
        return;
    }

    msg = conn->rmsg;
    if (msg != NULL) {
        conn->rmsg = NULL;

        ASSERT(msg->peer == NULL);
        ASSERT(msg->request && !msg->done);

        log_debug(LOG_INFO, ""close c %d discarding pending req %""PRIu64"" len ""
                  ""%""PRIu32"" type %d"", conn->sd, msg->id, msg->mlen,
                  msg->type);

        req_put(msg);
    }

    ASSERT(conn->smsg == NULL);
    ASSERT(TAILQ_EMPTY(&conn->imsg_q));

    for (msg = TAILQ_FIRST(&conn->omsg_q); msg != NULL; msg = nmsg) {
        nmsg = TAILQ_NEXT(msg, c_tqe);

        /* dequeue the message (request) from client outq */
        conn->dequeue_outq(ctx, conn, msg);

        if (msg->done) {
            log_debug(LOG_INFO, ""close c %d discarding %s req %""PRIu64"" len ""
                      ""%""PRIu32"" type %d"", conn->sd,
                      msg->error ? ""error"": ""completed"", msg->id, msg->mlen,
                      msg->type);
            req_put(msg);
        } else {
            msg->swallow = 1;

            ASSERT(msg->request);
            ASSERT(msg->peer == NULL);

            log_debug(LOG_INFO, ""close c %d schedule swallow of req %""PRIu64"" ""
                      ""len %""PRIu32"" type %d"", conn->sd, msg->id, msg->mlen,
                      msg->type);
        }
    }
    ASSERT(TAILQ_EMPTY(&conn->omsg_q));

    conn->unref(conn);

    status = close(conn->sd);
    if (status < 0) {
        log_error(""close c %d failed, ignored: %s"", conn->sd, strerror(errno));
    }
    conn->sd = -1;

    conn_put(conn);
}
"
./repos/twemproxy/src/nc_connection.c,https://github.com/twitter/twemproxy,"/*
 * twemproxy - A fast and lightweight proxy for memcached protocol.
 * Copyright (C) 2011 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <sys/uio.h>

#include <nc_core.h>
#include <nc_server.h>
#include <nc_client.h>
#include <nc_proxy.h>
#include <proto/nc_proto.h>

/*
 *                   nc_connection.[ch]
 *                Connection (struct conn)
 *                 +         +          +
 *                 |         |          |
 *                 |       Proxy        |
 *                 |     nc_proxy.[ch]  |
 *                 /                    \
 *              Client                Server
 *           nc_client.[ch]         nc_server.[ch]
 *
 * Nutcracker essentially multiplexes m client connections over n server
 * connections. Usually m >> n, so that nutcracker can pipeline requests
 * from several clients over a server connection and hence use the connection
 * bandwidth to the server efficiently
 *
 * Client and server connection maintain two fifo queues for requests:
 *
 * 1). in_q (imsg_q):  queue of incoming requests
 * 2). out_q (omsg_q): queue of outstanding (outgoing) requests
 *
 * Request received over the client connection are forwarded to the server by
 * enqueuing the request in the chosen server's in_q. From the client's
 * perspective once the request is forwarded, it is outstanding and is tracked
 * in the client's out_q (unless the request was tagged as noreply). The server
 * in turn picks up requests from its own in_q in fifo order and puts them on
 * the wire. Once the request is outstanding on the wire, and a response is
 * expected for it, the server keeps track of outstanding requests it in its
 * own out_q.
 *
 * The server's out_q enables us to pair a request with a response while the
 * client's out_q enables us to pair request and response in the order in
 * which they are received from the client.
 *
 *
 *      Clients                             Servers
 *                                    .
 *    in_q: <empty>                   .
 *    out_q: req11 -> req12           .   in_q:  req22
 *    (client1)                       .   out_q: req11 -> req21 -> req12
 *                                    .   (server1)
 *    in_q: <empty>                   .
 *    out_q: req21 -> req22 -> req23  .
 *    (client2)                       .
 *                                    .   in_q:  req23
 *                                    .   out_q: <empty>
 *                                    .   (server2)
 *
 * In the above example, client1 has two pipelined requests req11 and req12
 * both of which are outstanding on the server connection server1. On the
 * other hand, client2 has three requests req21, req22 and req23, of which
 * only req21 is outstanding on the server connection while req22 and
 * req23 are still waiting to be put on the wire. The fifo of client's
 * out_q ensures that we always send back the response of request at the head
 * of the queue, before sending out responses of other completed requests in
 * the queue.
 */

static uint32_t nfree_connq;       /* # free conn q */
static struct conn_tqh free_connq; /* free conn q */
static uint64_t ntotal_conn;       /* total # connections counter from start */
static uint32_t ncurr_conn;        /* current # connections */
static uint32_t ncurr_cconn;       /* current # client connections */

/*
 * Return the context associated with this connection.
 */
struct context *
conn_to_ctx(const struct conn *conn)
{
    struct server_pool *pool;

    if (conn->proxy || conn->client) {
        pool = conn->owner;
    } else {
        struct server *server = conn->owner;
        pool = server->owner;
    }

    return pool->ctx;
}

static struct conn *
_conn_get(void)
{
    struct conn *conn;

    if (!TAILQ_EMPTY(&free_connq)) {
        ASSERT(nfree_connq > 0);

        conn = TAILQ_FIRST(&free_connq);
        nfree_connq--;
        TAILQ_REMOVE(&free_connq, conn, conn_tqe);
    } else {
        conn = nc_alloc(sizeof(*conn));
        if (conn == NULL) {
            return NULL;
        }
    }

    conn->owner = NULL;

    conn->sd = -1;
    /* {family, addrlen, addr} are initialized in enqueue handler */

    TAILQ_INIT(&conn->imsg_q);
    TAILQ_INIT(&conn->omsg_q);
    conn->rmsg = NULL;
    conn->smsg = NULL;

    /*
     * Callbacks {recv, recv_next, recv_done}, {send, send_next, send_done},
     * {close, active}, parse, {ref, unref}, {enqueue_inq, dequeue_inq} and
     * {enqueue_outq, dequeue_outq} are initialized by the wrapper.
     */

    conn->send_bytes = 0;
    conn->recv_bytes = 0;

    conn->events = 0;
    conn->err = 0;
    conn->recv_active = 0;
    conn->recv_ready = 0;
    conn->send_active = 0;
    conn->send_ready = 0;

    conn->client = 0;
    conn->proxy = 0;
    conn->connecting = 0;
    conn->connected = 0;
    conn->eof = 0;
    conn->done = 0;
    conn->redis = 0;
    conn->authenticated = 0;

    ntotal_conn++;
    ncurr_conn++;

    return conn;
}

struct conn *
conn_get(void *owner, bool client, bool redis)
{
    struct conn *conn;

    conn = _conn_get();
    if (conn == NULL) {
        return NULL;
    }

    /* connection either handles redis or memcache messages */
    conn->redis = redis ? 1 : 0;

    conn->client = client ? 1 : 0;

    if (conn->client) {
        /*
         * client receives a request, possibly parsing it, and sends a
         * response downstream.
         */
        conn->recv = msg_recv;
        conn->recv_next = req_recv_next;
        conn->recv_done = req_recv_done;

        conn->send = msg_send;
        conn->send_next = rsp_send_next;
        conn->send_done = rsp_send_done;

        conn->close = client_close;
        conn->active = client_active;

        conn->ref = client_ref;
        conn->unref = client_unref;

        conn->enqueue_inq = NULL;
        conn->dequeue_inq = NULL;
        conn->enqueue_outq = req_client_enqueue_omsgq;
        conn->dequeue_outq = req_client_dequeue_omsgq;
        conn->post_connect = NULL;
        conn->swallow_msg = NULL;

        ncurr_cconn++;
    } else {
        /*
         * server receives a response, possibly parsing it, and sends a
         * request upstream.
         */
        conn->recv = msg_recv;
        conn->recv_next = rsp_recv_next;
        conn->recv_done = rsp_recv_done;

        conn->send = msg_send;
        conn->send_next = req_send_next;
        conn->send_done = req_send_done;

        conn->close = server_close;
        conn->active = server_active;

        conn->ref = server_ref;
        conn->unref = server_unref;

        conn->enqueue_inq = req_server_enqueue_imsgq;
        conn->dequeue_inq = req_server_dequeue_imsgq;
        conn->enqueue_outq = req_server_enqueue_omsgq;
        conn->dequeue_outq = req_server_dequeue_omsgq;
        if (redis) {
          conn->post_connect = redis_post_connect;
          conn->swallow_msg = redis_swallow_msg;
        } else {
          conn->post_connect = memcache_post_connect;
          conn->swallow_msg = memcache_swallow_msg;
        }
    }

    conn->ref(conn, owner);
    log_debug(LOG_VVERB, ""get conn %p client %d"", conn, conn->client);

    return conn;
}

struct conn *
conn_get_proxy(struct server_pool *pool)
{
    struct conn *conn;

    conn = _conn_get();
    if (conn == NULL) {
        return NULL;
    }

    conn->redis = pool->redis;

    conn->proxy = 1;

    conn->recv = proxy_recv;
    conn->recv_next = NULL;
    conn->recv_done = NULL;

    conn->send = NULL;
    conn->send_next = NULL;
    conn->send_done = NULL;

    conn->close = proxy_close;
    conn->active = NULL;

    conn->ref = proxy_ref;
    conn->unref = proxy_unref;

    conn->enqueue_inq = NULL;
    conn->dequeue_inq = NULL;
    conn->enqueue_outq = NULL;
    conn->dequeue_outq = NULL;

    conn->ref(conn, pool);

    log_debug(LOG_VVERB, ""get conn %p proxy %d"", conn, conn->proxy);

    return conn;
}

static void
conn_free(struct conn *conn)
{
    log_debug(LOG_VVERB, ""free conn %p"", conn);
    nc_free(conn);
}

void
conn_put(struct conn *conn)
{
    ASSERT(conn->sd < 0);
    ASSERT(conn->owner == NULL);

    log_debug(LOG_VVERB, ""put conn %p"", conn);

    nfree_connq++;
    TAILQ_INSERT_HEAD(&free_connq, conn, conn_tqe);

    if (conn->client) {
        ncurr_cconn--;
    }
    ncurr_conn--;
}

void
conn_init(void)
{
    log_debug(LOG_DEBUG, ""conn size %d"", (int)sizeof(struct conn));
    nfree_connq = 0;
    TAILQ_INIT(&free_connq);
}

void
conn_deinit(void)
{
    struct conn *conn, *nconn; /* current and next connection */

    for (conn = TAILQ_FIRST(&free_connq); conn != NULL;
         conn = nconn, nfree_connq--) {
        ASSERT(nfree_connq > 0);
        nconn = TAILQ_NEXT(conn, conn_tqe);
        conn_free(conn);
    }
    ASSERT(nfree_connq == 0);
}

ssize_t
conn_recv(struct conn *conn, void *buf, size_t size)
{
    ssize_t n;

    ASSERT(buf != NULL);
    ASSERT(size > 0);
    ASSERT(conn->recv_ready);

    for (;;) {
        n = nc_read(conn->sd, buf, size);

        log_debug(LOG_VERB, ""recv on sd %d %zd of %zu"", conn->sd, n, size);

        if (n > 0) {
            if (n < (ssize_t) size) {
                conn->recv_ready = 0;
            }
            conn->recv_bytes += (size_t)n;
            return n;
        }

        if (n == 0) {
            conn->recv_ready = 0;
            conn->eof = 1;
            log_debug(LOG_INFO, ""recv on sd %d eof rb %zu sb %zu"", conn->sd,
                      conn->recv_bytes, conn->send_bytes);
            return n;
        }

        if (errno == EINTR) {
            log_debug(LOG_VERB, ""recv on sd %d not ready - eintr"", conn->sd);
            continue;
        } else if (errno == EAGAIN || errno == EWOULDBLOCK) {
            conn->recv_ready = 0;
            log_debug(LOG_VERB, ""recv on sd %d not ready - eagain"", conn->sd);
            return NC_EAGAIN;
        } else {
            conn->recv_ready = 0;
            conn->err = errno;
            log_error(""recv on sd %d failed: %s"", conn->sd, strerror(errno));
            return NC_ERROR;
        }
    }

    NOT_REACHED();

    return NC_ERROR;
}

ssize_t
conn_sendv(struct conn *conn, const struct array *sendv, size_t nsend)
{
    ssize_t n;

    ASSERT(array_n(sendv) > 0);
    ASSERT(nsend != 0);
    ASSERT(conn->send_ready);

    for (;;) {
        n = nc_writev(conn->sd, sendv->elem, sendv->nelem);

        log_debug(LOG_VERB, ""sendv on sd %d %zd of %zu in %""PRIu32"" buffers"",
                  conn->sd, n, nsend, sendv->nelem);

        if (n > 0) {
            if (n < (ssize_t) nsend) {
                conn->send_ready = 0;
            }
            conn->send_bytes += (size_t)n;
            return n;
        }

        if (n == 0) {
            log_warn(""sendv on sd %d returned zero"", conn->sd);
            conn->send_ready = 0;
            return 0;
        }

        if (errno == EINTR) {
            log_debug(LOG_VERB, ""sendv on sd %d not ready - eintr"", conn->sd);
            continue;
        } else if (errno == EAGAIN || errno == EWOULDBLOCK) {
            conn->send_ready = 0;
            log_debug(LOG_VERB, ""sendv on sd %d not ready - eagain"", conn->sd);
            return NC_EAGAIN;
        } else {
            conn->send_ready = 0;
            conn->err = errno;
            log_error(""sendv on sd %d failed: %s"", conn->sd, strerror(errno));
            return NC_ERROR;
        }
    }

    NOT_REACHED();

    return NC_ERROR;
}

uint32_t
conn_ncurr_conn(void)
{
    return ncurr_conn;
}

uint64_t
conn_ntotal_conn(void)
{
    return ntotal_conn;
}

uint32_t
conn_ncurr_cconn(void)
{
    return ncurr_cconn;
}

/*
 * Returns true if the connection is authenticated or doesn't require
 * authentication, otherwise return false
 */
bool
conn_authenticated(const struct conn *conn)
{
    struct server_pool *pool;

    ASSERT(!conn->proxy);

    pool = conn->client ? conn->owner : ((struct server *)conn->owner)->owner;

    if (!pool->require_auth) {
        return true;
    }

    if (!conn->authenticated) {
        return false;
    }

    return true;
}
"
./repos/twemproxy/src/nc_core.c,https://github.com/twitter/twemproxy,"/*
 * twemproxy - A fast and lightweight proxy for memcached protocol.
 * Copyright (C) 2011 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stdlib.h>
#include <unistd.h>
#include <nc_core.h>
#include <nc_conf.h>
#include <nc_server.h>
#include <nc_proxy.h>

static uint32_t ctx_id; /* context generation */

static rstatus_t
core_calc_connections(struct context *ctx)
{
    int status;
    struct rlimit limit;

    status = getrlimit(RLIMIT_NOFILE, &limit);
    if (status < 0) {
        log_error(""getrlimit failed: %s"", strerror(errno));
        return NC_ERROR;
    }

    ctx->max_nfd = (uint32_t)limit.rlim_cur;
    ctx->max_ncconn = ctx->max_nfd - ctx->max_nsconn - RESERVED_FDS;
    log_debug(LOG_NOTICE, ""max fds %""PRIu32"" max client conns %""PRIu32"" ""
              ""max server conns %""PRIu32"""", ctx->max_nfd, ctx->max_ncconn,
              ctx->max_nsconn);

    return NC_OK;
}

static struct context *
core_ctx_create(struct instance *nci)
{
    rstatus_t status;
    struct context *ctx;

    ctx = nc_alloc(sizeof(*ctx));
    if (ctx == NULL) {
        return NULL;
    }
    ctx->id = ++ctx_id;
    ctx->cf = NULL;
    ctx->stats = NULL;
    ctx->evb = NULL;
    array_null(&ctx->pool);
    ctx->max_timeout = nci->stats_interval;
    ctx->timeout = ctx->max_timeout;
    ctx->max_nfd = 0;
    ctx->max_ncconn = 0;
    ctx->max_nsconn = 0;

    /* parse and create configuration */
    ctx->cf = conf_create(nci->conf_filename);
    if (ctx->cf == NULL) {
        nc_free(ctx);
        return NULL;
    }

    /* initialize server pool from configuration */
    status = server_pool_init(&ctx->pool, &ctx->cf->pool, ctx);
    if (status != NC_OK) {
        conf_destroy(ctx->cf);
        nc_free(ctx);
        return NULL;
    }

    /*
     * Get rlimit and calculate max client connections after we have
     * calculated max server connections
     */
    status = core_calc_connections(ctx);
    if (status != NC_OK) {
        server_pool_deinit(&ctx->pool);
        conf_destroy(ctx->cf);
        nc_free(ctx);
        return NULL;
    }

    /* create stats per server pool */
    ctx->stats = stats_create(nci->stats_port, nci->stats_addr, nci->stats_interval,
                              nci->hostname, &ctx->pool);
    if (ctx->stats == NULL) {
        server_pool_deinit(&ctx->pool);
        conf_destroy(ctx->cf);
        nc_free(ctx);
        return NULL;
    }

    /* initialize event handling for client, proxy and server */
    ctx->evb = event_base_create(EVENT_SIZE, &core_core);
    if (ctx->evb == NULL) {
        stats_destroy(ctx->stats);
        server_pool_deinit(&ctx->pool);
        conf_destroy(ctx->cf);
        nc_free(ctx);
        return NULL;
    }

    /* preconnect? servers in server pool */
    status = server_pool_preconnect(ctx);
    if (status != NC_OK) {
        server_pool_disconnect(ctx);
        event_base_destroy(ctx->evb);
        stats_destroy(ctx->stats);
        server_pool_deinit(&ctx->pool);
        conf_destroy(ctx->cf);
        nc_free(ctx);
        return NULL;
    }

    /* initialize proxy per server pool */
    status = proxy_init(ctx);
    if (status != NC_OK) {
        server_pool_disconnect(ctx);
        event_base_destroy(ctx->evb);
        stats_destroy(ctx->stats);
        server_pool_deinit(&ctx->pool);
        conf_destroy(ctx->cf);
        nc_free(ctx);
        return NULL;
    }

    log_debug(LOG_VVERB, ""created ctx %p id %""PRIu32"""", ctx, ctx->id);

    return ctx;
}

static void
core_ctx_destroy(struct context *ctx)
{
    log_debug(LOG_VVERB, ""destroy ctx %p id %""PRIu32"""", ctx, ctx->id);
    proxy_deinit(ctx);
    server_pool_disconnect(ctx);
    event_base_destroy(ctx->evb);
    stats_destroy(ctx->stats);
    server_pool_deinit(&ctx->pool);
    conf_destroy(ctx->cf);
    nc_free(ctx);
}

struct context *
core_start(struct instance *nci)
{
    struct context *ctx;

    mbuf_init(nci);
    msg_init();
    conn_init();

    ctx = core_ctx_create(nci);
    if (ctx != NULL) {
        nci->ctx = ctx;
        return ctx;
    }

    conn_deinit();
    msg_deinit();
    mbuf_deinit();

    return NULL;
}

void
core_stop(struct context *ctx)
{
    conn_deinit();
    msg_deinit();
    mbuf_deinit();
    core_ctx_destroy(ctx);
}

static rstatus_t
core_recv(struct context *ctx, struct conn *conn)
{
    rstatus_t status;

    status = conn->recv(ctx, conn);
    if (status != NC_OK) {
        log_debug(LOG_INFO, ""recv on %c %d failed: %s"",
                  conn->client ? 'c' : (conn->proxy ? 'p' : 's'), conn->sd,
                  strerror(errno));
    }

    return status;
}

static rstatus_t
core_send(struct context *ctx, struct conn *conn)
{
    rstatus_t status;

    status = conn->send(ctx, conn);
    if (status != NC_OK) {
        log_debug(LOG_INFO, ""send on %c %d failed: status: %d errno: %d %s"",
                  conn->client ? 'c' : (conn->proxy ? 'p' : 's'), conn->sd,
                  status, errno, strerror(errno));
    }

    return status;
}

static void
core_close(struct context *ctx, struct conn *conn)
{
    rstatus_t status;
    char type;
    const char *addrstr;

    ASSERT(conn->sd > 0);

    if (conn->client) {
        type = 'c';
        addrstr = nc_unresolve_peer_desc(conn->sd);
    } else {
        type = conn->proxy ? 'p' : 's';
        addrstr = nc_unresolve_addr(conn->addr, conn->addrlen);
    }
    log_debug(LOG_NOTICE, ""close %c %d '%s' on event %04""PRIX32"" eof %d done ""
              ""%d rb %zu sb %zu%c %s"", type, conn->sd, addrstr, conn->events,
              conn->eof, conn->done, conn->recv_bytes, conn->send_bytes,
              conn->err ? ':' : ' ', conn->err ? strerror(conn->err) : """");

    status = event_del_conn(ctx->evb, conn);
    if (status < 0) {
        log_warn(""event del conn %c %d failed, ignored: %s"",
                 type, conn->sd, strerror(errno));
    }

    conn->close(ctx, conn);
}

static void
core_error(struct context *ctx, struct conn *conn)
{
    rstatus_t status;
    char type = conn->client ? 'c' : (conn->proxy ? 'p' : 's');

    status = nc_get_soerror(conn->sd);
    if (status < 0) {
        log_warn(""get soerr on %c %d failed, ignored: %s"", type, conn->sd,
                  strerror(errno));
    }
    conn->err = errno;

    core_close(ctx, conn);
}

static void
core_timeout(struct context *ctx)
{
    for (;;) {
        struct msg *msg;
        struct conn *conn;
        int64_t now, then;

        msg = msg_tmo_min();
        if (msg == NULL) {
            ctx->timeout = ctx->max_timeout;
            return;
        }

        /* skip over req that are in-error or done */

        if (msg->error || msg->done) {
            msg_tmo_delete(msg);
            continue;
        }

        /*
         * timeout expired req and all the outstanding req on the timing
         * out server
         */

        conn = msg->tmo_rbe.data;
        then = msg->tmo_rbe.key;

        now = nc_msec_now();
        if (now < then) {
            int delta = (int)(then - now);
            ctx->timeout = MIN(delta, ctx->max_timeout);
            return;
        }

        log_debug(LOG_INFO, ""req %""PRIu64"" on s %d timedout"", msg->id, conn->sd);

        msg_tmo_delete(msg);
        conn->err = ETIMEDOUT;

        core_close(ctx, conn);
    }
}

rstatus_t
core_core(void *arg, uint32_t events)
{
    rstatus_t status;
    struct conn *conn = arg;
    struct context *ctx;

    if (conn->owner == NULL) {
        log_warn(""conn is already unrefed!"");
        return NC_OK;
    }

    ctx = conn_to_ctx(conn);

    log_debug(LOG_VVERB, ""event %04""PRIX32"" on %c %d"", events,
              conn->client ? 'c' : (conn->proxy ? 'p' : 's'), conn->sd);

    conn->events = events;

    /* error takes precedence over read | write */
    if (events & EVENT_ERR) {
        core_error(ctx, conn);
        return NC_ERROR;
    }

    /* read takes precedence over write */
    if (events & EVENT_READ) {
        status = core_recv(ctx, conn);
        if (status != NC_OK || conn->done || conn->err) {
            core_close(ctx, conn);
            return NC_ERROR;
        }
    }

    if (events & EVENT_WRITE) {
        status = core_send(ctx, conn);
        if (status != NC_OK || conn->done || conn->err) {
            core_close(ctx, conn);
            return NC_ERROR;
        }
    }

    return NC_OK;
}

rstatus_t
core_loop(struct context *ctx)
{
    int nsd;

    nsd = event_wait(ctx->evb, ctx->timeout);
    if (nsd < 0) {
        return nsd;
    }

    core_timeout(ctx);

    stats_swap(ctx->stats);

    return NC_OK;
}
"
./repos/vim/src/arglist.c,https://github.com/vim/vim,"/* vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *
 * Do "":help uganda""  in Vim to read copying and usage conditions.
 * Do "":help credits"" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 */

/*
 * arglist.c: functions for dealing with the argument list
 */

#include ""vim.h""

#define AL_SET	1
#define AL_ADD	2
#define AL_DEL	3

// This flag is set whenever the argument list is being changed and calling a
// function that might trigger an autocommand.
static int arglist_locked = FALSE;

    static int
check_arglist_locked(void)
{
    if (arglist_locked)
    {
	emsg(_(e_cannot_change_arglist_recursively));
	return FAIL;
    }
    return OK;
}

/*
 * Clear an argument list: free all file names and reset it to zero entries.
 */
    void
alist_clear(alist_T *al)
{
    if (check_arglist_locked() == FAIL)
	return;
    while (--al->al_ga.ga_len >= 0)
	vim_free(AARGLIST(al)[al->al_ga.ga_len].ae_fname);
    ga_clear(&al->al_ga);
}

/*
 * Init an argument list.
 */
    void
alist_init(alist_T *al)
{
    ga_init2(&al->al_ga, sizeof(aentry_T), 5);
}

/*
 * Remove a reference from an argument list.
 * Ignored when the argument list is the global one.
 * If the argument list is no longer used by any window, free it.
 */
    void
alist_unlink(alist_T *al)
{
    if (al != &global_alist && --al->al_refcount <= 0)
    {
	alist_clear(al);
	vim_free(al);
    }
}

/*
 * Create a new argument list and use it for the current window.
 */
    void
alist_new(void)
{
    curwin->w_alist = ALLOC_ONE(alist_T);
    if (curwin->w_alist == NULL)
    {
	curwin->w_alist = &global_alist;
	++global_alist.al_refcount;
    }
    else
    {
	curwin->w_alist->al_refcount = 1;
	curwin->w_alist->id = ++max_alist_id;
	alist_init(curwin->w_alist);
    }
}

#if !defined(UNIX) || defined(PROTO)
/*
 * Expand the file names in the global argument list.
 * If ""fnum_list"" is not NULL, use ""fnum_list[fnum_len]"" as a list of buffer
 * numbers to be re-used.
 */
    void
alist_expand(int *fnum_list, int fnum_len)
{
    char_u	**old_arg_files;
    int		old_arg_count;
    char_u	**new_arg_files;
    int		new_arg_file_count;
    char_u	*save_p_su = p_su;
    int		i;

    old_arg_files = ALLOC_MULT(char_u *, GARGCOUNT);
    if (old_arg_files == NULL)
	return;

    // Don't use 'suffixes' here.  This should work like the shell did the
    // expansion.  Also, the vimrc file isn't read yet, thus the user
    // can't set the options.
    p_su = empty_option;
    for (i = 0; i < GARGCOUNT; ++i)
	old_arg_files[i] = vim_strsave(GARGLIST[i].ae_fname);
    old_arg_count = GARGCOUNT;
    if (expand_wildcards(old_arg_count, old_arg_files,
		&new_arg_file_count, &new_arg_files,
		EW_FILE|EW_NOTFOUND|EW_ADDSLASH|EW_NOERROR) == OK
	    && new_arg_file_count > 0)
    {
	alist_set(&global_alist, new_arg_file_count, new_arg_files,
		TRUE, fnum_list, fnum_len);
	FreeWild(old_arg_count, old_arg_files);
    }
    p_su = save_p_su;
}
#endif

/*
 * Set the argument list for the current window.
 * Takes over the allocated files[] and the allocated fnames in it.
 */
    void
alist_set(
    alist_T	*al,
    int		count,
    char_u	**files,
    int		use_curbuf,
    int		*fnum_list,
    int		fnum_len)
{
    int		i;

    if (check_arglist_locked() == FAIL)
	return;

    alist_clear(al);
    if (GA_GROW_OK(&al->al_ga, count))
    {
	for (i = 0; i < count; ++i)
	{
	    if (got_int)
	    {
		// When adding many buffers this can take a long time.  Allow
		// interrupting here.
		while (i < count)
		    vim_free(files[i++]);
		break;
	    }

	    // May set buffer name of a buffer previously used for the
	    // argument list, so that it's re-used by alist_add.
	    if (fnum_list != NULL && i < fnum_len)
	    {
		arglist_locked = TRUE;
		buf_set_name(fnum_list[i], files[i]);
		arglist_locked = FALSE;
	    }

	    alist_add(al, files[i], use_curbuf ? 2 : 1);
	    ui_breakcheck();
	}
	vim_free(files);
    }
    else
	FreeWild(count, files);
    if (al == &global_alist)
	arg_had_last = FALSE;
}

/*
 * Add file ""fname"" to argument list ""al"".
 * ""fname"" must have been allocated and ""al"" must have been checked for room.
 */
    void
alist_add(
    alist_T	*al,
    char_u	*fname,
    int		set_fnum)	// 1: set buffer number; 2: re-use curbuf
{
    if (fname == NULL)		// don't add NULL file names
	return;
    if (check_arglist_locked() == FAIL)
	return;
    arglist_locked = TRUE;

#ifdef BACKSLASH_IN_FILENAME
    slash_adjust(fname);
#endif
    AARGLIST(al)[al->al_ga.ga_len].ae_fname = fname;
    if (set_fnum > 0)
	AARGLIST(al)[al->al_ga.ga_len].ae_fnum =
	    buflist_add(fname, BLN_LISTED | (set_fnum == 2 ? BLN_CURBUF : 0));
    ++al->al_ga.ga_len;

    arglist_locked = FALSE;
}

#if defined(BACKSLASH_IN_FILENAME) || defined(PROTO)
/*
 * Adjust slashes in file names.  Called after 'shellslash' was set.
 */
    void
alist_slash_adjust(void)
{
    int		i;
    win_T	*wp;
    tabpage_T	*tp;

    for (i = 0; i < GARGCOUNT; ++i)
	if (GARGLIST[i].ae_fname != NULL)
	    slash_adjust(GARGLIST[i].ae_fname);
    FOR_ALL_TAB_WINDOWS(tp, wp)
	if (wp->w_alist != &global_alist)
	    for (i = 0; i < WARGCOUNT(wp); ++i)
		if (WARGLIST(wp)[i].ae_fname != NULL)
		    slash_adjust(WARGLIST(wp)[i].ae_fname);
}
#endif

/*
 * Isolate one argument, taking backticks.
 * Changes the argument in-place, puts a NUL after it.  Backticks remain.
 * Return a pointer to the start of the next argument.
 */
    static char_u *
do_one_arg(char_u *str)
{
    char_u	*p;
    int		inbacktick;

    inbacktick = FALSE;
    for (p = str; *str; ++str)
    {
	// When the backslash is used for escaping the special meaning of a
	// character we need to keep it until wildcard expansion.
	if (rem_backslash(str))
	{
	    *p++ = *str++;
	    *p++ = *str;
	}
	else
	{
	    // An item ends at a space not in backticks
	    if (!inbacktick && vim_isspace(*str))
		break;
	    if (*str == '`')
		inbacktick ^= TRUE;
	    *p++ = *str;
	}
    }
    str = skipwhite(str);
    *p = NUL;

    return str;
}

/*
 * Separate the arguments in ""str"" and return a list of pointers in the
 * growarray ""gap"".
 */
    static int
get_arglist(garray_T *gap, char_u *str, int escaped)
{
    ga_init2(gap, sizeof(char_u *), 20);
    while (*str != NUL)
    {
	if (ga_grow(gap, 1) == FAIL)
	{
	    ga_clear(gap);
	    return FAIL;
	}
	((char_u **)gap->ga_data)[gap->ga_len++] = str;

	// If str is escaped, don't handle backslashes or spaces
	if (!escaped)
	    return OK;

	// Isolate one argument, change it in-place, put a NUL after it.
	str = do_one_arg(str);
    }
    return OK;
}

#if defined(FEAT_QUICKFIX) || defined(FEAT_SYN_HL) || defined(FEAT_SPELL) || defined(PROTO)
/*
 * Parse a list of arguments (file names), expand them and return in
 * ""fnames[fcountp]"".  When ""wig"" is TRUE, removes files matching 'wildignore'.
 * Return FAIL or OK.
 */
    int
get_arglist_exp(
    char_u	*str,
    int		*fcountp,
    char_u	***fnamesp,
    int		wig)
{
    garray_T	ga;
    int		i;

    if (get_arglist(&ga, str, TRUE) == FAIL)
	return FAIL;
    if (wig == TRUE)
	i = expand_wildcards(ga.ga_len, (char_u **)ga.ga_data,
			     fcountp, fnamesp, EW_FILE|EW_NOTFOUND|EW_NOTWILD);
    else
	i = gen_expand_wildcards(ga.ga_len, (char_u **)ga.ga_data,
			     fcountp, fnamesp, EW_FILE|EW_NOTFOUND|EW_NOTWILD);

    ga_clear(&ga);
    return i;
}
#endif

/*
 * Check the validity of the arg_idx for each other window.
 */
    static void
alist_check_arg_idx(void)
{
    win_T	*win;
    tabpage_T	*tp;

    FOR_ALL_TAB_WINDOWS(tp, win)
	if (win->w_alist == curwin->w_alist)
	    check_arg_idx(win);
}

/*
 * Add files[count] to the arglist of the current window after arg ""after"".
 * The file names in files[count] must have been allocated and are taken over.
 * Files[] itself is not taken over.
 */
    static void
alist_add_list(
    int		count,
    char_u	**files,
    int		after,	    // where to add: 0 = before first one
    int		will_edit)  // will edit adding argument
{
    int		i;
    int		old_argcount = ARGCOUNT;

    if (check_arglist_locked() != FAIL
	    && GA_GROW_OK(&ALIST(curwin)->al_ga, count))
    {
	if (after < 0)
	    after = 0;
	if (after > ARGCOUNT)
	    after = ARGCOUNT;
	if (after < ARGCOUNT)
	    mch_memmove(&(ARGLIST[after + count]), &(ARGLIST[after]),
				       (ARGCOUNT - after) * sizeof(aentry_T));
	arglist_locked = TRUE;
	for (i = 0; i < count; ++i)
	{
	    int flags = BLN_LISTED | (will_edit ? BLN_CURBUF : 0);

	    ARGLIST[after + i].ae_fname = files[i];
	    ARGLIST[after + i].ae_fnum = buflist_add(files[i], flags);
	}
	arglist_locked = FALSE;
	ALIST(curwin)->al_ga.ga_len += count;
	if (old_argcount > 0 && curwin->w_arg_idx >= after)
	    curwin->w_arg_idx += count;
	return;
    }

    for (i = 0; i < count; ++i)
	vim_free(files[i]);
}

/*
 * Delete the file names in 'alist_ga' from the argument list.
 */
    static void
arglist_del_files(garray_T *alist_ga)
{
    regmatch_T	regmatch;
    int		didone;
    int		i;
    char_u	*p;
    int		match;

    // Delete the items: use each item as a regexp and find a match in the
    // argument list.
    regmatch.rm_ic = p_fic;	// ignore case when 'fileignorecase' is set
    for (i = 0; i < alist_ga->ga_len && !got_int; ++i)
    {
	p = ((char_u **)alist_ga->ga_data)[i];
	p = file_pat_to_reg_pat(p, NULL, NULL, FALSE);
	if (p == NULL)
	    break;
	regmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);
	if (regmatch.regprog == NULL)
	{
	    vim_free(p);
	    break;
	}

	didone = FALSE;
	for (match = 0; match < ARGCOUNT; ++match)
	    if (vim_regexec(&regmatch, alist_name(&ARGLIST[match]), (colnr_T)0))
	    {
		didone = TRUE;
		vim_free(ARGLIST[match].ae_fname);
		mch_memmove(ARGLIST + match, ARGLIST + match + 1,
			(ARGCOUNT - match - 1) * sizeof(aentry_T));
		--ALIST(curwin)->al_ga.ga_len;
		if (curwin->w_arg_idx > match)
		    --curwin->w_arg_idx;
		--match;
	    }

	vim_regfree(regmatch.regprog);
	vim_free(p);
	if (!didone)
	    semsg(_(e_no_match_str_2), ((char_u **)alist_ga->ga_data)[i]);
    }
    ga_clear(alist_ga);
}

/*
 * ""what"" == AL_SET: Redefine the argument list to 'str'.
 * ""what"" == AL_ADD: add files in 'str' to the argument list after ""after"".
 * ""what"" == AL_DEL: remove files in 'str' from the argument list.
 *
 * Return FAIL for failure, OK otherwise.
 */
    static int
do_arglist(
    char_u	*str,
    int		what,
    int		after UNUSED,	// 0 means before first one
    int		will_edit)	// will edit added argument
{
    garray_T	new_ga;
    int		exp_count;
    char_u	**exp_files;
    int		i;
    int		arg_escaped = TRUE;

    if (check_arglist_locked() == FAIL)
	return FAIL;

    // Set default argument for "":argadd"" command.
    if (what == AL_ADD && *str == NUL)
    {
	if (curbuf->b_ffname == NULL)
	    return FAIL;
	str = curbuf->b_fname;
	arg_escaped = FALSE;
    }

    // Collect all file name arguments in ""new_ga"".
    if (get_arglist(&new_ga, str, arg_escaped) == FAIL)
	return FAIL;

    if (what == AL_DEL)
	arglist_del_files(&new_ga);
    else
    {
	i = expand_wildcards(new_ga.ga_len, (char_u **)new_ga.ga_data,
		&exp_count, &exp_files, EW_DIR|EW_FILE|EW_ADDSLASH|EW_NOTFOUND);
	ga_clear(&new_ga);
	if (i == FAIL || exp_count == 0)
	{
	    emsg(_(e_no_match));
	    return FAIL;
	}

	if (what == AL_ADD)
	{
	    alist_add_list(exp_count, exp_files, after, will_edit);
	    vim_free(exp_files);
	}
	else // what == AL_SET
	    alist_set(ALIST(curwin), exp_count, exp_files, will_edit, NULL, 0);
    }

    alist_check_arg_idx();

    return OK;
}

/*
 * Redefine the argument list.
 */
    void
set_arglist(char_u *str)
{
    do_arglist(str, AL_SET, 0, TRUE);
}

/*
 * Return TRUE if window ""win"" is editing the file at the current argument
 * index.
 */
    int
editing_arg_idx(win_T *win)
{
    return !(win->w_arg_idx >= WARGCOUNT(win)
		|| (win->w_buffer->b_fnum
				      != WARGLIST(win)[win->w_arg_idx].ae_fnum
		    && (win->w_buffer->b_ffname == NULL
			 || !(fullpathcmp(
				 alist_name(&WARGLIST(win)[win->w_arg_idx]),
			  win->w_buffer->b_ffname, TRUE, TRUE) & FPC_SAME))));
}

/*
 * Check if window ""win"" is editing the w_arg_idx file in its argument list.
 */
    void
check_arg_idx(win_T *win)
{
    if (WARGCOUNT(win) > 1 && !editing_arg_idx(win))
    {
	// We are not editing the current entry in the argument list.
	// Set ""arg_had_last"" if we are editing the last one.
	win->w_arg_idx_invalid = TRUE;
	if (win->w_arg_idx != WARGCOUNT(win) - 1
		&& arg_had_last == FALSE
		&& ALIST(win) == &global_alist
		&& GARGCOUNT > 0
		&& win->w_arg_idx < GARGCOUNT
		&& (win->w_buffer->b_fnum == GARGLIST[GARGCOUNT - 1].ae_fnum
		    || (win->w_buffer->b_ffname != NULL
			&& (fullpathcmp(alist_name(&GARGLIST[GARGCOUNT - 1]),
			  win->w_buffer->b_ffname, TRUE, TRUE) & FPC_SAME))))
	    arg_had_last = TRUE;
    }
    else
    {
	// We are editing the current entry in the argument list.
	// Set ""arg_had_last"" if it's also the last one
	win->w_arg_idx_invalid = FALSE;
	if (win->w_arg_idx == WARGCOUNT(win) - 1
					      && win->w_alist == &global_alist)
	    arg_had_last = TRUE;
    }
}

/*
 * "":args"", "":argslocal"" and "":argsglobal"".
 */
    void
ex_args(exarg_T *eap)
{
    int		i;

    if (eap->cmdidx != CMD_args)
    {
	if (check_arglist_locked() == FAIL)
	    return;
	alist_unlink(ALIST(curwin));
	if (eap->cmdidx == CMD_argglobal)
	    ALIST(curwin) = &global_alist;
	else // eap->cmdidx == CMD_arglocal
	    alist_new();
    }

    // "":args file .."": define new argument list, handle like "":next""
    // Also for "":argslocal file .."" and "":argsglobal file .."".
    if (*eap->arg != NUL)
    {
	if (check_arglist_locked() == FAIL)
	    return;
	ex_next(eap);
	return;
    }

    // "":args"": list arguments.
    if (eap->cmdidx == CMD_args)
    {
	char_u **items;

	if (ARGCOUNT <= 0)
	    return;		// empty argument list

	items = ALLOC_MULT(char_u *, ARGCOUNT);
	if (items == NULL)
	    return;

	// Overwrite the command, for a short list there is no scrolling
	// required and no wait_return().
	gotocmdline(TRUE);

	for (i = 0; i < ARGCOUNT; ++i)
	    items[i] = alist_name(&ARGLIST[i]);
	list_in_columns(items, ARGCOUNT, curwin->w_arg_idx);
	vim_free(items);

	return;
    }

    // "":argslocal"": make a local copy of the global argument list.
    if (eap->cmdidx == CMD_arglocal)
    {
	garray_T	*gap = &curwin->w_alist->al_ga;

	if (GA_GROW_FAILS(gap, GARGCOUNT))
	    return;

	for (i = 0; i < GARGCOUNT; ++i)
	    if (GARGLIST[i].ae_fname != NULL)
	    {
		AARGLIST(curwin->w_alist)[gap->ga_len].ae_fname =
		    vim_strsave(GARGLIST[i].ae_fname);
		AARGLIST(curwin->w_alist)[gap->ga_len].ae_fnum =
		    GARGLIST[i].ae_fnum;
		++gap->ga_len;
	    }
    }
}

/*
 * "":previous"", "":sprevious"", "":Next"" and "":sNext"".
 */
    void
ex_previous(exarg_T *eap)
{
    // If past the last one already, go to the last one.
    if (curwin->w_arg_idx - (int)eap->line2 >= ARGCOUNT)
	do_argfile(eap, ARGCOUNT - 1);
    else
	do_argfile(eap, curwin->w_arg_idx - (int)eap->line2);
}

/*
 * "":rewind"", "":first"", "":sfirst"" and "":srewind"".
 */
    void
ex_rewind(exarg_T *eap)
{
    do_argfile(eap, 0);
}

/*
 * "":last"" and "":slast"".
 */
    void
ex_last(exarg_T *eap)
{
    do_argfile(eap, ARGCOUNT - 1);
}

/*
 * "":argument"" and "":sargument"".
 */
    void
ex_argument(exarg_T *eap)
{
    int		i;

    if (eap->addr_count > 0)
	i = eap->line2 - 1;
    else
	i = curwin->w_arg_idx;
    do_argfile(eap, i);
}

/*
 * Edit file ""argn"" of the argument lists.
 */
    void
do_argfile(exarg_T *eap, int argn)
{
    int		other;
    char_u	*p;
    int		old_arg_idx = curwin->w_arg_idx;
    int is_split_cmd = *eap->cmd == 's';

    if (ERROR_IF_ANY_POPUP_WINDOW)
	return;
    if (argn < 0 || argn >= ARGCOUNT)
    {
	if (ARGCOUNT <= 1)
	    emsg(_(e_there_is_only_one_file_to_edit));
	else if (argn < 0)
	    emsg(_(e_cannot_go_before_first_file));
	else
	    emsg(_(e_cannot_go_beyond_last_file));

	return;
    }

    if (!is_split_cmd
	    && (&ARGLIST[argn])->ae_fnum != curbuf->b_fnum
	    && !check_can_set_curbuf_forceit(eap->forceit))
	return;

    setpcmark();
#ifdef FEAT_GUI
    need_mouse_correct = TRUE;
#endif

    // split window or create new tab page first
    if (is_split_cmd || cmdmod.cmod_tab != 0)
    {
	if (win_split(0, 0) == FAIL)
	    return;
	RESET_BINDING(curwin);
    }
    else
    {
	// if 'hidden' set, only check for changed file when re-editing
	// the same buffer
	other = TRUE;
	if (buf_hide(curbuf))
	{
	    p = fix_fname(alist_name(&ARGLIST[argn]));
	    other = otherfile(p);
	    vim_free(p);
	}
	if ((!buf_hide(curbuf) || !other)
		&& check_changed(curbuf, CCGD_AW
		    | (other ? 0 : CCGD_MULTWIN)
		    | (eap->forceit ? CCGD_FORCEIT : 0)
		    | CCGD_EXCMD))
	    return;
    }

    curwin->w_arg_idx = argn;
    if (argn == ARGCOUNT - 1 && curwin->w_alist == &global_alist)
	arg_had_last = TRUE;

    // Edit the file; always use the last known line number.
    // When it fails (e.g. Abort for already edited file) restore the
    // argument index.
    if (do_ecmd(0, alist_name(&ARGLIST[curwin->w_arg_idx]), NULL,
		eap, ECMD_LAST,
		(buf_hide(curwin->w_buffer) ? ECMD_HIDE : 0)
		+ (eap->forceit ? ECMD_FORCEIT : 0), curwin) == FAIL)
	curwin->w_arg_idx = old_arg_idx;
    // like Vi: set the mark where the cursor is in the file.
    else if (eap->cmdidx != CMD_argdo)
	setmark('\'');
}

/*
 * "":next"", and commands that behave like it.
 */
    void
ex_next(exarg_T *eap)
{
    int		i;

    // check for changed buffer now, if this fails the argument list is not
    // redefined.
    if (       buf_hide(curbuf)
	    || eap->cmdidx == CMD_snext
	    || !check_changed(curbuf, CCGD_AW
				    | (eap->forceit ? CCGD_FORCEIT : 0)
				    | CCGD_EXCMD))
    {
	if (*eap->arg != NUL)		    // redefine file list
	{
	    if (do_arglist(eap->arg, AL_SET, 0, TRUE) == FAIL)
		return;
	    i = 0;
	}
	else
	    i = curwin->w_arg_idx + (int)eap->line2;
	do_argfile(eap, i);
    }
}

/*
 * "":argdedupe""
 */
    void
ex_argdedupe(exarg_T *eap UNUSED)
{
    int i;
    int j;

    for (i = 0; i < ARGCOUNT; ++i)
    {
	// Expand each argument to a full path to catch different paths leading
	// to the same file.
	char_u *firstFullname = FullName_save(ARGLIST[i].ae_fname, FALSE);
	if (firstFullname == NULL)
	    return;  // out of memory

	for (j = i + 1; j < ARGCOUNT; ++j)
	{
	    char_u *secondFullname = FullName_save(ARGLIST[j].ae_fname, FALSE);
	    if (secondFullname == NULL)
		break;  // out of memory
	    int areNamesDuplicate =
				  fnamecmp(firstFullname, secondFullname) == 0;
	    vim_free(secondFullname);

	    if (areNamesDuplicate)
	    {
		// remove one duplicate argument
		vim_free(ARGLIST[j].ae_fname);
		mch_memmove(ARGLIST + j, ARGLIST + j + 1,
					(ARGCOUNT - j - 1) * sizeof(aentry_T));
		--ARGCOUNT;

		if (curwin->w_arg_idx == j)
		    curwin->w_arg_idx = i;
		else if (curwin->w_arg_idx > j)
		    --curwin->w_arg_idx;

		--j;
	    }
	}

	vim_free(firstFullname);
    }
}

/*
 * "":argedit""
 */
    void
ex_argedit(exarg_T *eap)
{
    int i = eap->addr_count ? (int)eap->line2 : curwin->w_arg_idx + 1;
    // Whether curbuf will be reused, curbuf->b_ffname will be set.
    int curbuf_is_reusable = curbuf_reusable();

    if (do_arglist(eap->arg, AL_ADD, i, TRUE) == FAIL)
	return;
    maketitle();

    if (curwin->w_arg_idx == 0
	    && (curbuf->b_ml.ml_flags & ML_EMPTY)
	    && (curbuf->b_ffname == NULL || curbuf_is_reusable))
	i = 0;
    // Edit the argument.
    if (i < ARGCOUNT)
	do_argfile(eap, i);
}

/*
 * "":argadd""
 */
    void
ex_argadd(exarg_T *eap)
{
    do_arglist(eap->arg, AL_ADD,
	       eap->addr_count > 0 ? (int)eap->line2 : curwin->w_arg_idx + 1,
	       FALSE);
    maketitle();
}

/*
 * "":argdelete""
 */
    void
ex_argdelete(exarg_T *eap)
{
    int		i;
    int		n;

    if (check_arglist_locked() == FAIL)
	return;

    if (eap->addr_count > 0 || *eap->arg == NUL)
    {
	// "":argdel"" works like "":.argdel""
	if (eap->addr_count == 0)
	{
	    if (curwin->w_arg_idx >= ARGCOUNT)
	    {
		emsg(_(e_no_argument_to_delete));
		return;
	    }
	    eap->line1 = eap->line2 = curwin->w_arg_idx + 1;
	}
	else if (eap->line2 > ARGCOUNT)
	    // "":1,4argdel"": Delete all arguments in the range.
	    eap->line2 = ARGCOUNT;
	n = eap->line2 - eap->line1 + 1;
	if (*eap->arg != NUL)
	    // Can't have both a range and an argument.
	    emsg(_(e_invalid_argument));
	else if (n <= 0)
	{
	    // Don't give an error for "":%argdel"" if the list is empty.
	    if (eap->line1 != 1 || eap->line2 != 0)
		emsg(_(e_invalid_range));
	}
	else
	{
	    for (i = eap->line1; i <= eap->line2; ++i)
		vim_free(ARGLIST[i - 1].ae_fname);
	    mch_memmove(ARGLIST + eap->line1 - 1, ARGLIST + eap->line2,
			(size_t)((ARGCOUNT - eap->line2) * sizeof(aentry_T)));
	    ALIST(curwin)->al_ga.ga_len -= n;
	    if (curwin->w_arg_idx >= eap->line2)
		curwin->w_arg_idx -= n;
	    else if (curwin->w_arg_idx > eap->line1)
		curwin->w_arg_idx = eap->line1;
	    if (ARGCOUNT == 0)
		curwin->w_arg_idx = 0;
	    else if (curwin->w_arg_idx >= ARGCOUNT)
		curwin->w_arg_idx = ARGCOUNT - 1;
	}
    }
    else
	do_arglist(eap->arg, AL_DEL, 0, FALSE);
    maketitle();
}

/*
 * Function given to ExpandGeneric() to obtain the possible arguments of the
 * argedit and argdelete commands.
 */
    char_u *
get_arglist_name(expand_T *xp UNUSED, int idx)
{
    if (idx >= ARGCOUNT)
	return NULL;

    return alist_name(&ARGLIST[idx]);
}

/*
 * Get the file name for an argument list entry.
 */
    char_u *
alist_name(aentry_T *aep)
{
    buf_T	*bp;

    // Use the name from the associated buffer if it exists.
    bp = buflist_findnr(aep->ae_fnum);
    if (bp == NULL || bp->b_fname == NULL)
	return aep->ae_fname;
    return bp->b_fname;
}

/*
 * State used by the :all command to open all the files in the argument list in
 * separate windows.
 */
typedef struct {
    alist_T	*alist;		// argument list to be used
    int		had_tab;
    int		keep_tabs;
    int		forceit;

    int		use_firstwin;	// use first window for arglist
    char_u	*opened;	// Array of weight for which args are open:
				//  0: not opened
				//  1: opened in other tab
				//  2: opened in curtab
				//  3: opened in curtab and curwin
    int		opened_len;	// length of opened[]
    win_T	*new_curwin;
    tabpage_T	*new_curtab;
} arg_all_state_T;

/*
 * Close all the windows containing files which are not in the argument list.
 * Used by the "":all"" command.
 */
    static void
arg_all_close_unused_windows(arg_all_state_T *aall)
{
    win_T	*wp;
    win_T	*wpnext;
    tabpage_T	*tpnext;
    buf_T	*buf;
    int		i;
    win_T	*old_curwin;
    tabpage_T	*old_curtab;

    old_curwin = curwin;
    old_curtab = curtab;

    if (aall->had_tab > 0)
	goto_tabpage_tp(first_tabpage, TRUE, TRUE);

    // moving tabpages around in an autocommand may cause an endless loop
    tabpage_move_disallowed++;
    for (;;)
    {
	tpnext = curtab->tp_next;
	for (wp = firstwin; wp != NULL; wp = wpnext)
	{
	    wpnext = wp->w_next;
	    buf = wp->w_buffer;
	    if (buf->b_ffname == NULL
		    || (!aall->keep_tabs && (buf->b_nwindows > 1
			    || wp->w_width != Columns)))
		i = aall->opened_len;
	    else
	    {
		// check if the buffer in this window is in the arglist
		for (i = 0; i < aall->opened_len; ++i)
		{
		    if (i < aall->alist->al_ga.ga_len
			    && (AARGLIST(aall->alist)[i].ae_fnum == buf->b_fnum
				|| fullpathcmp(alist_name(
						    &AARGLIST(aall->alist)[i]),
					buf->b_ffname, TRUE, TRUE) & FPC_SAME))
		    {
			int weight = 1;

			if (old_curtab == curtab)
			{
			    ++weight;
			    if (old_curwin == wp)
				++weight;
			}

			if (weight > (int)aall->opened[i])
			{
			    aall->opened[i] = (char_u)weight;
			    if (i == 0)
			    {
				if (aall->new_curwin != NULL)
				    aall->new_curwin->w_arg_idx =
							      aall->opened_len;
				aall->new_curwin = wp;
				aall->new_curtab = curtab;
			    }
			}
			else if (aall->keep_tabs)
			    i = aall->opened_len;

			if (wp->w_alist != aall->alist)
			{
			    // Use the current argument list for all windows
			    // containing a file from it.
			    alist_unlink(wp->w_alist);
			    wp->w_alist = aall->alist;
			    ++wp->w_alist->al_refcount;
			}
			break;
		    }
		}
	    }
	    wp->w_arg_idx = i;

	    if (i == aall->opened_len && !aall->keep_tabs)// close this window
	    {
		if (buf_hide(buf) || aall->forceit || buf->b_nwindows > 1
							|| !bufIsChanged(buf))
		{
		    // If the buffer was changed, and we would like to hide it,
		    // try autowriting.
		    if (!buf_hide(buf) && buf->b_nwindows <= 1
							 && bufIsChanged(buf))
		    {
			bufref_T    bufref;

			set_bufref(&bufref, buf);

			(void)autowrite(buf, FALSE);

			// check if autocommands removed the window
			if (!win_valid(wp) || !bufref_valid(&bufref))
			{
			    wpnext = firstwin;	// start all over...
			    continue;
			}
		    }
		    // don't close last window
		    if (ONE_WINDOW
			    && (first_tabpage->tp_next == NULL
				|| !aall->had_tab))
			aall->use_firstwin = TRUE;
		    else
		    {
			win_close(wp, !buf_hide(buf) && !bufIsChanged(buf));

			// check if autocommands removed the next window
			if (!win_valid(wpnext))
			    wpnext = firstwin;	// start all over...
		    }
		}
	    }
	}

	// Without the "":tab"" modifier only do the current tab page.
	if (aall->had_tab == 0 || tpnext == NULL)
	    break;

	// check if autocommands removed the next tab page
	if (!valid_tabpage(tpnext))
	    tpnext = first_tabpage;	// start all over...

	goto_tabpage_tp(tpnext, TRUE, TRUE);
    }
    tabpage_move_disallowed--;
}

/*
 * Open upto ""count"" windows for the files in the argument list 'aall->alist'.
 */
    static void
arg_all_open_windows(arg_all_state_T *aall, int count)
{
    win_T	*wp;
    int		tab_drop_empty_window = FALSE;
    int		i;
    int		split_ret = OK;
    int		p_ea_save;

    // "":tab drop file"" should re-use an empty window to avoid ""--remote-tab""
    // leaving an empty tab page when executed locally.
    if (aall->keep_tabs && BUFEMPTY() && curbuf->b_nwindows == 1
			    && curbuf->b_ffname == NULL && !curbuf->b_changed)
    {
	aall->use_firstwin = TRUE;
	tab_drop_empty_window = TRUE;
    }

    for (i = 0; i < count && !got_int; ++i)
    {
	if (aall->alist == &global_alist && i == global_alist.al_ga.ga_len - 1)
	    arg_had_last = TRUE;
	if (aall->opened[i] > 0)
	{
	    // Move the already present window to below the current window
	    if (curwin->w_arg_idx != i)
	    {
		FOR_ALL_WINDOWS(wp)
		{
		    if (wp->w_arg_idx == i)
		    {
			if (aall->keep_tabs)
			{
			    aall->new_curwin = wp;
			    aall->new_curtab = curtab;
			}
			else if (wp->w_frame->fr_parent
				!= curwin->w_frame->fr_parent)
			{
			    emsg(_(e_window_layout_changed_unexpectedly));
			    i = count;
			    break;
			}
			else
			    win_move_after(wp, curwin);
			break;
		    }
		}
	    }
	}
	else if (split_ret == OK)
	{
	    // trigger events for tab drop
	    if (tab_drop_empty_window && i == count - 1)
		--autocmd_no_enter;
	    if (!aall->use_firstwin)		// split current window
	    {
		p_ea_save = p_ea;
		p_ea = TRUE;		// use space from all windows
		split_ret = win_split(0, WSP_ROOM | WSP_BELOW);
		p_ea = p_ea_save;
		if (split_ret == FAIL)
		    continue;
	    }
	    else    // first window: do autocmd for leaving this buffer
		--autocmd_no_leave;

	    // edit file ""i""
	    curwin->w_arg_idx = i;
	    if (i == 0)
	    {
		aall->new_curwin = curwin;
		aall->new_curtab = curtab;
	    }
	    (void)do_ecmd(0, alist_name(&AARGLIST(aall->alist)[i]), NULL, NULL,
		    ECMD_ONE,
		    ((buf_hide(curwin->w_buffer)
		      || bufIsChanged(curwin->w_buffer)) ? ECMD_HIDE : 0)
		    + ECMD_OLDBUF, curwin);
	    if (tab_drop_empty_window && i == count - 1)
		++autocmd_no_enter;
	    if (aall->use_firstwin)
		++autocmd_no_leave;
	    aall->use_firstwin = FALSE;
	}
	ui_breakcheck();

	// When "":tab"" was used open a new tab for a new window repeatedly.
	if (aall->had_tab > 0 && tabpage_index(NULL) <= p_tpm)
	    cmdmod.cmod_tab = 9999;
    }
}

/*
 * do_arg_all(): Open up to ""count"" windows, one for each argument.
 */
    static void
do_arg_all(
    int	count,
    int	forceit,		// hide buffers in current windows
    int keep_tabs)		// keep current tabs, for "":tab drop file""
{
    arg_all_state_T	aall;
    win_T		*last_curwin;
    tabpage_T		*last_curtab;
    int			prev_arglist_locked = arglist_locked;

    if (cmdwin_type != 0)
    {
	emsg(_(e_invalid_in_cmdline_window));
	return;
    }
    if (ARGCOUNT <= 0)
    {
	// Don't give an error message.  We don't want it when the "":all""
	// command is in the .vimrc.
	return;
    }
    setpcmark();

    aall.use_firstwin = FALSE;
    aall.had_tab = cmdmod.cmod_tab;
    aall.new_curwin = NULL;
    aall.new_curtab = NULL;
    aall.forceit = forceit;
    aall.keep_tabs = keep_tabs;
    aall.opened_len = ARGCOUNT;
    aall.opened = alloc_clear(aall.opened_len);
    if (aall.opened == NULL)
	return;

    // Autocommands may do anything to the argument list.  Make sure it's not
    // freed while we are working here by ""locking"" it.  We still have to
    // watch out for its size being changed.
    aall.alist = curwin->w_alist;
    ++aall.alist->al_refcount;
    arglist_locked = TRUE;

#ifdef FEAT_GUI
    need_mouse_correct = TRUE;
#endif

    tabpage_T *new_lu_tp = curtab;

    // Try closing all windows that are not in the argument list.
    // Also close windows that are not full width;
    // When 'hidden' or ""forceit"" set the buffer becomes hidden.
    // Windows that have a changed buffer and can't be hidden won't be closed.
    // When the "":tab"" modifier was used do this for all tab pages.
    arg_all_close_unused_windows(&aall);

    // Open a window for files in the argument list that don't have one.
    // ARGCOUNT may change while doing this, because of autocommands.
    if (count > aall.opened_len || count <= 0)
	count = aall.opened_len;

    // Don't execute Win/Buf Enter/Leave autocommands here.
    ++autocmd_no_enter;
    ++autocmd_no_leave;
    last_curwin = curwin;
    last_curtab = curtab;
    win_enter(lastwin, FALSE);

    /*
     * Open upto ""count"" windows.
     */
    arg_all_open_windows(&aall, count);

    // Remove the ""lock"" on the argument list.
    alist_unlink(aall.alist);
    arglist_locked = prev_arglist_locked;

    --autocmd_no_enter;

    // restore last referenced tabpage's curwin
    if (last_curtab != aall.new_curtab)
    {
	if (valid_tabpage(last_curtab))
	    goto_tabpage_tp(last_curtab, TRUE, TRUE);
	if (win_valid(last_curwin))
	    win_enter(last_curwin, FALSE);
    }
    // to window with first arg
    if (valid_tabpage(aall.new_curtab))
	goto_tabpage_tp(aall.new_curtab, TRUE, TRUE);

    // Now set the last used tabpage to where we started.
    if (valid_tabpage(new_lu_tp))
	lastused_tabpage = new_lu_tp;

    if (win_valid(aall.new_curwin))
	win_enter(aall.new_curwin, FALSE);

    --autocmd_no_leave;
    vim_free(aall.opened);
}

/*
 * "":all"" and "":sall"".
 * Also used for "":tab drop file ..."" after setting the argument list.
 */
    void
ex_all(exarg_T *eap)
{
    if (eap->addr_count == 0)
	eap->line2 = 9999;
    do_arg_all((int)eap->line2, eap->forceit, eap->cmdidx == CMD_drop);
}

/*
 * Concatenate all files in the argument list, separated by spaces, and return
 * it in one allocated string.
 * Spaces and backslashes in the file names are escaped with a backslash.
 * Returns NULL when out of memory.
 */
    char_u *
arg_all(void)
{
    int		len;
    int		idx;
    char_u	*retval = NULL;
    char_u	*p;

    // Do this loop two times:
    // first time: compute the total length
    // second time: concatenate the names
    for (;;)
    {
	len = 0;
	for (idx = 0; idx < ARGCOUNT; ++idx)
	{
	    p = alist_name(&ARGLIST[idx]);
	    if (p == NULL)
		continue;
	    if (len > 0)
	    {
		// insert a space in between names
		if (retval != NULL)
		    retval[len] = ' ';
		++len;
	    }
	    for ( ; *p != NUL; ++p)
	    {
		if (*p == ' '
#ifndef BACKSLASH_IN_FILENAME
			|| *p == '\\'
#endif
			|| *p == '`')
		{
		    // insert a backslash
		    if (retval != NULL)
			retval[len] = '\\';
		    ++len;
		}
		if (retval != NULL)
		    retval[len] = *p;
		++len;
	    }
	}

	// second time: break here
	if (retval != NULL)
	{
	    retval[len] = NUL;
	    break;
	}

	// allocate memory
	retval = alloc(len + 1);
	if (retval == NULL)
	    break;
    }

    return retval;
}

#if defined(FEAT_EVAL) || defined(PROTO)
/*
 * ""argc([window id])"" function
 */
    void
f_argc(typval_T *argvars, typval_T *rettv)
{
    win_T	*wp;

    if (in_vim9script() && check_for_opt_number_arg(argvars, 0) == FAIL)
	return;

    if (argvars[0].v_type == VAR_UNKNOWN)
	// use the current window
	rettv->vval.v_number = ARGCOUNT;
    else if (argvars[0].v_type == VAR_NUMBER
					   && tv_get_number(&argvars[0]) == -1)
	// use the global argument list
	rettv->vval.v_number = GARGCOUNT;
    else
    {
	// use the argument list of the specified window
	wp = find_win_by_nr_or_id(&argvars[0]);
	if (wp != NULL)
	    rettv->vval.v_number = WARGCOUNT(wp);
	else
	    rettv->vval.v_number = -1;
    }
}

/*
 * ""argidx()"" function
 */
    void
f_argidx(typval_T *argvars UNUSED, typval_T *rettv)
{
    rettv->vval.v_number = curwin->w_arg_idx;
}

/*
 * ""arglistid()"" function
 */
    void
f_arglistid(typval_T *argvars, typval_T *rettv)
{
    win_T	*wp;

    if (in_vim9script()
	    && (check_for_opt_number_arg(argvars, 0) == FAIL
		|| (argvars[0].v_type != VAR_UNKNOWN
		    && check_for_opt_number_arg(argvars, 1) == FAIL)))
	return;

    rettv->vval.v_number = -1;
    wp = find_tabwin(&argvars[0], &argvars[1], NULL);
    if (wp != NULL)
	rettv->vval.v_number = wp->w_alist->id;
}

/*
 * Get the argument list for a given window
 */
    static void
get_arglist_as_rettv(aentry_T *arglist, int argcount, typval_T *rettv)
{
    int		idx;

    if (rettv_list_alloc(rettv) == OK && arglist != NULL)
	for (idx = 0; idx < argcount; ++idx)
	    list_append_string(rettv->vval.v_list,
						alist_name(&arglist[idx]), -1);
}

/*
 * ""argv(nr)"" function
 */
    void
f_argv(typval_T *argvars, typval_T *rettv)
{
    int		idx;
    aentry_T	*arglist = NULL;
    int		argcount = -1;

    if (in_vim9script()
	    && (check_for_opt_number_arg(argvars, 0) == FAIL
		|| (argvars[0].v_type != VAR_UNKNOWN
		    && check_for_opt_number_arg(argvars, 1) == FAIL)))
	return;

    if (argvars[0].v_type == VAR_UNKNOWN)
    {
	get_arglist_as_rettv(ARGLIST, ARGCOUNT, rettv);
	return;
    }

    if (argvars[1].v_type == VAR_UNKNOWN)
    {
	arglist = ARGLIST;
	argcount = ARGCOUNT;
    }
    else if (argvars[1].v_type == VAR_NUMBER
	    && tv_get_number(&argvars[1]) == -1)
    {
	arglist = GARGLIST;
	argcount = GARGCOUNT;
    }
    else
    {
	win_T	*wp = find_win_by_nr_or_id(&argvars[1]);

	if (wp != NULL)
	{
	    // Use the argument list of the specified window
	    arglist = WARGLIST(wp);
	    argcount = WARGCOUNT(wp);
	}
    }

    rettv->v_type = VAR_STRING;
    rettv->vval.v_string = NULL;
    idx = tv_get_number_chk(&argvars[0], NULL);
    if (arglist != NULL && idx >= 0 && idx < argcount)
	rettv->vval.v_string = vim_strsave(alist_name(&arglist[idx]));
    else if (idx == -1)
	get_arglist_as_rettv(arglist, argcount, rettv);
}
#endif
"
./repos/vim/src/autocmd.c,https://github.com/vim/vim,"/* vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *
 * Do "":help uganda""  in Vim to read copying and usage conditions.
 * Do "":help credits"" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 */

/*
 * autocmd.c: Autocommand related functions
 */

#include ""vim.h""

/*
 * The autocommands are stored in a list for each event.
 * Autocommands for the same pattern, that are consecutive, are joined
 * together, to avoid having to match the pattern too often.
 * The result is an array of Autopat lists, which point to AutoCmd lists:
 *
 * last_autopat[0]  -----------------------------+
 *						 V
 * first_autopat[0] --> Autopat.next  -->  Autopat.next -->  NULL
 *			Autopat.cmds	   Autopat.cmds
 *			    |			 |
 *			    V			 V
 *			AutoCmd.next	   AutoCmd.next
 *			    |			 |
 *			    V			 V
 *			AutoCmd.next		NULL
 *			    |
 *			    V
 *			   NULL
 *
 * last_autopat[1]  --------+
 *			    V
 * first_autopat[1] --> Autopat.next  -->  NULL
 *			Autopat.cmds
 *			    |
 *			    V
 *			AutoCmd.next
 *			    |
 *			    V
 *			   NULL
 *   etc.
 *
 *   The order of AutoCmds is important, this is the order in which they were
 *   defined and will have to be executed.
 */
typedef struct AutoCmd
{
    char_u	    *cmd;		// The command to be executed (NULL
					// when command has been removed).
    char	    once;		// ""One shot"": removed after execution
    char	    nested;		// If autocommands nest here.
    char	    last;		// last command in list
    sctx_T	    script_ctx;		// script context where it is defined
    struct AutoCmd  *next;		// next AutoCmd in list
} AutoCmd;

typedef struct AutoPat
{
    struct AutoPat  *next;		// Next AutoPat in AutoPat list; MUST
					// be the first entry.
    char_u	    *pat;		// pattern as typed (NULL when pattern
					// has been removed)
    regprog_T	    *reg_prog;		// compiled regprog for pattern
    AutoCmd	    *cmds;		// list of commands to do
    int		    group;		// group ID
    int		    patlen;		// strlen() of pat
    int		    buflocal_nr;	// !=0 for buffer-local AutoPat
    char	    allow_dirs;		// Pattern may match whole path
    char	    last;		// last pattern for apply_autocmds()
} AutoPat;

//
// special cases:
// BufNewFile and BufRead are searched for ALOT (especially at startup)
// so we pre-determine their index into the event_tab[] table for fast access.
// Keep these values in sync with event_tab[]!
#define BUFNEWFILE_INDEX 9
#define BUFREAD_INDEX 10

// must be sorted by the 'value' field because it is used by bsearch()!
static keyvalue_T event_tab[] = {
    KEYVALUE_ENTRY(EVENT_BUFADD, ""BufAdd""),
    KEYVALUE_ENTRY(EVENT_BUFADD, ""BufCreate""),
    KEYVALUE_ENTRY(EVENT_BUFDELETE, ""BufDelete""),
    KEYVALUE_ENTRY(EVENT_BUFENTER, ""BufEnter""),
    KEYVALUE_ENTRY(EVENT_BUFFILEPOST, ""BufFilePost""),
    KEYVALUE_ENTRY(EVENT_BUFFILEPRE, ""BufFilePre""),
    KEYVALUE_ENTRY(EVENT_BUFHIDDEN, ""BufHidden""),
    KEYVALUE_ENTRY(EVENT_BUFLEAVE, ""BufLeave""),
    KEYVALUE_ENTRY(EVENT_BUFNEW, ""BufNew""),
    KEYVALUE_ENTRY(EVENT_BUFNEWFILE, ""BufNewFile""),	// BUFNEWFILE_INDEX
    KEYVALUE_ENTRY(EVENT_BUFREADPOST, ""BufRead""),	// BUFREAD_INDEX
    KEYVALUE_ENTRY(EVENT_BUFREADCMD, ""BufReadCmd""),
    KEYVALUE_ENTRY(EVENT_BUFREADPOST, ""BufReadPost""),
    KEYVALUE_ENTRY(EVENT_BUFREADPRE, ""BufReadPre""),
    KEYVALUE_ENTRY(EVENT_BUFUNLOAD, ""BufUnload""),
    KEYVALUE_ENTRY(EVENT_BUFWINENTER, ""BufWinEnter""),
    KEYVALUE_ENTRY(EVENT_BUFWINLEAVE, ""BufWinLeave""),
    KEYVALUE_ENTRY(EVENT_BUFWIPEOUT, ""BufWipeout""),
    KEYVALUE_ENTRY(EVENT_BUFWRITEPRE, ""BufWrite""),
    KEYVALUE_ENTRY(EVENT_BUFWRITECMD, ""BufWriteCmd""),
    KEYVALUE_ENTRY(EVENT_BUFWRITEPOST, ""BufWritePost""),
    KEYVALUE_ENTRY(EVENT_BUFWRITEPRE, ""BufWritePre""),
    KEYVALUE_ENTRY(EVENT_CMDLINECHANGED, ""CmdlineChanged""),
    KEYVALUE_ENTRY(EVENT_CMDLINEENTER, ""CmdlineEnter""),
    KEYVALUE_ENTRY(EVENT_CMDLINELEAVE, ""CmdlineLeave""),
    KEYVALUE_ENTRY(EVENT_CMDUNDEFINED, ""CmdUndefined""),
    KEYVALUE_ENTRY(EVENT_CMDWINENTER, ""CmdwinEnter""),
    KEYVALUE_ENTRY(EVENT_CMDWINLEAVE, ""CmdwinLeave""),
    KEYVALUE_ENTRY(EVENT_COLORSCHEME, ""ColorScheme""),
    KEYVALUE_ENTRY(EVENT_COLORSCHEMEPRE, ""ColorSchemePre""),
    KEYVALUE_ENTRY(EVENT_COMPLETECHANGED, ""CompleteChanged""),
    KEYVALUE_ENTRY(EVENT_COMPLETEDONE, ""CompleteDone""),
    KEYVALUE_ENTRY(EVENT_COMPLETEDONEPRE, ""CompleteDonePre""),
    KEYVALUE_ENTRY(EVENT_CURSORHOLD, ""CursorHold""),
    KEYVALUE_ENTRY(EVENT_CURSORHOLDI, ""CursorHoldI""),
    KEYVALUE_ENTRY(EVENT_CURSORMOVED, ""CursorMoved""),
    KEYVALUE_ENTRY(EVENT_CURSORMOVEDI, ""CursorMovedI""),
    KEYVALUE_ENTRY(EVENT_DIFFUPDATED, ""DiffUpdated""),
    KEYVALUE_ENTRY(EVENT_DIRCHANGED, ""DirChanged""),
    KEYVALUE_ENTRY(EVENT_DIRCHANGEDPRE, ""DirChangedPre""),
    KEYVALUE_ENTRY(EVENT_ENCODINGCHANGED, ""EncodingChanged""),
    KEYVALUE_ENTRY(EVENT_EXITPRE, ""ExitPre""),
    KEYVALUE_ENTRY(EVENT_FILEAPPENDCMD, ""FileAppendCmd""),
    KEYVALUE_ENTRY(EVENT_FILEAPPENDPOST, ""FileAppendPost""),
    KEYVALUE_ENTRY(EVENT_FILEAPPENDPRE, ""FileAppendPre""),
    KEYVALUE_ENTRY(EVENT_FILECHANGEDRO, ""FileChangedRO""),
    KEYVALUE_ENTRY(EVENT_FILECHANGEDSHELL, ""FileChangedShell""),
    KEYVALUE_ENTRY(EVENT_FILECHANGEDSHELLPOST, ""FileChangedShellPost""),
    KEYVALUE_ENTRY(EVENT_ENCODINGCHANGED, ""FileEncoding""),
    KEYVALUE_ENTRY(EVENT_FILEREADCMD, ""FileReadCmd""),
    KEYVALUE_ENTRY(EVENT_FILEREADPOST, ""FileReadPost""),
    KEYVALUE_ENTRY(EVENT_FILEREADPRE, ""FileReadPre""),
    KEYVALUE_ENTRY(EVENT_FILETYPE, ""FileType""),
    KEYVALUE_ENTRY(EVENT_FILEWRITECMD, ""FileWriteCmd""),
    KEYVALUE_ENTRY(EVENT_FILEWRITEPOST, ""FileWritePost""),
    KEYVALUE_ENTRY(EVENT_FILEWRITEPRE, ""FileWritePre""),
    KEYVALUE_ENTRY(EVENT_FILTERREADPOST, ""FilterReadPost""),
    KEYVALUE_ENTRY(EVENT_FILTERREADPRE, ""FilterReadPre""),
    KEYVALUE_ENTRY(EVENT_FILTERWRITEPOST, ""FilterWritePost""),
    KEYVALUE_ENTRY(EVENT_FILTERWRITEPRE, ""FilterWritePre""),
    KEYVALUE_ENTRY(EVENT_FOCUSGAINED, ""FocusGained""),
    KEYVALUE_ENTRY(EVENT_FOCUSLOST, ""FocusLost""),
    KEYVALUE_ENTRY(EVENT_FUNCUNDEFINED, ""FuncUndefined""),
    KEYVALUE_ENTRY(EVENT_GUIENTER, ""GUIEnter""),
    KEYVALUE_ENTRY(EVENT_GUIFAILED, ""GUIFailed""),
    KEYVALUE_ENTRY(EVENT_INSERTCHANGE, ""InsertChange""),
    KEYVALUE_ENTRY(EVENT_INSERTCHARPRE, ""InsertCharPre""),
    KEYVALUE_ENTRY(EVENT_INSERTENTER, ""InsertEnter""),
    KEYVALUE_ENTRY(EVENT_INSERTLEAVE, ""InsertLeave""),
    KEYVALUE_ENTRY(EVENT_INSERTLEAVEPRE, ""InsertLeavePre""),
    KEYVALUE_ENTRY(EVENT_MENUPOPUP, ""MenuPopup""),
    KEYVALUE_ENTRY(EVENT_MODECHANGED, ""ModeChanged""),
    KEYVALUE_ENTRY(EVENT_OPTIONSET, ""OptionSet""),
    KEYVALUE_ENTRY(EVENT_QUICKFIXCMDPOST, ""QuickFixCmdPost""),
    KEYVALUE_ENTRY(EVENT_QUICKFIXCMDPRE, ""QuickFixCmdPre""),
    KEYVALUE_ENTRY(EVENT_QUITPRE, ""QuitPre""),
    KEYVALUE_ENTRY(EVENT_REMOTEREPLY, ""RemoteReply""),
    KEYVALUE_ENTRY(EVENT_SAFESTATE, ""SafeState""),
    KEYVALUE_ENTRY(EVENT_SAFESTATEAGAIN, ""SafeStateAgain""),
    KEYVALUE_ENTRY(EVENT_SESSIONLOADPOST, ""SessionLoadPost""),
    KEYVALUE_ENTRY(EVENT_SESSIONWRITEPOST, ""SessionWritePost""),
    KEYVALUE_ENTRY(EVENT_SHELLCMDPOST, ""ShellCmdPost""),
    KEYVALUE_ENTRY(EVENT_SHELLFILTERPOST, ""ShellFilterPost""),
    KEYVALUE_ENTRY(EVENT_SIGUSR1, ""SigUSR1""),
    KEYVALUE_ENTRY(EVENT_SOURCECMD, ""SourceCmd""),
    KEYVALUE_ENTRY(EVENT_SOURCEPOST, ""SourcePost""),
    KEYVALUE_ENTRY(EVENT_SOURCEPRE, ""SourcePre""),
    KEYVALUE_ENTRY(EVENT_SPELLFILEMISSING, ""SpellFileMissing""),
    KEYVALUE_ENTRY(EVENT_STDINREADPOST, ""StdinReadPost""),
    KEYVALUE_ENTRY(EVENT_STDINREADPRE, ""StdinReadPre""),
    KEYVALUE_ENTRY(EVENT_SWAPEXISTS, ""SwapExists""),
    KEYVALUE_ENTRY(EVENT_SYNTAX, ""Syntax""),
    KEYVALUE_ENTRY(EVENT_TABCLOSED, ""TabClosed""),
    KEYVALUE_ENTRY(EVENT_TABENTER, ""TabEnter""),
    KEYVALUE_ENTRY(EVENT_TABLEAVE, ""TabLeave""),
    KEYVALUE_ENTRY(EVENT_TABNEW, ""TabNew""),
    KEYVALUE_ENTRY(EVENT_TERMCHANGED, ""TermChanged""),
    KEYVALUE_ENTRY(EVENT_TERMINALOPEN, ""TerminalOpen""),
    KEYVALUE_ENTRY(EVENT_TERMINALWINOPEN, ""TerminalWinOpen""),
    KEYVALUE_ENTRY(EVENT_TERMRESPONSE, ""TermResponse""),
    KEYVALUE_ENTRY(EVENT_TERMRESPONSEALL, ""TermResponseAll""),
    KEYVALUE_ENTRY(EVENT_TEXTCHANGED, ""TextChanged""),
    KEYVALUE_ENTRY(EVENT_TEXTCHANGEDI, ""TextChangedI""),
    KEYVALUE_ENTRY(EVENT_TEXTCHANGEDP, ""TextChangedP""),
    KEYVALUE_ENTRY(EVENT_TEXTCHANGEDT, ""TextChangedT""),
    KEYVALUE_ENTRY(EVENT_TEXTYANKPOST, ""TextYankPost""),
    KEYVALUE_ENTRY(EVENT_USER, ""User""),
    KEYVALUE_ENTRY(EVENT_VIMENTER, ""VimEnter""),
    KEYVALUE_ENTRY(EVENT_VIMLEAVE, ""VimLeave""),
    KEYVALUE_ENTRY(EVENT_VIMLEAVEPRE, ""VimLeavePre""),
    KEYVALUE_ENTRY(EVENT_VIMRESIZED, ""VimResized""),
    KEYVALUE_ENTRY(EVENT_VIMRESUME, ""VimResume""),
    KEYVALUE_ENTRY(EVENT_VIMSUSPEND, ""VimSuspend""),
    KEYVALUE_ENTRY(EVENT_WINCLOSED, ""WinClosed""),
    KEYVALUE_ENTRY(EVENT_WINENTER, ""WinEnter""),
    KEYVALUE_ENTRY(EVENT_WINLEAVE, ""WinLeave""),
    KEYVALUE_ENTRY(EVENT_WINNEW, ""WinNew""),
    KEYVALUE_ENTRY(EVENT_WINNEWPRE, ""WinNewPre""),
    KEYVALUE_ENTRY(EVENT_WINRESIZED, ""WinResized""),
    KEYVALUE_ENTRY(EVENT_WINSCROLLED, ""WinScrolled"")
};

static AutoPat *first_autopat[NUM_EVENTS] = {
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL
};

static AutoPat *last_autopat[NUM_EVENTS] = {
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL
};

#define AUGROUP_DEFAULT    (-1)	    // default autocmd group
#define AUGROUP_ERROR	   (-2)	    // erroneous autocmd group
#define AUGROUP_ALL	   (-3)	    // all autocmd groups

/*
 * struct used to keep status while executing autocommands for an event.
 */
struct AutoPatCmd_S
{
    AutoPat	*curpat;	// next AutoPat to examine
    AutoCmd	*nextcmd;	// next AutoCmd to execute
    int		group;		// group being used
    char_u	*fname;		// fname to match with
    char_u	*sfname;	// sfname to match with
    char_u	*tail;		// tail of fname
    event_T	event;		// current event
    sctx_T	script_ctx;	// script context where it is defined
    int		arg_bufnr;	// Initially equal to <abuf>, set to zero when
				// buf is deleted.
    AutoPatCmd_T *next;		// chain of active apc-s for auto-invalidation
};

static AutoPatCmd_T *active_apc_list = NULL; // stack of active autocommands

// Macro to loop over all the patterns for an autocmd event
#define FOR_ALL_AUTOCMD_PATTERNS(event, ap) \
    for ((ap) = first_autopat[(int)(event)]; (ap) != NULL; (ap) = (ap)->next)

/*
 * augroups stores a list of autocmd group names.
 */
static garray_T augroups = {0, 0, sizeof(char_u *), 10, NULL};
#define AUGROUP_NAME(i) (((char_u **)augroups.ga_data)[i])
// use get_deleted_augroup() to get this
static char_u *deleted_augroup = NULL;

/*
 * The ID of the current group.  Group 0 is the default one.
 */
static int current_augroup = AUGROUP_DEFAULT;

static int au_need_clean = FALSE;   // need to delete marked patterns

static event_T event_name2nr(char_u *start, char_u **end);
static char_u *event_nr2name(event_T event);
static int au_get_grouparg(char_u **argp);
static int do_autocmd_event(event_T event, char_u *pat, int once, int nested, char_u *cmd, int forceit, int group, int flags);
static int apply_autocmds_group(event_T event, char_u *fname, char_u *fname_io, int force, int group, buf_T *buf, exarg_T *eap);
static void auto_next_pat(AutoPatCmd_T *apc, int stop_at_last);
static int au_find_group(char_u *name);

static event_T	last_event;
static int	last_group;
static int	autocmd_blocked = 0;	// block all autocmds

    static char_u *
get_deleted_augroup(void)
{
    if (deleted_augroup == NULL)
	deleted_augroup = (char_u *)_(""--Deleted--"");
    return deleted_augroup;
}

/*
 * Show the autocommands for one AutoPat.
 */
    static void
show_autocmd(AutoPat *ap, event_T event)
{
    AutoCmd *ac;

    // Check for ""got_int"" (here and at various places below), which is set
    // when ""q"" has been hit for the ""--more--"" prompt
    if (got_int)
	return;
    if (ap->pat == NULL)		// pattern has been removed
	return;

    // Make sure no info referenced by ""ap"" is cleared, e.g. when a timer
    // clears an augroup.  Jump to ""theend"" after this!
    // ""ap->pat"" may be cleared anyway.
    ++autocmd_busy;

    msg_putchar('\n');
    if (got_int)
	goto theend;
    if (event != last_event || ap->group != last_group)
    {
	if (ap->group != AUGROUP_DEFAULT)
	{
	    if (AUGROUP_NAME(ap->group) == NULL)
		msg_puts_attr((char *)get_deleted_augroup(), HL_ATTR(HLF_E));
	    else
		msg_puts_attr((char *)AUGROUP_NAME(ap->group), HL_ATTR(HLF_T));
	    msg_puts(""  "");
	}
	msg_puts_attr((char *)event_nr2name(event), HL_ATTR(HLF_T));
	last_event = event;
	last_group = ap->group;
	msg_putchar('\n');
	if (got_int)
	    goto theend;
    }

    if (ap->pat == NULL)
	goto theend;  // timer might have cleared the pattern or group

    msg_col = 4;
    msg_outtrans(ap->pat);

    for (ac = ap->cmds; ac != NULL; ac = ac->next)
    {
	if (ac->cmd == NULL)		// skip removed commands
	    continue;

	if (msg_col >= 14)
	    msg_putchar('\n');
	msg_col = 14;
	if (got_int)
	    goto theend;
	msg_outtrans(ac->cmd);
#ifdef FEAT_EVAL
	if (p_verbose > 0)
	    last_set_msg(ac->script_ctx);
#endif
	if (got_int)
	    goto theend;
	if (ac->next != NULL)
	{
	    msg_putchar('\n');
	    if (got_int)
		goto theend;
	}
    }

theend:
    --autocmd_busy;
}

/*
 * Mark an autocommand pattern for deletion.
 */
    static void
au_remove_pat(AutoPat *ap)
{
    VIM_CLEAR(ap->pat);
    ap->buflocal_nr = -1;
    au_need_clean = TRUE;
}

/*
 * Mark all commands for a pattern for deletion.
 */
    static void
au_remove_cmds(AutoPat *ap)
{
    AutoCmd *ac;

    for (ac = ap->cmds; ac != NULL; ac = ac->next)
	VIM_CLEAR(ac->cmd);
    au_need_clean = TRUE;
}

// Delete one command from an autocmd pattern.
static void au_del_cmd(AutoCmd *ac)
{
    VIM_CLEAR(ac->cmd);
    au_need_clean = TRUE;
}

/*
 * Cleanup autocommands and patterns that have been deleted.
 * This is only done when not executing autocommands.
 */
    static void
au_cleanup(void)
{
    AutoPat	*ap, **prev_ap;
    AutoCmd	*ac, **prev_ac;
    event_T	event;

    if (autocmd_busy || !au_need_clean)
	return;

    // loop over all events
    for (event = (event_T)0; (int)event < NUM_EVENTS;
					    event = (event_T)((int)event + 1))
    {
	// loop over all autocommand patterns
	prev_ap = &(first_autopat[(int)event]);
	for (ap = *prev_ap; ap != NULL; ap = *prev_ap)
	{
	    int has_cmd = FALSE;

	    // loop over all commands for this pattern
	    prev_ac = &(ap->cmds);
	    for (ac = *prev_ac; ac != NULL; ac = *prev_ac)
	    {
		// remove the command if the pattern is to be deleted or when
		// the command has been marked for deletion
		if (ap->pat == NULL || ac->cmd == NULL)
		{
		    *prev_ac = ac->next;
		    vim_free(ac->cmd);
		    vim_free(ac);
		}
		else
		{
		    has_cmd = TRUE;
		    prev_ac = &(ac->next);
		}
	    }

	    if (ap->pat != NULL && !has_cmd)
		// Pattern was not marked for deletion, but all of its
		// commands were.  So mark the pattern for deletion.
		au_remove_pat(ap);

	    // remove the pattern if it has been marked for deletion
	    if (ap->pat == NULL)
	    {
		if (ap->next == NULL)
		{
		    if (prev_ap == &(first_autopat[(int)event]))
			last_autopat[(int)event] = NULL;
		    else
			// this depends on the ""next"" field being the first in
			// the struct
			last_autopat[(int)event] = (AutoPat *)prev_ap;
		}
		*prev_ap = ap->next;
		vim_regfree(ap->reg_prog);
		vim_free(ap);
	    }
	    else
		prev_ap = &(ap->next);
	}
    }

    au_need_clean = FALSE;
}

/*
 * Called when buffer is freed, to remove/invalidate related buffer-local
 * autocmds.
 */
    void
aubuflocal_remove(buf_T *buf)
{
    AutoPat	    *ap;
    event_T	    event;
    AutoPatCmd_T    *apc;

    // invalidate currently executing autocommands
    for (apc = active_apc_list; apc; apc = apc->next)
	if (buf->b_fnum == apc->arg_bufnr)
	    apc->arg_bufnr = 0;

    // invalidate buflocals looping through events
    for (event = (event_T)0; (int)event < NUM_EVENTS;
					    event = (event_T)((int)event + 1))
	// loop over all autocommand patterns
	FOR_ALL_AUTOCMD_PATTERNS(event, ap)
	    if (ap->buflocal_nr == buf->b_fnum)
	    {
		au_remove_pat(ap);
		if (p_verbose >= 6)
		{
		    verbose_enter();
		    smsg(_(""auto-removing autocommand: %s <buffer=%d>""),
					   event_nr2name(event), buf->b_fnum);
		    verbose_leave();
		}
	    }
    au_cleanup();
}

/*
 * Add an autocmd group name.
 * Return its ID.  Returns AUGROUP_ERROR (< 0) for error.
 */
    static int
au_new_group(char_u *name)
{
    int		i;

    i = au_find_group(name);
    if (i != AUGROUP_ERROR)
	return i;

    // the group doesn't exist yet, add it.  First try using a free entry.
    for (i = 0; i < augroups.ga_len; ++i)
	if (AUGROUP_NAME(i) == NULL)
	    break;
    if (i == augroups.ga_len && ga_grow(&augroups, 1) == FAIL)
	return AUGROUP_ERROR;

    AUGROUP_NAME(i) = vim_strsave(name);
    if (AUGROUP_NAME(i) == NULL)
	return AUGROUP_ERROR;
    if (i == augroups.ga_len)
	++augroups.ga_len;

    return i;
}

    static void
au_del_group(char_u *name)
{
    int		i;
    event_T	event;
    AutoPat	*ap;
    int		in_use = FALSE;


    i = au_find_group(name);
    if (i == AUGROUP_ERROR)	// the group doesn't exist
    {
	semsg(_(e_no_such_group_str), name);
	return;
    }
    if (i == current_augroup)
    {
	emsg(_(e_cannot_delete_current_group));
	return;
    }

    for (event = (event_T)0; (int)event < NUM_EVENTS;
	    event = (event_T)((int)event + 1))
    {
	FOR_ALL_AUTOCMD_PATTERNS(event, ap)
	    if (ap->group == i && ap->pat != NULL)
	    {
		give_warning((char_u *)_(""W19: Deleting augroup that is still in use""), TRUE);
		in_use = TRUE;
		event = NUM_EVENTS;
		break;
	    }
    }
    vim_free(AUGROUP_NAME(i));
    if (in_use)
	AUGROUP_NAME(i) = get_deleted_augroup();
    else
	AUGROUP_NAME(i) = NULL;
}

/*
 * Find the ID of an autocmd group name.
 * Return its ID.  Returns AUGROUP_ERROR (< 0) for error.
 */
    static int
au_find_group(char_u *name)
{
    int	    i;

    for (i = 0; i < augroups.ga_len; ++i)
	if (AUGROUP_NAME(i) != NULL && AUGROUP_NAME(i) != get_deleted_augroup()
		&& STRCMP(AUGROUP_NAME(i), name) == 0)
	    return i;
    return AUGROUP_ERROR;
}

/*
 * Return TRUE if augroup ""name"" exists.
 */
    int
au_has_group(char_u *name)
{
    return au_find_group(name) != AUGROUP_ERROR;
}

/*
 * "":augroup {name}"".
 */
    void
do_augroup(char_u *arg, int del_group)
{
    int	    i;

    if (del_group)
    {
	if (*arg == NUL)
	    emsg(_(e_argument_required));
	else
	    au_del_group(arg);
    }
    else if (STRICMP(arg, ""end"") == 0)   // "":aug end"": back to group 0
	current_augroup = AUGROUP_DEFAULT;
    else if (*arg)		    // "":aug xxx"": switch to group xxx
    {
	i = au_new_group(arg);
	if (i != AUGROUP_ERROR)
	    current_augroup = i;
    }
    else			    // "":aug"": list the group names
    {
	msg_start();
	for (i = 0; i < augroups.ga_len; ++i)
	{
	    if (AUGROUP_NAME(i) != NULL)
	    {
		msg_puts((char *)AUGROUP_NAME(i));
		msg_puts(""  "");
	    }
	}
	msg_clr_eos();
	msg_end();
    }
}

    void
autocmd_init(void)
{
    CLEAR_FIELD(aucmd_win);
}

#if defined(EXITFREE) || defined(PROTO)
    void
free_all_autocmds(void)
{
    char_u	*s;

    for (current_augroup = -1; current_augroup < augroups.ga_len;
							    ++current_augroup)
	do_autocmd(NULL, (char_u *)"""", TRUE);

    for (int i = 0; i < augroups.ga_len; ++i)
    {
	s = ((char_u **)(augroups.ga_data))[i];
	if (s != get_deleted_augroup())
	    vim_free(s);
    }
    ga_clear(&augroups);

    // aucmd_win[] is freed in win_free_all()
}
#endif

/*
 * Return TRUE if ""win"" is an active entry in aucmd_win[].
 */
    int
is_aucmd_win(win_T *win)
{
    for (int i = 0; i < AUCMD_WIN_COUNT; ++i)
	if (aucmd_win[i].auc_win_used && aucmd_win[i].auc_win == win)
	    return TRUE;
    return FALSE;
}

/*
 * Return the event number for event name ""start"".
 * Return NUM_EVENTS if the event name was not found.
 * Return a pointer to the next event name in ""end"".
 */
    static event_T
event_name2nr(char_u *start, char_u **end)
{
    char_u	*p;
    keyvalue_T target;
    keyvalue_T *entry;
    static keyvalue_T *bufnewfile = &event_tab[BUFNEWFILE_INDEX];
    static keyvalue_T *bufread = &event_tab[BUFREAD_INDEX];

    // the event name ends with end of line, '|', a blank or a comma
    for (p = start; *p && !VIM_ISWHITE(*p) && *p != ',' && *p != '|'; ++p)
	;

    target.key = 0;
    target.value = (char *)start;
    target.length = (size_t)(p - start);

    // special cases:
    // BufNewFile and BufRead are searched for ALOT (especially at startup)
    // so we check for them first.
    if (cmp_keyvalue_value_ni(&target, bufnewfile) == 0)
	entry = bufnewfile;
    else
    if (cmp_keyvalue_value_ni(&target, bufread) == 0)
	entry = bufread;
    else
	entry = (keyvalue_T *)bsearch(&target, &event_tab, ARRAY_LENGTH(event_tab), sizeof(event_tab[0]), cmp_keyvalue_value_ni);

    if (*p == ',')
	++p;
    *end = p;

    return (entry == NULL) ? NUM_EVENTS : (event_T)entry->key;
}

/*
 * Return the name for event ""event"".
 */
    static char_u *
event_nr2name(event_T event)
{
    int	    i;
#define CACHE_SIZE 12
    static int cache_tab[CACHE_SIZE];
    static int cache_last_index = -1;

    if (cache_last_index < 0)
    {
	for (i = 0; i < (int)ARRAY_LENGTH(cache_tab); ++i)
	    cache_tab[i] = -1;
	cache_last_index = ARRAY_LENGTH(cache_tab) - 1;
    }

    // first look in the cache
    // the cache is circular. to search it we start at the most recent entry
    // and go backwards wrapping around when we get to index 0.
    for (i = cache_last_index; cache_tab[i] >= 0; )
    {
	if ((event_T)event_tab[cache_tab[i]].key == event)
	    return (char_u *)event_tab[cache_tab[i]].value;

	if (i == 0)
	    i = ARRAY_LENGTH(cache_tab) - 1;
	else
	    --i;

	// are we back at the start?
	if (i == cache_last_index)
	    break;
    }

    // look in the event table itself
    for (i = 0; i < (int)ARRAY_LENGTH(event_tab); ++i)
    {
	if ((event_T)event_tab[i].key == event)
	{
	    // store the found entry in the next position in the cache,
	    // wrapping around when we get to the maximum index.
	    if (cache_last_index == ARRAY_LENGTH(cache_tab) - 1)
		cache_last_index = 0;
	    else
		++cache_last_index;
	    cache_tab[cache_last_index] = i;
	    break;
	}
    }

    return (i == (int)ARRAY_LENGTH(event_tab)) ? (char_u *)""Unknown"" : (char_u *)event_tab[i].value;
}

/*
 * Scan over the events.  ""*"" stands for all events.
 */
    static char_u *
find_end_event(
    char_u  *arg,
    int	    have_group)	    // TRUE when group name was found
{
    char_u  *pat;
    char_u  *p;

    if (*arg == '*')
    {
	if (arg[1] && !VIM_ISWHITE(arg[1]))
	{
	    semsg(_(e_illegal_character_after_star_str), arg);
	    return NULL;
	}
	pat = arg + 1;
    }
    else
    {
	for (pat = arg; *pat && *pat != '|' && !VIM_ISWHITE(*pat); pat = p)
	{
	    if ((int)event_name2nr(pat, &p) >= NUM_EVENTS)
	    {
		if (have_group)
		    semsg(_(e_no_such_event_str), pat);
		else
		    semsg(_(e_no_such_group_or_event_str), pat);
		return NULL;
	    }
	}
    }
    return pat;
}

/*
 * Return TRUE if ""event"" is included in 'eventignore'.
 */
    static int
event_ignored(event_T event)
{
    char_u	*p = p_ei;

    while (*p != NUL)
    {
	if (STRNICMP(p, ""all"", 3) == 0 && (p[3] == NUL || p[3] == ','))
	    return TRUE;
	if (event_name2nr(p, &p) == event)
	    return TRUE;
    }

    return FALSE;
}

/*
 * Return OK when the contents of p_ei is valid, FAIL otherwise.
 */
    int
check_ei(void)
{
    char_u	*p = p_ei;

    while (*p)
    {
	if (STRNICMP(p, ""all"", 3) == 0 && (p[3] == NUL || p[3] == ','))
	{
	    p += 3;
	    if (*p == ',')
		++p;
	}
	else if (event_name2nr(p, &p) == NUM_EVENTS)
	    return FAIL;
    }

    return OK;
}

# if defined(FEAT_SYN_HL) || defined(PROTO)

/*
 * Add ""what"" to 'eventignore' to skip loading syntax highlighting for every
 * buffer loaded into the window.  ""what"" must start with a comma.
 * Returns the old value of 'eventignore' in allocated memory.
 */
    char_u *
au_event_disable(char *what)
{
    char_u	*new_ei;
    char_u	*save_ei;
    size_t	p_ei_len;

    p_ei_len = STRLEN(p_ei);
    save_ei = vim_strnsave(p_ei, p_ei_len);
    if (save_ei == NULL)
	return NULL;

    new_ei = vim_strnsave(p_ei, p_ei_len + STRLEN(what));
    if (new_ei == NULL)
    {
	vim_free(save_ei);
	return NULL;
    }

    if (*what == ',' && *p_ei == NUL)
	STRCPY(new_ei, what + 1);
    else
	STRCAT(new_ei, what);
    set_string_option_direct((char_u *)""ei"", -1, new_ei,
	    OPT_FREE, SID_NONE);
    vim_free(new_ei);
    return save_ei;
}

    void
au_event_restore(char_u *old_ei)
{
    if (old_ei != NULL)
    {
	set_string_option_direct((char_u *)""ei"", -1, old_ei,
							  OPT_FREE, SID_NONE);
	vim_free(old_ei);
    }
}
# endif  // FEAT_SYN_HL

/*
 * do_autocmd() -- implements the :autocmd command.  Can be used in the
 *  following ways:
 *
 * :autocmd <event> <pat> <cmd>	    Add <cmd> to the list of commands that
 *				    will be automatically executed for <event>
 *				    when editing a file matching <pat>, in
 *				    the current group.
 * :autocmd <event> <pat>	    Show the autocommands associated with
 *				    <event> and <pat>.
 * :autocmd <event>		    Show the autocommands associated with
 *				    <event>.
 * :autocmd			    Show all autocommands.
 * :autocmd! <event> <pat> <cmd>    Remove all autocommands associated with
 *				    <event> and <pat>, and add the command
 *				    <cmd>, for the current group.
 * :autocmd! <event> <pat>	    Remove all autocommands associated with
 *				    <event> and <pat> for the current group.
 * :autocmd! <event>		    Remove all autocommands associated with
 *				    <event> for the current group.
 * :autocmd!			    Remove ALL autocommands for the current
 *				    group.
 *
 *  Multiple events and patterns may be given separated by commas.  Here are
 *  some examples:
 * :autocmd bufread,bufenter *.c,*.h	set tw=0 smartindent noic
 * :autocmd bufleave	     *		set tw=79 nosmartindent ic infercase
 *
 * :autocmd * *.c		show all autocommands for *.c files.
 *
 * Mostly a {group} argument can optionally appear before <event>.
 * ""eap"" can be NULL.
 */
    void
do_autocmd(exarg_T *eap, char_u *arg_in, int forceit)
{
    char_u	*arg = arg_in;
    char_u	*pat;
    char_u	*envpat = NULL;
    char_u	*cmd;
    int		cmd_need_free = FALSE;
    event_T	event;
    char_u	*tofree = NULL;
    int		nested = FALSE;
    int		once = FALSE;
    int		group;
    int		i;
    int		flags = 0;

    if (*arg == '|')
    {
	eap->nextcmd = arg + 1;
	arg = (char_u *)"""";
	group = AUGROUP_ALL;	// no argument, use all groups
    }
    else
    {
	/*
	 * Check for a legal group name.  If not, use AUGROUP_ALL.
	 */
	group = au_get_grouparg(&arg);
	if (arg == NULL)	    // out of memory
	    return;
    }

    /*
     * Scan over the events.
     * If we find an illegal name, return here, don't do anything.
     */
    pat = find_end_event(arg, group != AUGROUP_ALL);
    if (pat == NULL)
	return;

    pat = skipwhite(pat);
    if (*pat == '|')
    {
	eap->nextcmd = pat + 1;
	pat = (char_u *)"""";
	cmd = (char_u *)"""";
    }
    else
    {
	/*
	 * Scan over the pattern.  Put a NUL at the end.
	 */
	cmd = pat;
	while (*cmd && (!VIM_ISWHITE(*cmd) || cmd[-1] == '\\'))
	    cmd++;
	if (*cmd)
	    *cmd++ = NUL;

	// Expand environment variables in the pattern.  Set 'shellslash', we
	// want forward slashes here.
	if (vim_strchr(pat, '$') != NULL || vim_strchr(pat, '~') != NULL)
	{
#ifdef BACKSLASH_IN_FILENAME
	    int	p_ssl_save = p_ssl;

	    p_ssl = TRUE;
#endif
	    envpat = expand_env_save(pat);
#ifdef BACKSLASH_IN_FILENAME
	    p_ssl = p_ssl_save;
#endif
	    if (envpat != NULL)
		pat = envpat;
	}

	cmd = skipwhite(cmd);
	for (i = 0; i < 2; i++)
	{
	    if (*cmd == NUL)
		continue;

	    // Check for ""++once"" flag.
	    if (STRNCMP(cmd, ""++once"", 6) == 0 && VIM_ISWHITE(cmd[6]))
	    {
		if (once)
		    semsg(_(e_duplicate_argument_str), ""++once"");
		once = TRUE;
		cmd = skipwhite(cmd + 6);
	    }

	    // Check for ""++nested"" flag.
	    if ((STRNCMP(cmd, ""++nested"", 8) == 0 && VIM_ISWHITE(cmd[8])))
	    {
		if (nested)
		{
		    semsg(_(e_duplicate_argument_str), ""++nested"");
		    return;
		}
		nested = TRUE;
		cmd = skipwhite(cmd + 8);
	    }

	    // Check for the old ""nested"" flag in legacy script.
	    if (STRNCMP(cmd, ""nested"", 6) == 0 && VIM_ISWHITE(cmd[6]))
	    {
		if (in_vim9script())
		{
		    // If there ever is a :nested command this error should
		    // be removed and ""nested"" accepted as the start of the
		    // command.
		    emsg(_(e_invalid_command_nested_did_you_mean_plusplus_nested));
		    return;
		}
		if (nested)
		{
		    semsg(_(e_duplicate_argument_str), ""nested"");
		    return;
		}
		nested = TRUE;
		cmd = skipwhite(cmd + 6);
	    }
	}

	/*
	 * Find the start of the commands.
	 * Expand <sfile> in it.
	 */
	if (*cmd != NUL)
	{
	    if (eap != NULL)
		// Read a {} block if it follows.
		cmd = may_get_cmd_block(eap, cmd, &tofree, &flags);

	    cmd = expand_sfile(cmd);
	    if (cmd == NULL)	    // some error
		return;
	    cmd_need_free = TRUE;
	}
    }

    /*
     * Print header when showing autocommands.
     */
    if (!forceit && *cmd == NUL)
	// Highlight title
	msg_puts_title(_(""\n--- Autocommands ---""));

    /*
     * Loop over the events.
     */
    last_event = (event_T)-1;		// for listing the event name
    last_group = AUGROUP_ERROR;		// for listing the group name
    if (*arg == '*' || *arg == NUL || *arg == '|')
    {
	if (*cmd != NUL)
	    emsg(_(e_cannot_define_autocommands_for_all_events));
	else
	    for (event = (event_T)0; (int)event < NUM_EVENTS;
					     event = (event_T)((int)event + 1))
		if (do_autocmd_event(event, pat,
			     once, nested, cmd, forceit, group, flags) == FAIL)
		    break;
    }
    else
    {
	while (*arg && *arg != '|' && !VIM_ISWHITE(*arg))
	    if (do_autocmd_event(event_name2nr(arg, &arg), pat,
			  once, nested,	cmd, forceit, group, flags) == FAIL)
		break;
    }

    if (cmd_need_free)
	vim_free(cmd);
    vim_free(tofree);
    vim_free(envpat);
}

/*
 * Find the group ID in a "":autocmd"" or "":doautocmd"" argument.
 * The ""argp"" argument is advanced to the following argument.
 *
 * Returns the group ID, AUGROUP_ERROR for error (out of memory).
 */
    static int
au_get_grouparg(char_u **argp)
{
    char_u	*group_name;
    char_u	*p;
    char_u	*arg = *argp;
    int		group = AUGROUP_ALL;

    for (p = arg; *p && !VIM_ISWHITE(*p) && *p != '|'; ++p)
	;
    if (p <= arg)
	return AUGROUP_ALL;

    group_name = vim_strnsave(arg, p - arg);
    if (group_name == NULL)		// out of memory
	return AUGROUP_ERROR;
    group = au_find_group(group_name);
    if (group == AUGROUP_ERROR)
	group = AUGROUP_ALL;	// no match, use all groups
    else
	*argp = skipwhite(p);	// match, skip over group name
    vim_free(group_name);
    return group;
}

/*
 * do_autocmd() for one event.
 * If *pat == NUL do for all patterns.
 * If *cmd == NUL show entries.
 * If forceit == TRUE delete entries.
 * If group is not AUGROUP_ALL, only use this group.
 */
    static int
do_autocmd_event(
    event_T	event,
    char_u	*pat,
    int		once,
    int		nested,
    char_u	*cmd,
    int		forceit,
    int		group,
    int		flags)
{
    AutoPat	*ap;
    AutoPat	**prev_ap;
    AutoCmd	*ac;
    AutoCmd	**prev_ac;
    int		brace_level;
    char_u	*endpat;
    int		findgroup;
    int		allgroups;
    int		patlen;
    int		is_buflocal;
    int		buflocal_nr;
    char_u	buflocal_pat[25];	// for ""<buffer=X>""

    if (group == AUGROUP_ALL)
	findgroup = current_augroup;
    else
	findgroup = group;
    allgroups = (group == AUGROUP_ALL && !forceit && *cmd == NUL);

    /*
     * Show or delete all patterns for an event.
     */
    if (*pat == NUL)
    {
	FOR_ALL_AUTOCMD_PATTERNS(event, ap)
	{
	    if (forceit)  // delete the AutoPat, if it's in the current group
	    {
		if (ap->group == findgroup)
		    au_remove_pat(ap);
	    }
	    else if (group == AUGROUP_ALL || ap->group == group)
		show_autocmd(ap, event);
	}
    }

    /*
     * Loop through all the specified patterns.
     */
    for ( ; *pat; pat = (*endpat == ',' ? endpat + 1 : endpat))
    {
	/*
	 * Find end of the pattern.
	 * Watch out for a comma in braces, like ""*.\{obj,o\}"".
	 */
	brace_level = 0;
	for (endpat = pat; *endpat && (*endpat != ',' || brace_level
			   || (endpat > pat && endpat[-1] == '\\')); ++endpat)
	{
	    if (*endpat == '{')
		brace_level++;
	    else if (*endpat == '}')
		brace_level--;
	}
	if (pat == endpat)		// ignore single comma
	    continue;
	patlen = (int)(endpat - pat);

	/*
	 * detect special <buflocal[=X]> buffer-local patterns
	 */
	is_buflocal = FALSE;
	buflocal_nr = 0;

	if (patlen >= 8 && STRNCMP(pat, ""<buffer"", 7) == 0
						    && pat[patlen - 1] == '>')
	{
	    // ""<buffer...>"": Error will be printed only for addition.
	    // printing and removing will proceed silently.
	    is_buflocal = TRUE;
	    if (patlen == 8)
		// ""<buffer>""
		buflocal_nr = curbuf->b_fnum;
	    else if (patlen > 9 && pat[7] == '=')
	    {
		if (patlen == 13 && STRNICMP(pat, ""<buffer=abuf>"", 13) == 0)
		    // ""<buffer=abuf>""
		    buflocal_nr = autocmd_bufnr;
		else if (skipdigits(pat + 8) == pat + patlen - 1)
		    // ""<buffer=123>""
		    buflocal_nr = atoi((char *)pat + 8);
	    }
	}

	if (is_buflocal)
	{
	    // normalize pat into standard ""<buffer>#N"" form
	    sprintf((char *)buflocal_pat, ""<buffer=%d>"", buflocal_nr);
	    pat = buflocal_pat;			// can modify pat and patlen
	    patlen = (int)STRLEN(buflocal_pat);	//   but not endpat
	}

	/*
	 * Find AutoPat entries with this pattern.  When adding a command it
	 * always goes at or after the last one, so start at the end.
	 */
	if (!forceit && *cmd != NUL && last_autopat[(int)event] != NULL)
	    prev_ap = &last_autopat[(int)event];
	else
	    prev_ap = &first_autopat[(int)event];
	while ((ap = *prev_ap) != NULL)
	{
	    if (ap->pat != NULL)
	    {
		/*
		 * Accept a pattern when:
		 * - a group was specified and it's that group, or a group was
		 *   not specified and it's the current group, or a group was
		 *   not specified and we are listing
		 * - the length of the pattern matches
		 * - the pattern matches.
		 * For <buffer[=X]>, this condition works because we normalize
		 * all buffer-local patterns.
		 */
		if ((allgroups || ap->group == findgroup)
			&& ap->patlen == patlen
			&& STRNCMP(pat, ap->pat, patlen) == 0)
		{
		    /*
		     * Remove existing autocommands.
		     * If adding any new autocmd's for this AutoPat, don't
		     * delete the pattern from the autopat list, append to
		     * this list.
		     */
		    if (forceit)
		    {
			if (*cmd != NUL && ap->next == NULL)
			{
			    au_remove_cmds(ap);
			    break;
			}
			au_remove_pat(ap);
		    }

		    /*
		     * Show autocmd's for this autopat, or buflocals <buffer=X>
		     */
		    else if (*cmd == NUL)
			show_autocmd(ap, event);

		    /*
		     * Add autocmd to this autopat, if it's the last one.
		     */
		    else if (ap->next == NULL)
			break;
		}
	    }
	    prev_ap = &ap->next;
	}

	/*
	 * Add a new command.
	 */
	if (*cmd != NUL)
	{
	    /*
	     * If the pattern we want to add a command to does appear at the
	     * end of the list (or not is not in the list at all), add the
	     * pattern at the end of the list.
	     */
	    if (ap == NULL)
	    {
		// refuse to add buffer-local ap if buffer number is invalid
		if (is_buflocal && (buflocal_nr == 0
				      || buflist_findnr(buflocal_nr) == NULL))
		{
		    semsg(_(e_buffer_nr_invalid_buffer_number), buflocal_nr);
		    return FAIL;
		}

		ap = ALLOC_ONE(AutoPat);
		if (ap == NULL)
		    return FAIL;
		ap->pat = vim_strnsave(pat, patlen);
		ap->patlen = patlen;
		if (ap->pat == NULL)
		{
		    vim_free(ap);
		    return FAIL;
		}

#ifdef FEAT_EVAL
		// need to initialize last_mode for the first ModeChanged
		// autocmd
		if (event == EVENT_MODECHANGED && !has_modechanged())
		    get_mode(last_mode);
#endif
		// Initialize the fields checked by the WinScrolled and
		// WinResized trigger to prevent them from firing right after
		// the first autocmd is defined.
		if ((event == EVENT_WINSCROLLED || event == EVENT_WINRESIZED)
			&& !(has_winscrolled() || has_winresized()))
		{
		    tabpage_T *save_curtab = curtab;
		    tabpage_T *tp;
		    FOR_ALL_TABPAGES(tp)
		    {
			unuse_tabpage(curtab);
			use_tabpage(tp);
			snapshot_windows_scroll_size();
		    }
		    unuse_tabpage(curtab);
		    use_tabpage(save_curtab);
		}

		if (is_buflocal)
		{
		    ap->buflocal_nr = buflocal_nr;
		    ap->reg_prog = NULL;
		}
		else
		{
		    char_u	*reg_pat;

		    ap->buflocal_nr = 0;
		    reg_pat = file_pat_to_reg_pat(pat, endpat,
							 &ap->allow_dirs, TRUE);
		    if (reg_pat != NULL)
			ap->reg_prog = vim_regcomp(reg_pat, RE_MAGIC);
		    vim_free(reg_pat);
		    if (reg_pat == NULL || ap->reg_prog == NULL)
		    {
			vim_free(ap->pat);
			vim_free(ap);
			return FAIL;
		    }
		}
		ap->cmds = NULL;
		*prev_ap = ap;
		last_autopat[(int)event] = ap;
		ap->next = NULL;
		if (group == AUGROUP_ALL)
		    ap->group = current_augroup;
		else
		    ap->group = group;
	    }

	    /*
	     * Add the autocmd at the end of the AutoCmd list.
	     */
	    prev_ac = &(ap->cmds);
	    while ((ac = *prev_ac) != NULL)
		prev_ac = &ac->next;
	    ac = ALLOC_ONE(AutoCmd);
	    if (ac == NULL)
		return FAIL;
	    ac->cmd = vim_strsave(cmd);
	    ac->script_ctx = current_sctx;
	    if (flags & UC_VIM9)
		ac->script_ctx.sc_version = SCRIPT_VERSION_VIM9;
#ifdef FEAT_EVAL
	    ac->script_ctx.sc_lnum += SOURCING_LNUM;
#endif
	    if (ac->cmd == NULL)
	    {
		vim_free(ac);
		return FAIL;
	    }
	    ac->next = NULL;
	    *prev_ac = ac;
	    ac->once = once;
	    ac->nested = nested;
	}
    }

    au_cleanup();	// may really delete removed patterns/commands now
    return OK;
}

/*
 * Implementation of "":doautocmd [group] event [fname]"".
 * Return OK for success, FAIL for failure;
 */
    int
do_doautocmd(
    char_u	*arg_start,
    int		do_msg,	    // give message for no matching autocmds?
    int		*did_something)
{
    char_u	*arg = arg_start;
    char_u	*fname;
    int		nothing_done = TRUE;
    int		group;

    if (did_something != NULL)
	*did_something = FALSE;

    /*
     * Check for a legal group name.  If not, use AUGROUP_ALL.
     */
    group = au_get_grouparg(&arg);
    if (arg == NULL)	    // out of memory
	return FAIL;

    if (*arg == '*')
    {
	emsg(_(e_cant_execute_autocommands_for_all_events));
	return FAIL;
    }

    /*
     * Scan over the events.
     * If we find an illegal name, return here, don't do anything.
     */
    fname = find_end_event(arg, group != AUGROUP_ALL);
    if (fname == NULL)
	return FAIL;

    fname = skipwhite(fname);

    /*
     * Loop over the events.
     */
    while (*arg && !ends_excmd(*arg) && !VIM_ISWHITE(*arg))
	if (apply_autocmds_group(event_name2nr(arg, &arg),
				      fname, NULL, TRUE, group, curbuf, NULL))
	    nothing_done = FALSE;

    if (nothing_done && do_msg
#ifdef FEAT_EVAL
		&& !aborting()
#endif
	       )
	smsg(_(""No matching autocommands: %s""), arg_start);
    if (did_something != NULL)
	*did_something = !nothing_done;

#ifdef FEAT_EVAL
    return aborting() ? FAIL : OK;
#else
    return OK;
#endif
}

/*
 * "":doautoall"": execute autocommands for each loaded buffer.
 */
    void
ex_doautoall(exarg_T *eap)
{
    int		retval = OK;
    aco_save_T	aco;
    buf_T	*buf;
    bufref_T	bufref;
    char_u	*arg = eap->arg;
    int		call_do_modelines = check_nomodeline(&arg);
    int		did_aucmd;

    /*
     * This is a bit tricky: For some commands curwin->w_buffer needs to be
     * equal to curbuf, but for some buffers there may not be a window.
     * So we change the buffer for the current window for a moment.  This
     * gives problems when the autocommands make changes to the list of
     * buffers or windows...
     */
    FOR_ALL_BUFFERS(buf)
    {
	// Only do loaded buffers and skip the current buffer, it's done last.
	if (buf->b_ml.ml_mfp == NULL || buf == curbuf)
	    continue;

	// Find a window for this buffer and save some values.
	aucmd_prepbuf(&aco, buf);
	if (curbuf != buf)
	{
	    // Failed to find a window for this buffer.  Better not execute
	    // autocommands then.
	    retval = FAIL;
	    break;
	}

	set_bufref(&bufref, buf);

	// execute the autocommands for this buffer
	retval = do_doautocmd(arg, FALSE, &did_aucmd);

	if (call_do_modelines && did_aucmd)
	    // Execute the modeline settings, but don't set window-local
	    // options if we are using the current window for another
	    // buffer.
	    do_modelines(is_aucmd_win(curwin) ? OPT_NOWIN : 0);

	// restore the current window
	aucmd_restbuf(&aco);

	// stop if there is some error or buffer was deleted
	if (retval == FAIL || !bufref_valid(&bufref))
	{
	    retval = FAIL;
	    break;
	}
    }

    // Execute autocommands for the current buffer last.
    if (retval == OK)
    {
	do_doautocmd(arg, FALSE, &did_aucmd);
	if (call_do_modelines && did_aucmd)
	    do_modelines(0);
    }
}

/*
 * Check *argp for <nomodeline>.  When it is present return FALSE, otherwise
 * return TRUE and advance *argp to after it.
 * Thus return TRUE when do_modelines() should be called.
 */
    int
check_nomodeline(char_u **argp)
{
    if (STRNCMP(*argp, ""<nomodeline>"", 12) == 0)
    {
	*argp = skipwhite(*argp + 12);
	return FALSE;
    }
    return TRUE;
}

/*
 * Prepare for executing autocommands for (hidden) buffer ""buf"".
 * Search for a visible window containing the current buffer.  If there isn't
 * one then use an entry in ""aucmd_win[]"".
 * Set ""curbuf"" and ""curwin"" to match ""buf"".
 * When this fails ""curbuf"" is not equal ""buf"".
 */
    void
aucmd_prepbuf(
    aco_save_T	*aco,		// structure to save values in
    buf_T	*buf)		// new curbuf
{
    win_T	*win;
    int		save_ea;
#ifdef FEAT_AUTOCHDIR
    int		save_acd;
#endif

    // Find a window that is for the new buffer
    if (buf == curbuf)		// be quick when buf is curbuf
	win = curwin;
    else
	FOR_ALL_WINDOWS(win)
	    if (win->w_buffer == buf)
		break;

    // Allocate a window when needed.
    win_T *auc_win = NULL;
    int auc_idx = AUCMD_WIN_COUNT;
    if (win == NULL)
    {
	for (auc_idx = 0; auc_idx < AUCMD_WIN_COUNT; ++auc_idx)
	    if (!aucmd_win[auc_idx].auc_win_used)
	    {
		if (aucmd_win[auc_idx].auc_win == NULL)
		    aucmd_win[auc_idx].auc_win = win_alloc_popup_win();
		auc_win = aucmd_win[auc_idx].auc_win;
		if (auc_win != NULL)
		    aucmd_win[auc_idx].auc_win_used = TRUE;
		break;
	    }

	// If this fails (out of memory or using all AUCMD_WIN_COUNT
	// entries) then we can't reliable execute the autocmd, return with
	// ""curbuf"" unequal ""buf"".
	if (auc_win == NULL)
	    return;
    }

    aco->save_curwin_id = curwin->w_id;
    aco->save_prevwin_id = prevwin == NULL ? 0 : prevwin->w_id;
    aco->save_State = State;
#ifdef FEAT_JOB_CHANNEL
    if (bt_prompt(curbuf))
	aco->save_prompt_insert = curbuf->b_prompt_insert;
#endif

    if (win != NULL)
    {
	// There is a window for ""buf"" in the current tab page, make it the
	// curwin.  This is preferred, it has the least side effects (esp. if
	// ""buf"" is curbuf).
	aco->use_aucmd_win_idx = -1;
	curwin = win;
    }
    else
    {
	// There is no window for ""buf"", use ""auc_win"".  To minimize the side
	// effects, insert it in the current tab page.
	// Anything related to a window (e.g., setting folds) may have
	// unexpected results.
	aco->use_aucmd_win_idx = auc_idx;

	win_init_popup_win(auc_win, buf);

	aco->globaldir = globaldir;
	globaldir = NULL;

	// Split the current window, put the auc_win in the upper half.
	// We don't want the BufEnter or WinEnter autocommands.
	block_autocmds();
	make_snapshot(SNAP_AUCMD_IDX);
	save_ea = p_ea;
	p_ea = FALSE;

#ifdef FEAT_AUTOCHDIR
	// Prevent chdir() call in win_enter_ext(), through do_autochdir().
	save_acd = p_acd;
	p_acd = FALSE;
#endif

	(void)win_split_ins(0, WSP_TOP | WSP_FORCE_ROOM, auc_win, 0, NULL);
	(void)win_comp_pos();   // recompute window positions
	p_ea = save_ea;
#ifdef FEAT_AUTOCHDIR
	p_acd = save_acd;
#endif
	unblock_autocmds();
	curwin = auc_win;
    }
    curbuf = buf;
    aco->new_curwin_id = curwin->w_id;
    set_bufref(&aco->new_curbuf, curbuf);

    // disable the Visual area, the position may be invalid in another buffer
    aco->save_VIsual_active = VIsual_active;
    VIsual_active = FALSE;
}

/*
 * Cleanup after executing autocommands for a (hidden) buffer.
 * Restore the window as it was (if possible).
 */
    void
aucmd_restbuf(
    aco_save_T	*aco)		// structure holding saved values
{
    int	    dummy;
    win_T   *save_curwin;

    if (aco->use_aucmd_win_idx >= 0)
    {
	win_T *awp = aucmd_win[aco->use_aucmd_win_idx].auc_win;

	// Find ""awp"", it can't be closed, but it may be in another tab
	// page. Do not trigger autocommands here.
	block_autocmds();
	if (curwin != awp)
	{
	    tabpage_T	*tp;
	    win_T	*wp;

	    FOR_ALL_TAB_WINDOWS(tp, wp)
	    {
		if (wp == awp)
		{
		    if (tp != curtab)
			goto_tabpage_tp(tp, TRUE, TRUE);
		    win_goto(awp);
		    goto win_found;
		}
	    }
	}
win_found:
	--curbuf->b_nwindows;
#ifdef FEAT_JOB_CHANNEL
	int save_stop_insert_mode = stop_insert_mode;
	// May need to stop Insert mode if we were in a prompt buffer.
	leaving_window(curwin);
	// Do not stop Insert mode when already in Insert mode before.
	if (aco->save_State & MODE_INSERT)
	    stop_insert_mode = save_stop_insert_mode;
#endif
	// Remove the window and frame from the tree of frames.
	(void)winframe_remove(curwin, &dummy, NULL, NULL);
	win_remove(curwin, NULL);

	// The window is marked as not used, but it is not freed, it can be
	// used again.
	aucmd_win[aco->use_aucmd_win_idx].auc_win_used = FALSE;
	last_status(FALSE);	    // may need to remove last status line

	if (!valid_tabpage_win(curtab))
	    // no valid window in current tabpage
	    close_tabpage(curtab);

	restore_snapshot(SNAP_AUCMD_IDX, FALSE);
	(void)win_comp_pos();   // recompute window positions
	unblock_autocmds();

	save_curwin = win_find_by_id(aco->save_curwin_id);
	if (save_curwin != NULL)
	    curwin = save_curwin;
	else
	    // Hmm, original window disappeared.  Just use the first one.
	    curwin = firstwin;
	curbuf = curwin->w_buffer;
#ifdef FEAT_JOB_CHANNEL
	// May need to restore insert mode for a prompt buffer.
	entering_window(curwin);
	if (bt_prompt(curbuf))
	    curbuf->b_prompt_insert = aco->save_prompt_insert;
#endif
	prevwin = win_find_by_id(aco->save_prevwin_id);
#ifdef FEAT_EVAL
	vars_clear(&awp->w_vars->dv_hashtab);  // free all w: variables
	hash_init(&awp->w_vars->dv_hashtab);   // re-use the hashtab
#endif
	vim_free(globaldir);
	globaldir = aco->globaldir;

	// the buffer contents may have changed
	VIsual_active = aco->save_VIsual_active;
	check_cursor();
	if (curwin->w_topline > curbuf->b_ml.ml_line_count)
	{
	    curwin->w_topline = curbuf->b_ml.ml_line_count;
#ifdef FEAT_DIFF
	    curwin->w_topfill = 0;
#endif
	}
#if defined(FEAT_GUI)
	if (gui.in_use)
	{
	    // Hide the scrollbars from the ""awp"" and update.
	    gui_mch_enable_scrollbar(&awp->w_scrollbars[SBAR_LEFT], FALSE);
	    gui_mch_enable_scrollbar(&awp->w_scrollbars[SBAR_RIGHT], FALSE);
	    gui_may_update_scrollbars();
	}
#endif
    }
    else
    {
	// Restore curwin.  Use the window ID, a window may have been closed
	// and the memory re-used for another one.
	save_curwin = win_find_by_id(aco->save_curwin_id);
	if (save_curwin != NULL)
	{
	    // Restore the buffer which was previously edited by curwin, if
	    // it was changed, we are still the same window and the buffer is
	    // valid.
	    if (curwin->w_id == aco->new_curwin_id
		    && curbuf != aco->new_curbuf.br_buf
		    && bufref_valid(&aco->new_curbuf)
		    && aco->new_curbuf.br_buf->b_ml.ml_mfp != NULL)
	    {
# if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)
		if (curwin->w_s == &curbuf->b_s)
		    curwin->w_s = &aco->new_curbuf.br_buf->b_s;
# endif
		--curbuf->b_nwindows;
		curbuf = aco->new_curbuf.br_buf;
		curwin->w_buffer = curbuf;
		++curbuf->b_nwindows;
	    }

	    curwin = save_curwin;
	    curbuf = curwin->w_buffer;
	    prevwin = win_find_by_id(aco->save_prevwin_id);

	    // In case the autocommand moves the cursor to a position that
	    // does not exist in curbuf.
	    VIsual_active = aco->save_VIsual_active;
	    check_cursor();
	}
    }

    VIsual_active = aco->save_VIsual_active;
    check_cursor();	    // just in case lines got deleted
    if (VIsual_active)
	check_pos(curbuf, &VIsual);
}

static int	autocmd_nested = FALSE;

/*
 * Execute autocommands for ""event"" and file name ""fname"".
 * Return TRUE if some commands were executed.
 */
    int
apply_autocmds(
    event_T	event,
    char_u	*fname,	    // NULL or empty means use actual file name
    char_u	*fname_io,  // fname to use for <afile> on cmdline
    int		force,	    // when TRUE, ignore autocmd_busy
    buf_T	*buf)	    // buffer for <abuf>
{
    return apply_autocmds_group(event, fname, fname_io, force,
						      AUGROUP_ALL, buf, NULL);
}

/*
 * Like apply_autocmds(), but with extra ""eap"" argument.  This takes care of
 * setting v:filearg.
 */
    int
apply_autocmds_exarg(
    event_T	event,
    char_u	*fname,
    char_u	*fname_io,
    int		force,
    buf_T	*buf,
    exarg_T	*eap)
{
    return apply_autocmds_group(event, fname, fname_io, force,
						       AUGROUP_ALL, buf, eap);
}

/*
 * Like apply_autocmds(), but handles the caller's retval.  If the script
 * processing is being aborted or if retval is FAIL when inside a try
 * conditional, no autocommands are executed.  If otherwise the autocommands
 * cause the script to be aborted, retval is set to FAIL.
 */
    int
apply_autocmds_retval(
    event_T	event,
    char_u	*fname,	    // NULL or empty means use actual file name
    char_u	*fname_io,  // fname to use for <afile> on cmdline
    int		force,	    // when TRUE, ignore autocmd_busy
    buf_T	*buf,	    // buffer for <abuf>
    int		*retval)    // pointer to caller's retval
{
    int		did_cmd;

#ifdef FEAT_EVAL
    if (should_abort(*retval))
	return FALSE;
#endif

    did_cmd = apply_autocmds_group(event, fname, fname_io, force,
						      AUGROUP_ALL, buf, NULL);
    if (did_cmd
#ifdef FEAT_EVAL
	    && aborting()
#endif
	    )
	*retval = FAIL;
    return did_cmd;
}

/*
 * Return TRUE when there is a CursorHold autocommand defined.
 */
    static int
has_cursorhold(void)
{
    return (first_autopat[(int)(get_real_state() == MODE_NORMAL_BUSY
			    ? EVENT_CURSORHOLD : EVENT_CURSORHOLDI)] != NULL);
}

/*
 * Return TRUE if the CursorHold event can be triggered.
 */
    int
trigger_cursorhold(void)
{
    int		state;

    if (!did_cursorhold
	    && has_cursorhold()
	    && reg_recording == 0
	    && typebuf.tb_len == 0
	    && !ins_compl_active())
    {
	state = get_real_state();
	if (state == MODE_NORMAL_BUSY || (state & MODE_INSERT) != 0)
	    return TRUE;
    }
    return FALSE;
}

/*
 * Return TRUE when there is a WinResized autocommand defined.
 */
    int
has_winresized(void)
{
    return (first_autopat[(int)EVENT_WINRESIZED] != NULL);
}

/*
 * Return TRUE when there is a WinScrolled autocommand defined.
 */
    int
has_winscrolled(void)
{
    return (first_autopat[(int)EVENT_WINSCROLLED] != NULL);
}

/*
 * Return TRUE when there is a CursorMoved autocommand defined.
 */
    int
has_cursormoved(void)
{
    return (first_autopat[(int)EVENT_CURSORMOVED] != NULL);
}

/*
 * Return TRUE when there is a CursorMovedI autocommand defined.
 */
    int
has_cursormovedI(void)
{
    return (first_autopat[(int)EVENT_CURSORMOVEDI] != NULL);
}

/*
 * Return TRUE when there is a TextChanged autocommand defined.
 */
    int
has_textchanged(void)
{
    return (first_autopat[(int)EVENT_TEXTCHANGED] != NULL);
}

/*
 * Return TRUE when there is a TextChangedI autocommand defined.
 */
    int
has_textchangedI(void)
{
    return (first_autopat[(int)EVENT_TEXTCHANGEDI] != NULL);
}

/*
 * Return TRUE when there is a TextChangedP autocommand defined.
 */
    int
has_textchangedP(void)
{
    return (first_autopat[(int)EVENT_TEXTCHANGEDP] != NULL);
}

/*
 * Return TRUE when there is an InsertCharPre autocommand defined.
 */
    int
has_insertcharpre(void)
{
    return (first_autopat[(int)EVENT_INSERTCHARPRE] != NULL);
}

/*
 * Return TRUE when there is an CmdUndefined autocommand defined.
 */
    int
has_cmdundefined(void)
{
    return (first_autopat[(int)EVENT_CMDUNDEFINED] != NULL);
}

#if defined(FEAT_EVAL) || defined(PROTO)
/*
 * Return TRUE when there is a TextYankPost autocommand defined.
 */
    int
has_textyankpost(void)
{
    return (first_autopat[(int)EVENT_TEXTYANKPOST] != NULL);
}
#endif

#if defined(FEAT_EVAL) || defined(PROTO)
/*
 * Return TRUE when there is a CompleteChanged autocommand defined.
 */
    int
has_completechanged(void)
{
    return (first_autopat[(int)EVENT_COMPLETECHANGED] != NULL);
}
#endif

#if defined(FEAT_EVAL) || defined(PROTO)
/*
 * Return TRUE when there is a ModeChanged autocommand defined.
 */
    int
has_modechanged(void)
{
    return (first_autopat[(int)EVENT_MODECHANGED] != NULL);
}
#endif

/*
 * Execute autocommands for ""event"" and file name ""fname"".
 * Return TRUE if some commands were executed.
 */
    static int
apply_autocmds_group(
    event_T	event,
    char_u	*fname,	     // NULL or empty means use actual file name
    char_u	*fname_io,   // fname to use for <afile> on cmdline, NULL means
			     // use fname
    int		force,	     // when TRUE, ignore autocmd_busy
    int		group,	     // group ID, or AUGROUP_ALL
    buf_T	*buf,	     // buffer for <abuf>
    exarg_T	*eap UNUSED) // command arguments
{
    char_u	*sfname = NULL;	// short file name
    char_u	*tail;
    int		save_changed;
    buf_T	*old_curbuf;
    int		retval = FALSE;
    char_u	*save_autocmd_fname;
    int		save_autocmd_fname_full;
    int		save_autocmd_bufnr;
    char_u	*save_autocmd_match;
    int		save_autocmd_busy;
    int		save_autocmd_nested;
    static int	nesting = 0;
    AutoPatCmd_T patcmd;
    AutoPat	*ap;
    sctx_T	save_current_sctx;
#ifdef FEAT_EVAL
    funccal_entry_T funccal_entry;
    char_u	*save_cmdarg;
    long	save_cmdbang;
#endif
    static int	filechangeshell_busy = FALSE;
#ifdef FEAT_PROFILE
    proftime_T	wait_time;
#endif
    int		did_save_redobuff = FALSE;
    save_redo_T	save_redo;
    int		save_KeyTyped = KeyTyped;
    ESTACK_CHECK_DECLARATION;

    /*
     * Quickly return if there are no autocommands for this event or
     * autocommands are blocked.
     */
    if (event == NUM_EVENTS || first_autopat[(int)event] == NULL
	    || autocmd_blocked > 0)
	goto BYPASS_AU;

    /*
     * When autocommands are busy, new autocommands are only executed when
     * explicitly enabled with the ""nested"" flag.
     */
    if (autocmd_busy && !(force || autocmd_nested))
	goto BYPASS_AU;

#ifdef FEAT_EVAL
    /*
     * Quickly return when immediately aborting on error, or when an interrupt
     * occurred or an exception was thrown but not caught.
     */
    if (aborting())
	goto BYPASS_AU;
#endif

    /*
     * FileChangedShell never nests, because it can create an endless loop.
     */
    if (filechangeshell_busy && (event == EVENT_FILECHANGEDSHELL
				      || event == EVENT_FILECHANGEDSHELLPOST))
	goto BYPASS_AU;

    /*
     * Ignore events in 'eventignore'.
     */
    if (event_ignored(event))
	goto BYPASS_AU;

    /*
     * Allow nesting of autocommands, but restrict the depth, because it's
     * possible to create an endless loop.
     */
    if (nesting == 10)
    {
	emsg(_(e_autocommand_nesting_too_deep));
	goto BYPASS_AU;
    }

    /*
     * Check if these autocommands are disabled.  Used when doing "":all"" or
     * "":ball"".
     */
    if (       (autocmd_no_enter
		&& (event == EVENT_WINENTER || event == EVENT_BUFENTER))
	    || (autocmd_no_leave
		&& (event == EVENT_WINLEAVE || event == EVENT_BUFLEAVE)))
	goto BYPASS_AU;

    if (event == EVENT_CMDLINECHANGED)
	++aucmd_cmdline_changed_count;

    /*
     * Save the autocmd_* variables and info about the current buffer.
     */
    save_autocmd_fname = autocmd_fname;
    save_autocmd_fname_full = autocmd_fname_full;
    save_autocmd_bufnr = autocmd_bufnr;
    save_autocmd_match = autocmd_match;
    save_autocmd_busy = autocmd_busy;
    save_autocmd_nested = autocmd_nested;
    save_changed = curbuf->b_changed;
    old_curbuf = curbuf;

    /*
     * Set the file name to be used for <afile>.
     * Make a copy to avoid that changing a buffer name or directory makes it
     * invalid.
     */
    if (fname_io == NULL)
    {
	if (event == EVENT_COLORSCHEME || event == EVENT_COLORSCHEMEPRE
						 || event == EVENT_OPTIONSET
						 || event == EVENT_MODECHANGED
						 || event == EVENT_TERMRESPONSEALL)
	    autocmd_fname = NULL;
	else if (fname != NULL && !ends_excmd(*fname))
	    autocmd_fname = fname;
	else if (buf != NULL)
	    autocmd_fname = buf->b_ffname;
	else
	    autocmd_fname = NULL;
    }
    else
	autocmd_fname = fname_io;
    if (autocmd_fname != NULL)
	autocmd_fname = vim_strsave(autocmd_fname);
    autocmd_fname_full = FALSE; // call FullName_save() later

    /*
     * Set the buffer number to be used for <abuf>.
     */
    if (buf == NULL)
	autocmd_bufnr = 0;
    else
	autocmd_bufnr = buf->b_fnum;

    /*
     * When the file name is NULL or empty, use the file name of buffer ""buf"".
     * Always use the full path of the file name to match with, in case
     * ""allow_dirs"" is set.
     */
    if (fname == NULL || *fname == NUL)
    {
	if (buf == NULL)
	    fname = NULL;
	else
	{
#ifdef FEAT_SYN_HL
	    if (event == EVENT_SYNTAX)
		fname = buf->b_p_syn;
	    else
#endif
		if (event == EVENT_FILETYPE)
		    fname = buf->b_p_ft;
		else
		{
		    if (buf->b_sfname != NULL)
			sfname = vim_strsave(buf->b_sfname);
		    fname = buf->b_ffname;
		}
	}
	if (fname == NULL)
	    fname = (char_u *)"""";
	fname = vim_strsave(fname);	// make a copy, so we can change it
    }
    else
    {
	sfname = vim_strsave(fname);
	// Don't try expanding FileType, Syntax, FuncUndefined, WindowID,
	// ColorScheme, QuickFixCmd*, DirChanged and similar.
	if (event == EVENT_FILETYPE
		|| event == EVENT_SYNTAX
		|| event == EVENT_CMDLINECHANGED
		|| event == EVENT_CMDLINEENTER
		|| event == EVENT_CMDLINELEAVE
		|| event == EVENT_CMDWINENTER
		|| event == EVENT_CMDWINLEAVE
		|| event == EVENT_CMDUNDEFINED
		|| event == EVENT_FUNCUNDEFINED
		|| event == EVENT_REMOTEREPLY
		|| event == EVENT_SPELLFILEMISSING
		|| event == EVENT_QUICKFIXCMDPRE
		|| event == EVENT_COLORSCHEME
		|| event == EVENT_COLORSCHEMEPRE
		|| event == EVENT_OPTIONSET
		|| event == EVENT_QUICKFIXCMDPOST
		|| event == EVENT_DIRCHANGED
		|| event == EVENT_DIRCHANGEDPRE
		|| event == EVENT_MODECHANGED
		|| event == EVENT_MENUPOPUP
		|| event == EVENT_USER
		|| event == EVENT_WINCLOSED
		|| event == EVENT_WINRESIZED
		|| event == EVENT_WINSCROLLED
		|| event == EVENT_TERMRESPONSEALL)
	{
	    fname = vim_strsave(fname);
	    autocmd_fname_full = TRUE; // don't expand it later
	}
	else
	    fname = FullName_save(fname, FALSE);
    }
    if (fname == NULL)	    // out of memory
    {
	vim_free(sfname);
	retval = FALSE;
	goto BYPASS_AU;
    }

#ifdef BACKSLASH_IN_FILENAME
    /*
     * Replace all backslashes with forward slashes.  This makes the
     * autocommand patterns portable between Unix and MS-DOS.
     */
    if (sfname != NULL)
	forward_slash(sfname);
    forward_slash(fname);
#endif

#ifdef VMS
    // remove version for correct match
    if (sfname != NULL)
	vms_remove_version(sfname);
    vms_remove_version(fname);
#endif

    /*
     * Set the name to be used for <amatch>.
     */
    autocmd_match = fname;


    // Don't redraw while doing autocommands.
    ++RedrawingDisabled;

    // name and lnum are filled in later
    estack_push(ETYPE_AUCMD, NULL, 0);
    ESTACK_CHECK_SETUP;

    save_current_sctx = current_sctx;

#ifdef FEAT_EVAL
# ifdef FEAT_PROFILE
    if (do_profiling == PROF_YES)
	prof_child_enter(&wait_time); // doesn't count for the caller itself
# endif

    // Don't use local function variables, if called from a function.
    save_funccal(&funccal_entry);
#endif

    /*
     * When starting to execute autocommands, save the search patterns.
     */
    if (!autocmd_busy)
    {
	save_search_patterns();
	if (!ins_compl_active())
	{
	    saveRedobuff(&save_redo);
	    did_save_redobuff = TRUE;
	}
	curbuf->b_did_filetype = curbuf->b_keep_filetype;
    }

    /*
     * Note that we are applying autocmds.  Some commands need to know.
     */
    autocmd_busy = TRUE;
    filechangeshell_busy = (event == EVENT_FILECHANGEDSHELL);
    ++nesting;		// see matching decrement below

    // Remember that FileType was triggered.  Used for did_filetype().
    if (event == EVENT_FILETYPE)
	curbuf->b_did_filetype = TRUE;

    tail = gettail(fname);

    // Find first autocommand that matches
    CLEAR_FIELD(patcmd);
    patcmd.curpat = first_autopat[(int)event];
    patcmd.group = group;
    patcmd.fname = fname;
    patcmd.sfname = sfname;
    patcmd.tail = tail;
    patcmd.event = event;
    patcmd.arg_bufnr = autocmd_bufnr;
    auto_next_pat(&patcmd, FALSE);

    // found one, start executing the autocommands
    if (patcmd.curpat != NULL)
    {
	// add to active_apc_list
	patcmd.next = active_apc_list;
	active_apc_list = &patcmd;

#ifdef FEAT_EVAL
	// set v:cmdarg (only when there is a matching pattern)
	save_cmdbang = (long)get_vim_var_nr(VV_CMDBANG);
	if (eap != NULL)
	{
	    save_cmdarg = set_cmdarg(eap, NULL);
	    set_vim_var_nr(VV_CMDBANG, (long)eap->forceit);
	}
	else
	    save_cmdarg = NULL;	// avoid gcc warning
#endif
	retval = TRUE;
	// mark the last pattern, to avoid an endless loop when more patterns
	// are added when executing autocommands
	for (ap = patcmd.curpat; ap->next != NULL; ap = ap->next)
	    ap->last = FALSE;
	ap->last = TRUE;

	// Make sure cursor and topline are valid.  The first time the current
	// values are saved, restored by reset_lnums().  When nested only the
	// values are corrected when needed.
	if (nesting == 1)
	    check_lnums(TRUE);
	else
	    check_lnums_nested(TRUE);

	int save_did_emsg = did_emsg;
	int save_ex_pressedreturn = get_pressedreturn();

	do_cmdline(NULL, getnextac, (void *)&patcmd,
				     DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);

	did_emsg += save_did_emsg;
	set_pressedreturn(save_ex_pressedreturn);

	if (nesting == 1)
	    // restore cursor and topline, unless they were changed
	    reset_lnums();

#ifdef FEAT_EVAL
	if (eap != NULL)
	{
	    (void)set_cmdarg(NULL, save_cmdarg);
	    set_vim_var_nr(VV_CMDBANG, save_cmdbang);
	}
#endif
	// delete from active_apc_list
	if (active_apc_list == &patcmd)	    // just in case
	    active_apc_list = patcmd.next;
    }

    if (RedrawingDisabled > 0)
	--RedrawingDisabled;
    autocmd_busy = save_autocmd_busy;
    filechangeshell_busy = FALSE;
    autocmd_nested = save_autocmd_nested;
    vim_free(SOURCING_NAME);
    ESTACK_CHECK_NOW;
    estack_pop();
    vim_free(autocmd_fname);
    autocmd_fname = save_autocmd_fname;
    autocmd_fname_full = save_autocmd_fname_full;
    autocmd_bufnr = save_autocmd_bufnr;
    autocmd_match = save_autocmd_match;
    current_sctx = save_current_sctx;
#ifdef FEAT_EVAL
    restore_funccal();
# ifdef FEAT_PROFILE
    if (do_profiling == PROF_YES)
	prof_child_exit(&wait_time);
# endif
#endif
    KeyTyped = save_KeyTyped;
    vim_free(fname);
    vim_free(sfname);
    --nesting;		// see matching increment above

    /*
     * When stopping to execute autocommands, restore the search patterns and
     * the redo buffer.  Free any buffers in the au_pending_free_buf list and
     * free any windows in the au_pending_free_win list.
     */
    if (!autocmd_busy)
    {
	restore_search_patterns();
	if (did_save_redobuff)
	    restoreRedobuff(&save_redo);
	curbuf->b_did_filetype = FALSE;
	while (au_pending_free_buf != NULL)
	{
	    buf_T *b = au_pending_free_buf->b_next;

	    vim_free(au_pending_free_buf);
	    au_pending_free_buf = b;
	}
	while (au_pending_free_win != NULL)
	{
	    win_T *w = au_pending_free_win->w_next;

	    vim_free(au_pending_free_win);
	    au_pending_free_win = w;
	}
    }

    /*
     * Some events don't set or reset the Changed flag.
     * Check if still in the same buffer!
     */
    if (curbuf == old_curbuf
	    && (event == EVENT_BUFREADPOST
		|| event == EVENT_BUFWRITEPOST
		|| event == EVENT_FILEAPPENDPOST
		|| event == EVENT_VIMLEAVE
		|| event == EVENT_VIMLEAVEPRE))
    {
	if (curbuf->b_changed != save_changed)
	    need_maketitle = TRUE;
	curbuf->b_changed = save_changed;
    }

    au_cleanup();	// may really delete removed patterns/commands now

BYPASS_AU:
    // When wiping out a buffer make sure all its buffer-local autocommands
    // are deleted.
    if (event == EVENT_BUFWIPEOUT && buf != NULL)
	aubuflocal_remove(buf);

    if (retval == OK && event == EVENT_FILETYPE)
	curbuf->b_au_did_filetype = TRUE;

    return retval;
}

# ifdef FEAT_EVAL
static char_u	*old_termresponse = NULL;
static char_u	*old_termu7resp = NULL;
static char_u	*old_termblinkresp = NULL;
static char_u	*old_termrbgresp = NULL;
static char_u	*old_termrfgresp = NULL;
static char_u	*old_termstyleresp = NULL;
# endif

/*
 * Block triggering autocommands until unblock_autocmd() is called.
 * Can be used recursively, so long as it's symmetric.
 */
    void
block_autocmds(void)
{
# ifdef FEAT_EVAL
    // Remember the value of v:termresponse.
    if (autocmd_blocked == 0)
    {
	old_termresponse = get_vim_var_str(VV_TERMRESPONSE);
	old_termu7resp = get_vim_var_str(VV_TERMU7RESP);
	old_termblinkresp = get_vim_var_str(VV_TERMBLINKRESP);
	old_termrbgresp = get_vim_var_str(VV_TERMRBGRESP);
	old_termrfgresp = get_vim_var_str(VV_TERMRFGRESP);
	old_termstyleresp = get_vim_var_str(VV_TERMSTYLERESP);
    }
# endif
    ++autocmd_blocked;
}

    void
unblock_autocmds(void)
{
    --autocmd_blocked;

# ifdef FEAT_EVAL
    // When v:termresponse, etc, were set while autocommands were blocked,
    // trigger the autocommands now.  Esp. useful when executing a shell
    // command during startup (vimdiff).
    if (autocmd_blocked == 0)
    {
	if (get_vim_var_str(VV_TERMRESPONSE) != old_termresponse)
	{
	    apply_autocmds(EVENT_TERMRESPONSE, NULL, NULL, FALSE, curbuf);
	    apply_autocmds(EVENT_TERMRESPONSEALL, (char_u *)""version"", NULL, FALSE, curbuf);
	}
	if (get_vim_var_str(VV_TERMU7RESP) != old_termu7resp)
	{
	    apply_autocmds(EVENT_TERMRESPONSEALL, (char_u *)""ambiguouswidth"", NULL, FALSE, curbuf);
	}
	if (get_vim_var_str(VV_TERMBLINKRESP) != old_termblinkresp)
	{
	    apply_autocmds(EVENT_TERMRESPONSEALL, (char_u *)""cursorblink"", NULL, FALSE, curbuf);
	}
	if (get_vim_var_str(VV_TERMRBGRESP) != old_termrbgresp)
	{
	    apply_autocmds(EVENT_TERMRESPONSEALL, (char_u *)""background"", NULL, FALSE, curbuf);
	}
	if (get_vim_var_str(VV_TERMRFGRESP) != old_termrfgresp)
	{
	    apply_autocmds(EVENT_TERMRESPONSEALL, (char_u *)""foreground"", NULL, FALSE, curbuf);
	}
	if (get_vim_var_str(VV_TERMSTYLERESP) != old_termstyleresp)
	{
	    apply_autocmds(EVENT_TERMRESPONSEALL, (char_u *)""cursorshape"", NULL, FALSE, curbuf);
	}
    }
# endif
}

    int
is_autocmd_blocked(void)
{
    return autocmd_blocked != 0;
}

/*
 * Find next autocommand pattern that matches.
 */
    static void
auto_next_pat(
    AutoPatCmd_T *apc,
    int		stop_at_last)	    // stop when 'last' flag is set
{
    AutoPat	*ap;
    AutoCmd	*cp;
    char_u	*name;
    char	*s;
    estack_T	*entry;
    char_u	*namep;

    entry = ((estack_T *)exestack.ga_data) + exestack.ga_len - 1;

    // Clear the exestack entry for this ETYPE_AUCMD entry.
    VIM_CLEAR(entry->es_name);
    entry->es_info.aucmd = NULL;

    for (ap = apc->curpat; ap != NULL && !got_int; ap = ap->next)
    {
	apc->curpat = NULL;

	// Only use a pattern when it has not been removed, has commands and
	// the group matches. For buffer-local autocommands only check the
	// buffer number.
	if (ap->pat != NULL && ap->cmds != NULL
		&& (apc->group == AUGROUP_ALL || apc->group == ap->group))
	{
	    // execution-condition
	    if (ap->buflocal_nr == 0
		    ? (match_file_pat(NULL, &ap->reg_prog, apc->fname,
				      apc->sfname, apc->tail, ap->allow_dirs))
		    : ap->buflocal_nr == apc->arg_bufnr)
	    {
		name = event_nr2name(apc->event);
		s = _(""%s Autocommands for \""%s\"""");
		namep = alloc(STRLEN(s) + STRLEN(name) + ap->patlen + 1);
		if (namep != NULL)
		{
		    sprintf((char *)namep, s, (char *)name, (char *)ap->pat);
		    if (p_verbose >= 8)
		    {
			verbose_enter();
			smsg(_(""Executing %s""), namep);
			verbose_leave();
		    }
		}

		// Update the exestack entry for this autocmd.
		entry->es_name = namep;
		entry->es_info.aucmd = apc;

		apc->curpat = ap;
		apc->nextcmd = ap->cmds;
		// mark last command
		for (cp = ap->cmds; cp->next != NULL; cp = cp->next)
		    cp->last = FALSE;
		cp->last = TRUE;
	    }
	    line_breakcheck();
	    if (apc->curpat != NULL)	    // found a match
		break;
	}
	if (stop_at_last && ap->last)
	    break;
    }
}

#if defined(FEAT_EVAL) || defined(PROTO)
/*
 * Get the script context where autocommand ""acp"" is defined.
 */
    sctx_T *
acp_script_ctx(AutoPatCmd_T *acp)
{
    return &acp->script_ctx;
}
#endif

/*
 * Get next autocommand command.
 * Called by do_cmdline() to get the next line for "":if"".
 * Returns allocated string, or NULL for end of autocommands.
 */
    char_u *
getnextac(
	int c UNUSED,
	void *cookie,
	int indent UNUSED,
	getline_opt_T options UNUSED)
{
    AutoPatCmd_T    *acp = (AutoPatCmd_T *)cookie;
    char_u	    *retval;
    AutoCmd	    *ac;

    // Can be called again after returning the last line.
    if (acp->curpat == NULL)
	return NULL;

    // repeat until we find an autocommand to execute
    for (;;)
    {
	// skip removed commands
	while (acp->nextcmd != NULL && acp->nextcmd->cmd == NULL)
	    if (acp->nextcmd->last)
		acp->nextcmd = NULL;
	    else
		acp->nextcmd = acp->nextcmd->next;

	if (acp->nextcmd != NULL)
	    break;

	// at end of commands, find next pattern that matches
	if (acp->curpat->last)
	    acp->curpat = NULL;
	else
	    acp->curpat = acp->curpat->next;
	if (acp->curpat != NULL)
	    auto_next_pat(acp, TRUE);
	if (acp->curpat == NULL)
	    return NULL;
    }

    ac = acp->nextcmd;

    if (p_verbose >= 9)
    {
	verbose_enter_scroll();
	smsg(_(""autocommand %s""), ac->cmd);
	msg_puts(""\n"");   // don't overwrite this either
	verbose_leave_scroll();
    }
    retval = vim_strsave(ac->cmd);
    // Remove one-shot (""once"") autocmd in anticipation of its execution.
    if (ac->once)
	au_del_cmd(ac);
    autocmd_nested = ac->nested;
    current_sctx = ac->script_ctx;
    acp->script_ctx = current_sctx;
    if (ac->last)
	acp->nextcmd = NULL;
    else
	acp->nextcmd = ac->next;
    return retval;
}

/*
 * Return TRUE if there is a matching autocommand for ""fname"".
 * To account for buffer-local autocommands, function needs to know
 * in which buffer the file will be opened.
 */
    int
has_autocmd(event_T event, char_u *sfname, buf_T *buf)
{
    AutoPat	*ap;
    char_u	*fname;
    char_u	*tail = gettail(sfname);
    int		retval = FALSE;

    fname = FullName_save(sfname, FALSE);
    if (fname == NULL)
	return FALSE;

#ifdef BACKSLASH_IN_FILENAME
    /*
     * Replace all backslashes with forward slashes.  This makes the
     * autocommand patterns portable between Unix and MS-DOS.
     */
    sfname = vim_strsave(sfname);
    if (sfname != NULL)
	forward_slash(sfname);
    forward_slash(fname);
#endif

    FOR_ALL_AUTOCMD_PATTERNS(event, ap)
	if (ap->pat != NULL && ap->cmds != NULL
	      && (ap->buflocal_nr == 0
		? match_file_pat(NULL, &ap->reg_prog,
					  fname, sfname, tail, ap->allow_dirs)
		: buf != NULL && ap->buflocal_nr == buf->b_fnum
	   ))
	{
	    retval = TRUE;
	    break;
	}

    vim_free(fname);
#ifdef BACKSLASH_IN_FILENAME
    vim_free(sfname);
#endif

    return retval;
}

/*
 * Function given to ExpandGeneric() to obtain the list of autocommand group
 * names.
 */
    char_u *
get_augroup_name(expand_T *xp UNUSED, int idx)
{
    if (idx == augroups.ga_len)		// add ""END"" add the end
	return (char_u *)""END"";
    if (idx < 0 || idx >= augroups.ga_len)	// end of list
	return NULL;
    if (AUGROUP_NAME(idx) == NULL || AUGROUP_NAME(idx) == get_deleted_augroup())
	// skip deleted entries
	return (char_u *)"""";
    return AUGROUP_NAME(idx);		// return a name
}

static int include_groups = FALSE;

    char_u  *
set_context_in_autocmd(
    expand_T	*xp,
    char_u	*arg,
    int		doautocmd)	// TRUE for :doauto*, FALSE for :autocmd
{
    char_u	*p;
    int		group;

    // check for a group name, skip it if present
    include_groups = FALSE;
    p = arg;
    group = au_get_grouparg(&arg);
    if (group == AUGROUP_ERROR)
	return NULL;
    // If there only is a group name that's what we expand.
    if (*arg == NUL && group != AUGROUP_ALL && !VIM_ISWHITE(arg[-1]))
    {
	arg = p;
	group = AUGROUP_ALL;
    }

    // skip over event name
    for (p = arg; *p != NUL && !VIM_ISWHITE(*p); ++p)
	if (*p == ',')
	    arg = p + 1;
    if (*p == NUL)
    {
	if (group == AUGROUP_ALL)
	    include_groups = TRUE;
	xp->xp_context = EXPAND_EVENTS;	    // expand event name
	xp->xp_pattern = arg;
	return NULL;
    }

    // skip over pattern
    arg = skipwhite(p);
    while (*arg && (!VIM_ISWHITE(*arg) || arg[-1] == '\\'))
	arg++;
    if (*arg)
	return arg;			    // expand (next) command

    if (doautocmd)
	xp->xp_context = EXPAND_FILES;	    // expand file names
    else
	xp->xp_context = EXPAND_NOTHING;    // pattern is not expanded
    return NULL;
}

/*
 * Function given to ExpandGeneric() to obtain the list of event names.
 */
    char_u *
get_event_name(expand_T *xp UNUSED, int idx)
{
    int i;

    if (idx < augroups.ga_len)		// First list group names, if wanted
    {
	if (!include_groups || AUGROUP_NAME(idx) == NULL
				 || AUGROUP_NAME(idx) == get_deleted_augroup())
	    return (char_u *)"""";	// skip deleted entries
	return AUGROUP_NAME(idx);	// return a name
    }

    i = idx - augroups.ga_len;
    if (i < 0 || i >= (int)ARRAY_LENGTH(event_tab))
	return NULL;

    return (char_u *)event_tab[i].value;
}

/*
 * Function given to ExpandGeneric() to obtain the list of event names. Don't
 * include groups.
 */
    char_u *
get_event_name_no_group(expand_T *xp UNUSED, int idx)
{
    if (idx < 0 || idx >= (int)ARRAY_LENGTH(event_tab))
	return NULL;

    return (char_u *)event_tab[idx].value;
}


#if defined(FEAT_EVAL) || defined(PROTO)
/*
 * Return TRUE if autocmd is supported.
 */
    int
autocmd_supported(char_u *name)
{
    char_u *p;

    return (event_name2nr(name, &p) != NUM_EVENTS);
}

/*
 * Return TRUE if an autocommand is defined for a group, event and
 * pattern:  The group can be omitted to accept any group. ""event"" and ""pattern""
 * can be NULL to accept any event and pattern. ""pattern"" can be NULL to accept
 * any pattern. Buffer-local patterns <buffer> or <buffer=N> are accepted.
 * Used for:
 *	exists(""#Group"") or
 *	exists(""#Group#Event"") or
 *	exists(""#Group#Event#pat"") or
 *	exists(""#Event"") or
 *	exists(""#Event#pat"")
 */
    int
au_exists(char_u *arg)
{
    char_u	*arg_save;
    char_u	*pattern = NULL;
    char_u	*event_name;
    char_u	*p;
    event_T	event;
    AutoPat	*ap;
    buf_T	*buflocal_buf = NULL;
    int		group;
    int		retval = FALSE;

    // Make a copy so that we can change the '#' chars to a NUL.
    arg_save = vim_strsave(arg);
    if (arg_save == NULL)
	return FALSE;
    p = vim_strchr(arg_save, '#');
    if (p != NULL)
	*p++ = NUL;

    // First, look for an autocmd group name
    group = au_find_group(arg_save);
    if (group == AUGROUP_ERROR)
    {
	// Didn't match a group name, assume the first argument is an event.
	group = AUGROUP_ALL;
	event_name = arg_save;
    }
    else
    {
	if (p == NULL)
	{
	    // ""Group"": group name is present and it's recognized
	    retval = TRUE;
	    goto theend;
	}

	// Must be ""Group#Event"" or ""Group#Event#pat"".
	event_name = p;
	p = vim_strchr(event_name, '#');
	if (p != NULL)
	    *p++ = NUL;	    // ""Group#Event#pat""
    }

    pattern = p;	    // ""pattern"" is NULL when there is no pattern

    // find the index (enum) for the event name
    event = event_name2nr(event_name, &p);

    // return FALSE if the event name is not recognized
    if (event == NUM_EVENTS)
	goto theend;

    // Find the first autocommand for this event.
    // If there isn't any, return FALSE;
    // If there is one and no pattern given, return TRUE;
    ap = first_autopat[(int)event];
    if (ap == NULL)
	goto theend;

    // if pattern is ""<buffer>"", special handling is needed which uses curbuf
    // for pattern ""<buffer=N>, fnamecmp() will work fine
    if (pattern != NULL && STRICMP(pattern, ""<buffer>"") == 0)
	buflocal_buf = curbuf;

    // Check if there is an autocommand with the given pattern.
    for ( ; ap != NULL; ap = ap->next)
	// only use a pattern when it has not been removed and has commands.
	// For buffer-local autocommands, fnamecmp() works fine.
	if (ap->pat != NULL && ap->cmds != NULL
	    && (group == AUGROUP_ALL || ap->group == group)
	    && (pattern == NULL
		|| (buflocal_buf == NULL
		    ? fnamecmp(ap->pat, pattern) == 0
		    : ap->buflocal_nr == buflocal_buf->b_fnum)))
	{
	    retval = TRUE;
	    break;
	}

theend:
    vim_free(arg_save);
    return retval;
}

/*
 * autocmd_add() and autocmd_delete() functions
 */
    static void
autocmd_add_or_delete(typval_T *argvars, typval_T *rettv, int delete)
{
    list_T	*aucmd_list;
    listitem_T	*li;
    dict_T	*event_dict;
    dictitem_T	*di;
    char_u	*event_name = NULL;
    list_T	*event_list;
    listitem_T	*eli;
    event_T	event;
    char_u	*group_name = NULL;
    int		group;
    char_u	*pat = NULL;
    list_T	*pat_list;
    listitem_T	*pli;
    char_u	*cmd = NULL;
    char_u	*end;
    int		once;
    int		nested;
    int		replace;		// replace the cmd for a group/event
    int		retval = VVAL_TRUE;
    int		save_augroup = current_augroup;

    rettv->v_type = VAR_BOOL;
    rettv->vval.v_number = VVAL_FALSE;

    if (check_for_list_arg(argvars, 0) == FAIL)
	return;

    aucmd_list = argvars[0].vval.v_list;
    if (aucmd_list == NULL)
	return;

    FOR_ALL_LIST_ITEMS(aucmd_list, li)
    {
	VIM_CLEAR(group_name);
	VIM_CLEAR(cmd);
	event_name = NULL;
	event_list = NULL;
	pat = NULL;
	pat_list = NULL;

	if (li->li_tv.v_type != VAR_DICT)
	    continue;

	event_dict = li->li_tv.vval.v_dict;
	if (event_dict == NULL)
	    continue;

	di = dict_find(event_dict, (char_u *)""event"", -1);
	if (di != NULL)
	{
	    if (di->di_tv.v_type == VAR_STRING)
	    {
		event_name = di->di_tv.vval.v_string;
		if (event_name == NULL)
		{
		    emsg(_(e_string_required));
		    continue;
		}
	    }
	    else if (di->di_tv.v_type == VAR_LIST)
	    {
		event_list = di->di_tv.vval.v_list;
		if (event_list == NULL)
		{
		    emsg(_(e_list_required));
		    continue;
		}
	    }
	    else
	    {
		emsg(_(e_string_or_list_expected));
		continue;
	    }
	}

	group_name = dict_get_string(event_dict, ""group"", TRUE);
	if (group_name == NULL || *group_name == NUL)
	    // if the autocmd group name is not specified, then use the current
	    // autocmd group
	    group = current_augroup;
	else
	{
	    group = au_find_group(group_name);
	    if (group == AUGROUP_ERROR)
	    {
		if (delete)
		{
		    semsg(_(e_no_such_group_str), group_name);
		    retval = VVAL_FALSE;
		    break;
		}
		// group is not found, create it now
		group = au_new_group(group_name);
		if (group == AUGROUP_ERROR)
		{
		    semsg(_(e_no_such_group_str), group_name);
		    retval = VVAL_FALSE;
		    break;
		}

		current_augroup = group;
	    }
	}

	// if a buffer number is specified, then generate a pattern of the form
	// ""<buffer=n>. Otherwise, use the pattern supplied by the user.
	if (dict_has_key(event_dict, ""bufnr""))
	{
	    varnumber_T	bnum;

	    bnum = dict_get_number_def(event_dict, ""bufnr"", -1);
	    if (bnum == -1)
		continue;

	    vim_snprintf((char *)IObuff, IOSIZE, ""<buffer=%d>"", (int)bnum);
	    pat = IObuff;
	}
	else
	{
	    di = dict_find(event_dict, (char_u *)""pattern"", -1);
	    if (di != NULL)
	    {
		if (di->di_tv.v_type == VAR_STRING)
		{
		    pat = di->di_tv.vval.v_string;
		    if (pat == NULL)
		    {
			emsg(_(e_string_required));
			continue;
		    }
		}
		else if (di->di_tv.v_type == VAR_LIST)
		{
		    pat_list = di->di_tv.vval.v_list;
		    if (pat_list == NULL)
		    {
			emsg(_(e_list_required));
			continue;
		    }
		}
		else
		{
		    emsg(_(e_string_or_list_expected));
		    continue;
		}
	    }
	    else if (delete)
		pat = (char_u *)"""";
	}

	once = dict_get_bool(event_dict, ""once"", FALSE);
	nested = dict_get_bool(event_dict, ""nested"", FALSE);
	// if 'replace' is true, then remove all the commands associated with
	// this autocmd event/group and add the new command.
	replace = dict_get_bool(event_dict, ""replace"", FALSE);

	cmd = dict_get_string(event_dict, ""cmd"", TRUE);
	if (cmd == NULL)
	{
	    if (delete)
		cmd = vim_strsave((char_u *)"""");
	    else
		continue;
	}

	if (delete && (event_name == NULL
		    || (event_name[0] == '*' && event_name[1] == NUL)))
	{
	    // if the event name is not specified or '*', delete all the events
	    for (event = (event_T)0; (int)event < NUM_EVENTS;
		    event = (event_T)((int)event + 1))
	    {
		if (do_autocmd_event(event, pat, once, nested, cmd, delete,
							group, 0) == FAIL)
		{
		    retval = VVAL_FALSE;
		    break;
		}
	    }
	}
	else
	{
	    char_u *p = NULL;

	    eli = NULL;
	    end = NULL;
	    while (TRUE)
	    {
		if (event_list != NULL)
		{
		    if (eli == NULL)
			eli = event_list->lv_first;
		    else
			eli = eli->li_next;
		    if (eli == NULL)
			break;
		    if (eli->li_tv.v_type != VAR_STRING
			    || (p = eli->li_tv.vval.v_string) == NULL)
		    {
			emsg(_(e_string_required));
			break;
		    }
		}
		else
		{
		    if (p == NULL)
			p = event_name;
		    if (p == NULL || *p == NUL)
			break;
		}

		event = event_name2nr(p, &end);
		if (event == NUM_EVENTS || *end != NUL)
		{
		    // this also catches something following a valid event name
		    semsg(_(e_no_such_event_str), p);
		    retval = VVAL_FALSE;
		    break;
		}
		if (pat != NULL)
		{
		    if (do_autocmd_event(event, pat, once, nested, cmd,
				delete | replace, group, 0) == FAIL)
		    {
			retval = VVAL_FALSE;
			break;
		    }
		}
		else if (pat_list != NULL)
		{
		    FOR_ALL_LIST_ITEMS(pat_list, pli)
		    {
			if (pli->li_tv.v_type != VAR_STRING
				|| pli->li_tv.vval.v_string == NULL)
			{
			    emsg(_(e_string_required));
			    continue;
			}
			if (do_autocmd_event(event,
				    pli->li_tv.vval.v_string, once, nested,
				    cmd, delete | replace, group, 0) ==
				FAIL)
			{
			    retval = VVAL_FALSE;
			    break;
			}
		    }
		    if (retval == VVAL_FALSE)
			break;
		}
		if (event_name != NULL)
		    p = end;
	    }
	}

	// if only the autocmd group name is specified for delete and the
	// autocmd event, pattern and cmd are not specified, then delete the
	// autocmd group.
	if (delete && group_name != NULL &&
		(event_name == NULL || event_name[0] == NUL)
		&& (pat == NULL || pat[0] == NUL)
		&& (cmd == NULL || cmd[0] == NUL))
	    au_del_group(group_name);
    }

    VIM_CLEAR(group_name);
    VIM_CLEAR(cmd);

    current_augroup = save_augroup;
    rettv->vval.v_number = retval;
}

/*
 * autocmd_add() function
 */
    void
f_autocmd_add(typval_T *argvars, typval_T *rettv)
{
    autocmd_add_or_delete(argvars, rettv, FALSE);
}

/*
 * autocmd_delete() function
 */
    void
f_autocmd_delete(typval_T *argvars, typval_T *rettv)
{
    autocmd_add_or_delete(argvars, rettv, TRUE);
}

/*
 * autocmd_get() function
 * Returns a List of autocmds.
 */
    void
f_autocmd_get(typval_T *argvars, typval_T *rettv)
{
    event_T	event_arg = NUM_EVENTS;
    event_T	event;
    AutoPat	*ap;
    AutoCmd	*ac;
    list_T	*event_list;
    dict_T	*event_dict;
    char_u	*event_name = NULL;
    char_u	*pat = NULL;
    char_u	*name = NULL;
    int		group = AUGROUP_ALL;

    if (rettv_list_alloc(rettv) == FAIL)
	return;
    if (check_for_opt_dict_arg(argvars, 0) == FAIL)
	return;

    if (argvars[0].v_type == VAR_DICT)
    {
	// return only the autocmds in the specified group
	if (dict_has_key(argvars[0].vval.v_dict, ""group""))
	{
	    name = dict_get_string(argvars[0].vval.v_dict, ""group"", TRUE);
	    if (name == NULL)
		return;

	    if (*name == NUL)
		group = AUGROUP_DEFAULT;
	    else
	    {
		group = au_find_group(name);
		if (group == AUGROUP_ERROR)
		{
		    semsg(_(e_no_such_group_str), name);
		    vim_free(name);
		    return;
		}
	    }
	    vim_free(name);
	}

	// return only the autocmds for the specified event
	if (dict_has_key(argvars[0].vval.v_dict, ""event""))
	{
	    name = dict_get_string(argvars[0].vval.v_dict, ""event"", TRUE);
	    if (name == NULL)
		return;

	    if (name[0] == '*' && name[1] == NUL)
		event_arg = NUM_EVENTS;
	    else
	    {
		keyvalue_T target;
		keyvalue_T *entry;

		target.key = 0;
		target.value = (char *)name;
		target.length = (int)STRLEN(target.value);
		entry = (keyvalue_T *)bsearch(&target, &event_tab, ARRAY_LENGTH(event_tab), sizeof(event_tab[0]), cmp_keyvalue_value_ni);
		if (entry == NULL)
		{
		    semsg(_(e_no_such_event_str), name);
		    vim_free(name);
		    return;
		}
		event_arg = (event_T)entry->key;
	    }
	    vim_free(name);
	}

	// return only the autocmds for the specified pattern
	if (dict_has_key(argvars[0].vval.v_dict, ""pattern""))
	{
	    pat = dict_get_string(argvars[0].vval.v_dict, ""pattern"", TRUE);
	    if (pat == NULL)
		return;
	}
    }

    event_list = rettv->vval.v_list;

    // iterate through all the autocmd events
    for (event = (event_T)0; (int)event < NUM_EVENTS;
	    event = (event_T)((int)event + 1))
    {
	if (event_arg != NUM_EVENTS && event != event_arg)
	    continue;

	event_name = event_nr2name(event);

	// iterate through all the patterns for this autocmd event
	FOR_ALL_AUTOCMD_PATTERNS(event, ap)
	{
	    char_u	*group_name;

	    if (group != AUGROUP_ALL && group != ap->group)
		continue;

	    if (pat != NULL && STRCMP(pat, ap->pat) != 0)
		continue;

	    group_name = get_augroup_name(NULL, ap->group);

	    // iterate through all the commands for this pattern and add one
	    // item for each cmd.
	    for (ac = ap->cmds; ac != NULL; ac = ac->next)
	    {
		event_dict = dict_alloc();
		if (event_dict == NULL
			|| list_append_dict(event_list, event_dict) == FAIL)
		    return;

		if (dict_add_string(event_dict, ""event"", event_name) == FAIL
			|| dict_add_string(event_dict, ""group"",
					group_name == NULL ? (char_u *)""""
							  : group_name) == FAIL
			|| (ap->buflocal_nr != 0
				&& (dict_add_number(event_dict, ""bufnr"",
						    ap->buflocal_nr) == FAIL))
			|| dict_add_string(event_dict, ""pattern"",
							      ap->pat) == FAIL
			|| dict_add_string(event_dict, ""cmd"", ac->cmd) == FAIL
			|| dict_add_bool(event_dict, ""once"", ac->once) == FAIL
			|| dict_add_bool(event_dict, ""nested"",
							   ac->nested) == FAIL)
		    return;
	    }
	}
    }

    vim_free(pat);
}

#endif
"
./repos/vim/src/alloc.c,https://github.com/vim/vim,"/* vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *
 * Do "":help uganda""  in Vim to read copying and usage conditions.
 * Do "":help credits"" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 */

/*
 * alloc.c: functions for memory management
 */

#include ""vim.h""

/**********************************************************************
 * Various routines dealing with allocation and deallocation of memory.
 */

#if defined(MEM_PROFILE) || defined(PROTO)

# define MEM_SIZES  8200
static long_u mem_allocs[MEM_SIZES];
static long_u mem_frees[MEM_SIZES];
static long_u mem_allocated;
static long_u mem_freed;
static long_u mem_peak;
static long_u num_alloc;
static long_u num_freed;

    static void
mem_pre_alloc_s(size_t *sizep)
{
    *sizep += sizeof(size_t);
}

    static void
mem_pre_alloc_l(size_t *sizep)
{
    *sizep += sizeof(size_t);
}

    static void
mem_post_alloc(
    void **pp,
    size_t size)
{
    if (*pp == NULL)
	return;
    size -= sizeof(size_t);
    *(long_u *)*pp = size;
    if (size <= MEM_SIZES-1)
	mem_allocs[size-1]++;
    else
	mem_allocs[MEM_SIZES-1]++;
    mem_allocated += size;
    if (mem_allocated - mem_freed > mem_peak)
	mem_peak = mem_allocated - mem_freed;
    num_alloc++;
    *pp = (void *)((char *)*pp + sizeof(size_t));
}

    static void
mem_pre_free(void **pp)
{
    long_u size;

    *pp = (void *)((char *)*pp - sizeof(size_t));
    size = *(size_t *)*pp;
    if (size <= MEM_SIZES-1)
	mem_frees[size-1]++;
    else
	mem_frees[MEM_SIZES-1]++;
    mem_freed += size;
    num_freed++;
}

/*
 * called on exit via atexit()
 */
    void
vim_mem_profile_dump(void)
{
    int i, j;

    printf(""\r\n"");
    j = 0;
    for (i = 0; i < MEM_SIZES - 1; i++)
    {
	if (mem_allocs[i] == 0 && mem_frees[i] == 0)
	    continue;

	if (mem_frees[i] > mem_allocs[i])
	    printf(""\r\n%s"", _(""ERROR: ""));
	printf(""[%4d / %4lu-%-4lu] "", i + 1, mem_allocs[i], mem_frees[i]);
	j++;
	if (j > 3)
	{
	    j = 0;
	    printf(""\r\n"");
	}
    }

    i = MEM_SIZES - 1;
    if (mem_allocs[i])
    {
	printf(""\r\n"");
	if (mem_frees[i] > mem_allocs[i])
	    puts(_(""ERROR: ""));
	printf(""[>%d / %4lu-%-4lu]"", i, mem_allocs[i], mem_frees[i]);
    }

    printf(_(""\n[bytes] total alloc-freed %lu-%lu, in use %lu, peak use %lu\n""),
	    mem_allocated, mem_freed, mem_allocated - mem_freed, mem_peak);
    printf(_(""[calls] total re/malloc()'s %lu, total free()'s %lu\n\n""),
	    num_alloc, num_freed);
}

#endif // MEM_PROFILE

#ifdef FEAT_EVAL
    int
alloc_does_fail(size_t size)
{
    if (alloc_fail_countdown == 0)
    {
	if (--alloc_fail_repeat <= 0)
	    alloc_fail_id = 0;
	do_outofmem_msg(size);
	return TRUE;
    }
    --alloc_fail_countdown;
    return FALSE;
}
#endif

/*
 * Some memory is reserved for error messages and for being able to
 * call mf_release_all(), which needs some memory for mf_trans_add().
 */
#define KEEP_ROOM (2 * 8192L)
#define KEEP_ROOM_KB (KEEP_ROOM / 1024L)

/*
 * The normal way to allocate memory.  This handles an out-of-memory situation
 * as well as possible, still returns NULL when we're completely out.
 */
    void *
alloc(size_t size)
{
    return lalloc(size, TRUE);
}

#if defined(FEAT_QUICKFIX) || defined(PROTO)
/*
 * alloc() with an ID for alloc_fail().
 */
    void *
alloc_id(size_t size, alloc_id_T id UNUSED)
{
# ifdef FEAT_EVAL
    if (alloc_fail_id == id && alloc_does_fail(size))
	return NULL;
# endif
    return lalloc(size, TRUE);
}
#endif

/*
 * Allocate memory and set all bytes to zero.
 */
    void *
alloc_clear(size_t size)
{
    void *p;

    p = lalloc(size, TRUE);
    if (p != NULL)
	(void)vim_memset(p, 0, size);
    return p;
}

/*
 * Same as alloc_clear() but with allocation id for testing
 */
    void *
alloc_clear_id(size_t size, alloc_id_T id UNUSED)
{
#ifdef FEAT_EVAL
    if (alloc_fail_id == id && alloc_does_fail(size))
	return NULL;
#endif
    return alloc_clear(size);
}

/*
 * Allocate memory like lalloc() and set all bytes to zero.
 */
    void *
lalloc_clear(size_t size, int message)
{
    void *p;

    p = lalloc(size, message);
    if (p != NULL)
	(void)vim_memset(p, 0, size);
    return p;
}

/*
 * Low level memory allocation function.
 * This is used often, KEEP IT FAST!
 */
    void *
lalloc(size_t size, int message)
{
    void	*p;		    // pointer to new storage space
    static int	releasing = FALSE;  // don't do mf_release_all() recursive
    int		try_again;
#if defined(HAVE_AVAIL_MEM)
    static size_t allocated = 0;    // allocated since last avail check
#endif

    // Safety check for allocating zero bytes
    if (size == 0)
    {
	// Don't hide this message
	emsg_silent = 0;
	iemsg(e_internal_error_lalloc_zero);
	return NULL;
    }

#ifdef MEM_PROFILE
    mem_pre_alloc_l(&size);
#endif

    // Loop when out of memory: Try to release some memfile blocks and
    // if some blocks are released call malloc again.
    for (;;)
    {
	// Handle three kinds of systems:
	// 1. No check for available memory: Just return.
	// 2. Slow check for available memory: call mch_avail_mem() after
	//    allocating KEEP_ROOM amount of memory.
	// 3. Strict check for available memory: call mch_avail_mem()
	if ((p = malloc(size)) != NULL)
	{
#ifndef HAVE_AVAIL_MEM
	    // 1. No check for available memory: Just return.
	    goto theend;
#else
	    // 2. Slow check for available memory: call mch_avail_mem() after
	    //    allocating (KEEP_ROOM / 2) amount of memory.
	    allocated += size;
	    if (allocated < KEEP_ROOM / 2)
		goto theend;
	    allocated = 0;

	    // 3. check for available memory: call mch_avail_mem()
	    if (mch_avail_mem(TRUE) < KEEP_ROOM_KB && !releasing)
	    {
		free(p);	// System is low... no go!
		p = NULL;
	    }
	    else
		goto theend;
#endif
	}
	// Remember that mf_release_all() is being called to avoid an endless
	// loop, because mf_release_all() may call alloc() recursively.
	if (releasing)
	    break;
	releasing = TRUE;

	clear_sb_text(TRUE);	      // free any scrollback text
	try_again = mf_release_all(); // release as many blocks as possible

	releasing = FALSE;
	if (!try_again)
	    break;
    }

    if (message && p == NULL)
	do_outofmem_msg(size);

theend:
#ifdef MEM_PROFILE
    mem_post_alloc(&p, size);
#endif
    return p;
}

/*
 * lalloc() with an ID for alloc_fail().
 */
#if defined(FEAT_SIGNS) || defined(PROTO)
    void *
lalloc_id(size_t size, int message, alloc_id_T id UNUSED)
{
#ifdef FEAT_EVAL
    if (alloc_fail_id == id && alloc_does_fail(size))
	return NULL;
#endif
    return (lalloc(size, message));
}
#endif

#if defined(MEM_PROFILE) || defined(PROTO)
/*
 * realloc() with memory profiling.
 */
    void *
mem_realloc(void *ptr, size_t size)
{
    void *p;

    mem_pre_free(&ptr);
    mem_pre_alloc_s(&size);

    p = realloc(ptr, size);

    mem_post_alloc(&p, size);

    return p;
}
#endif

/*
* Avoid repeating the error message many times (they take 1 second each).
* Did_outofmem_msg is reset when a character is read.
*/
    void
do_outofmem_msg(size_t size)
{
    if (did_outofmem_msg)
	return;

    // Don't hide this message
    emsg_silent = 0;

    // Must come first to avoid coming back here when printing the error
    // message fails, e.g. when setting v:errmsg.
    did_outofmem_msg = TRUE;

    semsg(_(e_out_of_memory_allocating_nr_bytes), (long_u)size);

    if (starting == NO_SCREEN)
	// Not even finished with initializations and already out of
	// memory?  Then nothing is going to work, exit.
	mch_exit(123);
}

#if defined(EXITFREE) || defined(PROTO)

/*
 * Free everything that we allocated.
 * Can be used to detect memory leaks, e.g., with ccmalloc.
 * NOTE: This is tricky!  Things are freed that functions depend on.  Don't be
 * surprised if Vim crashes...
 * Some things can't be freed, esp. things local to a library function.
 */
    void
free_all_mem(void)
{
    buf_T	*buf, *nextbuf;

    // When we cause a crash here it is caught and Vim tries to exit cleanly.
    // Don't try freeing everything again.
    if (entered_free_all_mem)
	return;
    entered_free_all_mem = TRUE;
    // Don't want to trigger autocommands from here on.
    block_autocmds();

    // Close all tabs and windows.  Reset 'equalalways' to avoid redraws.
    p_ea = FALSE;
    if (first_tabpage != NULL && first_tabpage->tp_next != NULL)
	do_cmdline_cmd((char_u *)""tabonly!"");
    if (!ONE_WINDOW)
	do_cmdline_cmd((char_u *)""only!"");

# if defined(FEAT_SPELL)
    // Free all spell info.
    spell_free_all();
# endif

# if defined(FEAT_BEVAL_TERM)
    ui_remove_balloon();
# endif
# ifdef FEAT_PROP_POPUP
    if (curwin != NULL)
	close_all_popups(TRUE);
# endif

    // Clear user commands (before deleting buffers).
    ex_comclear(NULL);

    // When exiting from mainerr_arg_missing curbuf has not been initialized,
    // and not much else.
    if (curbuf != NULL)
    {
# ifdef FEAT_MENU
	// Clear menus.
	do_cmdline_cmd((char_u *)""aunmenu *"");
	do_cmdline_cmd((char_u *)""tlunmenu *"");
#  ifdef FEAT_MULTI_LANG
	do_cmdline_cmd((char_u *)""menutranslate clear"");
#  endif
# endif
	// Clear mappings, abbreviations, breakpoints.
	do_cmdline_cmd((char_u *)""lmapclear"");
	do_cmdline_cmd((char_u *)""xmapclear"");
	do_cmdline_cmd((char_u *)""mapclear"");
	do_cmdline_cmd((char_u *)""mapclear!"");
	do_cmdline_cmd((char_u *)""abclear"");
# if defined(FEAT_EVAL)
	do_cmdline_cmd((char_u *)""breakdel *"");
# endif
# if defined(FEAT_PROFILE)
	do_cmdline_cmd((char_u *)""profdel *"");
# endif
# if defined(FEAT_KEYMAP)
	do_cmdline_cmd((char_u *)""set keymap="");
# endif
    }

    free_titles();
    free_findfile();

    // Obviously named calls.
    free_all_autocmds();
    clear_termcodes();
    free_all_marks();
    alist_clear(&global_alist);
    free_homedir();
    free_users();
    free_search_patterns();
    free_old_sub();
    free_last_insert();
    free_insexpand_stuff();
    free_prev_shellcmd();
    free_regexp_stuff();
    free_tag_stuff();
    free_xim_stuff();
    free_cd_dir();
# ifdef FEAT_SIGNS
    free_signs();
# endif
# ifdef FEAT_EVAL
    set_expr_line(NULL, NULL);
# endif
# ifdef FEAT_DIFF
    if (curtab != NULL)
	diff_clear(curtab);
# endif
    clear_sb_text(TRUE);	      // free any scrollback text

    // Free some global vars.
    free_username();
# ifdef FEAT_CLIPBOARD
    vim_regfree(clip_exclude_prog);
# endif
    vim_free(last_cmdline);
    vim_free(new_last_cmdline);
    set_keep_msg(NULL, 0);

    // Clear cmdline history.
    p_hi = 0;
    init_history();
# ifdef FEAT_PROP_POPUP
    clear_global_prop_types();
# endif

# ifdef FEAT_QUICKFIX
    free_quickfix();
# endif

    // Close all script inputs.
    close_all_scripts();

    if (curwin != NULL)
	// Destroy all windows.  Must come before freeing buffers.
	win_free_all();

    // Free all option values.  Must come after closing windows.
    free_all_options();

    // Free all buffers.  Reset 'autochdir' to avoid accessing things that
    // were freed already.
# ifdef FEAT_AUTOCHDIR
    p_acd = FALSE;
# endif
    for (buf = firstbuf; buf != NULL; )
    {
	bufref_T    bufref;

	set_bufref(&bufref, buf);
	nextbuf = buf->b_next;
	close_buffer(NULL, buf, DOBUF_WIPE, FALSE, FALSE);
	if (bufref_valid(&bufref))
	    buf = nextbuf;	// didn't work, try next one
	else
	    buf = firstbuf;
    }

# ifdef FEAT_ARABIC
    free_arshape_buf();
# endif

    // Clear registers.
    clear_registers();
    ResetRedobuff();
    ResetRedobuff();

# if defined(FEAT_CLIENTSERVER) && defined(FEAT_X11)
    vim_free(serverDelayedStartName);
# endif

    // highlight info
    free_highlight();

    reset_last_sourcing();

    if (first_tabpage != NULL)
    {
	free_tabpage(first_tabpage);
	first_tabpage = NULL;
    }

# ifdef UNIX
    // Machine-specific free.
    mch_free_mem();
# endif

    // message history
    for (;;)
	if (delete_first_msg() == FAIL)
	    break;

# ifdef FEAT_JOB_CHANNEL
    channel_free_all();
# endif
# ifdef FEAT_TIMERS
    timer_free_all();
# endif
# ifdef FEAT_EVAL
    // must be after channel_free_all() with unrefs partials
    eval_clear();
# endif
# ifdef FEAT_JOB_CHANNEL
    // must be after eval_clear() with unrefs jobs
    job_free_all();
# endif

    free_termoptions();
    free_cur_term();

    // screenlines (can't display anything now!)
    free_screenlines();

# if defined(FEAT_SOUND)
    sound_free();
# endif
# if defined(USE_XSMP)
    xsmp_close();
# endif
# ifdef FEAT_GUI_GTK
    gui_mch_free_all();
# endif
# ifdef FEAT_TCL
    vim_tcl_finalize();
# endif
    clear_hl_tables();

    vim_free(IObuff);
    vim_free(NameBuff);
# ifdef FEAT_QUICKFIX
    check_quickfix_busy();
# endif
# ifdef FEAT_EVAL
    free_resub_eval_result();
# endif
    free_vbuf();
}
#endif

/*
 * Copy ""p[len]"" into allocated memory, ignoring NUL characters.
 * Returns NULL when out of memory.
 */
    char_u *
vim_memsave(char_u *p, size_t len)
{
    char_u *ret = alloc(len);

    if (ret != NULL)
	mch_memmove(ret, p, len);
    return ret;
}

/*
 * Replacement for free() that ignores NULL pointers.
 * Also skip free() when exiting for sure, this helps when we caught a deadly
 * signal that was caused by a crash in free().
 * If you want to set NULL after calling this function, you should use
 * VIM_CLEAR() instead.
 */
    void
vim_free(void *x)
{
    if (x != NULL && !really_exiting)
    {
#ifdef MEM_PROFILE
	mem_pre_free(&x);
#endif
	free(x);
    }
}

/************************************************************************
 * Functions for handling growing arrays.
 */

/*
 * Clear an allocated growing array.
 */
    void
ga_clear(garray_T *gap)
{
    vim_free(gap->ga_data);
    ga_init(gap);
}

/*
 * Clear a growing array that contains a list of strings.
 */
    void
ga_clear_strings(garray_T *gap)
{
    int		i;

    if (gap->ga_data != NULL)
	for (i = 0; i < gap->ga_len; ++i)
	    vim_free(((char_u **)(gap->ga_data))[i]);
    ga_clear(gap);
}

#if defined(FEAT_EVAL) || defined(PROTO)
/*
 * Copy a growing array that contains a list of strings.
 */
    int
ga_copy_strings(garray_T *from, garray_T *to)
{
    int		i;

    ga_init2(to, sizeof(char_u *), 1);
    if (ga_grow(to, from->ga_len) == FAIL)
	return FAIL;

    for (i = 0; i < from->ga_len; ++i)
    {
	char_u *orig = ((char_u **)from->ga_data)[i];
	char_u *copy;

	if (orig == NULL)
	    copy = NULL;
	else
	{
	    copy = vim_strsave(orig);
	    if (copy == NULL)
	    {
		to->ga_len = i;
		ga_clear_strings(to);
		return FAIL;
	    }
	}
	((char_u **)to->ga_data)[i] = copy;
    }
    to->ga_len = from->ga_len;
    return OK;
}
#endif

/*
 * Initialize a growing array.	Don't forget to set ga_itemsize and
 * ga_growsize!  Or use ga_init2().
 */
    void
ga_init(garray_T *gap)
{
    gap->ga_data = NULL;
    gap->ga_maxlen = 0;
    gap->ga_len = 0;
}

    void
ga_init2(garray_T *gap, size_t itemsize, int growsize)
{
    ga_init(gap);
    gap->ga_itemsize = (int)itemsize;
    gap->ga_growsize = growsize;
}

/*
 * Make room in growing array ""gap"" for at least ""n"" items.
 * Return FAIL for failure, OK otherwise.
 */
    int
ga_grow(garray_T *gap, int n)
{
    if (gap->ga_maxlen - gap->ga_len < n)
	return ga_grow_inner(gap, n);
    return OK;
}

/*
 * Same as ga_grow() but uses an allocation id for testing.
 */
    int
ga_grow_id(garray_T *gap, int n, alloc_id_T id UNUSED)
{
#ifdef FEAT_EVAL
    if (alloc_fail_id == id && alloc_does_fail(sizeof(list_T)))
	return FAIL;
#endif

    return ga_grow(gap, n);
}

    int
ga_grow_inner(garray_T *gap, int n)
{
    size_t	old_len;
    size_t	new_len;
    char_u	*pp;

    if (n < gap->ga_growsize)
	n = gap->ga_growsize;

    // A linear growth is very inefficient when the array grows big.  This
    // is a compromise between allocating memory that won't be used and too
    // many copy operations. A factor of 1.5 seems reasonable.
    if (n < gap->ga_len / 2)
	n = gap->ga_len / 2;

    new_len = (size_t)gap->ga_itemsize * (gap->ga_len + n);
    pp = vim_realloc(gap->ga_data, new_len);
    if (pp == NULL)
	return FAIL;
    old_len = (size_t)gap->ga_itemsize * gap->ga_maxlen;
    vim_memset(pp + old_len, 0, new_len - old_len);
    gap->ga_maxlen = gap->ga_len + n;
    gap->ga_data = pp;
    return OK;
}

/*
 * For a growing array that contains a list of strings: concatenate all the
 * strings with a separating ""sep"".
 * Returns NULL when out of memory.
 */
    char_u *
ga_concat_strings(garray_T *gap, char *sep)
{
    int		i;
    int		len = 0;
    int		sep_len = (int)STRLEN(sep);
    char_u	*s;
    char_u	*p;

    for (i = 0; i < gap->ga_len; ++i)
	len += (int)STRLEN(((char_u **)(gap->ga_data))[i]) + sep_len;

    s = alloc(len + 1);
    if (s == NULL)
	return NULL;

    *s = NUL;
    p = s;
    for (i = 0; i < gap->ga_len; ++i)
    {
	if (p != s)
	{
	    STRCPY(p, sep);
	    p += sep_len;
	}
	STRCPY(p, ((char_u **)(gap->ga_data))[i]);
	p += STRLEN(p);
    }
    return s;
}

/*
 * Make a copy of string ""p"" and add it to ""gap"".
 * When out of memory nothing changes and FAIL is returned.
 */
    int
ga_copy_string(garray_T *gap, char_u *p)
{
    char_u *cp = vim_strsave(p);

    if (cp == NULL)
	return FAIL;

    if (ga_grow(gap, 1) == FAIL)
    {
	vim_free(cp);
	return FAIL;
    }
    ((char_u **)(gap->ga_data))[gap->ga_len++] = cp;
    return OK;
}

/*
 * Add string ""p"" to ""gap"".
 * When out of memory FAIL is returned (caller may want to free ""p"").
 */
    int
ga_add_string(garray_T *gap, char_u *p)
{
    if (ga_grow(gap, 1) == FAIL)
	return FAIL;
    ((char_u **)(gap->ga_data))[gap->ga_len++] = p;
    return OK;
}

/*
 * Concatenate a string to a growarray which contains bytes.
 * When ""s"" is NULL memory allocation fails does not do anything.
 * Note: Does NOT copy the NUL at the end!
 */
    void
ga_concat(garray_T *gap, char_u *s)
{
    int    len;

    if (s == NULL || *s == NUL)
	return;
    len = (int)STRLEN(s);
    if (ga_grow(gap, len) == OK)
    {
	mch_memmove((char *)gap->ga_data + gap->ga_len, s, (size_t)len);
	gap->ga_len += len;
    }
}

/*
 * Concatenate 'len' bytes from string 's' to a growarray.
 * When ""s"" is NULL does not do anything.
 */
    void
ga_concat_len(garray_T *gap, char_u *s, size_t len)
{
    if (s == NULL || *s == NUL || len == 0)
	return;
    if (ga_grow(gap, (int)len) == OK)
    {
	mch_memmove((char *)gap->ga_data + gap->ga_len, s, len);
	gap->ga_len += (int)len;
    }
}

/*
 * Append one byte to a growarray which contains bytes.
 */
    int
ga_append(garray_T *gap, int c)
{
    if (ga_grow(gap, 1) == FAIL)
	return FAIL;
    *((char *)gap->ga_data + gap->ga_len) = c;
    ++gap->ga_len;
    return OK;
}

#if (defined(UNIX) && !defined(USE_SYSTEM)) || defined(MSWIN) \
	|| defined(PROTO)
/*
 * Append the text in ""gap"" below the cursor line and clear ""gap"".
 */
    void
append_ga_line(garray_T *gap)
{
    // Remove trailing CR.
    if (gap->ga_len > 0
	    && !curbuf->b_p_bin
	    && ((char_u *)gap->ga_data)[gap->ga_len - 1] == CAR)
	--gap->ga_len;
    ga_append(gap, NUL);
    ml_append(curwin->w_cursor.lnum++, gap->ga_data, 0, FALSE);
    gap->ga_len = 0;
}
#endif

"
./repos/vim/src/beval.c,https://github.com/vim/vim,"/* vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *			Visual Workshop integration by Gordon Prieur
 *
 * Do "":help uganda""  in Vim to read copying and usage conditions.
 * Do "":help credits"" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 */

#include ""vim.h""

#if defined(FEAT_BEVAL) || defined(FEAT_PROP_POPUP) || defined(PROTO)
/*
 * Find text under the mouse position ""row"" / ""col"".
 * If ""getword"" is TRUE the returned text in ""*textp"" is not the whole line but
 * the relevant word in allocated memory.
 * Return OK if found.
 * Return FAIL if not found, no text at the mouse position.
 */
    int
find_word_under_cursor(
	int	    mouserow,
	int	    mousecol,
	int	    getword,
	int	    flags,	// flags for find_ident_at_pos()
	win_T	    **winp,	// can be NULL
	linenr_T    *lnump,	// can be NULL
	char_u	    **textp,
	int	    *colp,	// column where mouse hovers, can be NULL
	int	    *startcolp) // column where text starts, can be NULL
{
    int		row = mouserow;
    int		col = mousecol;
    int		scol;
    win_T	*wp;
    char_u	*lbuf;
    linenr_T	lnum;

    *textp = NULL;
    wp = mouse_find_win(&row, &col, FAIL_POPUP);
    if (wp == NULL || row < 0 || row >= wp->w_height || col >= wp->w_width)
	return FAIL;

    // Found a window and the cursor is in the text.  Now find the line
    // number.
    if (mouse_comp_pos(wp, &row, &col, &lnum, NULL))
	return FAIL;		// position is below the last line

    // Not past end of the file.
    lbuf = ml_get_buf(wp->w_buffer, lnum, FALSE);
    if (col > win_linetabsize(wp, lnum, lbuf, (colnr_T)MAXCOL))
	return FAIL;		// past end of line

    // Not past end of line.
    if (getword)
    {
	// For Netbeans we get the relevant part of the line
	// instead of the whole line.
	int		len;
	pos_T	*spos = NULL, *epos = NULL;

	if (VIsual_active)
	{
	    if (LT_POS(VIsual, curwin->w_cursor))
	    {
		spos = &VIsual;
		epos = &curwin->w_cursor;
	    }
	    else
	    {
		spos = &curwin->w_cursor;
		epos = &VIsual;
	    }
	}

	col = vcol2col(wp, lnum, col, NULL);
	scol = col;

	if (VIsual_active
		&& wp->w_buffer == curwin->w_buffer
		&& (lnum == spos->lnum
		    ? col >= (int)spos->col
		    : lnum > spos->lnum)
		&& (lnum == epos->lnum
		    ? col <= (int)epos->col
		    : lnum < epos->lnum))
	{
	    // Visual mode and pointing to the line with the
	    // Visual selection: return selected text, with a
	    // maximum of one line.
	    if (spos->lnum != epos->lnum || spos->col == epos->col)
		return FAIL;

	    lbuf = ml_get_buf(curwin->w_buffer, VIsual.lnum, FALSE);
	    len = epos->col - spos->col;
	    if (*p_sel != 'e')
		len += mb_ptr2len(lbuf + epos->col);
	    lbuf = vim_strnsave(lbuf + spos->col, len);
	    lnum = spos->lnum;
	    col = spos->col;
	    scol = col;
	}
	else
	{
	    // Find the word under the cursor.
	    ++emsg_off;
	    len = find_ident_at_pos(wp, lnum, (colnr_T)col,
		    &lbuf, &scol, flags);
	    --emsg_off;
	    if (len == 0)
		return FAIL;
	    lbuf = vim_strnsave(lbuf, len);
	}
    }
    else
	scol = col;

    if (winp != NULL)
	*winp = wp;
    if (lnump != NULL)
	*lnump = lnum;
    *textp = lbuf;
    if (colp != NULL)
	*colp = col;
    if (startcolp != NULL)
	*startcolp = scol;

    return OK;
}
#endif

#if defined(FEAT_BEVAL) || defined(PROTO)

/*
 * Get the text and position to be evaluated for ""beval"".
 * If ""getword"" is TRUE the returned text is not the whole line but the
 * relevant word in allocated memory.
 * Returns OK or FAIL.
 */
    int
get_beval_info(
	BalloonEval	*beval,
	int		getword,
	win_T		**winp,
	linenr_T	*lnump,
	char_u		**textp,
	int		*colp)
{
    int		row = mouse_row;
    int		col = mouse_col;

# ifdef FEAT_BEVAL_GUI
    if (gui.in_use)
    {
	row = Y_2_ROW(beval->y);
	col = X_2_COL(beval->x);
    }
# endif
    if (find_word_under_cursor(row, col, getword,
		FIND_IDENT + FIND_STRING + FIND_EVAL,
		winp, lnump, textp, colp, NULL) == OK)
    {
# ifdef FEAT_VARTABS
	vim_free(beval->vts);
	beval->vts = tabstop_copy((*winp)->w_buffer->b_p_vts_array);
	if ((*winp)->w_buffer->b_p_vts_array != NULL && beval->vts == NULL)
	{
	    if (getword)
		vim_free(*textp);
	    return FAIL;
	}
# endif
	beval->ts = (*winp)->w_buffer->b_p_ts;
	return OK;
    }

    return FAIL;
}

/*
 * Show a balloon with ""mesg"" or ""list"".
 * Hide the balloon when both are NULL.
 */
    void
post_balloon(BalloonEval *beval UNUSED, char_u *mesg, list_T *list UNUSED)
{
# ifdef FEAT_BEVAL_TERM
#  ifdef FEAT_GUI
    if (!gui.in_use)
#  endif
	ui_post_balloon(mesg, list);
# endif
# ifdef FEAT_BEVAL_GUI
    if (gui.in_use)
	// GUI can't handle a list
	gui_mch_post_balloon(beval, mesg);
# endif
}

/*
 * Returns TRUE if the balloon eval has been enabled:
 * 'ballooneval' for the GUI and 'balloonevalterm' for the terminal.
 * Also checks if the screen isn't scrolled up.
 */
    int
can_use_beval(void)
{
    return (0
#ifdef FEAT_BEVAL_GUI
		|| (gui.in_use && p_beval)
#endif
#ifdef FEAT_BEVAL_TERM
		|| (
# ifdef FEAT_GUI
		    !gui.in_use &&
# endif
		    p_bevalterm)
#endif
	     ) && msg_scrolled == 0;
}

# ifdef FEAT_EVAL
/*
 * Evaluate the expression 'bexpr' and set the text in the balloon 'beval'.
 */
    static void
bexpr_eval(
	BalloonEval	*beval,
	char_u		*bexpr,
	win_T		*wp,
	linenr_T	lnum,
	int		col,
	char_u		*text)
{
    win_T	*cw;
    long	winnr = 0;
    buf_T	*save_curbuf;
    int		use_sandbox;
    static char_u  *result = NULL;
    size_t	len;

    sctx_T	save_sctx = current_sctx;

    // Convert window pointer to number.
    for (cw = firstwin; cw != wp; cw = cw->w_next)
	++winnr;

    set_vim_var_nr(VV_BEVAL_BUFNR, (long)wp->w_buffer->b_fnum);
    set_vim_var_nr(VV_BEVAL_WINNR, winnr);
    set_vim_var_nr(VV_BEVAL_WINID, wp->w_id);
    set_vim_var_nr(VV_BEVAL_LNUM, (long)lnum);
    set_vim_var_nr(VV_BEVAL_COL, (long)(col + 1));
    set_vim_var_string(VV_BEVAL_TEXT, text, -1);
    vim_free(text);

    /*
     * Temporarily change the curbuf, so that we can determine whether
     * the buffer-local balloonexpr option was set insecurely.
     */
    save_curbuf = curbuf;
    curbuf = wp->w_buffer;
    use_sandbox = was_set_insecurely((char_u *)""balloonexpr"",
				    *curbuf->b_p_bexpr == NUL ? 0 : OPT_LOCAL);
    curbuf = save_curbuf;
    if (use_sandbox)
	++sandbox;
    ++textlock;

    if (bexpr == p_bexpr)
    {
	sctx_T *sp = get_option_sctx(""balloonexpr"");

	if (sp != NULL)
	    current_sctx = *sp;
    }
    else
	current_sctx = curbuf->b_p_script_ctx[BV_BEXPR];

    vim_free(result);
    result = eval_to_string(bexpr, TRUE, TRUE);

    // Remove one trailing newline, it is added when the result was a
    // list and it's hardly ever useful.  If the user really wants a
    // trailing newline he can add two and one remains.
    if (result != NULL)
    {
	len = STRLEN(result);
	if (len > 0 && result[len - 1] == NL)
	    result[len - 1] = NUL;
    }

    if (use_sandbox)
	--sandbox;
    --textlock;
    current_sctx = save_sctx;

    set_vim_var_string(VV_BEVAL_TEXT, NULL, -1);
    if (result != NULL && result[0] != NUL)
	post_balloon(beval, result, NULL);

    // The 'balloonexpr' evaluation may show something on the screen
    // that requires a screen update.
    if (must_redraw)
	redraw_after_callback(FALSE, FALSE);
}
# endif

/*
 * Common code, invoked when the mouse is resting for a moment.
 */
    void
general_beval_cb(BalloonEval *beval, int state UNUSED)
{
#ifdef FEAT_EVAL
    win_T	*wp;
    int		col;
    linenr_T	lnum;
    char_u	*text;
    char_u	*bexpr;
#endif
    static int	recursive = FALSE;

    // Don't do anything when 'ballooneval' is off, messages scrolled the
    // windows up or we have no beval area.
    if (!can_use_beval() || beval == NULL)
	return;

    // Don't do this recursively.  Happens when the expression evaluation
    // takes a long time and invokes something that checks for CTRL-C typed.
    if (recursive)
	return;
    recursive = TRUE;

#ifdef FEAT_EVAL
    if (get_beval_info(beval, TRUE, &wp, &lnum, &text, &col) == OK)
    {
	bexpr = (*wp->w_buffer->b_p_bexpr == NUL) ? p_bexpr
						    : wp->w_buffer->b_p_bexpr;
	if (*bexpr != NUL)
	{
	    bexpr_eval(beval, bexpr, wp, lnum, col, text);
	    recursive = FALSE;
	    return;
	}
    }
#endif
#ifdef FEAT_NETBEANS_INTG
    if (bevalServers & BEVAL_NETBEANS)
	netbeans_beval_cb(beval, state);
#endif

    recursive = FALSE;
}

#endif
"
./repos/vim/src/arabic.c,https://github.com/vim/vim,"/* vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved    by Bram Moolenaar
 *
 * Do "":help uganda""  in Vim to read copying and usage conditions.
 * Do "":help credits"" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 */

/*
 * arabic.c: functions for Arabic language
 *
 * Author: Nadim Shaikli & Isam Bayazidi
 * Farsi support and restructuring to make adding new letters easier by Ali
 * Gholami Rudi.  Further work by Ameretat Reith.
 */

/*
 * Sorted list of unicode Arabic characters.  Each entry holds the
 * presentation forms of a letter.
 *
 * Arabic characters are categorized into following types:
 *
 * Isolated	- iso-8859-6 form
 * Initial	- unicode form-B start
 * Medial	- unicode form-B middle
 * Final	- unicode form-B final
 * Stand-Alone	- unicode form-B isolated
 */

#include ""vim.h""

#if defined(FEAT_ARABIC) || defined(PROTO)

// Unicode values for Arabic characters.
#define a_HAMZA				0x0621
#define a_ALEF_MADDA			0x0622
#define a_ALEF_HAMZA_ABOVE		0x0623
#define a_WAW_HAMZA			0x0624
#define a_ALEF_HAMZA_BELOW		0x0625
#define a_YEH_HAMZA			0x0626
#define a_ALEF				0x0627
#define a_BEH				0x0628
#define a_TEH_MARBUTA			0x0629
#define a_TEH				0x062a
#define a_THEH				0x062b
#define a_JEEM				0x062c
#define a_HAH				0x062d
#define a_KHAH				0x062e
#define a_DAL				0x062f
#define a_THAL				0x0630
#define a_REH				0x0631
#define a_ZAIN				0x0632
#define a_SEEN				0x0633
#define a_SHEEN				0x0634
#define a_SAD				0x0635
#define a_DAD				0x0636
#define a_TAH				0x0637
#define a_ZAH				0x0638
#define a_AIN				0x0639
#define a_GHAIN				0x063a
#define a_TATWEEL			0x0640
#define a_FEH				0x0641
#define a_QAF				0x0642
#define a_KAF				0x0643
#define a_LAM				0x0644
#define a_MEEM				0x0645
#define a_NOON				0x0646
#define a_HEH				0x0647
#define a_WAW				0x0648
#define a_ALEF_MAKSURA			0x0649
#define a_YEH				0x064a
#define a_FATHATAN			0x064b
#define a_DAMMATAN			0x064c
#define a_KASRATAN			0x064d
#define a_FATHA				0x064e
#define a_DAMMA				0x064f
#define a_KASRA				0x0650
#define a_SHADDA			0x0651
#define a_SUKUN				0x0652
#define a_MADDA_ABOVE			0x0653
#define a_HAMZA_ABOVE			0x0654
#define a_HAMZA_BELOW			0x0655

#define a_PEH				0x067e
#define a_TCHEH				0x0686
#define a_JEH				0x0698
#define a_FKAF				0x06a9
#define a_GAF				0x06af
#define a_FYEH				0x06cc

#define a_s_LAM_ALEF_MADDA_ABOVE	0xfef5
#define a_f_LAM_ALEF_MADDA_ABOVE	0xfef6
#define a_s_LAM_ALEF_HAMZA_ABOVE	0xfef7
#define a_f_LAM_ALEF_HAMZA_ABOVE	0xfef8
#define a_s_LAM_ALEF_HAMZA_BELOW	0xfef9
#define a_f_LAM_ALEF_HAMZA_BELOW	0xfefa
#define a_s_LAM_ALEF			0xfefb
#define a_f_LAM_ALEF			0xfefc

static struct achar {
    unsigned c;
    unsigned isolated;
    unsigned initial;
    unsigned medial;
    unsigned final;
} achars[] = {
    {a_HAMZA, 0xfe80, 0, 0, 0},
    {a_ALEF_MADDA, 0xfe81, 0, 0, 0xfe82},
    {a_ALEF_HAMZA_ABOVE, 0xfe83, 0, 0, 0xfe84},
    {a_WAW_HAMZA, 0xfe85, 0, 0, 0xfe86},
    {a_ALEF_HAMZA_BELOW, 0xfe87, 0, 0, 0xfe88},
    {a_YEH_HAMZA, 0xfe89, 0xfe8b, 0xfe8c, 0xfe8a},
    {a_ALEF, 0xfe8d, 0, 0, 0xfe8e},
    {a_BEH, 0xfe8f, 0xfe91, 0xfe92, 0xfe90},
    {a_TEH_MARBUTA, 0xfe93, 0, 0, 0xfe94},
    {a_TEH, 0xfe95, 0xfe97, 0xfe98, 0xfe96},
    {a_THEH, 0xfe99, 0xfe9b, 0xfe9c, 0xfe9a},
    {a_JEEM, 0xfe9d, 0xfe9f, 0xfea0, 0xfe9e},
    {a_HAH, 0xfea1, 0xfea3, 0xfea4, 0xfea2},
    {a_KHAH, 0xfea5, 0xfea7, 0xfea8, 0xfea6},
    {a_DAL, 0xfea9, 0, 0, 0xfeaa},
    {a_THAL, 0xfeab, 0, 0, 0xfeac},
    {a_REH, 0xfead, 0, 0, 0xfeae},
    {a_ZAIN, 0xfeaf, 0, 0, 0xfeb0},
    {a_SEEN, 0xfeb1, 0xfeb3, 0xfeb4, 0xfeb2},
    {a_SHEEN, 0xfeb5, 0xfeb7, 0xfeb8, 0xfeb6},
    {a_SAD, 0xfeb9, 0xfebb, 0xfebc, 0xfeba},
    {a_DAD, 0xfebd, 0xfebf, 0xfec0, 0xfebe},
    {a_TAH, 0xfec1, 0xfec3, 0xfec4, 0xfec2},
    {a_ZAH, 0xfec5, 0xfec7, 0xfec8, 0xfec6},
    {a_AIN, 0xfec9, 0xfecb, 0xfecc, 0xfeca},
    {a_GHAIN, 0xfecd, 0xfecf, 0xfed0, 0xfece},
    {a_TATWEEL, 0, 0x0640, 0x0640, 0x0640},
    {a_FEH, 0xfed1, 0xfed3, 0xfed4, 0xfed2},
    {a_QAF, 0xfed5, 0xfed7, 0xfed8, 0xfed6},
    {a_KAF, 0xfed9, 0xfedb, 0xfedc, 0xfeda},
    {a_LAM, 0xfedd, 0xfedf, 0xfee0, 0xfede},
    {a_MEEM, 0xfee1, 0xfee3, 0xfee4, 0xfee2},
    {a_NOON, 0xfee5, 0xfee7, 0xfee8, 0xfee6},
    {a_HEH, 0xfee9, 0xfeeb, 0xfeec, 0xfeea},
    {a_WAW, 0xfeed, 0, 0, 0xfeee},
    {a_ALEF_MAKSURA, 0xfeef, 0, 0, 0xfef0},
    {a_YEH, 0xfef1, 0xfef3, 0xfef4, 0xfef2},
    {a_FATHATAN, 0xfe70, 0, 0, 0},
    {a_DAMMATAN, 0xfe72, 0, 0, 0},
    {a_KASRATAN, 0xfe74, 0, 0, 0},
    {a_FATHA, 0xfe76, 0, 0xfe77, 0},
    {a_DAMMA, 0xfe78, 0, 0xfe79, 0},
    {a_KASRA, 0xfe7a, 0, 0xfe7b, 0},
    {a_SHADDA, 0xfe7c, 0, 0xfe7c, 0},
    {a_SUKUN, 0xfe7e, 0, 0xfe7f, 0},
    {a_MADDA_ABOVE, 0, 0, 0, 0},
    {a_HAMZA_ABOVE, 0, 0, 0, 0},
    {a_HAMZA_BELOW, 0, 0, 0, 0},
    {a_PEH, 0xfb56, 0xfb58, 0xfb59, 0xfb57},
    {a_TCHEH, 0xfb7a, 0xfb7c, 0xfb7d, 0xfb7b},
    {a_JEH, 0xfb8a, 0, 0, 0xfb8b},
    {a_FKAF, 0xfb8e, 0xfb90, 0xfb91, 0xfb8f},
    {a_GAF, 0xfb92, 0xfb94, 0xfb95, 0xfb93},
    {a_FYEH, 0xfbfc, 0xfbfe, 0xfbff, 0xfbfd},
};

#define a_BYTE_ORDER_MARK		0xfeff

/*
 * Find the struct achar pointer to the given Arabic char.
 * Returns NULL if not found.
 */
    static struct achar *
find_achar(int c)
{
    int h, m, l;

    // using binary search to find c
    h = ARRAY_LENGTH(achars);
    l = 0;
    while (l < h)
    {
	m = (h + l) / 2;
	if (achars[m].c == (unsigned)c)
	    return &achars[m];
	if ((unsigned)c < achars[m].c)
	    h = m;
	else
	    l = m + 1;
    }
    return NULL;
}

/*
 * Change shape - from Combination (2 char) to an Isolated
 */
    static int
chg_c_laa2i(int hid_c)
{
    int tempc;

    switch (hid_c)
    {
	case a_ALEF_MADDA:
	    tempc = a_s_LAM_ALEF_MADDA_ABOVE;
	    break;
	case a_ALEF_HAMZA_ABOVE:
	    tempc = a_s_LAM_ALEF_HAMZA_ABOVE;
	    break;
	case a_ALEF_HAMZA_BELOW:
	    tempc = a_s_LAM_ALEF_HAMZA_BELOW;
	    break;
	case a_ALEF:
	    tempc = a_s_LAM_ALEF;
	    break;
	default:
	    tempc = 0;
    }

    return tempc;
}

/*
 * Change shape - from Combination-Isolated to Final
 */
    static int
chg_c_laa2f(int hid_c)
{
    int tempc;

    switch (hid_c)
    {
	case a_ALEF_MADDA:
	    tempc = a_f_LAM_ALEF_MADDA_ABOVE;
	    break;
	case a_ALEF_HAMZA_ABOVE:
	    tempc = a_f_LAM_ALEF_HAMZA_ABOVE;
	    break;
	case a_ALEF_HAMZA_BELOW:
	    tempc = a_f_LAM_ALEF_HAMZA_BELOW;
	    break;
	case a_ALEF:
	    tempc = a_f_LAM_ALEF;
	    break;
	default:
	    tempc = 0;
    }

    return tempc;
}

/*
 * Returns whether it is possible to join the given letters
 */
    static int
can_join(int c1, int c2)
{
    struct achar *a1 = find_achar(c1);
    struct achar *a2 = find_achar(c2);

    return a1 && a2 && (a1->initial || a1->medial) && (a2->final || a2->medial);
}

/*
 * Check whether we are dealing with a character that could be regarded as an
 * Arabic combining character, need to check the character before this.
 */
    int
arabic_maycombine(int two)
{
    if (p_arshape && !p_tbidi)
	return (two == a_ALEF_MADDA
		    || two == a_ALEF_HAMZA_ABOVE
		    || two == a_ALEF_HAMZA_BELOW
		    || two == a_ALEF);
    return FALSE;
}

/*
 * Check whether we are dealing with Arabic combining characters.
 * Note: these are NOT really composing characters!
 */
    int
arabic_combine(
    int		one,	    // first character
    int		two)	    // character just after ""one""
{
    if (one == a_LAM)
	return arabic_maycombine(two);
    return FALSE;
}

/*
 * A_is_iso returns true if 'c' is an Arabic ISO-8859-6 character
 *		(alphabet/number/punctuation)
 */
    static int
A_is_iso(int c)
{
    return find_achar(c) != NULL;
}

/*
 * A_is_ok returns true if 'c' is an Arabic 10646 (8859-6 or Form-B)
 */
    static int
A_is_ok(int c)
{
    return (A_is_iso(c) || c == a_BYTE_ORDER_MARK);
}

/*
 * A_is_valid returns true if 'c' is an Arabic 10646 (8859-6 or Form-B)
 *		with some exceptions/exclusions
 */
    static int
A_is_valid(int c)
{
    return (A_is_ok(c) && c != a_HAMZA);
}

/*
 * Do Arabic shaping on character ""c"".  Returns the shaped character.
 * out:    ""ccp"" points to the first byte of the character to be shaped.
 * in/out: ""c1p"" points to the first composing char for ""c"".
 * in:     ""prev_c""  is the previous character (not shaped)
 * in:     ""prev_c1"" is the first composing char for the previous char
 *		     (not shaped)
 * in:     ""next_c""  is the next character (not shaped).
 */
    int
arabic_shape(
    int		c,
    int		*ccp,
    int		*c1p,
    int		prev_c,
    int		prev_c1,
    int		next_c)
{
    int		curr_c;
    int		curr_laa;
    int		prev_laa;

    // Deal only with Arabic characters, pass back all others
    if (!A_is_ok(c))
	return c;

    curr_laa = arabic_combine(c, *c1p);
    prev_laa = arabic_combine(prev_c, prev_c1);

    if (curr_laa)
    {
	if (A_is_valid(prev_c) && can_join(prev_c, a_LAM) && !prev_laa)
	    curr_c = chg_c_laa2f(*c1p);
	else
	    curr_c = chg_c_laa2i(*c1p);

	// Remove the composing character
	*c1p = 0;
    }
    else
    {
	struct achar *curr_a = find_achar(c);
	int backward_combine = !prev_laa && can_join(prev_c, c);
	int forward_combine = can_join(c, next_c);

	if (backward_combine)
	{
	    if (forward_combine)
		curr_c = curr_a->medial;
	    else
		curr_c = curr_a->final;
	}
	else
	{
	    if (forward_combine)
		curr_c = curr_a->initial;
	    else
		curr_c = curr_a->isolated;
	}
    }

    // Character missing from the table means using original character.
    if (curr_c == NUL)
	curr_c = c;

    if (curr_c != c && ccp != NULL)
    {
	char_u buf[MB_MAXBYTES + 1];

	// Update the first byte of the character.
	(*mb_char2bytes)(curr_c, buf);
	*ccp = buf[0];
    }

    // Return the shaped character
    return curr_c;
}
#endif // FEAT_ARABIC
"
./repos/tmate/alerts.c,https://github.com/tmate-io/tmate,"/* $OpenBSD$ */

/*
 * Copyright (c) 2015 Nicholas Marriott <nicholas.marriott@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <event.h>

#include ""tmux.h""

int	alerts_fired;

void	alerts_timer(int, short, void *);
int	alerts_enabled(struct window *, int);
void	alerts_callback(int, short, void *);
void	alerts_reset(struct window *);

void	alerts_run_hook(struct session *, struct winlink *, int);
int	alerts_check_all(struct session *, struct winlink *);
int	alerts_check_bell(struct session *, struct winlink *);
int	alerts_check_activity(struct session *, struct winlink *);
int	alerts_check_silence(struct session *, struct winlink *);
void	alerts_ring_bell(struct session *);

void
alerts_timer(__unused int fd, __unused short events, void *arg)
{
	struct window	*w = arg;

	log_debug(""@%u alerts timer expired"", w->id);
	alerts_reset(w);
	alerts_queue(w, WINDOW_SILENCE);
}

void
alerts_callback(__unused int fd, __unused short events, __unused void *arg)
{
	struct window	*w;
	struct session	*s;
	struct winlink	*wl;
	int		 flags, alerts;

	RB_FOREACH(w, windows, &windows) {
		RB_FOREACH(s, sessions, &sessions) {
			RB_FOREACH(wl, winlinks, &s->windows) {
				if (wl->window != w)
					continue;
				flags = w->flags;

				alerts = alerts_check_all(s, wl);

				log_debug(""%s:%d @%u alerts check, alerts %#x, ""
				    ""flags %#x"", s->name, wl->idx, w->id,
				    alerts, flags);
			}
		}
	}
	alerts_fired = 0;
}

void
alerts_run_hook(struct session *s, struct winlink *wl, int flags)
{
	struct cmd_find_state	 fs;

	if (cmd_find_from_winlink(&fs, s, wl) != 0)
		return;

	if (flags & WINDOW_BELL)
		hooks_run(s->hooks, NULL, &fs, ""alert-bell"");
	if (flags & WINDOW_SILENCE)
		hooks_run(s->hooks, NULL, &fs, ""alert-silence"");
	if (flags & WINDOW_ACTIVITY)
		hooks_run(s->hooks, NULL, &fs, ""alert-activity"");
}

int
alerts_check_all(struct session *s, struct winlink *wl)
{
	int	alerts;

	alerts  = alerts_check_bell(s, wl);
	alerts |= alerts_check_activity(s, wl);
	alerts |= alerts_check_silence(s, wl);
	if (alerts != 0) {
		alerts_run_hook(s, wl, alerts);
		server_status_session(s);
	}

	return (alerts);
}

void
alerts_check_session(struct session *s)
{
	struct winlink	*wl;

	RB_FOREACH(wl, winlinks, &s->windows)
		alerts_check_all(s, wl);
}

int
alerts_enabled(struct window *w, int flags)
{
	if (flags & WINDOW_BELL)
		return (1);
	if (flags & WINDOW_ACTIVITY) {
		if (options_get_number(w->options, ""monitor-activity""))
			return (1);
	}
	if (flags & WINDOW_SILENCE) {
		if (options_get_number(w->options, ""monitor-silence"") != 0)
			return (1);
	}
	return (0);
}

void
alerts_reset_all(void)
{
	struct window	*w;

	RB_FOREACH(w, windows, &windows)
		alerts_reset(w);
}

void
alerts_reset(struct window *w)
{
	struct timeval	tv;

	w->flags &= ~WINDOW_SILENCE;
	event_del(&w->alerts_timer);

	timerclear(&tv);
	tv.tv_sec = options_get_number(w->options, ""monitor-silence"");

	log_debug(""@%u alerts timer reset %u"", w->id, (u_int)tv.tv_sec);
	if (tv.tv_sec != 0)
		event_add(&w->alerts_timer, &tv);
}

void
alerts_queue(struct window *w, int flags)
{
	if (w->flags & WINDOW_ACTIVITY)
		alerts_reset(w);

	if (!event_initialized(&w->alerts_timer))
		evtimer_set(&w->alerts_timer, alerts_timer, w);

	if (!alerts_fired) {
		w->flags |= flags;
		log_debug(""@%u alerts flags added %#x"", w->id, flags);

		if (alerts_enabled(w, flags)) {
			log_debug(""alerts check queued (by @%u)"", w->id);
			event_once(-1, EV_TIMEOUT, alerts_callback, NULL, NULL);
			alerts_fired = 1;
		}
	}
}

int
alerts_check_bell(struct session *s, struct winlink *wl)
{
	struct client	*c;
	struct window	*w = wl->window;
	int		 action, visual;

	if (!(w->flags & WINDOW_BELL))
		return (0);
	if (s->curw != wl) {
		wl->flags |= WINLINK_BELL;
		w->flags &= ~WINDOW_BELL;
	}
	if (s->curw->window == w)
		w->flags &= ~WINDOW_BELL;

	action = options_get_number(s->options, ""bell-action"");
	if (action == BELL_NONE)
		return (0);

	visual = options_get_number(s->options, ""visual-bell"");
	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session != s || c->flags & CLIENT_CONTROL)
			continue;
		if (!visual) {
			if ((action == BELL_CURRENT &&
			    c->session->curw->window == w) ||
			    (action == BELL_OTHER &&
			    c->session->curw->window != w) ||
			    action == BELL_ANY)
				tty_putcode(&c->tty, TTYC_BEL);
			continue;
		}
		if (action == BELL_CURRENT && c->session->curw->window == w)
			status_message_set(c, ""Bell in current window"");
		else if (action == BELL_ANY || (action == BELL_OTHER &&
		    c->session->curw->window != w))
			status_message_set(c, ""Bell in window %d"", wl->idx);
	}

	return (WINDOW_BELL);
}

int
alerts_check_activity(struct session *s, struct winlink *wl)
{
	struct client	*c;
	struct window	*w = wl->window;

	if (s->curw->window == w)
		w->flags &= ~WINDOW_ACTIVITY;

	if (!(w->flags & WINDOW_ACTIVITY) || wl->flags & WINLINK_ACTIVITY)
		return (0);
	if (s->curw == wl)
		return (0);

	if (!options_get_number(w->options, ""monitor-activity""))
		return (0);

	if (options_get_number(s->options, ""bell-on-alert""))
		alerts_ring_bell(s);
	wl->flags |= WINLINK_ACTIVITY;

	if (options_get_number(s->options, ""visual-activity"")) {
		TAILQ_FOREACH(c, &clients, entry) {
			if (c->session != s)
				continue;
			status_message_set(c, ""Activity in window %d"", wl->idx);
		}
	}

	return (WINDOW_ACTIVITY);
}

int
alerts_check_silence(struct session *s, struct winlink *wl)
{
	struct client	*c;
	struct window	*w = wl->window;

	if (s->curw->window == w)
		w->flags &= ~WINDOW_SILENCE;

	if (!(w->flags & WINDOW_SILENCE) || wl->flags & WINLINK_SILENCE)
		return (0);
	if (s->curw == wl)
		return (0);

	if (options_get_number(w->options, ""monitor-silence"") == 0)
		return (0);

	if (options_get_number(s->options, ""bell-on-alert""))
		alerts_ring_bell(s);
	wl->flags |= WINLINK_SILENCE;

	if (options_get_number(s->options, ""visual-silence"")) {
		TAILQ_FOREACH(c, &clients, entry) {
			if (c->session != s)
				continue;
			status_message_set(c, ""Silence in window %d"", wl->idx);
		}
	}

	return (WINDOW_SILENCE);
}

void
alerts_ring_bell(struct session *s)
{
	struct client	*c;

	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session == s && !(c->flags & CLIENT_CONTROL))
			tty_putcode(&c->tty, TTYC_BEL);
	}
}
"
./repos/tmate/arguments.c,https://github.com/tmate-io/tmate,"/* $OpenBSD$ */

/*
 * Copyright (c) 2010 Nicholas Marriott <nicholas.marriott@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include ""tmux.h""

/*
 * Manipulate command arguments.
 */

struct args_entry {
	u_char			 flag;
	char			*value;
	RB_ENTRY(args_entry)	 entry;
};

struct args_entry	*args_find(struct args *, u_char);

RB_GENERATE(args_tree, args_entry, entry, args_cmp);

/* Arguments tree comparison function. */
int
args_cmp(struct args_entry *a1, struct args_entry *a2)
{
	return (a1->flag - a2->flag);
}

/* Create an arguments set with no flags. */
struct args *
args_create(int argc, ...)
{
	struct args	*args;
	va_list		 ap;
	int		 i;

	args = xcalloc(1, sizeof *args);

	args->argc = argc;
	if (argc == 0)
		args->argv = NULL;
	else
		args->argv = xcalloc(argc, sizeof *args->argv);

	va_start(ap, argc);
	for (i = 0; i < argc; i++)
		args->argv[i] = xstrdup(va_arg(ap, char *));
	va_end(ap);

	return (args);
}

/* Find a flag in the arguments tree. */
struct args_entry *
args_find(struct args *args, u_char ch)
{
	struct args_entry	entry;

	entry.flag = ch;
	return (RB_FIND(args_tree, &args->tree, &entry));
}

/* Parse an argv and argc into a new argument set. */
struct args *
args_parse(const char *template, int argc, char **argv)
{
	struct args	*args;
	int		 opt;

	args = xcalloc(1, sizeof *args);

	optreset = 1;
	optind = 1;

	while ((opt = getopt(argc, argv, template)) != -1) {
		if (opt < 0)
			continue;
		if (opt == '?' || strchr(template, opt) == NULL) {
			args_free(args);
			return (NULL);
		}
		args_set(args, opt, optarg);
	}
	argc -= optind;
	argv += optind;

	args->argc = argc;
	args->argv = cmd_copy_argv(argc, argv);

	return (args);
}

/* Free an arguments set. */
void
args_free(struct args *args)
{
	struct args_entry	*entry;
	struct args_entry	*entry1;

	cmd_free_argv(args->argc, args->argv);

	RB_FOREACH_SAFE(entry, args_tree, &args->tree, entry1) {
		RB_REMOVE(args_tree, &args->tree, entry);
		free(entry->value);
		free(entry);
	}

	free(args);
}

/* Add to string. */
static void printflike(3, 4)
args_print_add(char **buf, size_t *len, const char *fmt, ...)
{
	va_list  ap;
	char	*s;
	size_t	 slen;

	va_start(ap, fmt);
	slen = xvasprintf(&s, fmt, ap);
	va_end(ap);

	*len += slen;
	*buf = xrealloc(*buf, *len);

	strlcat(*buf, s, *len);
	free(s);
}

/* Print a set of arguments. */
char *
args_print(struct args *args)
{
	size_t		 	 len;
	char			*buf;
	int			 i;
	struct args_entry	*entry;

	len = 1;
	buf = xcalloc(1, len);

	/* Process the flags first. */
	RB_FOREACH(entry, args_tree, &args->tree) {
		if (entry->value != NULL)
			continue;

		if (*buf == '\0')
			args_print_add(&buf, &len, ""-"");
		args_print_add(&buf, &len, ""%c"", entry->flag);
	}

	/* Then the flags with arguments. */
	RB_FOREACH(entry, args_tree, &args->tree) {
		if (entry->value == NULL)
			continue;

		if (*buf != '\0')
			args_print_add(&buf, &len, "" -%c "", entry->flag);
		else
			args_print_add(&buf, &len, ""-%c "", entry->flag);
		if (strchr(entry->value, ' ') != NULL)
			args_print_add(&buf, &len, ""\""%s\"""", entry->value);
		else
			args_print_add(&buf, &len, ""%s"", entry->value);
	}

	/* And finally the argument vector. */
	for (i = 0; i < args->argc; i++) {
		if (*buf != '\0')
			args_print_add(&buf, &len, "" "");
		if (strchr(args->argv[i], ' ') != NULL)
			args_print_add(&buf, &len, ""\""%s\"""", args->argv[i]);
		else
			args_print_add(&buf, &len, ""%s"", args->argv[i]);
	}

	return (buf);
}

/* Return if an argument is present. */
int
args_has(struct args *args, u_char ch)
{
	return (args_find(args, ch) == NULL ? 0 : 1);
}

/* Set argument value in the arguments tree. */
void
args_set(struct args *args, u_char ch, const char *value)
{
	struct args_entry	*entry;

	/* Replace existing argument. */
	if ((entry = args_find(args, ch)) != NULL) {
		free(entry->value);
		entry->value = NULL;
	} else {
		entry = xcalloc(1, sizeof *entry);
		entry->flag = ch;
		RB_INSERT(args_tree, &args->tree, entry);
	}

	if (value != NULL)
		entry->value = xstrdup(value);
}

/* Get argument value. Will be NULL if it isn't present. */
const char *
args_get(struct args *args, u_char ch)
{
	struct args_entry	*entry;

	if ((entry = args_find(args, ch)) == NULL)
		return (NULL);
	return (entry->value);
}

/* Convert an argument value to a number. */
long long
args_strtonum(struct args *args, u_char ch, long long minval, long long maxval,
    char **cause)
{
	const char		*errstr;
	long long 	 	 ll;
	struct args_entry	*entry;

	if ((entry = args_find(args, ch)) == NULL) {
		*cause = xstrdup(""missing"");
		return (0);
	}

	ll = strtonum(entry->value, minval, maxval, &errstr);
	if (errstr != NULL) {
		*cause = xstrdup(errstr);
		return (0);
	}

	*cause = NULL;
	return (ll);
}
"
./repos/tmate/cfg.c,https://github.com/tmate-io/tmate,"/* $OpenBSD$ */

/*
 * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <ctype.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include ""tmux.h""
#include ""tmate.h""

char		 *cfg_file;
#ifdef TMATE
char		 *tmate_cfg_file;
#endif
struct cmd_q	 *cfg_cmd_q;
int		  cfg_finished;
int		  cfg_references;
char		**cfg_causes;
u_int		  cfg_ncauses;
struct client	 *cfg_client;

void	cfg_default_done(struct cmd_q *);

void
set_cfg_file(const char *path)
{
	free(cfg_file);
	cfg_file = xstrdup(path);
}

void
start_cfg(void)
{
	char		*cause = NULL;
	const char	*home;

	cfg_cmd_q = cmdq_new(NULL);
	cfg_cmd_q->emptyfn = cfg_default_done;

	cfg_finished = 0;
	cfg_references = 1;

	cfg_client = TAILQ_FIRST(&clients);
	if (cfg_client != NULL)
		cfg_client->references++;

	if (access(TMUX_CONF, R_OK) == 0) {
		if (load_cfg(TMUX_CONF, cfg_cmd_q, &cause) == -1)
			cfg_add_cause(""%s: %s"", TMUX_CONF, cause);
	} else if (errno != ENOENT)
		cfg_add_cause(""%s: %s"", TMUX_CONF, strerror(errno));

	if (cfg_file == NULL && (home = find_home()) != NULL) {
		xasprintf(&cfg_file, ""%s/.tmate.conf"", home);
		if (access(cfg_file, R_OK) != 0 && errno == ENOENT) {
			free(cfg_file);
			cfg_file = NULL;
		}
	}
	if (cfg_file != NULL && load_cfg(cfg_file, cfg_cmd_q, &cause) == -1)
		cfg_add_cause(""%s: %s"", cfg_file, cause);
	free(cause);

	cmdq_continue(cfg_cmd_q);
}

int
load_cfg(const char *path, struct cmd_q *cmdq, char **cause)
{
	FILE		*f;
	char		 delim[3] = { '\\', '\\', '\0' };
	u_int		 found;
	size_t		 line = 0;
	char		*buf, *cause1, *p;
	struct cmd_list	*cmdlist;

	log_debug(""loading %s"", path);
	if ((f = fopen(path, ""rb"")) == NULL) {
		xasprintf(cause, ""%s: %s"", path, strerror(errno));
		return (-1);
	}

	found = 0;
	while ((buf = fparseln(f, NULL, &line, delim, 0)) != NULL) {
		log_debug(""%s: %s"", path, buf);

		/* Skip empty lines. */
		p = buf;
		while (isspace((u_char) *p))
			p++;
		if (*p == '\0') {
			free(buf);
			continue;
		}

		/* Parse and run the command. */
		if (cmd_string_parse(p, &cmdlist, path, line, &cause1) != 0) {
			free(buf);
			if (cause1 == NULL)
				continue;
			cfg_add_cause(""%s:%zu: %s"", path, line, cause1);
			free(cause1);
			continue;
		}
		free(buf);

		if (cmdlist == NULL)
			continue;
		cmdq_append(cmdq, cmdlist, NULL);
		cmd_list_free(cmdlist);
		found++;
	}
	fclose(f);

	return (found);
}

static void print_cfg_errors(void)
{
	u_int i;

	for (i = 0; i < cfg_ncauses; i++) {
		tmate_info(""%s"", cfg_causes[i]);
		free(cfg_causes[i]);
	}

	free(cfg_causes);
	cfg_causes = NULL;
	cfg_ncauses = 0;
}

void
cfg_default_done(__unused struct cmd_q *cmdq)
{
	if (--cfg_references != 0)
		return;
	cfg_finished = 1;

#ifdef TMATE
	/* We do it this late, this way, CLI options take precedence over cfg file */
	tmate_load_cli_options();

	tmate_session_start();
	if (tmate_foreground && cfg_ncauses) {
		print_cfg_errors();
		exit(1);
	}
#endif

	if (!RB_EMPTY(&sessions))
		cfg_show_causes(RB_MIN(sessions, &sessions));

	cmdq_free(cfg_cmd_q);
	cfg_cmd_q = NULL;

	if (cfg_client != NULL) {
		/*
		 * The client command queue starts with client_exit set to 1 so
		 * only continue if not empty (that is, we have been delayed
		 * during configuration parsing for long enough that the
		 * MSG_COMMAND has arrived), else the client will exit before
		 * the MSG_COMMAND which might tell it not to.
		 */
		if (!TAILQ_EMPTY(&cfg_client->cmdq->queue))
			cmdq_continue(cfg_client->cmdq);
		server_client_unref(cfg_client);
		cfg_client = NULL;
	}
}

void
cfg_add_cause(const char *fmt, ...)
{
	va_list	 ap;
	char	*msg;

	va_start(ap, fmt);
	xvasprintf(&msg, fmt, ap);
	va_end(ap);

	cfg_ncauses++;
	cfg_causes = xreallocarray(cfg_causes, cfg_ncauses, sizeof *cfg_causes);
	cfg_causes[cfg_ncauses - 1] = msg;
}

void
cfg_print_causes(struct cmd_q *cmdq)
{
	u_int	 i;

	for (i = 0; i < cfg_ncauses; i++) {
		cmdq_print(cmdq, ""%s"", cfg_causes[i]);
		free(cfg_causes[i]);
	}

	free(cfg_causes);
	cfg_causes = NULL;
	cfg_ncauses = 0;
}

void
cfg_show_causes(struct session *s)
{
	struct window_pane	*wp;
	u_int			 i;

	if (s == NULL || cfg_ncauses == 0)
		return;
	wp = s->curw->window->active;

	window_pane_set_mode(wp, &window_copy_mode);
	window_copy_init_for_output(wp);
	for (i = 0; i < cfg_ncauses; i++) {
		window_copy_add(wp, ""%s"", cfg_causes[i]);
		free(cfg_causes[i]);
	}

	free(cfg_causes);
	cfg_causes = NULL;
	cfg_ncauses = 0;
}
"
./repos/tmate/attributes.c,https://github.com/tmate-io/tmate,"/* $OpenBSD$ */

/*
 * Copyright (c) 2009 Joshua Elsasser <josh@elsasser.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <string.h>

#include ""tmux.h""

const char *
attributes_tostring(u_char attr)
{
	static char	buf[128];
	size_t		len;

	if (attr == 0)
		return (""none"");

	len = xsnprintf(buf, sizeof buf, ""%s%s%s%s%s%s%s"",
		attr & GRID_ATTR_BRIGHT ? ""bright,"" : """",
		attr & GRID_ATTR_DIM ? ""dim,"" : """",
		attr & GRID_ATTR_UNDERSCORE ? ""underscore,"" : """",
		attr & GRID_ATTR_BLINK ? ""blink,"" : """",
		attr & GRID_ATTR_REVERSE ? ""reverse,"" : """",
		attr & GRID_ATTR_HIDDEN ? ""hidden,"" : """",
		attr & GRID_ATTR_ITALICS ? ""italics,"" : """");
	if (len > 0)
		buf[len - 1] = '\0';

	return (buf);
}

int
attributes_fromstring(const char *str)
{
	const char	delimiters[] = "" ,|"";
	u_char		attr;
	size_t		end;

	if (*str == '\0' || strcspn(str, delimiters) == 0)
		return (-1);
	if (strchr(delimiters, str[strlen(str) - 1]) != NULL)
		return (-1);

	if (strcasecmp(str, ""default"") == 0 || strcasecmp(str, ""none"") == 0)
		return (0);

	attr = 0;
	do {
		end = strcspn(str, delimiters);
		if ((end == 6 && strncasecmp(str, ""bright"", end) == 0) ||
		    (end == 4 && strncasecmp(str, ""bold"", end) == 0))
			attr |= GRID_ATTR_BRIGHT;
		else if (end == 3 && strncasecmp(str, ""dim"", end) == 0)
			attr |= GRID_ATTR_DIM;
		else if (end == 10 && strncasecmp(str, ""underscore"", end) == 0)
			attr |= GRID_ATTR_UNDERSCORE;
		else if (end == 5 && strncasecmp(str, ""blink"", end) == 0)
			attr |= GRID_ATTR_BLINK;
		else if (end == 7 && strncasecmp(str, ""reverse"", end) == 0)
			attr |= GRID_ATTR_REVERSE;
		else if (end == 6 && strncasecmp(str, ""hidden"", end) == 0)
			attr |= GRID_ATTR_HIDDEN;
		else if (end == 7 && strncasecmp(str, ""italics"", end) == 0)
			attr |= GRID_ATTR_ITALICS;
		else
			return (-1);
		str += end + strspn(str + end, delimiters);
	} while (*str != '\0');

	return (attr);
}
"
./repos/tmate/client.c,https://github.com/tmate-io/tmate,"/* $OpenBSD$ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/file.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/un.h>
#include <sys/wait.h>

#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include ""tmux.h""
#include ""tmate.h""

struct tmuxproc	*client_proc;
struct tmuxpeer	*client_peer;
int		 client_flags;
struct event	 client_stdin;
enum {
	CLIENT_EXIT_NONE,
	CLIENT_EXIT_DETACHED,
	CLIENT_EXIT_DETACHED_HUP,
	CLIENT_EXIT_LOST_TTY,
	CLIENT_EXIT_TERMINATED,
	CLIENT_EXIT_LOST_SERVER,
	CLIENT_EXIT_EXITED,
	CLIENT_EXIT_SERVER_EXITED,
} client_exitreason = CLIENT_EXIT_NONE;
int		 client_exitval;
enum msgtype	 client_exittype;
const char	*client_exitsession;
int		 client_attached;

__dead void	client_exec(const char *,const char *);
int		client_get_lock(char *);
int		client_connect(struct event_base *, const char *, int);
void		client_send_identify(const char *, const char *);
void		client_stdin_callback(int, short, void *);
void		client_write(int, const char *, size_t);
void		client_signal(int);
void		client_dispatch(struct imsg *, void *);
void		client_dispatch_attached(struct imsg *);
void		client_dispatch_wait(struct imsg *, const char *);
const char     *client_exit_message(void);

/*
 * Get server create lock. If already held then server start is happening in
 * another client, so block until the lock is released and return -2 to
 * retry. Return -1 on failure to continue and start the server anyway.
 */
int
client_get_lock(char *lockfile)
{
	int lockfd;

	log_debug(""lock file is %s"", lockfile);

	if ((lockfd = open(lockfile, O_WRONLY|O_CREAT, 0600)) == -1) {
		log_debug(""open failed: %s"", strerror(errno));
		return (-1);
	}

	if (flock(lockfd, LOCK_EX|LOCK_NB) == -1) {
		log_debug(""flock failed: %s"", strerror(errno));
		if (errno != EAGAIN)
			return (lockfd);
		while (flock(lockfd, LOCK_EX) == -1 && errno == EINTR)
			/* nothing */;
		close(lockfd);
		return (-2);
	}
	log_debug(""flock succeeded"");

	return (lockfd);
}

/* Connect client to server. */
int
client_connect(struct event_base *base, const char *path, int start_server)
{
	struct sockaddr_un	sa;
	size_t			size;
	int			fd, lockfd = -1, locked = 0;
	char		       *lockfile = NULL;

	memset(&sa, 0, sizeof sa);
	sa.sun_family = AF_UNIX;
	size = strlcpy(sa.sun_path, path, sizeof sa.sun_path);
	if (size >= sizeof sa.sun_path) {
		errno = ENAMETOOLONG;
		return (-1);
	}
	log_debug(""socket is %s"", path);

retry:
	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		return (-1);

	log_debug(""trying connect"");
	if (connect(fd, (struct sockaddr *)&sa, sizeof sa) == -1) {
		log_debug(""connect failed: %s"", strerror(errno));
		if (errno != ECONNREFUSED && errno != ENOENT)
			goto failed;
		if (!start_server)
			goto failed;
		close(fd);

		if (!locked) {
			xasprintf(&lockfile, ""%s.lock"", path);
			if ((lockfd = client_get_lock(lockfile)) < 0) {
				log_debug(""didn't get lock (%d)"", lockfd);

				free(lockfile);
				lockfile = NULL;

				if (lockfd == -2)
					goto retry;
			}
			log_debug(""got lock (%d)"", lockfd);

			/*
			 * Always retry at least once, even if we got the lock,
			 * because another client could have taken the lock,
			 * started the server and released the lock between our
			 * connect() and flock().
			 */
			locked = 1;
			goto retry;
		}

		if (lockfd >= 0 && unlink(path) != 0 && errno != ENOENT) {
			free(lockfile);
			close(lockfd);
			return (-1);
		}
		fd = server_start(base, lockfd, lockfile);
	}

	if (locked && lockfd >= 0) {
		free(lockfile);
		close(lockfd);
	}
	setblocking(fd, 0);
	return (fd);

failed:
	if (locked) {
		free(lockfile);
		close(lockfd);
	}
	close(fd);
	return (-1);
}

/* Get exit string from reason number. */
const char *
client_exit_message(void)
{
	static char msg[256];

	switch (client_exitreason) {
	case CLIENT_EXIT_NONE:
		break;
	case CLIENT_EXIT_DETACHED:
		if (client_exitsession != NULL) {
			xsnprintf(msg, sizeof msg, ""detached ""
			    ""(from session %s)"", client_exitsession);
			return (msg);
		}
		return (""detached"");
	case CLIENT_EXIT_DETACHED_HUP:
		if (client_exitsession != NULL) {
			xsnprintf(msg, sizeof msg, ""detached and SIGHUP ""
			    ""(from session %s)"", client_exitsession);
			return (msg);
		}
		return (""detached and SIGHUP"");
	case CLIENT_EXIT_LOST_TTY:
		return (""lost tty"");
	case CLIENT_EXIT_TERMINATED:
		return (""terminated"");
	case CLIENT_EXIT_LOST_SERVER:
		return (""lost server"");
	case CLIENT_EXIT_EXITED:
		return (""exited"");
	case CLIENT_EXIT_SERVER_EXITED:
		return (""server exited"");
	}
	return (""unknown reason"");
}

#ifdef TMATE
extern const struct cmd_entry cmd_attach_session_entry;
extern const struct cmd_entry cmd_new_session_entry;

/* For foreground mode */
static int __argc;
static const char **__argv;
#endif

int run_headless_command(int argc, const char **argv, int flags, void (*err_callback)(const char *))
{
	struct cmd_q *cmd_q;
	struct cmd_list *cmdlist;
	char *cause;
	cmd_q = cmdq_new(NULL); /* No client */

	if ((cmdlist = cmd_list_parse(argc, (char **)argv, NULL, 0, &cause)) == NULL) {
		if (err_callback)
			err_callback(cause);
		return -1;
	}

	cmdq_run(cmd_q, cmdlist, NULL);
	cmd_list_free(cmdlist);
	cmdq_free(cmd_q);

	if (flags & DEFER_ERRORS_CFG)
		return 0;

	/* error messages land in cfg_causes */
	int ret = cfg_ncauses ? -1 : 0;
	for (u_int i = 0; i < cfg_ncauses; i++) {
		if (err_callback)
			err_callback(cfg_causes[i]);
		free(cfg_causes[i]);
	}

	free(cfg_causes);
	cfg_causes = NULL;
	cfg_ncauses = 0;

	return ret;
}

static void initial_client_cmd_err_callback(const char *cause)
{
	tmate_info(""%s"", cause);
}

void run_initial_client_cmd(void)
{
	int argc = __argc;
	const char **argv = __argv;

	const char *default_argv[] = {""new-session""};
	if (argc == 0) {
		argc = 1;
		argv = default_argv;
	}

	if (run_headless_command(argc, argv, 0, initial_client_cmd_err_callback) < 0)
		exit(1);
}

/* Client main loop. */
int
client_main(struct event_base *base, int argc, char **argv, int flags,
    const char *shellcmd)
{
	struct cmd		*cmd;
	struct cmd_list		*cmdlist;
	struct msg_command_data	*data;
	int			 cmdflags, fd, i;
	const char		*ttynam, *cwd;
	pid_t			 ppid;
	enum msgtype		 msg;
	char			*cause, path[PATH_MAX];
	struct termios		 tio, saved_tio;
	size_t			 size;
#ifdef TMATE
	int cant_nest = 0;
	__argc = argc;
	__argv = (const char **)argv;
#endif

	/* Ignore SIGCHLD now or daemon() in the server will leave a zombie. */
	signal(SIGCHLD, SIG_IGN);

	/* Save the flags. */
	client_flags = flags;

	/* Set up the initial command. */
	cmdflags = 0;
	if (shellcmd != NULL) {
		msg = MSG_SHELL;
		cmdflags = CMD_STARTSERVER;
	} else if (argc == 0) {
		msg = MSG_COMMAND;
		cmdflags = CMD_STARTSERVER;
#ifdef TMATE
	cant_nest = 1;
#endif
	} else {
		msg = MSG_COMMAND;

		/*
		 * It sucks parsing the command string twice (in client and
		 * later in server) but it is necessary to get the start server
		 * flag.
		 */
		cmdlist = cmd_list_parse(argc, argv, NULL, 0, &cause);
		if (cmdlist == NULL) {
			fprintf(stderr, ""%s\n"", cause);
			return (1);
		}
		cmdflags &= ~CMD_STARTSERVER;
		TAILQ_FOREACH(cmd, &cmdlist->list, qentry) {
			if (cmd->entry->flags & CMD_STARTSERVER)
				cmdflags |= CMD_STARTSERVER;

#ifdef TMATE
			if (cmd->entry == &cmd_attach_session_entry ||
			    cmd->entry == &cmd_new_session_entry)
				cant_nest = 1;
#endif
		}
		cmd_list_free(cmdlist);
	}

#ifdef TMATE
	if (cant_nest && getenv(""TMUX"")) {
		fprintf(stderr, ""sessions should be nested with care, ""
			""unset $TMUX to force\n"");
		return (1);
	}
#endif

	/* Create client process structure (starts logging). */
	client_proc = proc_start(""client"", base, 0, client_signal);

	/* Initialize the client socket and start the server. */
	fd = client_connect(base, socket_path, cmdflags & CMD_STARTSERVER);
	if (fd == -1) {
		if (errno == ECONNREFUSED) {
			fprintf(stderr, ""no server running on %s\n"",
			    socket_path);
		} else {
#ifdef TMATE
			if (errno == ENOENT)
				fprintf(stderr, ""You must specify a socket name with -S. For example: \n""
					        ""  tmate -S /tmp/tmate.sock new-session -d\n""
					        ""  tmate -S /tmp/tmate.sock wait tmate-ready\n"");
			else
#endif
			fprintf(stderr, ""error connecting to %s (%s)\n"",
			    socket_path, strerror(errno));
		}
		return (1);
	}
	client_peer = proc_add_peer(client_proc, fd, client_dispatch,
	    (void *)shellcmd);

	/* Save these before pledge(). */
	if ((cwd = getcwd(path, sizeof path)) == NULL) {
		if ((cwd = find_home()) == NULL)
			cwd = ""/"";
	}
	if ((ttynam = ttyname(STDIN_FILENO)) == NULL)
		ttynam = """";

#ifdef __OpenBSD__
	/*
	 * Drop privileges for client. ""proc exec"" is needed for -c and for
	 * locking (which uses system(3)).
	 *
	 * ""tty"" is needed to restore termios(4) and also for some reason -CC
	 * does not work properly without it (input is not recognised).
	 *
	 * ""sendfd"" is dropped later in client_dispatch_wait().
	 */
	if (pledge(""stdio unix sendfd proc exec tty"", NULL) != 0)
		fatal(""pledge failed"");
#endif

	/* Free stuff that is not used in the client. */
	options_free(global_options);
	options_free(global_s_options);
	options_free(global_w_options);
	environ_free(global_environ);

	/* Create stdin handler. */
	setblocking(STDIN_FILENO, 0);
	event_set(&client_stdin, STDIN_FILENO, EV_READ|EV_PERSIST,
	    client_stdin_callback, NULL);
	if (client_flags & CLIENT_CONTROLCONTROL) {
		if (tcgetattr(STDIN_FILENO, &saved_tio) != 0)
			fatal(""tcgetattr failed"");
		cfmakeraw(&tio);
		tio.c_iflag = ICRNL|IXANY;
		tio.c_oflag = OPOST|ONLCR;
#ifdef NOKERNINFO
		tio.c_lflag = NOKERNINFO;
#endif
		tio.c_cflag = CREAD|CS8|HUPCL;
		tio.c_cc[VMIN] = 1;
		tio.c_cc[VTIME] = 0;
		cfsetispeed(&tio, cfgetispeed(&saved_tio));
		cfsetospeed(&tio, cfgetospeed(&saved_tio));
		tcsetattr(STDIN_FILENO, TCSANOW, &tio);
	}

	/* Send identify messages. */
	client_send_identify(ttynam, cwd);

	/* Send first command. */
	if (msg == MSG_COMMAND) {
		/* How big is the command? */
		size = 0;
		for (i = 0; i < argc; i++)
			size += strlen(argv[i]) + 1;
		data = xmalloc((sizeof *data) + size);

		/* Prepare command for server. */
		data->argc = argc;
		if (cmd_pack_argv(argc, argv, (char *)(data + 1), size) != 0) {
			fprintf(stderr, ""command too long\n"");
			free(data);
			return (1);
		}
		size += sizeof *data;

		/* Send the command. */
		if (proc_send(client_peer, msg, -1, data, size) != 0) {
			fprintf(stderr, ""failed to send command\n"");
			free(data);
			return (1);
		}
		free(data);
	} else if (msg == MSG_SHELL)
		proc_send(client_peer, msg, -1, NULL, 0);

	/* Start main loop. */
	proc_loop(client_proc, NULL);

	/* Print the exit message, if any, and exit. */
	if (client_attached) {
		if (client_exitreason != CLIENT_EXIT_NONE)
			printf(""[%s]\n"", client_exit_message());

		ppid = getppid();
		if (client_exittype == MSG_DETACHKILL && ppid > 1)
			kill(ppid, SIGHUP);
	} else if (client_flags & CLIENT_CONTROLCONTROL) {
		if (client_exitreason != CLIENT_EXIT_NONE)
			printf(""%%exit %s\n"", client_exit_message());
		else
			printf(""%%exit\n"");
		printf(""\033\\"");
		tcsetattr(STDOUT_FILENO, TCSAFLUSH, &saved_tio);
	} else if (client_exitreason != CLIENT_EXIT_NONE)
		fprintf(stderr, ""%s\n"", client_exit_message());
	setblocking(STDIN_FILENO, 1);
	return (client_exitval);
}

/* Send identify messages to server. */
void
client_send_identify(const char *ttynam, const char *cwd)
{
	const char	 *s;
	char		**ss;
	size_t		  sslen;
	int		  fd, flags = client_flags;
	pid_t		  pid;

	proc_send(client_peer, MSG_IDENTIFY_FLAGS, -1, &flags, sizeof flags);

	if ((s = getenv(""TERM"")) == NULL)
		s = """";
	proc_send(client_peer, MSG_IDENTIFY_TERM, -1, s, strlen(s) + 1);

	proc_send(client_peer, MSG_IDENTIFY_TTYNAME, -1, ttynam,
	    strlen(ttynam) + 1);
	proc_send(client_peer, MSG_IDENTIFY_CWD, -1, cwd, strlen(cwd) + 1);

	if ((fd = dup(STDIN_FILENO)) == -1)
		fatal(""dup failed"");
	proc_send(client_peer, MSG_IDENTIFY_STDIN, fd, NULL, 0);

	pid = getpid();
	proc_send(client_peer, MSG_IDENTIFY_CLIENTPID, -1, &pid, sizeof pid);

	for (ss = environ; *ss != NULL; ss++) {
		sslen = strlen(*ss) + 1;
		if (sslen > MAX_IMSGSIZE - IMSG_HEADER_SIZE)
			continue;
		proc_send(client_peer, MSG_IDENTIFY_ENVIRON, -1, *ss, sslen);
	}

	proc_send(client_peer, MSG_IDENTIFY_DONE, -1, NULL, 0);
}

/* Callback for client stdin read events. */
void
client_stdin_callback(__unused int fd, __unused short events,
    __unused void *arg)
{
	struct msg_stdin_data	data;

	data.size = read(STDIN_FILENO, data.data, sizeof data.data);
	if (data.size < 0 && (errno == EINTR || errno == EAGAIN))
		return;

	proc_send(client_peer, MSG_STDIN, -1, &data, sizeof data);
	if (data.size <= 0)
		event_del(&client_stdin);
}

/* Force write to file descriptor. */
void
client_write(int fd, const char *data, size_t size)
{
	ssize_t	used;

	while (size != 0) {
		used = write(fd, data, size);
		if (used == -1) {
			if (errno == EINTR || errno == EAGAIN)
				continue;
			break;
		}
		data += used;
		size -= used;
	}
}

/* Run command in shell; used for -c. */
__dead void
client_exec(const char *shell, const char *shellcmd)
{
	const char	*name, *ptr;
	char		*argv0;

	log_debug(""shell %s, command %s"", shell, shellcmd);

	ptr = strrchr(shell, '/');
	if (ptr != NULL && *(ptr + 1) != '\0')
		name = ptr + 1;
	else
		name = shell;
	if (client_flags & CLIENT_LOGIN)
		xasprintf(&argv0, ""-%s"", name);
	else
		xasprintf(&argv0, ""%s"", name);
	setenv(""SHELL"", shell, 1);

	setblocking(STDIN_FILENO, 1);
	setblocking(STDOUT_FILENO, 1);
	setblocking(STDERR_FILENO, 1);
	closefrom(STDERR_FILENO + 1);

	execl(shell, argv0, ""-c"", shellcmd, (char *) NULL);
	fatal(""execl failed"");
}

/* Callback to handle signals in the client. */
void
client_signal(int sig)
{
	struct sigaction sigact;
	int		 status;

	if (sig == SIGCHLD)
		waitpid(WAIT_ANY, &status, WNOHANG);
	else if (!client_attached) {
		if (sig == SIGTERM)
			proc_exit(client_proc);
	} else {
		switch (sig) {
		case SIGHUP:
			client_exitreason = CLIENT_EXIT_LOST_TTY;
			client_exitval = 1;
			proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
			break;
		case SIGTERM:
			client_exitreason = CLIENT_EXIT_TERMINATED;
			client_exitval = 1;
			proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
			break;
		case SIGWINCH:
			proc_send(client_peer, MSG_RESIZE, -1, NULL, 0);
			break;
		case SIGCONT:
			memset(&sigact, 0, sizeof sigact);
			sigemptyset(&sigact.sa_mask);
			sigact.sa_flags = SA_RESTART;
			sigact.sa_handler = SIG_IGN;
			if (sigaction(SIGTSTP, &sigact, NULL) != 0)
				fatal(""sigaction failed"");
			proc_send(client_peer, MSG_WAKEUP, -1, NULL, 0);
			break;
		}
	}
}

/* Callback for client read events. */
void
client_dispatch(struct imsg *imsg, void *arg)
{
	if (imsg == NULL) {
		client_exitreason = CLIENT_EXIT_LOST_SERVER;
		client_exitval = 1;
		proc_exit(client_proc);
		return;
	}

	if (client_attached)
		client_dispatch_attached(imsg);
	else
		client_dispatch_wait(imsg, arg);
}

/* Dispatch imsgs when in wait state (before MSG_READY). */
void
client_dispatch_wait(struct imsg *imsg, const char *shellcmd)
{
	char			*data;
	ssize_t			 datalen;
	struct msg_stdout_data	 stdoutdata;
	struct msg_stderr_data	 stderrdata;
	int			 retval;
#ifdef __OpenBSD__
	static int		 pledge_applied;

	/*
	 * ""sendfd"" is no longer required once all of the identify messages
	 * have been sent. We know the server won't send us anything until that
	 * point (because we don't ask it to), so we can drop ""sendfd"" once we
	 * get the first message from the server.
	 */
	if (!pledge_applied) {
		if (pledge(""stdio unix proc exec tty"", NULL) != 0)
			fatal(""pledge failed"");
		pledge_applied = 1;
	};
#endif

	data = imsg->data;
	datalen = imsg->hdr.len - IMSG_HEADER_SIZE;

	switch (imsg->hdr.type) {
	case MSG_EXIT:
	case MSG_SHUTDOWN:
		if (datalen != sizeof retval && datalen != 0)
			fatalx(""bad MSG_EXIT size"");
		if (datalen == sizeof retval) {
			memcpy(&retval, data, sizeof retval);
			client_exitval = retval;
		}
		proc_exit(client_proc);
		break;
	case MSG_READY:
		if (datalen != 0)
			fatalx(""bad MSG_READY size"");

		event_del(&client_stdin);
		client_attached = 1;
		proc_send(client_peer, MSG_RESIZE, -1, NULL, 0);
		break;
	case MSG_STDIN:
		if (datalen != 0)
			fatalx(""bad MSG_STDIN size"");

		event_add(&client_stdin, NULL);
		break;
	case MSG_STDOUT:
		if (datalen != sizeof stdoutdata)
			fatalx(""bad MSG_STDOUT size"");
		memcpy(&stdoutdata, data, sizeof stdoutdata);

		client_write(STDOUT_FILENO, stdoutdata.data,
		    stdoutdata.size);
		break;
	case MSG_STDERR:
		if (datalen != sizeof stderrdata)
			fatalx(""bad MSG_STDERR size"");
		memcpy(&stderrdata, data, sizeof stderrdata);

		client_write(STDERR_FILENO, stderrdata.data,
		    stderrdata.size);
		break;
	case MSG_VERSION:
		if (datalen != 0)
			fatalx(""bad MSG_VERSION size"");

		fprintf(stderr, ""protocol version mismatch ""
		    ""(client %d, server %u)\n"", PROTOCOL_VERSION,
		    imsg->hdr.peerid & 0xff);
		client_exitval = 1;
		proc_exit(client_proc);
		break;
	case MSG_SHELL:
		if (datalen == 0 || data[datalen - 1] != '\0')
			fatalx(""bad MSG_SHELL string"");

		clear_signals(0);
		client_exec(data, shellcmd);
		/* NOTREACHED */
	case MSG_DETACH:
	case MSG_DETACHKILL:
		proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
		break;
	case MSG_EXITED:
		proc_exit(client_proc);
		break;
	}
}

/* Dispatch imsgs in attached state (after MSG_READY). */
void
client_dispatch_attached(struct imsg *imsg)
{
	struct sigaction	 sigact;
	char			*data;
	ssize_t			 datalen;

	data = imsg->data;
	datalen = imsg->hdr.len - IMSG_HEADER_SIZE;

	switch (imsg->hdr.type) {
	case MSG_DETACH:
	case MSG_DETACHKILL:
		if (datalen == 0 || data[datalen - 1] != '\0')
			fatalx(""bad MSG_DETACH string"");

		client_exitsession = xstrdup(data);
		client_exittype = imsg->hdr.type;
		if (imsg->hdr.type == MSG_DETACHKILL)
			client_exitreason = CLIENT_EXIT_DETACHED_HUP;
		else
			client_exitreason = CLIENT_EXIT_DETACHED;
		proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
		break;
	case MSG_EXIT:
		if (datalen != 0 && datalen != sizeof (int))
			fatalx(""bad MSG_EXIT size"");

		proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
		client_exitreason = CLIENT_EXIT_EXITED;
		break;
	case MSG_EXITED:
		if (datalen != 0)
			fatalx(""bad MSG_EXITED size"");

		proc_exit(client_proc);
		break;
	case MSG_SHUTDOWN:
		if (datalen != 0)
			fatalx(""bad MSG_SHUTDOWN size"");

		proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
		client_exitreason = CLIENT_EXIT_SERVER_EXITED;
		client_exitval = 1;
		break;
	case MSG_SUSPEND:
		if (datalen != 0)
			fatalx(""bad MSG_SUSPEND size"");

		memset(&sigact, 0, sizeof sigact);
		sigemptyset(&sigact.sa_mask);
		sigact.sa_flags = SA_RESTART;
		sigact.sa_handler = SIG_DFL;
		if (sigaction(SIGTSTP, &sigact, NULL) != 0)
			fatal(""sigaction failed"");
		kill(getpid(), SIGTSTP);
		break;
	case MSG_LOCK:
		if (datalen == 0 || data[datalen - 1] != '\0')
			fatalx(""bad MSG_LOCK string"");

		system(data);
		proc_send(client_peer, MSG_UNLOCK, -1, NULL, 0);
		break;
	}
}
"
./repos/aria2/src/strptime.c,https://github.com/aria2/aria2,"/*
 * Copyright (c) 1999 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of KTH nor the names of its contributors may be
 *    used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY KTH AND ITS CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL KTH OR ITS CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

#ifndef HAVE_CONFIG_H
#  include ""config.h""
#endif // HAVE_CONFIG_H

#ifndef HAVE_LOCALTIME_R
#  include ""localtime_r.h""
#endif // HAVE_LOCALTIME_R

#ifndef HAVE_TIMEGM
#  include ""timegm.h""
#endif // HAVE_TIMEGM

#include <stddef.h>
#include <stdio.h>
#include <time.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

#ifdef HAVE_ALLOCA_H
#  include <alloca.h>
#endif // HAVE_ALLOCA_H

#ifdef HAVE_MALLOC_H
#  include <malloc.h>
#endif // HAVE_MALLOC_H

#include ""strptime.h""

static const char* abb_weekdays[] = {""Sun"", ""Mon"", ""Tue"", ""Wed"",
                                     ""Thu"", ""Fri"", ""Sat"", NULL};

static const char* full_weekdays[] = {""Sunday"",    ""Monday"",   ""Tuesday"",
                                      ""Wednesday"", ""Thursday"", ""Friday"",
                                      ""Saturday"",  NULL};

static const char* abb_month[] = {""Jan"", ""Feb"", ""Mar"", ""Apr"", ""May"",
                                  ""Jun"", ""Jul"", ""Aug"", ""Sep"", ""Oct"",
                                  ""Nov"", ""Dec"", NULL};

static const char* full_month[] = {
    ""January"", ""February"",  ""March"",   ""April"",    ""May"",      ""June"", ""July"",
    ""August"",  ""September"", ""October"", ""November"", ""December"", NULL,
};

static const char* ampm[] = {""am"", ""pm"", NULL};

/*
 * tm_year is relative this year
 */
const int tm_year_base = 1900;

/*
 * Return TRUE iff `year' was a leap year.
 * Needed for strptime.
 */
static int is_leap_year(int year)
{
  return (year % 4) == 0 && ((year % 100) != 0 || (year % 400) == 0);
}

/* Needed for strptime. */
static int match_string(const char** buf, const char** strs)
{
  int i = 0;

  for (i = 0; strs[i] != NULL; ++i) {
    int len = strlen(strs[i]);

    if (strncasecmp(*buf, strs[i], len) == 0) {
      *buf += len;
      return i;
    }
  }
  return -1;
}

/* Needed for strptime. */
static int first_day(int year)
{
  int ret = 4;

  for (; year > 1970; --year)
    ret = (ret + 365 + is_leap_year(year) ? 1 : 0) % 7;
  return ret;
}

/*
 * Set `timeptr' given `wnum' (week number [0, 53])
 * Needed for strptime
 */

static void set_week_number_sun(struct tm* timeptr, int wnum)
{
  int fday = first_day(timeptr->tm_year + tm_year_base);

  timeptr->tm_yday = wnum * 7 + timeptr->tm_wday - fday;
  if (timeptr->tm_yday < 0) {
    timeptr->tm_wday = fday;
    timeptr->tm_yday = 0;
  }
}

/*
 * Set `timeptr' given `wnum' (week number [0, 53])
 * Needed for strptime
 */

static void set_week_number_mon(struct tm* timeptr, int wnum)
{
  int fday = (first_day(timeptr->tm_year + tm_year_base) + 6) % 7;

  timeptr->tm_yday = wnum * 7 + (timeptr->tm_wday + 6) % 7 - fday;
  if (timeptr->tm_yday < 0) {
    timeptr->tm_wday = (fday + 1) % 7;
    timeptr->tm_yday = 0;
  }
}

/*
 * Set `timeptr' given `wnum' (week number [0, 53])
 * Needed for strptime
 */
static void set_week_number_mon4(struct tm* timeptr, int wnum)
{
  int fday = (first_day(timeptr->tm_year + tm_year_base) + 6) % 7;
  int offset = 0;

  if (fday < 4)
    offset += 7;

  timeptr->tm_yday = offset + (wnum - 1) * 7 + timeptr->tm_wday - fday;
  if (timeptr->tm_yday < 0) {
    timeptr->tm_wday = fday;
    timeptr->tm_yday = 0;
  }
}

/* strptime: roken */
// extern ""C""
static char* _strptime(const char* buf, const char* format, struct tm* timeptr,
                       int* gmt)
{
  char c;

  for (; (c = *format) != '\0'; ++format) {
    char* s;
    int ret;

    if (isspace(c)) {
      while (isspace(*buf))
        ++buf;
    }
    else if (c == '%' && format[1] != '\0') {
      c = *++format;
      if (c == 'E' || c == 'O')
        c = *++format;
      switch (c) {
      case 'A':
      case 'a':
        ret = match_string(&buf, full_weekdays);
        if (ret < 0)
          ret = match_string(&buf, abb_weekdays);
        if (ret < 0)
          return NULL;
        timeptr->tm_wday = ret;
        break;
      case 'B':
      case 'b':
      case 'h':
        ret = match_string(&buf, full_month);
        if (ret < 0)
          ret = match_string(&buf, abb_month);
        if (ret < 0)
          return NULL;
        timeptr->tm_mon = ret;
        break;
      case 'C':
        ret = strtol(buf, &s, 10);
        if (s == buf)
          return NULL;
        timeptr->tm_year = (ret * 100) - tm_year_base;
        buf = s;
        break;
      case 'c': /* %a %b %e %H:%M:%S %Y */
        s = strptime(buf, ""%a %b %e %H:%M:%S %Y"", timeptr);
        if (s == NULL)
          return NULL;
        buf = s;
        break;
      case 'D': /* %m/%d/%y */
        s = strptime(buf, ""%m/%d/%y"", timeptr);
        if (s == NULL)
          return NULL;
        buf = s;
        break;
      case 'd':
      case 'e':
        ret = strtol(buf, &s, 10);
        if (s == buf)
          return NULL;
        timeptr->tm_mday = ret;
        buf = s;
        break;
      case 'H':
      case 'k':
        ret = strtol(buf, &s, 10);
        if (s == buf)
          return NULL;
        timeptr->tm_hour = ret;
        buf = s;
        break;
      case 'I':
      case 'l':
        ret = strtol(buf, &s, 10);
        if (s == buf)
          return NULL;
        if (ret == 12)
          timeptr->tm_hour = 0;
        else
          timeptr->tm_hour = ret;
        buf = s;
        break;
      case 'j':
        ret = strtol(buf, &s, 10);
        if (s == buf)
          return NULL;
        timeptr->tm_yday = ret - 1;
        buf = s;
        break;
      case 'm':
        ret = strtol(buf, &s, 10);
        if (s == buf)
          return NULL;
        timeptr->tm_mon = ret - 1;
        buf = s;
        break;
      case 'M':
        ret = strtol(buf, &s, 10);
        if (s == buf)
          return NULL;
        timeptr->tm_min = ret;
        buf = s;
        break;
      case 'n':
        if (*buf == '\n')
          ++buf;
        else
          return NULL;
        break;
      case 'p':
        ret = match_string(&buf, ampm);
        if (ret < 0)
          return NULL;
        if (timeptr->tm_hour == 0) {
          if (ret == 1)
            timeptr->tm_hour = 12;
        }
        else
          timeptr->tm_hour += 12;
        break;
      case 'r': /* %I:%M:%S %p */
        s = strptime(buf, ""%I:%M:%S %p"", timeptr);
        if (s == NULL)
          return NULL;
        buf = s;
        break;
      case 'R': /* %H:%M */
        s = strptime(buf, ""%H:%M"", timeptr);
        if (s == NULL)
          return NULL;
        buf = s;
        break;
      case 'S':
        ret = strtol(buf, &s, 10);
        if (s == buf)
          return NULL;
        timeptr->tm_sec = ret;
        buf = s;
        break;
      case 't':
        if (*buf == '\t')
          ++buf;
        else
          return NULL;
        break;
      case 'T': /* %H:%M:%S */
      case 'X':
        s = strptime(buf, ""%H:%M:%S"", timeptr);
        if (s == NULL)
          return NULL;
        buf = s;
        break;
      case 'u':
        ret = strtol(buf, &s, 10);
        if (s == buf)
          return NULL;
        timeptr->tm_wday = ret - 1;
        buf = s;
        break;
      case 'w':
        ret = strtol(buf, &s, 10);
        if (s == buf)
          return NULL;
        timeptr->tm_wday = ret;
        buf = s;
        break;
      case 'U':
        ret = strtol(buf, &s, 10);
        if (s == buf)
          return NULL;
        set_week_number_sun(timeptr, ret);
        buf = s;
        break;
      case 'V':
        ret = strtol(buf, &s, 10);
        if (s == buf)
          return NULL;
        set_week_number_mon4(timeptr, ret);
        buf = s;
        break;
      case 'W':
        ret = strtol(buf, &s, 10);
        if (s == buf)
          return NULL;
        set_week_number_mon(timeptr, ret);
        buf = s;
        break;
      case 'x':
        s = strptime(buf, ""%Y:%m:%d"", timeptr);
        if (s == NULL)
          return NULL;
        buf = s;
        break;
      case 'y':
        ret = strtol(buf, &s, 10);
        if (s == buf)
          return NULL;
        /*
         * y represents stricty 2 digits, raise error if more than 3
         * digits are parsed.
         */
        if (ret > 99) {
          return NULL;
        }
        /*
         * The value in the range 69-99 refer to years in 20th century.
         * The value in the range 00-68 refer to years in 21st century.
         */
        if (ret < 69)
          timeptr->tm_year = 100 + ret;
        else
          timeptr->tm_year = ret;
        buf = s;
        break;
      case 'Y':
        ret = strtol(buf, &s, 10);
        if (s == buf)
          return NULL;
        timeptr->tm_year = ret - tm_year_base;
        buf = s;
        break;
      case 'Z':
        /* source:
         * cygwin-1.5.24-2-src/cygwin-1.5.24-2/winsup/cygwin/libc/strptime.cc */
        {
          const char* cp;
          char* zonestr;

          for (cp = buf; *cp && isupper((unsigned char)*cp); ++cp) { /*empty*/
          }
          if (cp - buf) {
            zonestr = (char*)alloca(cp - buf + 1);
            strncpy(zonestr, buf, cp - buf);
            zonestr[cp - buf] = '\0';
            tzset();
            if (0 == strcmp(zonestr, ""GMT"")) {
              *gmt = 1;
            }
            else if (0 == strcmp(zonestr, tzname[0])) {
              timeptr->tm_isdst = 0;
            }
            else if (0 == strcmp(zonestr, tzname[1])) {
              timeptr->tm_isdst = 1;
            }
            else {
              return 0;
            }
            buf += cp - buf;
          }
        }
        break;
      case '\0':
        --format;
      /* FALLTHROUGH */
      case '%':
        if (*buf == '%')
          ++buf;
        else
          return NULL;
        break;
      default:
        if (*buf == '%' || *++buf == c)
          ++buf;
        else
          return NULL;
        break;
      }
    }
    else {
      if (*buf == c)
        ++buf;
      else
        return NULL;
    }
  }
  return (char*)buf;
}

char* strptime(const char* buf, const char* format, struct tm* timeptr)
{
  char* ret;
  int gmt;

  gmt = 0;
  ret = _strptime(buf, format, timeptr, &gmt);
  return (ret);
}
"
./repos/aria2/src/timegm.c,https://github.com/aria2/aria2,"/*
 * aria2 - The high speed download utility
 *
 * Copyright (C) 2012 Tatsuhiro Tsujikawa
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 *
 * In addition, as a special exception, the copyright holders give
 * permission to link the code of portions of this program with the
 * OpenSSL library under certain conditions as described in each
 * individual source file, and distribute linked combinations
 * including the two.
 * You must obey the GNU General Public License in all respects
 * for all of the code used other than OpenSSL.  If you modify
 * file(s) with this exception, you may extend this exception to your
 * version of the file(s), but you are not obligated to do so.  If you
 * do not wish to do so, delete this exception statement from your
 * version.  If you delete this exception statement from all source
 * files in the program, then also delete it here.
 */
/* copyright --> */
#include ""timegm.h""

#include <stdint.h>

/* Counter the number of leap year in the range [0, y). The |y| is the
   year, including century (e.g., 2012) */
static int count_leap_year(int y)
{
  y -= 1;
  return y / 4 - y / 100 + y / 400;
}

/* Returns nonzero if the |y| is the leap year. The |y| is the year,
   including century (e.g., 2012) */
static int is_leap_year(int y)
{
  return y % 4 == 0 && (y % 100 != 0 || y % 400 == 0);
}

/* The number of days before ith month begins */
static int daysum[] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};

// Based on the algorithm of Python 2.7 calendar.timegm.
time_t timegm(struct tm* tm)
{
  int days;
  int num_leap_year;
  int64_t t;
  if (tm->tm_mon > 11) {
    return -1;
  }
  num_leap_year = count_leap_year(tm->tm_year + 1900) - count_leap_year(1970);
  days = (tm->tm_year - 70) * 365 + num_leap_year + daysum[tm->tm_mon] +
         tm->tm_mday - 1;
  if (tm->tm_mon >= 2 && is_leap_year(tm->tm_year + 1900)) {
    ++days;
  }
  t = ((int64_t)days * 24 + tm->tm_hour) * 3600 + tm->tm_min * 60 + tm->tm_sec;
  if (sizeof(time_t) == 4) {
    if (t < INT32_MIN || t > INT32_MAX) {
      return -1;
    }
  }
  return t;
}
"
./repos/aria2/src/alloca.c,https://github.com/aria2/aria2,"/* alloca.c -- allocate automatically reclaimed memory
   (Mostly) portable public-domain implementation -- D A Gwyn

   This implementation of the PWB library alloca function,
   which is used to allocate space off the run-time stack so
   that it is automatically reclaimed upon procedure exit,
   was inspired by discussions with J. Q. Johnson of Cornell.
   J.Otto Tennant <jot@cray.com> contributed the Cray support.

   There are some preprocessor constants that can
   be defined when compiling for your specific system, for
   improved efficiency; however, the defaults should be okay.

   The general concept of this implementation is to keep
   track of all alloca-allocated blocks, and reclaim any
   that are found to be deeper in the stack than the current
   invocation.  This heuristic does not reclaim storage as
   soon as it becomes invalid, but it will do so eventually.

   As a special case, alloca(0) reclaims storage without
   allocating any.  It is a good idea to use alloca(0) in
   your main control loop, etc. to force garbage collection.  */

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#if HAVE_STRING_H
#  include <string.h>
#endif
#if HAVE_STDLIB_H
#  include <stdlib.h>
#endif

#ifdef emacs
#  include ""blockinput.h""
#endif

/* If compiling with GCC 2, this file's not needed.  */
#if !defined(__GNUC__) || __GNUC__ < 2

/* If someone has defined alloca as a macro,
   there must be some other way alloca is supposed to work.  */
#  ifndef alloca

#    ifdef emacs
#      ifdef static
/* actually, only want this if static is defined as """"
   -- this is for usg, in which emacs must undefine static
   in order to make unexec workable
   */
#        ifndef STACK_DIRECTION
you lose-- must know STACK_DIRECTION at compile - time
#        endif /* STACK_DIRECTION undefined */
#      endif   /* static */
#    endif     /* emacs */

/* If your stack is a linked list of frames, you have to
   provide an ""address metric"" ADDRESS_FUNCTION macro.  */

#    if defined(CRAY) && defined(CRAY_STACKSEG_END)
    long
    i00afunc();
#      define ADDRESS_FUNCTION(arg) (char*)i00afunc(&(arg))
#    else
#      define ADDRESS_FUNCTION(arg) &(arg)
#    endif

#    if __STDC__
typedef void* pointer;
#    else
typedef char* pointer;
#    endif

#    ifndef NULL
#      define NULL 0
#    endif

/* Different portions of Emacs need to call different versions of
   malloc.  The Emacs executable needs alloca to call xmalloc, because
   ordinary malloc isn't protected from input signals.  On the other
   hand, the utilities in lib-src need alloca to call malloc; some of
   them are very simple, and don't have an xmalloc routine.

   Non-Emacs programs expect this to call xmalloc.

   Callers below should use malloc.  */

#    ifndef emacs
#      undef malloc
#      define malloc xmalloc
#    endif
extern pointer malloc();

/* Define STACK_DIRECTION if you know the direction of stack
   growth for your system; otherwise it will be automatically
   deduced at run-time.

   STACK_DIRECTION > 0 => grows toward higher addresses
   STACK_DIRECTION < 0 => grows toward lower addresses
   STACK_DIRECTION = 0 => direction of growth unknown  */

#    ifndef STACK_DIRECTION
#      define STACK_DIRECTION 0 /* Direction unknown.  */
#    endif

#    if STACK_DIRECTION != 0

#      define STACK_DIR STACK_DIRECTION /* Known at compile-time.  */

#    else /* STACK_DIRECTION == 0; need run-time code.  */

static int stack_dir; /* 1 or -1 once known.  */
#      define STACK_DIR stack_dir

static void find_stack_direction()
{
  static char* addr = NULL; /* Address of first `dummy', once known.  */
  auto char dummy;          /* To get stack address.  */

  if (addr == NULL) { /* Initial entry.  */
    addr = ADDRESS_FUNCTION(dummy);

    find_stack_direction(); /* Recurse once.  */
  }
  else {
    /* Second entry.  */
    if (ADDRESS_FUNCTION(dummy) > addr)
      stack_dir = 1; /* Stack grew upward.  */
    else
      stack_dir = -1; /* Stack grew downward.  */
  }
}

#    endif /* STACK_DIRECTION == 0 */

/* An ""alloca header"" is used to:
   (a) chain together all alloca'ed blocks;
   (b) keep track of stack depth.

   It is very important that sizeof(header) agree with malloc
   alignment chunk size.  The following default should work okay.  */

#    ifndef ALIGN_SIZE
#      define ALIGN_SIZE sizeof(double)
#    endif

typedef union hdr {
  char align[ALIGN_SIZE]; /* To force sizeof(header).  */
  struct {
    union hdr* next; /* For chaining headers.  */
    char* deep;      /* For stack depth measure.  */
  } h;
} header;

static header* last_alloca_header = NULL; /* -> last alloca header.  */

/* Return a pointer to at least SIZE bytes of storage,
   which will be automatically reclaimed upon exit from
   the procedure that called alloca.  Originally, this space
   was supposed to be taken from the current stack frame of the
   caller, but that method cannot be made to work for some
   implementations of C, for example under Gould's UTX/32.  */

pointer alloca(size_t size)
{
  auto char probe; /* Probes stack depth: */
  register char* depth = ADDRESS_FUNCTION(probe);

#    if STACK_DIRECTION == 0
  if (STACK_DIR == 0) /* Unknown growth direction.  */
    find_stack_direction();
#    endif

  /* Reclaim garbage, defined as all alloca'd storage that
     was allocated from deeper in the stack than currently.  */

  {
    register header* hp; /* Traverses linked list.  */

#    ifdef emacs
    BLOCK_INPUT;
#    endif

    for (hp = last_alloca_header; hp != NULL;)
      if ((STACK_DIR > 0 && hp->h.deep > depth) ||
          (STACK_DIR < 0 && hp->h.deep < depth)) {
        register header* np = hp->h.next;

        free((pointer)hp); /* Collect garbage.  */

        hp = np; /* -> next header.  */
      }
      else
        break; /* Rest are not deeper.  */

    last_alloca_header = hp; /* -> last valid storage.  */

#    ifdef emacs
    UNBLOCK_INPUT;
#    endif
  }

  if (size == 0)
    return NULL; /* No allocation required.  */

  /* Allocate combined header + user data storage.  */

  {
    register pointer new = malloc(sizeof(header) + size);
    /* Address of header.  */

    if (new == 0)
      abort();

    ((header*)new)->h.next = last_alloca_header;
    ((header*)new)->h.deep = depth;

    last_alloca_header = (header*)new;

    /* User storage begins just after header.  */

    return (pointer)((char*)new + sizeof(header));
  }
}

#    if defined(CRAY) && defined(CRAY_STACKSEG_END)

#      ifdef DEBUG_I00AFUNC
#        include <stdio.h>
#      endif

#      ifndef CRAY_STACK
#        define CRAY_STACK
#        ifndef CRAY2
/* Stack structures for CRAY-1, CRAY X-MP, and CRAY Y-MP */
struct stack_control_header {
  long shgrow : 32; /* Number of times stack has grown.  */
  long shaseg : 32; /* Size of increments to stack.  */
  long shhwm : 32;  /* High water mark of stack.  */
  long shsize : 32; /* Current size of stack (all segments).  */
};

/* The stack segment linkage control information occurs at
   the high-address end of a stack segment.  (The stack
   grows from low addresses to high addresses.)  The initial
   part of the stack segment linkage control information is
   0200 (octal) words.  This provides for register storage
   for the routine which overflows the stack.  */

struct stack_segment_linkage {
  long ss[0200];    /* 0200 overflow words.  */
  long sssize : 32; /* Number of words in this segment.  */
  long ssbase : 32; /* Offset to stack base.  */
  long : 32;
  long sspseg : 32; /* Offset to linkage control of previous
                       segment of stack.  */
  long : 32;
  long sstcpt : 32; /* Pointer to task common address block.  */
  long sscsnm;      /* Private control structure number for
                       microtasking.  */
  long ssusr1;      /* Reserved for user.  */
  long ssusr2;      /* Reserved for user.  */
  long sstpid;      /* Process ID for pid based multi-tasking.  */
  long ssgvup;      /* Pointer to multitasking thread giveup.  */
  long sscray[7];   /* Reserved for Cray Research.  */
  long ssa0;
  long ssa1;
  long ssa2;
  long ssa3;
  long ssa4;
  long ssa5;
  long ssa6;
  long ssa7;
  long sss0;
  long sss1;
  long sss2;
  long sss3;
  long sss4;
  long sss5;
  long sss6;
  long sss7;
};

#        else /* CRAY2 */
/* The following structure defines the vector of words
   returned by the STKSTAT library routine.  */
struct stk_stat {
  long now;             /* Current total stack size.  */
  long maxc;            /* Amount of contiguous space which would
                           be required to satisfy the maximum
                           stack demand to date.  */
  long high_water;      /* Stack high-water mark.  */
  long overflows;       /* Number of stack overflow ($STKOFEN) calls.  */
  long hits;            /* Number of internal buffer hits.  */
  long extends;         /* Number of block extensions.  */
  long stko_mallocs;    /* Block allocations by $STKOFEN.  */
  long underflows;      /* Number of stack underflow calls ($STKRETN).  */
  long stko_free;       /* Number of deallocations by $STKRETN.  */
  long stkm_free;       /* Number of deallocations by $STKMRET.  */
  long segments;        /* Current number of stack segments.  */
  long maxs;            /* Maximum number of stack segments so far.  */
  long pad_size;        /* Stack pad size.  */
  long current_address; /* Current stack segment address.  */
  long current_size;    /* Current stack segment size.  This
                           number is actually corrupted by STKSTAT to
                           include the fifteen word trailer area.  */
  long initial_address; /* Address of initial segment.  */
  long initial_size;    /* Size of initial segment.  */
};

/* The following structure describes the data structure which trails
   any stack segment.  I think that the description in 'asdef' is
   out of date.  I only describe the parts that I am sure about.  */

struct stk_trailer {
  long this_address; /* Address of this block.  */
  long this_size;    /* Size of this block (does not include
                        this trailer).  */
  long unknown2;
  long unknown3;
  long link; /* Address of trailer block of previous
                segment.  */
  long unknown5;
  long unknown6;
  long unknown7;
  long unknown8;
  long unknown9;
  long unknown10;
  long unknown11;
  long unknown12;
  long unknown13;
  long unknown14;
};

#        endif /* CRAY2 */
#      endif   /* not CRAY_STACK */

#      ifdef CRAY2
/* Determine a ""stack measure"" for an arbitrary ADDRESS.
   I doubt that ""lint"" will like this much.  */

static long i00afunc(long* address)
{
  struct stk_stat status;
  struct stk_trailer* trailer;
  long *block, size;
  long result = 0;

  /* We want to iterate through all of the segments.  The first
     step is to get the stack status structure.  We could do this
     more quickly and more directly, perhaps, by referencing the
     $LM00 common block, but I know that this works.  */

  STKSTAT(&status);

  /* Set up the iteration.  */

  trailer =
      (struct stk_trailer*)(status.current_address + status.current_size - 15);

  /* There must be at least one stack segment.  Therefore it is
     a fatal error if ""trailer"" is null.  */

  if (trailer == 0)
    abort();

  /* Discard segments that do not contain our argument address.  */

  while (trailer != 0) {
    block = (long*)trailer->this_address;
    size = trailer->this_size;
    if (block == 0 || size == 0)
      abort();
    trailer = (struct stk_trailer*)trailer->link;
    if ((block <= address) && (address < (block + size)))
      break;
  }

  /* Set the result to the offset in this segment and add the sizes
     of all predecessor segments.  */

  result = address - block;

  if (trailer == 0) {
    return result;
  }

  do {
    if (trailer->this_size <= 0)
      abort();
    result += trailer->this_size;
    trailer = (struct stk_trailer*)trailer->link;
  } while (trailer != 0);

  /* We are done.  Note that if you present a bogus address (one
     not in any segment), you will get a different number back, formed
     from subtracting the address of the first block.  This is probably
     not what you want.  */

  return (result);
}

#      else /* not CRAY2 */
/* Stack address function for a CRAY-1, CRAY X-MP, or CRAY Y-MP.
   Determine the number of the cell within the stack,
   given the address of the cell.  The purpose of this
   routine is to linearize, in some sense, stack addresses
   for alloca.  */

static long i00afunc(long address)
{
  long stkl = 0;

  long size, pseg, this_segment, stack;
  long result = 0;

  struct stack_segment_linkage* ssptr;

  /* Register B67 contains the address of the end of the
     current stack segment.  If you (as a subprogram) store
     your registers on the stack and find that you are past
     the contents of B67, you have overflowed the segment.

     B67 also points to the stack segment linkage control
     area, which is what we are really interested in.  */

  stkl = CRAY_STACKSEG_END();
  ssptr = (struct stack_segment_linkage*)stkl;

  /* If one subtracts 'size' from the end of the segment,
     one has the address of the first word of the segment.

     If this is not the first segment, 'pseg' will be
     nonzero.  */

  pseg = ssptr->sspseg;
  size = ssptr->sssize;

  this_segment = stkl - size;

  /* It is possible that calling this routine itself caused
     a stack overflow.  Discard stack segments which do not
     contain the target address.  */

  while (!(this_segment <= address && address <= stkl)) {
#        ifdef DEBUG_I00AFUNC
    fprintf(stderr, ""%011o %011o %011o\n"", this_segment, address, stkl);
#        endif
    if (pseg == 0)
      break;
    stkl = stkl - pseg;
    ssptr = (struct stack_segment_linkage*)stkl;
    size = ssptr->sssize;
    pseg = ssptr->sspseg;
    this_segment = stkl - size;
  }

  result = address - this_segment;

  /* If you subtract pseg from the current end of the stack,
     you get the address of the previous stack segment's end.
     This seems a little convoluted to me, but I'll bet you save
     a cycle somewhere.  */

  while (pseg != 0) {
#        ifdef DEBUG_I00AFUNC
    fprintf(stderr, ""%011o %011o\n"", pseg, size);
#        endif
    stkl = stkl - pseg;
    ssptr = (struct stack_segment_linkage*)stkl;
    size = ssptr->sssize;
    pseg = ssptr->sspseg;
    result += size;
  }
  return (result);
}

#      endif /* not CRAY2 */
#    endif   /* CRAY */

#  endif /* no alloca */
#endif   /* not GCC version 2 */
"
./repos/aria2/src/getaddrinfo.c,https://github.com/aria2/aria2,"/*
 * Copyright (c) 2001, 02  Motoyuki Kasahara
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * This program provides getaddrinfo() and getnameinfo() described in
 * RFC2133, 2553 and 3493.  These functions are mainly used for IPv6
 * application to resolve hostname or address.
 *
 * This program is designed to be working on traditional IPv4 systems
 * which don't have those functions.  Therefore, this implementation
 * supports IPv4 only.
 *
 * This program is useful for application which should support both IPv6
 * and traditional IPv4 systems.  Use genuine getaddrinfo() and getnameinfo()
 * provided by system if the system supports IPv6.  Otherwise, use this
 * implementation.
 *
 * This program is intended to be used in combination with GNU Autoconf.
 *
 * This program also provides freeaddrinfo() and gai_strerror().
 *
 * To use this program in your application, insert the following lines to
 * C source files after including `sys/types.h', `sys/socket.h' and
 * `netdb.h'.  `getaddrinfo.h' defines `struct addrinfo' and AI_, NI_,
 * EAI_ macros.
 *
 *    #ifndef HAVE_GETADDRINFO
 *    #include ""getaddrinfo.h""
 *    #endif
 *
 * Restriction:
 *   getaddrinfo() and getnameinfo() of this program are NOT thread
 *   safe, unless the cpp macro ENABLE_PTHREAD is defined.
 */

/*
 * Add the following code to your configure.ac (or configure.in).
 *   AC_C_CONST
 *   AC_HEADER_STDC
 *   AC_CHECK_HEADERS(string.h memory.h stdlib.h)
 *   AC_CHECK_FUNCS(memcpy)
 *   AC_REPLACE_FUNCS(memset)
 *   AC_TYPE_SOCKLEN_T
 *   AC_TYPE_IN_PORT_T
 *   AC_DECL_H_ERRNO
 *
 *   AC_CHECK_FUNCS(getaddrinfo getnameinfo)
 *   if test ""$ac_cv_func_getaddrinfo$ac_cv_func_getnameinfo"" != yesyes ; then
 *       LIBOBJS=""$LIBOBJS getaddrinfo.$ac_objext""
 *   fi
 */

#ifdef HAVE_CONFIG_H
#  include ""config.h""
#endif

#ifdef __MINGW32__
#  include <winsock2.h>
#  undef ERROR
#  include <ws2tcpip.h>
#endif

#ifdef HAVE_SYS_SOCKET_H
#  include <sys/socket.h>
#endif
#ifdef HAVE_NETINET_IN_H
#  include <netinet/in.h>
#endif
#ifdef HAVE_ARPA_INET_H
#  include <arpa/inet.h>
#endif
#ifdef HAVE_NETDB_H
#  include <netdb.h>
#endif

#include <sys/types.h>
#include <stdio.h>

#if defined(STDC_HEADERS) || defined(HAVE_STRING_H)
#  include <string.h>
#  if !defined(STDC_HEADERS) && defined(HAVE_MEMORY_H)
#    include <memory.h>
#  endif /* not STDC_HEADERS and HAVE_MEMORY_H */
#else    /* not STDC_HEADERS and not HAVE_STRING_H */
#  include <strings.h>
#endif /* not STDC_HEADERS and not HAVE_STRING_H */

#ifdef HAVE_STDLIB_H
#  include <stdlib.h>
#endif

#ifdef ENABLE_PTHREAD
#  include <pthread.h>
#endif

#ifdef ENABLE_NLS
#  include <libintl.h>
#endif

#ifndef HAVE_MEMCPY
#  define memcpy(d, s, n) bcopy((s), (d), (n))
#  ifdef __STDC__
void* memchr(const void*, int, size_t);
int memcmp(const void*, const void*, size_t);
void* memmove(void*, const void*, size_t);
void* memset(void*, int, size_t);
#  else  /* not __STDC__ */
char* memchr();
int memcmp();
char* memmove();
char* memset();
#  endif /* not __STDC__ */
#endif   /* not HAVE_MEMCPY */

#ifndef H_ERRNO_DECLARED
extern int h_errno;
#endif

#include ""getaddrinfo.h""

#ifdef ENABLE_NLS
#  define _(string) gettext(string)
#  ifdef gettext_noop
#    define N_(string) gettext_noop(string)
#  else
#    define N_(string) (string)
#  endif
#else
#  define gettext(string) (string)
#  define _(string) (string)
#  define N_(string) (string)
#endif

/*
 * Error messages for gai_strerror().
 */
static char* eai_errlist[] = {
    N_(""Success""),

    /* EAI_ADDRFAMILY */
    N_(""Address family for hostname not supported""),

    /* EAI_AGAIN */
    N_(""Temporary failure in name resolution""),

    /* EAI_BADFLAGS */
    N_(""Invalid value for ai_flags""),

    /* EAI_FAIL */
    N_(""Non-recoverable failure in name resolution""),

    /* EAI_FAMILY */
    N_(""ai_family not supported""),

    /* EAI_MEMORY */
    N_(""Memory allocation failure""),

    /* EAI_NONAME */
    N_(""hostname nor servname provided, or not known""),

    /* EAI_OVERFLOW */
    N_(""An argument buffer overflowed""),

    /* EAI_SERVICE */
    N_(""servname not supported for ai_socktype""),

    /* EAI_SOCKTYPE */
    N_(""ai_socktype not supported""),

    /* EAI_SYSTEM */
    N_(""System error returned in errno"")};

/*
 * Default hints for getaddrinfo().
 */
static struct addrinfo default_hints = {0, PF_UNSPEC, 0,    0,
                                        0, NULL,      NULL, NULL};

/*
 * Mutex.
 */
#ifdef ENABLE_PTHREAD
static pthread_mutex_t gai_mutex = PTHREAD_MUTEX_INITIALIZER;
#endif

/*
 * Declaration of static functions.
 */
#ifdef __STDC__
static int is_integer(const char*);
static int is_address(const char*);
static int itoa_length(int);
#else
static int is_integer();
static int is_address();
static int itoa_length();
#endif

/*
 * gai_strerror().
 */
const char* gai_strerror(ecode)
int ecode;
{
  if (ecode < 0 || ecode > EAI_SYSTEM)
    return _(""Unknown error"");

  return gettext(eai_errlist[ecode]);
}

/*
 * freeaddrinfo().
 */
void freeaddrinfo(ai) struct addrinfo* ai;
{
  struct addrinfo* next_ai;

  while (ai != NULL) {
    if (ai->ai_canonname != NULL)
      free(ai->ai_canonname);
    if (ai->ai_addr != NULL)
      free(ai->ai_addr);
    next_ai = ai->ai_next;
    free(ai);
    ai = next_ai;
  }
}

/*
 * Return 1 if the string `s' represents an integer.
 */
static int is_integer(s) const char* s;
{
  if (*s == '-' || *s == '+')
    s++;
  if (*s < '0' || '9' < *s)
    return 0;

  s++;
  while ('0' <= *s && *s <= '9')
    s++;

  return (*s == '\0');
}

/*
 * Return 1 if the string `s' represents an IPv4 address.
 * Unlike inet_addr(), it doesn't permit malformed nortation such
 * as ""192.168"".
 */
static int is_address(s) const char* s;
{
  const static char delimiters[] = {'.', '.', '.', '\0'};
  int i, j;
  int octet;

  for (i = 0; i < 4; i++) {
    if (*s == '0' && *(s + 1) != delimiters[i])
      return 0;
    for (j = 0, octet = 0; '0' <= *s && *s <= '9' && j < 3; s++, j++)
      octet = octet * 10 + (*s - '0');
    if (j == 0 || octet > 255 || *s != delimiters[i])
      return 0;
    s++;
  }

  return 1;
}

/*
 * Calculate length of the string `s', where `s' is set by
 * sprintf(s, ""%d"", n).
 */
static int itoa_length(n)
int n;
{
  int result = 1;

  if (n < 0) {
    n = -n;
    result++;
  }

  while (n >= 10) {
    result++;
    n /= 10;
  }

  return result;
}

/*
 * getaddrinfo().
 */
int getaddrinfo(nodename, servname, hints, res) const char* nodename;
const char* servname;
const struct addrinfo* hints;
struct addrinfo** res;
{
  struct addrinfo* head_res = NULL;
  struct addrinfo* tail_res = NULL;
  struct addrinfo* new_res;
  struct sockaddr_in* sa_in;
  struct in_addr** addr_list;
  struct in_addr* addr_list_buf[2];
  struct in_addr addr_buf;
  struct in_addr** ap;
  struct servent* servent;
  struct hostent* hostent;
  const char* canonname = NULL;
  in_port_t port;
  int saved_h_errno;
  int result = 0;

#ifdef ENABLE_PTHREAD
  pthread_mutex_lock(&gai_mutex);
#endif

  saved_h_errno = h_errno;

  if (nodename == NULL && servname == NULL) {
    result = EAI_NONAME;
    goto end;
  }

  if (hints != NULL) {
    if (hints->ai_family != PF_INET && hints->ai_family != PF_UNSPEC) {
      result = EAI_FAMILY;
      goto end;
    }
    if (hints->ai_socktype != SOCK_DGRAM && hints->ai_socktype != SOCK_STREAM &&
        hints->ai_socktype != 0) {
      result = EAI_SOCKTYPE;
      goto end;
    }
  }
  else {
    hints = &default_hints;
  }

  if (servname != NULL) {
    if (is_integer(servname))
      port = htons(atoi(servname));
    else {
      if (hints->ai_flags & AI_NUMERICSERV) {
        result = EAI_NONAME;
        goto end;
      }

      if (hints->ai_socktype == SOCK_DGRAM)
        servent = getservbyname(servname, ""udp"");
      else if (hints->ai_socktype == SOCK_STREAM)
        servent = getservbyname(servname, ""tcp"");
      else if (hints->ai_socktype == 0)
        servent = getservbyname(servname, ""tcp"");
      else {
        result = EAI_SOCKTYPE;
        goto end;
      }

      if (servent == NULL) {
        result = EAI_SERVICE;
        goto end;
      }
      port = servent->s_port;
    }
  }
  else {
    port = htons(0);
  }

  if (nodename != NULL) {
    if (is_address(nodename)) {
      addr_buf.s_addr = inet_addr(nodename);
      addr_list_buf[0] = &addr_buf;
      addr_list_buf[1] = NULL;
      addr_list = addr_list_buf;

      if (hints->ai_flags & AI_CANONNAME &&
          !(hints->ai_flags & AI_NUMERICHOST)) {
        hostent =
            gethostbyaddr((char*)&addr_buf, sizeof(struct in_addr), AF_INET);
        if (hostent != NULL)
          canonname = hostent->h_name;
        else
          canonname = nodename;
      }
    }
    else {
      if (hints->ai_flags & AI_NUMERICHOST) {
        result = EAI_NONAME;
        goto end;
      }

      hostent = gethostbyname(nodename);
      if (hostent == NULL) {
        switch (h_errno) {
        case HOST_NOT_FOUND:
        case NO_DATA:
          result = EAI_NONAME;
          goto end;
        case TRY_AGAIN:
          result = EAI_AGAIN;
          goto end;
        default:
          result = EAI_FAIL;
          goto end;
        }
      }
      addr_list = (struct in_addr**)hostent->h_addr_list;

      if (hints->ai_flags & AI_CANONNAME)
        canonname = hostent->h_name;
    }
  }
  else {
    if (hints->ai_flags & AI_PASSIVE)
      addr_buf.s_addr = htonl(INADDR_ANY);
    else
      addr_buf.s_addr = htonl(0x7F000001);
    addr_list_buf[0] = &addr_buf;
    addr_list_buf[1] = NULL;
    addr_list = addr_list_buf;
  }

  for (ap = addr_list; *ap != NULL; ap++) {
    new_res = (struct addrinfo*)malloc(sizeof(struct addrinfo));
    if (new_res == NULL) {
      if (head_res != NULL)
        freeaddrinfo(head_res);
      result = EAI_MEMORY;
      goto end;
    }

    new_res->ai_family = PF_INET;
    new_res->ai_socktype = hints->ai_socktype;
    new_res->ai_protocol = hints->ai_protocol;
    new_res->ai_addr = NULL;
    new_res->ai_addrlen = sizeof(struct sockaddr_in);
    new_res->ai_canonname = NULL;
    new_res->ai_next = NULL;

    new_res->ai_addr = (struct sockaddr*)malloc(sizeof(struct sockaddr_in));
    if (new_res->ai_addr == NULL) {
      free(new_res);
      if (head_res != NULL)
        freeaddrinfo(head_res);
      result = EAI_MEMORY;
      goto end;
    }

    sa_in = (struct sockaddr_in*)new_res->ai_addr;
    memset(sa_in, 0, sizeof(struct sockaddr_in));
    sa_in->sin_family = PF_INET;
    sa_in->sin_port = port;
    memcpy(&sa_in->sin_addr, *ap, sizeof(struct in_addr));

    if (head_res == NULL)
      head_res = new_res;
    else
      tail_res->ai_next = new_res;
    tail_res = new_res;
  }

  if (canonname != NULL && head_res != NULL) {
    head_res->ai_canonname = (char*)malloc(strlen(canonname) + 1);
    if (head_res->ai_canonname != NULL)
      strcpy(head_res->ai_canonname, canonname);
  }

  *res = head_res;

end:
  h_errno = saved_h_errno;
#ifdef ENABLE_PTHREAD
  pthread_mutex_unlock(&gai_mutex);
#endif
  return result;
}

/*
 * getnameinfo().
 */
int getnameinfo(sa, salen, node, nodelen, serv, servlen, flags) const
    struct sockaddr* sa;
socklen_t salen;
char* node;
socklen_t nodelen;
char* serv;
socklen_t servlen;
int flags;
{
  const struct sockaddr_in* sa_in = (const struct sockaddr_in*)sa;
  struct hostent* hostent;
  struct servent* servent;
  char* ntoa_address;
  int saved_h_errno;
  int result = 0;

#ifdef ENABLE_PTHREAD
  pthread_mutex_lock(&gai_mutex);
#endif

  saved_h_errno = h_errno;

  if (sa_in->sin_family != PF_INET) {
    result = EAI_FAMILY;
    goto end;
  }
  else if (node == NULL && serv == NULL) {
    result = EAI_NONAME;
    goto end;
  }

  if (serv != NULL && servlen > 0) {
    if (flags & NI_NUMERICSERV)
      servent = NULL;
    else if (flags & NI_DGRAM)
      servent = getservbyport(sa_in->sin_port, ""udp"");
    else
      servent = getservbyport(sa_in->sin_port, ""tcp"");

    if (servent != NULL) {
      if (servlen <= strlen(servent->s_name)) {
        result = EAI_OVERFLOW;
        goto end;
      }
      strcpy(serv, servent->s_name);
    }
    else {
      if (servlen <= itoa_length(ntohs(sa_in->sin_port))) {
        result = EAI_OVERFLOW;
        goto end;
      }
      sprintf(serv, ""%d"", ntohs(sa_in->sin_port));
    }
  }

  if (node != NULL && nodelen > 0) {
    if (flags & NI_NUMERICHOST)
      hostent = NULL;
    else {
      hostent = gethostbyaddr((char*)&sa_in->sin_addr, sizeof(struct in_addr),
                              AF_INET);
    }
    if (hostent != NULL) {
      if (nodelen <= strlen(hostent->h_name)) {
        result = EAI_OVERFLOW;
        goto end;
      }
      strcpy(node, hostent->h_name);
    }
    else {
      if (flags & NI_NAMEREQD) {
        result = EAI_NONAME;
        goto end;
      }
      ntoa_address = inet_ntoa(sa_in->sin_addr);
      if (nodelen <= strlen(ntoa_address)) {
        result = EAI_OVERFLOW;
        goto end;
      }
      strcpy(node, ntoa_address);
    }
  }

end:
  h_errno = saved_h_errno;
#ifdef ENABLE_PTHREAD
  pthread_mutex_unlock(&gai_mutex);
#endif
  return result;
}
"
./repos/aria2/src/uri_split.c,https://github.com/aria2/aria2,"/* <!-- copyright */
/*
 * aria2 - The high speed download utility
 *
 * Copyright (C) 2012 Tatsuhiro Tsujikawa
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 *
 * In addition, as a special exception, the copyright holders give
 * permission to link the code of portions of this program with the
 * OpenSSL library under certain conditions as described in each
 * individual source file, and distribute linked combinations
 * including the two.
 * You must obey the GNU General Public License in all respects
 * for all of the code used other than OpenSSL.  If you modify
 * file(s) with this exception, you may extend this exception to your
 * version of the file(s), but you are not obligated to do so.  If you
 * do not wish to do so, delete this exception statement from your
 * version.  If you delete this exception statement from all source
 * files in the program, then also delete it here.
 */
/* copyright --> */
#include ""uri_split.h""

#include <stdlib.h>

typedef enum {
  URI_BEFORE_SCHEME,
  URI_SCHEME,
  URI_SCHEME_SLASH1,
  URI_SCHEME_SLASH2,
  URI_BEFORE_MAYBE_USER,
  URI_MAYBE_USER,
  URI_BEFORE_MAYBE_PASSWD,
  URI_MAYBE_PASSWD,
  URI_BEFORE_HOST,
  URI_HOST,
  URI_BEFORE_IPV6HOST,
  URI_IPV6HOST,
  URI_AFTER_IPV6HOST,
  URI_BEFORE_PORT,
  URI_PORT,
  URI_PATH,
  URI_BEFORE_QUERY,
  URI_QUERY,
  URI_BEFORE_FRAGMENT,
  URI_FRAGMENT
} uri_split_state;

static void uri_set_field(uri_split_result* res, int field, const char* first,
                          const char* last, const char* uri)
{
  if (first) {
    res->field_set |= 1 << field;
    res->fields[field].off = first - uri;
    res->fields[field].len = last - first;
  }
}

static int is_digit(char c) { return '0' <= c && c <= '9'; }

int uri_split(uri_split_result* res, const char* uri)
{
  int state = URI_BEFORE_SCHEME;
  const char *scheme_first = NULL, *scheme_last = NULL, *host_first = NULL,
             *host_last = NULL, *path_first = NULL, *path_last = NULL,
             *query_first = NULL, *query_last = NULL, *fragment_first = NULL,
             *fragment_last = NULL, *user_first = NULL, *user_last = NULL,
             *passwd_first = NULL, *passwd_last = NULL, *last_atmark = NULL,
             *last_slash = NULL, *p = uri;
  int32_t port = -1;
  uint8_t flags = 0;

  for (; *p; ++p) {
    switch (state) {
    case URI_BEFORE_SCHEME:
      scheme_first = p;
      state = URI_SCHEME;
      break;
    case URI_SCHEME:
      if (*p == ':') {
        scheme_last = p;
        state = URI_SCHEME_SLASH1;
      }
      break;
    case URI_SCHEME_SLASH1:
      if (*p == '/') {
        state = URI_SCHEME_SLASH2;
      }
      else {
        return -1;
      }
      break;
    case URI_SCHEME_SLASH2:
      if (*p == '/') {
        state = URI_BEFORE_MAYBE_USER;
      }
      else {
        return -1;
      }
      break;
    case URI_BEFORE_MAYBE_USER:
      switch (*p) {
      case '@':
      case ':':
      case '/':
        return -1;
      case '[':
        state = URI_BEFORE_IPV6HOST;
        break;
      default:
        user_first = p;
        state = URI_MAYBE_USER;
      }
      break;
    case URI_MAYBE_USER:
      switch (*p) {
      case '@':
        last_atmark = p;
        break;
      case ':':
        user_last = p;
        state = URI_BEFORE_MAYBE_PASSWD;
        break;
      case '[':
        if (last_atmark == p - 1) {
          user_last = last_atmark;
          state = URI_BEFORE_IPV6HOST;
        }
        else {
          return -1;
        }
        break;
      case '/':
      case '?':
      case '#':
        /* It turns out that this is only host or user + host if
           last_atmark is not NULL. */
        if (last_atmark) {
          host_first = last_atmark + 1;
          host_last = p;
          user_last = last_atmark;
        }
        else {
          host_first = user_first;
          host_last = p;
          user_first = user_last = NULL;
        }
        switch (*p) {
        case '/':
          path_first = last_slash = p;
          state = URI_PATH;
          break;
        case '?':
          state = URI_BEFORE_QUERY;
          break;
        case '#':
          state = URI_BEFORE_FRAGMENT;
          break;
        }
        break;
      }
      break;
    case URI_BEFORE_MAYBE_PASSWD:
      passwd_first = p;
      switch (*p) {
      case '@':
        passwd_last = last_atmark = p;
        state = URI_BEFORE_HOST;
        break;
      case '/':
        return -1;
      default:
        /* sums up port number in case of port. */
        if (is_digit(*p)) {
          port = *p - '0';
        }
        state = URI_MAYBE_PASSWD;
      }
      break;
    case URI_MAYBE_PASSWD:
      switch (*p) {
      case '@':
        passwd_last = last_atmark = p;
        /* Passwd confirmed, reset port to -1. */
        port = -1;
        state = URI_BEFORE_HOST;
        break;
      case '[':
        return -1;
      case '/':
      case '?':
      case '#':
        /* This is port not password.  port is in [passwd_first, p) */
        if (port == -1) {
          return -1;
        }
        if (last_atmark) {
          host_first = last_atmark + 1;
          host_last = passwd_first - 1;
          user_last = last_atmark;
        }
        else {
          host_first = user_first;
          host_last = passwd_first - 1;
          user_first = user_last = NULL;
        }
        passwd_first = passwd_last = NULL;
        switch (*p) {
        case '/':
          path_first = last_slash = p;
          state = URI_PATH;
          break;
        case '?':
          state = URI_BEFORE_QUERY;
          break;
        case '#':
          state = URI_BEFORE_FRAGMENT;
          break;
        }
        break;
      default:
        if (port != -1) {
          if (is_digit(*p)) {
            port *= 10;
            port += *p - '0';
            if (port > UINT16_MAX) {
              port = -1;
            }
          }
          else {
            port = -1;
          }
        }
        break;
      }
      break;
    case URI_BEFORE_HOST:
      switch (*p) {
      case ':':
      case '/':
        return -1;
      case '[':
        state = URI_BEFORE_IPV6HOST;
        break;
      default:
        host_first = p;
        state = URI_HOST;
        break;
      }
      break;
    case URI_HOST:
      switch (*p) {
      case ':':
        host_last = p;
        state = URI_BEFORE_PORT;
        break;
      case '/':
        host_last = path_first = last_slash = p;
        state = URI_PATH;
        break;
      case '?':
        host_last = p;
        state = URI_BEFORE_QUERY;
        break;
      case '#':
        host_last = p;
        state = URI_BEFORE_FRAGMENT;
        break;
      }
      break;
    case URI_BEFORE_IPV6HOST:
      if (*p == ']') {
        return -1;
      }
      host_first = p;
      state = URI_IPV6HOST;
      break;
    case URI_IPV6HOST:
      if (*p == ']') {
        flags |= USF_IPV6ADDR;
        host_last = p;
        state = URI_AFTER_IPV6HOST;
      }
      break;
    case URI_AFTER_IPV6HOST:
      switch (*p) {
      case ':':
        state = URI_BEFORE_PORT;
        break;
      case '/':
        path_first = last_slash = p;
        state = URI_PATH;
        break;
      case '?':
        state = URI_BEFORE_QUERY;
        break;
      case '#':
        state = URI_BEFORE_FRAGMENT;
        break;
      default:
        return -1;
      }
      break;
    case URI_BEFORE_PORT:
      if (is_digit(*p)) {
        port = *p - '0';
        state = URI_PORT;
      }
      else {
        return -1;
      }
      break;
    case URI_PORT:
      switch (*p) {
      case '/':
        path_first = last_slash = p;
        state = URI_PATH;
        break;
      case '?':
        state = URI_BEFORE_QUERY;
        break;
      case '#':
        state = URI_BEFORE_FRAGMENT;
        break;
      default:
        if (is_digit(*p)) {
          port *= 10;
          port += *p - '0';
          if (port > UINT16_MAX) {
            return -1;
          }
        }
        else {
          return -1;
        }
      }
      break;
    case URI_PATH:
      switch (*p) {
      case '/':
        last_slash = p;
        break;
      case '?':
        path_last = p;
        state = URI_BEFORE_QUERY;
        break;
      case '#':
        path_last = p;
        state = URI_BEFORE_FRAGMENT;
        break;
      }
      break;
    case URI_BEFORE_QUERY:
      query_first = p;
      if (*p == '#') {
        query_last = p;
        state = URI_BEFORE_FRAGMENT;
      }
      else {
        state = URI_QUERY;
      }
      break;
    case URI_QUERY:
      if (*p == '#') {
        query_last = p;
        state = URI_BEFORE_FRAGMENT;
      }
      break;
    case URI_BEFORE_FRAGMENT:
      fragment_first = p;
      state = URI_FRAGMENT;
      break;
    case URI_FRAGMENT:
      break;
    }
  }
  /* Handle premature states */
  switch (state) {
  case URI_BEFORE_SCHEME:
  case URI_SCHEME:
  case URI_SCHEME_SLASH1:
  case URI_SCHEME_SLASH2:
    return -1;
  case URI_BEFORE_MAYBE_USER:
    return -1;
  case URI_MAYBE_USER:
    if (last_atmark) {
      host_first = last_atmark + 1;
      host_last = p;
      if (host_first == host_last) {
        return -1;
      }
      user_last = last_atmark;
    }
    else {
      host_first = user_first;
      host_last = p;
      user_first = user_last = NULL;
    }
    break;
  case URI_BEFORE_MAYBE_PASSWD:
    return -1;
  case URI_MAYBE_PASSWD:
    if (port == -1) {
      return -1;
    }
    if (last_atmark) {
      host_first = last_atmark + 1;
      host_last = passwd_first - 1;
      user_last = last_atmark;
    }
    else {
      host_first = user_first;
      host_last = passwd_first - 1;
      user_first = user_last = NULL;
    }
    passwd_first = passwd_last = NULL;
    break;
  case URI_BEFORE_HOST:
    return -1;
  case URI_HOST:
    host_last = p;
    break;
  case URI_BEFORE_IPV6HOST:
  case URI_IPV6HOST:
    return -1;
  case URI_AFTER_IPV6HOST:
    break;
  case URI_BEFORE_PORT:
    return -1;
  case URI_PORT:
    if (port == -1) {
      return -1;
    }
    break;
  case URI_PATH:
    path_last = p;
    break;
  case URI_BEFORE_QUERY:
    query_first = query_last = p;
    break;
  case URI_QUERY:
    query_last = p;
    break;
  case URI_BEFORE_FRAGMENT:
    fragment_first = fragment_last = p;
    break;
  case URI_FRAGMENT:
    fragment_last = p;
    break;
  default:
    return -1;
  };

  if (res) {
    res->field_set = 0;
    res->port = 0;
    res->flags = flags;

    uri_set_field(res, USR_SCHEME, scheme_first, scheme_last, uri);
    uri_set_field(res, USR_HOST, host_first, host_last, uri);
    uri_set_field(res, USR_PATH, path_first, path_last, uri);
    uri_set_field(res, USR_QUERY, query_first, query_last, uri);
    uri_set_field(res, USR_FRAGMENT, fragment_first, fragment_last, uri);
    uri_set_field(res, USR_USER, user_first, user_last, uri);
    uri_set_field(res, USR_PASSWD, passwd_first, passwd_last, uri);
    if (res->field_set & (1 << USR_USER)) {
      uri_set_field(res, USR_USERINFO, user_first, last_atmark, uri);
    }
    if (last_slash && last_slash + 1 != path_last) {
      uri_set_field(res, USR_BASENAME, last_slash + 1, path_last, uri);
    }
    if (port != -1) {
      res->field_set |= 1 << USR_PORT;
      res->port = port;
    }
  }

  return 0;
}
"
