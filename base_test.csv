./repos-test/cmd-queue.c,"






static enum cmd_retval	cmdq_continue_one(struct cmd_q *);


struct cmd_q *
cmdq_new(struct client *c)
{
	struct cmd_q	*cmdq;

	cmdq = xcalloc(1, sizeof *cmdq);
	cmdq->references = 1;
	cmdq->flags = 0;

	cmdq->client = c;
	cmdq->client_exit = -1;

	TAILQ_INIT(&cmdq->queue);
	cmdq->item = NULL;
	cmdq->cmd = NULL;

	cmd_find_clear_state(&cmdq->current, NULL, 0);
	cmdq->parent = NULL;

	return (cmdq);
}


int
cmdq_free(struct cmd_q *cmdq)
{
	if (--cmdq->references != 0) {
		if (cmdq->flags & CMD_Q_DEAD)
			return (1);
		return (0);
	}

	cmdq_flush(cmdq);
	free(cmdq);
	return (1);
}


void
cmdq_print(struct cmd_q *cmdq, const char *fmt, ...)
{
	struct client	*c = cmdq->client;
	struct window	*w;
	va_list		 ap;
	char		*tmp, *msg;

	va_start(ap, fmt);

	if (c == NULL)
		;
	else if (c->session == NULL || (c->flags & CLIENT_CONTROL)) {
		if (~c->flags & CLIENT_UTF8) {
			vasprintf(&tmp, fmt, ap);
			msg = utf8_sanitize(tmp);
			free(tmp);
			evbuffer_add(c->stdout_data, msg, strlen(msg));
			free(msg);
		} else
			evbuffer_add_vprintf(c->stdout_data, fmt, ap);
		evbuffer_add(c->stdout_data, ""\n"", 1);
		server_client_push_stdout(c);
	} else {
		w = c->session->curw->window;
		if (w->active->mode != &window_copy_mode) {
			window_pane_reset_mode(w->active);
			window_pane_set_mode(w->active, &window_copy_mode);
			window_copy_init_for_output(w->active);
#ifdef TMATE
			tmate_sync_copy_mode(w->active);
#endif
		}
		window_copy_vadd(w->active, fmt, ap);
	}

	va_end(ap);
}


void
cmdq_error(struct cmd_q *cmdq, const char *fmt, ...)
{
	struct client	*c = cmdq->client;
	struct cmd	*cmd = cmdq->cmd;
	va_list		 ap;
	char		*msg;
	size_t		 msglen;
	char		*tmp;

	va_start(ap, fmt);
	msglen = xvasprintf(&msg, fmt, ap);
	va_end(ap);

	if (c == NULL)
#ifdef TMATE
		if (cmd->file && cmd->line)
			cfg_add_cause(""%s:%u: %s"", cmd->file, cmd->line, msg);
		else
			cfg_add_cause(""%s"", msg);
#else
		cfg_add_cause(""%s:%u: %s"", cmd->file, cmd->line, msg);
#endif
	else if (c->session == NULL || (c->flags & CLIENT_CONTROL)) {
		if (~c->flags & CLIENT_UTF8) {
			tmp = msg;
			msg = utf8_sanitize(tmp);
			free(tmp);
			msglen = strlen(msg);
		}
		evbuffer_add(c->stderr_data, msg, msglen);
		evbuffer_add(c->stderr_data, ""\n"", 1);
		server_client_push_stderr(c);
		c->retval = 1;
	} else {
		*msg = toupper((u_char) *msg);
		status_message_set(c, ""%s"", msg);
	}

	free(msg);
}


void
cmdq_guard(struct cmd_q *cmdq, const char *guard, int flags)
{
	struct client	*c = cmdq->client;

	if (c == NULL || !(c->flags & CLIENT_CONTROL))
		return;

	evbuffer_add_printf(c->stdout_data, ""%%%s %ld %u %d\n"", guard,
	    (long) cmdq->time, cmdq->number, flags);
	server_client_push_stdout(c);
}


void
cmdq_run(struct cmd_q *cmdq, struct cmd_list *cmdlist, struct mouse_event *m)
{
	cmdq_append(cmdq, cmdlist, m);

	if (cmdq->item == NULL) {
		cmdq->cmd = NULL;
		cmdq_continue(cmdq);
	}
}


void
cmdq_append(struct cmd_q *cmdq, struct cmd_list *cmdlist, struct mouse_event *m)
{
	struct cmd_q_item	*item;

	item = xcalloc(1, sizeof *item);
	item->cmdlist = cmdlist;
	TAILQ_INSERT_TAIL(&cmdq->queue, item, qentry);
	cmdlist->references++;

	if (m != NULL)
		memcpy(&item->mouse, m, sizeof item->mouse);
	else
		item->mouse.valid = 0;
}


static enum cmd_retval
cmdq_continue_one(struct cmd_q *cmdq)
{
	struct cmd	*cmd = cmdq->cmd;
	enum cmd_retval	 retval;
	char		*tmp;
	int		 flags = !!(cmd->flags & CMD_CONTROL);

#ifdef TMATE
	if (tmate_should_replicate_cmd(cmd->entry))
		tmate_exec_cmd(cmd);
#endif

	tmp = cmd_print(cmd);
	log_debug(""cmdq %p: %s"", cmdq, tmp);
	free(tmp);

	cmdq->time = time(NULL);
	cmdq->number++;

	cmdq_guard(cmdq, ""begin"", flags);

	if (cmd_prepare_state(cmd, cmdq, NULL) != 0)
		goto error;
	retval = cmd->entry->exec(cmd, cmdq);
	if (retval == CMD_RETURN_ERROR)
		goto error;

	cmdq_guard(cmdq, ""end"", flags);
	return (retval);

error:
	cmdq_guard(cmdq, ""error"", flags);
	return (CMD_RETURN_ERROR);
}


int
cmdq_continue(struct cmd_q *cmdq)
{
	struct client		*c = cmdq->client;
	struct cmd_q_item	*next;
	enum cmd_retval		 retval;
	int			 empty;

	cmdq->references++;
	notify_disable();

	log_debug(""continuing cmdq %p: flags %#x, client %p"", cmdq, cmdq->flags,
	    c);

	empty = TAILQ_EMPTY(&cmdq->queue);
	if (empty)
		goto empty;

	if (cmdq->item == NULL) {
		cmdq->item = TAILQ_FIRST(&cmdq->queue);
		cmdq->cmd = TAILQ_FIRST(&cmdq->item->cmdlist->list);
	} else
		cmdq->cmd = TAILQ_NEXT(cmdq->cmd, qentry);

	do {
		while (cmdq->cmd != NULL) {
			retval = cmdq_continue_one(cmdq);
			if (retval == CMD_RETURN_ERROR)
				break;
			if (retval == CMD_RETURN_WAIT)
				goto out;
			if (retval == CMD_RETURN_STOP) {
				cmdq_flush(cmdq);
				goto empty;
			}
			cmdq->cmd = TAILQ_NEXT(cmdq->cmd, qentry);
		}
		next = TAILQ_NEXT(cmdq->item, qentry);

		TAILQ_REMOVE(&cmdq->queue, cmdq->item, qentry);
		cmd_list_free(cmdq->item->cmdlist);
		free(cmdq->item);

		cmdq->item = next;
		if (cmdq->item != NULL)
			cmdq->cmd = TAILQ_FIRST(&cmdq->item->cmdlist->list);
	} while (cmdq->item != NULL);

empty:
	if (cmdq->client_exit > 0)
		cmdq->client->flags |= CLIENT_EXIT;
	if (cmdq->emptyfn != NULL)
		cmdq->emptyfn(cmdq);
	empty = 1;

out:
	notify_enable();
	cmdq_free(cmdq);

	return (empty);
}


void
cmdq_flush(struct cmd_q *cmdq)
{
	struct cmd_q_item	*item, *item1;

	TAILQ_FOREACH_SAFE(item, &cmdq->queue, qentry, item1) {
		TAILQ_REMOVE(&cmdq->queue, item, qentry);
		cmd_list_free(item->cmdlist);
		free(item);
	}
	cmdq->item = NULL;
}

"
./repos-test/alerts.c,"






int	alerts_fired;

void	alerts_timer(int, short, void *);
int	alerts_enabled(struct window *, int);
void	alerts_callback(int, short, void *);
void	alerts_reset(struct window *);

void	alerts_run_hook(struct session *, struct winlink *, int);
int	alerts_check_all(struct session *, struct winlink *);
int	alerts_check_bell(struct session *, struct winlink *);
int	alerts_check_activity(struct session *, struct winlink *);
int	alerts_check_silence(struct session *, struct winlink *);
void	alerts_ring_bell(struct session *);

void
alerts_timer(__unused int fd, __unused short events, void *arg)
{
	struct window	*w = arg;

	log_debug(""@%u alerts timer expired"", w->id);
	alerts_reset(w);
	alerts_queue(w, WINDOW_SILENCE);
}

void
alerts_callback(__unused int fd, __unused short events, __unused void *arg)
{
	struct window	*w;
	struct session	*s;
	struct winlink	*wl;
	int		 flags, alerts;

	RB_FOREACH(w, windows, &windows) {
		RB_FOREACH(s, sessions, &sessions) {
			RB_FOREACH(wl, winlinks, &s->windows) {
				if (wl->window != w)
					continue;
				flags = w->flags;

				alerts = alerts_check_all(s, wl);

				log_debug(""%s:%d @%u alerts check, alerts %#x, ""
				    ""flags %#x"", s->name, wl->idx, w->id,
				    alerts, flags);
			}
		}
	}
	alerts_fired = 0;
}

void
alerts_run_hook(struct session *s, struct winlink *wl, int flags)
{
	struct cmd_find_state	 fs;

	if (cmd_find_from_winlink(&fs, s, wl) != 0)
		return;

	if (flags & WINDOW_BELL)
		hooks_run(s->hooks, NULL, &fs, ""alert-bell"");
	if (flags & WINDOW_SILENCE)
		hooks_run(s->hooks, NULL, &fs, ""alert-silence"");
	if (flags & WINDOW_ACTIVITY)
		hooks_run(s->hooks, NULL, &fs, ""alert-activity"");
}

int
alerts_check_all(struct session *s, struct winlink *wl)
{
	int	alerts;

	alerts  = alerts_check_bell(s, wl);
	alerts |= alerts_check_activity(s, wl);
	alerts |= alerts_check_silence(s, wl);
	if (alerts != 0) {
		alerts_run_hook(s, wl, alerts);
		server_status_session(s);
	}

	return (alerts);
}

void
alerts_check_session(struct session *s)
{
	struct winlink	*wl;

	RB_FOREACH(wl, winlinks, &s->windows)
		alerts_check_all(s, wl);
}

int
alerts_enabled(struct window *w, int flags)
{
	if (flags & WINDOW_BELL)
		return (1);
	if (flags & WINDOW_ACTIVITY) {
		if (options_get_number(w->options, ""monitor-activity""))
			return (1);
	}
	if (flags & WINDOW_SILENCE) {
		if (options_get_number(w->options, ""monitor-silence"") != 0)
			return (1);
	}
	return (0);
}

void
alerts_reset_all(void)
{
	struct window	*w;

	RB_FOREACH(w, windows, &windows)
		alerts_reset(w);
}

void
alerts_reset(struct window *w)
{
	struct timeval	tv;

	w->flags &= ~WINDOW_SILENCE;
	event_del(&w->alerts_timer);

	timerclear(&tv);
	tv.tv_sec = options_get_number(w->options, ""monitor-silence"");

	log_debug(""@%u alerts timer reset %u"", w->id, (u_int)tv.tv_sec);
	if (tv.tv_sec != 0)
		event_add(&w->alerts_timer, &tv);
}

void
alerts_queue(struct window *w, int flags)
{
	if (w->flags & WINDOW_ACTIVITY)
		alerts_reset(w);

	if (!event_initialized(&w->alerts_timer))
		evtimer_set(&w->alerts_timer, alerts_timer, w);

	if (!alerts_fired) {
		w->flags |= flags;
		log_debug(""@%u alerts flags added %#x"", w->id, flags);

		if (alerts_enabled(w, flags)) {
			log_debug(""alerts check queued (by @%u)"", w->id);
			event_once(-1, EV_TIMEOUT, alerts_callback, NULL, NULL);
			alerts_fired = 1;
		}
	}
}

int
alerts_check_bell(struct session *s, struct winlink *wl)
{
	struct client	*c;
	struct window	*w = wl->window;
	int		 action, visual;

	if (!(w->flags & WINDOW_BELL))
		return (0);
	if (s->curw != wl) {
		wl->flags |= WINLINK_BELL;
		w->flags &= ~WINDOW_BELL;
	}
	if (s->curw->window == w)
		w->flags &= ~WINDOW_BELL;

	action = options_get_number(s->options, ""bell-action"");
	if (action == BELL_NONE)
		return (0);

	visual = options_get_number(s->options, ""visual-bell"");
	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session != s || c->flags & CLIENT_CONTROL)
			continue;
		if (!visual) {
			if ((action == BELL_CURRENT &&
			    c->session->curw->window == w) ||
			    (action == BELL_OTHER &&
			    c->session->curw->window != w) ||
			    action == BELL_ANY)
				tty_putcode(&c->tty, TTYC_BEL);
			continue;
		}
		if (action == BELL_CURRENT && c->session->curw->window == w)
			status_message_set(c, ""Bell in current window"");
		else if (action == BELL_ANY || (action == BELL_OTHER &&
		    c->session->curw->window != w))
			status_message_set(c, ""Bell in window %d"", wl->idx);
	}

	return (WINDOW_BELL);
}

int
alerts_check_activity(struct session *s, struct winlink *wl)
{
	struct client	*c;
	struct window	*w = wl->window;

	if (s->curw->window == w)
		w->flags &= ~WINDOW_ACTIVITY;

	if (!(w->flags & WINDOW_ACTIVITY) || wl->flags & WINLINK_ACTIVITY)
		return (0);
	if (s->curw == wl)
		return (0);

	if (!options_get_number(w->options, ""monitor-activity""))
		return (0);

	if (options_get_number(s->options, ""bell-on-alert""))
		alerts_ring_bell(s);
	wl->flags |= WINLINK_ACTIVITY;

	if (options_get_number(s->options, ""visual-activity"")) {
		TAILQ_FOREACH(c, &clients, entry) {
			if (c->session != s)
				continue;
			status_message_set(c, ""Activity in window %d"", wl->idx);
		}
	}

	return (WINDOW_ACTIVITY);
}

int
alerts_check_silence(struct session *s, struct winlink *wl)
{
	struct client	*c;
	struct window	*w = wl->window;

	if (s->curw->window == w)
		w->flags &= ~WINDOW_SILENCE;

	if (!(w->flags & WINDOW_SILENCE) || wl->flags & WINLINK_SILENCE)
		return (0);
	if (s->curw == wl)
		return (0);

	if (options_get_number(w->options, ""monitor-silence"") == 0)
		return (0);

	if (options_get_number(s->options, ""bell-on-alert""))
		alerts_ring_bell(s);
	wl->flags |= WINLINK_SILENCE;

	if (options_get_number(s->options, ""visual-silence"")) {
		TAILQ_FOREACH(c, &clients, entry) {
			if (c->session != s)
				continue;
			status_message_set(c, ""Silence in window %d"", wl->idx);
		}
	}

	return (WINDOW_SILENCE);
}

void
alerts_ring_bell(struct session *s)
{
	struct client	*c;

	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session == s && !(c->flags & CLIENT_CONTROL))
			tty_putcode(&c->tty, TTYC_BEL);
	}
}
"
./repos-test/utf8.c,"






static int	utf8_width(wchar_t);


void
utf8_set(struct utf8_data *ud, u_char ch)
{
	u_int	i;

	*ud->data = ch;
	ud->have = 1;
	ud->size = 1;

	ud->width = 1;

	for (i = ud->size; i < sizeof ud->data; i++)
		ud->data[i] = '\0';
}


void
utf8_copy(struct utf8_data *to, const struct utf8_data *from)
{
	u_int	i;

	memcpy(to, from, sizeof *to);

	for (i = to->size; i < sizeof to->data; i++)
		to->data[i] = '\0';
}


enum utf8_state
utf8_open(struct utf8_data *ud, u_char ch)
{
	memset(ud, 0, sizeof *ud);
	if (ch >= 0xc2 && ch <= 0xdf)
		ud->size = 2;
	else if (ch >= 0xe0 && ch <= 0xef)
		ud->size = 3;
	else if (ch >= 0xf0 && ch <= 0xf4)
		ud->size = 4;
	else
		return (UTF8_ERROR);
	utf8_append(ud, ch);
	return (UTF8_MORE);
}


enum utf8_state
utf8_append(struct utf8_data *ud, u_char ch)
{
	wchar_t	wc;
	int	width;

	if (ud->have >= ud->size)
		fatalx(""UTF-8 character overflow"");
	if (ud->size > sizeof ud->data)
		fatalx(""UTF-8 character size too large"");

	if (ud->have != 0 && (ch & 0xc0) != 0x80)
		ud->width = 0xff;

	ud->data[ud->have++] = ch;
	if (ud->have != ud->size)
		return (UTF8_MORE);

	if (ud->width == 0xff)
		return (UTF8_ERROR);

	if (utf8_combine(ud, &wc) != UTF8_DONE)
		return (UTF8_ERROR);
	if ((width = utf8_width(wc)) < 0)
		return (UTF8_ERROR);
	ud->width = width;

	return (UTF8_DONE);
}


static int
utf8_width(wchar_t wc)
{
	int	width;

	width = wcwidth(wc);
	if (width < 0 || width > 0xff)
		return (-1);
	return (width);
}


enum utf8_state
utf8_combine(const struct utf8_data *ud, wchar_t *wc)
{
	switch (mbtowc(wc, ud->data, ud->size)) {
	case -1:
		mbtowc(NULL, NULL, MB_CUR_MAX);
		return (UTF8_ERROR);
	case 0:
		return (UTF8_ERROR);
	default:
		return (UTF8_DONE);
	}
}


enum utf8_state
utf8_split(wchar_t wc, struct utf8_data *ud)
{
	char	s[MB_LEN_MAX];
	int	slen;

	slen = wctomb(s, wc);
	if (slen <= 0 || slen > (int)sizeof ud->data)
		return (UTF8_ERROR);

	memcpy(ud->data, s, slen);
	ud->size = slen;

	ud->width = utf8_width(wc);
	return (UTF8_DONE);
}


int
utf8_strvis(char *dst, const char *src, size_t len, int flag)
{
	struct utf8_data	 ud;
	const char		*start, *end;
	enum utf8_state		 more;
	size_t			 i;

	start = dst;
	end = src + len;

	while (src < end) {
		if ((more = utf8_open(&ud, *src)) == UTF8_MORE) {
			while (++src < end && more == UTF8_MORE)
				more = utf8_append(&ud, *src);
			if (more == UTF8_DONE) {
				
				for (i = 0; i < ud.size; i++)
					*dst++ = ud.data[i];
				continue;
			}
			
			src -= ud.have;
		}
		if (src < end - 1)
			dst = vis(dst, src[0], flag, src[1]);
		else if (src < end)
			dst = vis(dst, src[0], flag, '\0');
		src++;
	}

	*dst = '\0';
	return (dst - start);
}


char *
utf8_sanitize(const char *src)
{
	char			*dst;
	size_t			 n;
	enum utf8_state		 more;
	struct utf8_data	 ud;
	u_int			 i;

	dst = NULL;

	n = 0;
	while (*src != '\0') {
		dst = xreallocarray(dst, n + 1, sizeof *dst);
		if ((more = utf8_open(&ud, *src)) == UTF8_MORE) {
			while (*++src != '\0' && more == UTF8_MORE)
				more = utf8_append(&ud, *src);
			if (more == UTF8_DONE) {
				dst = xreallocarray(dst, n + ud.width,
				    sizeof *dst);
				for (i = 0; i < ud.width; i++)
					dst[n++] = '_';
				continue;
			}
			src -= ud.have;
		}
		if (*src > 0x1f && *src < 0x7f)
			dst[n++] = *src;
		else
			dst[n++] = '_';
		src++;
	}

	dst = xreallocarray(dst, n + 1, sizeof *dst);
	dst[n] = '\0';
	return (dst);
}


struct utf8_data *
utf8_fromcstr(const char *src)
{
	struct utf8_data	*dst;
	size_t			 n;
	enum utf8_state		 more;

	dst = NULL;

	n = 0;
	while (*src != '\0') {
		dst = xreallocarray(dst, n + 1, sizeof *dst);
		if ((more = utf8_open(&dst[n], *src)) == UTF8_MORE) {
			while (*++src != '\0' && more == UTF8_MORE)
				more = utf8_append(&dst[n], *src);
			if (more == UTF8_DONE) {
				n++;
				continue;
			}
			src -= dst[n].have;
		}
		utf8_set(&dst[n], *src);
		n++;
		src++;
	}

	dst = xreallocarray(dst, n + 1, sizeof *dst);
	dst[n].size = 0;
	return (dst);
}


char *
utf8_tocstr(struct utf8_data *src)
{
	char	*dst;
	size_t	 n;

	dst = NULL;

	n = 0;
	for(; src->size != 0; src++) {
		dst = xreallocarray(dst, n + src->size, 1);
		memcpy(dst + n, src->data, src->size);
		n += src->size;
	}

	dst = xreallocarray(dst, n + 1, 1);
	dst[n] = '\0';
	return (dst);
}


u_int
utf8_cstrwidth(const char *s)
{
	struct utf8_data	tmp;
	u_int			width;
	enum utf8_state		more;

	width = 0;
	while (*s != '\0') {
		if ((more = utf8_open(&tmp, *s)) == UTF8_MORE) {
			while (*++s != '\0' && more == UTF8_MORE)
				more = utf8_append(&tmp, *s);
			if (more == UTF8_DONE) {
				width += tmp.width;
				continue;
			}
			s -= tmp.have;
		}
		if (*s > 0x1f && *s != 0x7f)
			width++;
		s++;
	}
	return (width);
}


char *
utf8_trimcstr(const char *s, u_int width)
{
	struct utf8_data	*tmp, *next;
	char			*out;
	u_int			 at;

	tmp = utf8_fromcstr(s);

	at = 0;
	for (next = tmp; next->size != 0; next++) {
		if (at + next->width > width) {
			next->size = 0;
			break;
		}
		at += next->width;
	}

	out = utf8_tocstr(tmp);
	free(tmp);
	return (out);
}


char *
utf8_rtrimcstr(const char *s, u_int width)
{
	struct utf8_data	*tmp, *next, *end;
	char			*out;
	u_int			 at;

	tmp = utf8_fromcstr(s);

	for (end = tmp; end->size != 0; end++)
		;
	if (end == tmp) {
		free(tmp);
		return (xstrdup(""""));
	}
	next = end - 1;

	at = 0;
	for (;;)
	{
		if (at + next->width > width) {
			next++;
			break;
		}
		at += next->width;

		if (next == tmp)
			break;
		next--;
	}

	out = utf8_tocstr(next);
	free(tmp);
	return (out);
}


char *
utf8_padcstr(const char *s, u_int width)
{
	size_t	 slen;
	char	*out;
	u_int	  n, i;

	n = utf8_cstrwidth(s);
	if (n >= width)
		return (xstrdup(s));

	slen = strlen(s);
	out = xmalloc(slen + 1 + (width - n));
	memcpy(out, s, slen);
	for (i = n; i < width; i++)
		out[slen++] = ' ';
	out[slen] = '\0';
	return (out);
}
"
./repos-test/client.c,"






struct tmuxproc	*client_proc;
struct tmuxpeer	*client_peer;
int		 client_flags;
struct event	 client_stdin;
enum {
	CLIENT_EXIT_NONE,
	CLIENT_EXIT_DETACHED,
	CLIENT_EXIT_DETACHED_HUP,
	CLIENT_EXIT_LOST_TTY,
	CLIENT_EXIT_TERMINATED,
	CLIENT_EXIT_LOST_SERVER,
	CLIENT_EXIT_EXITED,
	CLIENT_EXIT_SERVER_EXITED,
} client_exitreason = CLIENT_EXIT_NONE;
int		 client_exitval;
enum msgtype	 client_exittype;
const char	*client_exitsession;
int		 client_attached;

__dead void	client_exec(const char *,const char *);
int		client_get_lock(char *);
int		client_connect(struct event_base *, const char *, int);
void		client_send_identify(const char *, const char *);
void		client_stdin_callback(int, short, void *);
void		client_write(int, const char *, size_t);
void		client_signal(int);
void		client_dispatch(struct imsg *, void *);
void		client_dispatch_attached(struct imsg *);
void		client_dispatch_wait(struct imsg *, const char *);
const char     *client_exit_message(void);


int
client_get_lock(char *lockfile)
{
	int lockfd;

	log_debug(""lock file is %s"", lockfile);

	if ((lockfd = open(lockfile, O_WRONLY|O_CREAT, 0600)) == -1) {
		log_debug(""open failed: %s"", strerror(errno));
		return (-1);
	}

	if (flock(lockfd, LOCK_EX|LOCK_NB) == -1) {
		log_debug(""flock failed: %s"", strerror(errno));
		if (errno != EAGAIN)
			return (lockfd);
		while (flock(lockfd, LOCK_EX) == -1 && errno == EINTR)
			;
		close(lockfd);
		return (-2);
	}
	log_debug(""flock succeeded"");

	return (lockfd);
}


int
client_connect(struct event_base *base, const char *path, int start_server)
{
	struct sockaddr_un	sa;
	size_t			size;
	int			fd, lockfd = -1, locked = 0;
	char		       *lockfile = NULL;

	memset(&sa, 0, sizeof sa);
	sa.sun_family = AF_UNIX;
	size = strlcpy(sa.sun_path, path, sizeof sa.sun_path);
	if (size >= sizeof sa.sun_path) {
		errno = ENAMETOOLONG;
		return (-1);
	}
	log_debug(""socket is %s"", path);

retry:
	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		return (-1);

	log_debug(""trying connect"");
	if (connect(fd, (struct sockaddr *)&sa, sizeof sa) == -1) {
		log_debug(""connect failed: %s"", strerror(errno));
		if (errno != ECONNREFUSED && errno != ENOENT)
			goto failed;
		if (!start_server)
			goto failed;
		close(fd);

		if (!locked) {
			xasprintf(&lockfile, ""%s.lock"", path);
			if ((lockfd = client_get_lock(lockfile)) < 0) {
				log_debug(""didn't get lock (%d)"", lockfd);

				free(lockfile);
				lockfile = NULL;

				if (lockfd == -2)
					goto retry;
			}
			log_debug(""got lock (%d)"", lockfd);

			
			locked = 1;
			goto retry;
		}

		if (lockfd >= 0 && unlink(path) != 0 && errno != ENOENT) {
			free(lockfile);
			close(lockfd);
			return (-1);
		}
		fd = server_start(base, lockfd, lockfile);
	}

	if (locked && lockfd >= 0) {
		free(lockfile);
		close(lockfd);
	}
	setblocking(fd, 0);
	return (fd);

failed:
	if (locked) {
		free(lockfile);
		close(lockfd);
	}
	close(fd);
	return (-1);
}


const char *
client_exit_message(void)
{
	static char msg[256];

	switch (client_exitreason) {
	case CLIENT_EXIT_NONE:
		break;
	case CLIENT_EXIT_DETACHED:
		if (client_exitsession != NULL) {
			xsnprintf(msg, sizeof msg, ""detached ""
			    ""(from session %s)"", client_exitsession);
			return (msg);
		}
		return (""detached"");
	case CLIENT_EXIT_DETACHED_HUP:
		if (client_exitsession != NULL) {
			xsnprintf(msg, sizeof msg, ""detached and SIGHUP ""
			    ""(from session %s)"", client_exitsession);
			return (msg);
		}
		return (""detached and SIGHUP"");
	case CLIENT_EXIT_LOST_TTY:
		return (""lost tty"");
	case CLIENT_EXIT_TERMINATED:
		return (""terminated"");
	case CLIENT_EXIT_LOST_SERVER:
		return (""lost server"");
	case CLIENT_EXIT_EXITED:
		return (""exited"");
	case CLIENT_EXIT_SERVER_EXITED:
		return (""server exited"");
	}
	return (""unknown reason"");
}

#ifdef TMATE
extern const struct cmd_entry cmd_attach_session_entry;
extern const struct cmd_entry cmd_new_session_entry;


static int __argc;
static const char **__argv;
#endif

int run_headless_command(int argc, const char **argv, int flags, void (*err_callback)(const char *))
{
	struct cmd_q *cmd_q;
	struct cmd_list *cmdlist;
	char *cause;
	cmd_q = cmdq_new(NULL); 

	if ((cmdlist = cmd_list_parse(argc, (char **)argv, NULL, 0, &cause)) == NULL) {
		if (err_callback)
			err_callback(cause);
		return -1;
	}

	cmdq_run(cmd_q, cmdlist, NULL);
	cmd_list_free(cmdlist);
	cmdq_free(cmd_q);

	if (flags & DEFER_ERRORS_CFG)
		return 0;

	
	int ret = cfg_ncauses ? -1 : 0;
	for (u_int i = 0; i < cfg_ncauses; i++) {
		if (err_callback)
			err_callback(cfg_causes[i]);
		free(cfg_causes[i]);
	}

	free(cfg_causes);
	cfg_causes = NULL;
	cfg_ncauses = 0;

	return ret;
}

static void initial_client_cmd_err_callback(const char *cause)
{
	tmate_info(""%s"", cause);
}

void run_initial_client_cmd(void)
{
	int argc = __argc;
	const char **argv = __argv;

	const char *default_argv[] = {""new-session""};
	if (argc == 0) {
		argc = 1;
		argv = default_argv;
	}

	if (run_headless_command(argc, argv, 0, initial_client_cmd_err_callback) < 0)
		exit(1);
}


int
client_main(struct event_base *base, int argc, char **argv, int flags,
    const char *shellcmd)
{
	struct cmd		*cmd;
	struct cmd_list		*cmdlist;
	struct msg_command_data	*data;
	int			 cmdflags, fd, i;
	const char		*ttynam, *cwd;
	pid_t			 ppid;
	enum msgtype		 msg;
	char			*cause, path[PATH_MAX];
	struct termios		 tio, saved_tio;
	size_t			 size;
#ifdef TMATE
	int cant_nest = 0;
	__argc = argc;
	__argv = (const char **)argv;
#endif

	
	signal(SIGCHLD, SIG_IGN);

	
	client_flags = flags;

	
	cmdflags = 0;
	if (shellcmd != NULL) {
		msg = MSG_SHELL;
		cmdflags = CMD_STARTSERVER;
	} else if (argc == 0) {
		msg = MSG_COMMAND;
		cmdflags = CMD_STARTSERVER;
#ifdef TMATE
	cant_nest = 1;
#endif
	} else {
		msg = MSG_COMMAND;

		
		cmdlist = cmd_list_parse(argc, argv, NULL, 0, &cause);
		if (cmdlist == NULL) {
			fprintf(stderr, ""%s\n"", cause);
			return (1);
		}
		cmdflags &= ~CMD_STARTSERVER;
		TAILQ_FOREACH(cmd, &cmdlist->list, qentry) {
			if (cmd->entry->flags & CMD_STARTSERVER)
				cmdflags |= CMD_STARTSERVER;

#ifdef TMATE
			if (cmd->entry == &cmd_attach_session_entry ||
			    cmd->entry == &cmd_new_session_entry)
				cant_nest = 1;
#endif
		}
		cmd_list_free(cmdlist);
	}

#ifdef TMATE
	if (cant_nest && getenv(""TMUX"")) {
		fprintf(stderr, ""sessions should be nested with care, ""
			""unset $TMUX to force\n"");
		return (1);
	}
#endif

	
	client_proc = proc_start(""client"", base, 0, client_signal);

	
	fd = client_connect(base, socket_path, cmdflags & CMD_STARTSERVER);
	if (fd == -1) {
		if (errno == ECONNREFUSED) {
			fprintf(stderr, ""no server running on %s\n"",
			    socket_path);
		} else {
#ifdef TMATE
			if (errno == ENOENT)
				fprintf(stderr, ""You must specify a socket name with -S. For example: \n""
					        ""  tmate -S /tmp/tmate.sock new-session -d\n""
					        ""  tmate -S /tmp/tmate.sock wait tmate-ready\n"");
			else
#endif
			fprintf(stderr, ""error connecting to %s (%s)\n"",
			    socket_path, strerror(errno));
		}
		return (1);
	}
	client_peer = proc_add_peer(client_proc, fd, client_dispatch,
	    (void *)shellcmd);

	
	if ((cwd = getcwd(path, sizeof path)) == NULL) {
		if ((cwd = find_home()) == NULL)
			cwd = ""/"";
	}
	if ((ttynam = ttyname(STDIN_FILENO)) == NULL)
		ttynam = """";

#ifdef __OpenBSD__
	
	if (pledge(""stdio unix sendfd proc exec tty"", NULL) != 0)
		fatal(""pledge failed"");
#endif

	
	options_free(global_options);
	options_free(global_s_options);
	options_free(global_w_options);
	environ_free(global_environ);

	
	setblocking(STDIN_FILENO, 0);
	event_set(&client_stdin, STDIN_FILENO, EV_READ|EV_PERSIST,
	    client_stdin_callback, NULL);
	if (client_flags & CLIENT_CONTROLCONTROL) {
		if (tcgetattr(STDIN_FILENO, &saved_tio) != 0)
			fatal(""tcgetattr failed"");
		cfmakeraw(&tio);
		tio.c_iflag = ICRNL|IXANY;
		tio.c_oflag = OPOST|ONLCR;
#ifdef NOKERNINFO
		tio.c_lflag = NOKERNINFO;
#endif
		tio.c_cflag = CREAD|CS8|HUPCL;
		tio.c_cc[VMIN] = 1;
		tio.c_cc[VTIME] = 0;
		cfsetispeed(&tio, cfgetispeed(&saved_tio));
		cfsetospeed(&tio, cfgetospeed(&saved_tio));
		tcsetattr(STDIN_FILENO, TCSANOW, &tio);
	}

	
	client_send_identify(ttynam, cwd);

	
	if (msg == MSG_COMMAND) {
		
		size = 0;
		for (i = 0; i < argc; i++)
			size += strlen(argv[i]) + 1;
		data = xmalloc((sizeof *data) + size);

		
		data->argc = argc;
		if (cmd_pack_argv(argc, argv, (char *)(data + 1), size) != 0) {
			fprintf(stderr, ""command too long\n"");
			free(data);
			return (1);
		}
		size += sizeof *data;

		
		if (proc_send(client_peer, msg, -1, data, size) != 0) {
			fprintf(stderr, ""failed to send command\n"");
			free(data);
			return (1);
		}
		free(data);
	} else if (msg == MSG_SHELL)
		proc_send(client_peer, msg, -1, NULL, 0);

	
	proc_loop(client_proc, NULL);

	
	if (client_attached) {
		if (client_exitreason != CLIENT_EXIT_NONE)
			printf(""[%s]\n"", client_exit_message());

		ppid = getppid();
		if (client_exittype == MSG_DETACHKILL && ppid > 1)
			kill(ppid, SIGHUP);
	} else if (client_flags & CLIENT_CONTROLCONTROL) {
		if (client_exitreason != CLIENT_EXIT_NONE)
			printf(""%%exit %s\n"", client_exit_message());
		else
			printf(""%%exit\n"");
		printf(""\033\\"");
		tcsetattr(STDOUT_FILENO, TCSAFLUSH, &saved_tio);
	} else if (client_exitreason != CLIENT_EXIT_NONE)
		fprintf(stderr, ""%s\n"", client_exit_message());
	setblocking(STDIN_FILENO, 1);
	return (client_exitval);
}


void
client_send_identify(const char *ttynam, const char *cwd)
{
	const char	 *s;
	char		**ss;
	size_t		  sslen;
	int		  fd, flags = client_flags;
	pid_t		  pid;

	proc_send(client_peer, MSG_IDENTIFY_FLAGS, -1, &flags, sizeof flags);

	if ((s = getenv(""TERM"")) == NULL)
		s = """";
	proc_send(client_peer, MSG_IDENTIFY_TERM, -1, s, strlen(s) + 1);

	proc_send(client_peer, MSG_IDENTIFY_TTYNAME, -1, ttynam,
	    strlen(ttynam) + 1);
	proc_send(client_peer, MSG_IDENTIFY_CWD, -1, cwd, strlen(cwd) + 1);

	if ((fd = dup(STDIN_FILENO)) == -1)
		fatal(""dup failed"");
	proc_send(client_peer, MSG_IDENTIFY_STDIN, fd, NULL, 0);

	pid = getpid();
	proc_send(client_peer, MSG_IDENTIFY_CLIENTPID, -1, &pid, sizeof pid);

	for (ss = environ; *ss != NULL; ss++) {
		sslen = strlen(*ss) + 1;
		if (sslen > MAX_IMSGSIZE - IMSG_HEADER_SIZE)
			continue;
		proc_send(client_peer, MSG_IDENTIFY_ENVIRON, -1, *ss, sslen);
	}

	proc_send(client_peer, MSG_IDENTIFY_DONE, -1, NULL, 0);
}


void
client_stdin_callback(__unused int fd, __unused short events,
    __unused void *arg)
{
	struct msg_stdin_data	data;

	data.size = read(STDIN_FILENO, data.data, sizeof data.data);
	if (data.size < 0 && (errno == EINTR || errno == EAGAIN))
		return;

	proc_send(client_peer, MSG_STDIN, -1, &data, sizeof data);
	if (data.size <= 0)
		event_del(&client_stdin);
}


void
client_write(int fd, const char *data, size_t size)
{
	ssize_t	used;

	while (size != 0) {
		used = write(fd, data, size);
		if (used == -1) {
			if (errno == EINTR || errno == EAGAIN)
				continue;
			break;
		}
		data += used;
		size -= used;
	}
}


__dead void
client_exec(const char *shell, const char *shellcmd)
{
	const char	*name, *ptr;
	char		*argv0;

	log_debug(""shell %s, command %s"", shell, shellcmd);

	ptr = strrchr(shell, '/');
	if (ptr != NULL && *(ptr + 1) != '\0')
		name = ptr + 1;
	else
		name = shell;
	if (client_flags & CLIENT_LOGIN)
		xasprintf(&argv0, ""-%s"", name);
	else
		xasprintf(&argv0, ""%s"", name);
	setenv(""SHELL"", shell, 1);

	setblocking(STDIN_FILENO, 1);
	setblocking(STDOUT_FILENO, 1);
	setblocking(STDERR_FILENO, 1);
	closefrom(STDERR_FILENO + 1);

	execl(shell, argv0, ""-c"", shellcmd, (char *) NULL);
	fatal(""execl failed"");
}


void
client_signal(int sig)
{
	struct sigaction sigact;
	int		 status;

	if (sig == SIGCHLD)
		waitpid(WAIT_ANY, &status, WNOHANG);
	else if (!client_attached) {
		if (sig == SIGTERM)
			proc_exit(client_proc);
	} else {
		switch (sig) {
		case SIGHUP:
			client_exitreason = CLIENT_EXIT_LOST_TTY;
			client_exitval = 1;
			proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
			break;
		case SIGTERM:
			client_exitreason = CLIENT_EXIT_TERMINATED;
			client_exitval = 1;
			proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
			break;
		case SIGWINCH:
			proc_send(client_peer, MSG_RESIZE, -1, NULL, 0);
			break;
		case SIGCONT:
			memset(&sigact, 0, sizeof sigact);
			sigemptyset(&sigact.sa_mask);
			sigact.sa_flags = SA_RESTART;
			sigact.sa_handler = SIG_IGN;
			if (sigaction(SIGTSTP, &sigact, NULL) != 0)
				fatal(""sigaction failed"");
			proc_send(client_peer, MSG_WAKEUP, -1, NULL, 0);
			break;
		}
	}
}


void
client_dispatch(struct imsg *imsg, void *arg)
{
	if (imsg == NULL) {
		client_exitreason = CLIENT_EXIT_LOST_SERVER;
		client_exitval = 1;
		proc_exit(client_proc);
		return;
	}

	if (client_attached)
		client_dispatch_attached(imsg);
	else
		client_dispatch_wait(imsg, arg);
}


void
client_dispatch_wait(struct imsg *imsg, const char *shellcmd)
{
	char			*data;
	ssize_t			 datalen;
	struct msg_stdout_data	 stdoutdata;
	struct msg_stderr_data	 stderrdata;
	int			 retval;
#ifdef __OpenBSD__
	static int		 pledge_applied;

	
	if (!pledge_applied) {
		if (pledge(""stdio unix proc exec tty"", NULL) != 0)
			fatal(""pledge failed"");
		pledge_applied = 1;
	};
#endif

	data = imsg->data;
	datalen = imsg->hdr.len - IMSG_HEADER_SIZE;

	switch (imsg->hdr.type) {
	case MSG_EXIT:
	case MSG_SHUTDOWN:
		if (datalen != sizeof retval && datalen != 0)
			fatalx(""bad MSG_EXIT size"");
		if (datalen == sizeof retval) {
			memcpy(&retval, data, sizeof retval);
			client_exitval = retval;
		}
		proc_exit(client_proc);
		break;
	case MSG_READY:
		if (datalen != 0)
			fatalx(""bad MSG_READY size"");

		event_del(&client_stdin);
		client_attached = 1;
		proc_send(client_peer, MSG_RESIZE, -1, NULL, 0);
		break;
	case MSG_STDIN:
		if (datalen != 0)
			fatalx(""bad MSG_STDIN size"");

		event_add(&client_stdin, NULL);
		break;
	case MSG_STDOUT:
		if (datalen != sizeof stdoutdata)
			fatalx(""bad MSG_STDOUT size"");
		memcpy(&stdoutdata, data, sizeof stdoutdata);

		client_write(STDOUT_FILENO, stdoutdata.data,
		    stdoutdata.size);
		break;
	case MSG_STDERR:
		if (datalen != sizeof stderrdata)
			fatalx(""bad MSG_STDERR size"");
		memcpy(&stderrdata, data, sizeof stderrdata);

		client_write(STDERR_FILENO, stderrdata.data,
		    stderrdata.size);
		break;
	case MSG_VERSION:
		if (datalen != 0)
			fatalx(""bad MSG_VERSION size"");

		fprintf(stderr, ""protocol version mismatch ""
		    ""(client %d, server %u)\n"", PROTOCOL_VERSION,
		    imsg->hdr.peerid & 0xff);
		client_exitval = 1;
		proc_exit(client_proc);
		break;
	case MSG_SHELL:
		if (datalen == 0 || data[datalen - 1] != '\0')
			fatalx(""bad MSG_SHELL string"");

		clear_signals(0);
		client_exec(data, shellcmd);
		
	case MSG_DETACH:
	case MSG_DETACHKILL:
		proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
		break;
	case MSG_EXITED:
		proc_exit(client_proc);
		break;
	}
}


void
client_dispatch_attached(struct imsg *imsg)
{
	struct sigaction	 sigact;
	char			*data;
	ssize_t			 datalen;

	data = imsg->data;
	datalen = imsg->hdr.len - IMSG_HEADER_SIZE;

	switch (imsg->hdr.type) {
	case MSG_DETACH:
	case MSG_DETACHKILL:
		if (datalen == 0 || data[datalen - 1] != '\0')
			fatalx(""bad MSG_DETACH string"");

		client_exitsession = xstrdup(data);
		client_exittype = imsg->hdr.type;
		if (imsg->hdr.type == MSG_DETACHKILL)
			client_exitreason = CLIENT_EXIT_DETACHED_HUP;
		else
			client_exitreason = CLIENT_EXIT_DETACHED;
		proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
		break;
	case MSG_EXIT:
		if (datalen != 0 && datalen != sizeof (int))
			fatalx(""bad MSG_EXIT size"");

		proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
		client_exitreason = CLIENT_EXIT_EXITED;
		break;
	case MSG_EXITED:
		if (datalen != 0)
			fatalx(""bad MSG_EXITED size"");

		proc_exit(client_proc);
		break;
	case MSG_SHUTDOWN:
		if (datalen != 0)
			fatalx(""bad MSG_SHUTDOWN size"");

		proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
		client_exitreason = CLIENT_EXIT_SERVER_EXITED;
		client_exitval = 1;
		break;
	case MSG_SUSPEND:
		if (datalen != 0)
			fatalx(""bad MSG_SUSPEND size"");

		memset(&sigact, 0, sizeof sigact);
		sigemptyset(&sigact.sa_mask);
		sigact.sa_flags = SA_RESTART;
		sigact.sa_handler = SIG_DFL;
		if (sigaction(SIGTSTP, &sigact, NULL) != 0)
			fatal(""sigaction failed"");
		kill(getpid(), SIGTSTP);
		break;
	case MSG_LOCK:
		if (datalen == 0 || data[datalen - 1] != '\0')
			fatalx(""bad MSG_LOCK string"");

		system(data);
		proc_send(client_peer, MSG_UNLOCK, -1, NULL, 0);
		break;
	}
}
"
